"use strict";(self.webpackChunk_cos_ui_apps_cos_ui=self.webpackChunk_cos_ui_apps_cos_ui||[]).push([[439],{80439:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "asEffect": () => (/* reexport */ asEffect),\n  "asLayoutEffect": () => (/* reexport */ asLayoutEffect),\n  "useActor": () => (/* reexport */ useActor),\n  "useInterpret": () => (/* reexport */ useInterpret),\n  "useMachine": () => (/* reexport */ useMachine),\n  "useSelector": () => (/* reexport */ useSelector),\n  "useService": () => (/* reexport */ useService),\n  "useSpawn": () => (/* reexport */ useSpawn)\n});\n\n// EXTERNAL MODULE: consume shared module (default) react@=17.0.1 (singleton) (fallback: ../../node_modules/react/index.js) (eager)\nvar index_js_eager_ = __webpack_require__(10791);\n// EXTERNAL MODULE: consume shared module (default) xstate@=4.23.1 (strict) (fallback: ../../node_modules/xstate/es/index.js)\nvar index_js_ = __webpack_require__(59993);\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/types.js\nvar ReactEffectType;\n(function (ReactEffectType) {\n    ReactEffectType[ReactEffectType["Effect"] = 1] = "Effect";\n    ReactEffectType[ReactEffectType["LayoutEffect"] = 2] = "LayoutEffect";\n})(ReactEffectType || (ReactEffectType = {}));\n\n;// CONCATENATED MODULE: ../../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js\n\n\nvar index =  index_js_eager_.useLayoutEffect ;\n\n/* harmony default export */ const use_isomorphic_layout_effect_browser_esm = (index);\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useConstant.js\n\nfunction useConstant(fn) {\n    var ref = index_js_eager_.useRef();\n    if (!ref.current) {\n        ref.current = { v: fn() };\n    }\n    return ref.current.v;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/utils.js\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === "number") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n};\nfunction partition(items, predicate) {\n    var e_1, _a;\n    var _b = __read([[], []], 2), truthy = _b[0], falsy = _b[1];\n    try {\n        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n            var item = items_1_1.value;\n            if (predicate(item)) {\n                truthy.push(item);\n            }\n            else {\n                falsy.push(item);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return [truthy, falsy];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useReactEffectActions.js\nvar useReactEffectActions_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\n\n\n\n\nfunction executeEffect(action, state) {\n    var exec = action.exec;\n    var originalExec = exec(state.context, state._event.data, {\n        action: action,\n        state: state,\n        _event: state._event\n    });\n    originalExec();\n}\nfunction useReactEffectActions(service) {\n    var effectActionsRef = (0,index_js_eager_.useRef)([]);\n    var layoutEffectActionsRef = (0,index_js_eager_.useRef)([]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        var sub = service.subscribe(function (currentState) {\n            var _a, _b;\n            if (currentState.actions.length) {\n                var reactEffectActions = currentState.actions.filter(function (action) {\n                    return (typeof action.exec === \'function\' &&\n                        \'__effect\' in action.exec);\n                });\n                var _c = useReactEffectActions_read(partition(reactEffectActions, function (action) {\n                    return action.exec.__effect === ReactEffectType.Effect;\n                }), 2), effectActions = _c[0], layoutEffectActions = _c[1];\n                (_a = effectActionsRef.current).push.apply(_a, __spreadArray([], useReactEffectActions_read(effectActions.map(function (effectAction) { return [effectAction, currentState]; }))));\n                (_b = layoutEffectActionsRef.current).push.apply(_b, __spreadArray([], useReactEffectActions_read(layoutEffectActions.map(function (layoutEffectAction) { return [layoutEffectAction, currentState]; }))));\n            }\n        });\n        return function () {\n            sub.unsubscribe();\n        };\n    }, []);\n    // this is somewhat weird - this should always be flushed within useLayoutEffect\n    // but we don\'t want to receive warnings about useLayoutEffect being used on the server\n    // so we have to use `useIsomorphicLayoutEffect` to silence those warnings\n    use_isomorphic_layout_effect_browser_esm(function () {\n        while (layoutEffectActionsRef.current.length) {\n            var _a = useReactEffectActions_read(layoutEffectActionsRef.current.shift(), 2), layoutEffectAction = _a[0], effectState = _a[1];\n            executeEffect(layoutEffectAction, effectState);\n        }\n    }); // https://github.com/davidkpiano/xstate/pull/1202#discussion_r429677773\n    (0,index_js_eager_.useEffect)(function () {\n        while (effectActionsRef.current.length) {\n            var _a = useReactEffectActions_read(effectActionsRef.current.shift(), 2), effectAction = _a[0], effectState = _a[1];\n            executeEffect(effectAction, effectState);\n        }\n    });\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useInterpret.js\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar useInterpret_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\n\n\n// copied from core/src/utils.ts\n// it avoids a breaking change between this package and XState which is its peer dep\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    if (typeof nextHandler === \'object\') {\n        return nextHandler;\n    }\n    var noop = function () { return void 0; };\n    return {\n        next: nextHandler,\n        error: errorHandler || noop,\n        complete: completionHandler || noop\n    };\n}\nfunction useInterpret(getMachine, options, observerOrListener) {\n    if (options === void 0) { options = {}; }\n    var machine = useConstant(function () {\n        return typeof getMachine === \'function\' ? getMachine() : getMachine;\n    });\n    if (false) { var _a, initialMachine; }\n    var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);\n    var service = useConstant(function () {\n        var machineConfig = {\n            context: context,\n            guards: guards,\n            actions: actions,\n            activities: activities,\n            services: services,\n            delays: delays\n        };\n        var machineWithConfig = machine.withConfig(machineConfig, __assign(__assign({}, machine.context), context));\n        return (0,index_js_.interpret)(machineWithConfig, __assign({ deferEvents: true }, interpreterOptions));\n    });\n    use_isomorphic_layout_effect_browser_esm(function () {\n        var sub;\n        if (observerOrListener) {\n            sub = service.subscribe(toObserver(observerOrListener));\n        }\n        return function () {\n            sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n        };\n    }, [observerOrListener]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        service.start(rehydratedState ? index_js_.State.create(rehydratedState) : undefined);\n        return function () {\n            service.stop();\n        };\n    }, []);\n    // Make sure actions and services are kept updated when they change.\n    // This mutation assignment is safe because the service instance is only used\n    // in one place -- this hook\'s caller.\n    use_isomorphic_layout_effect_browser_esm(function () {\n        Object.assign(service.machine.options.actions, actions);\n    }, [actions]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        Object.assign(service.machine.options.services, services);\n    }, [services]);\n    useReactEffectActions(service);\n    return service;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useMachine.js\nvar useMachine_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar useMachine_spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\n\n\n\n\nfunction createReactActionFunction(exec, tag) {\n    var effectExec = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // don\'t execute; just return\n        return function () {\n            return exec.apply(void 0, useMachine_spreadArray([], useMachine_read(args)));\n        };\n    };\n    Object.defineProperties(effectExec, {\n        name: { value: "effect:" + exec.name },\n        __effect: { value: tag }\n    });\n    return effectExec;\n}\nfunction asEffect(exec) {\n    return createReactActionFunction(exec, ReactEffectType.Effect);\n}\nfunction asLayoutEffect(exec) {\n    return createReactActionFunction(exec, ReactEffectType.LayoutEffect);\n}\nfunction useMachine(getMachine, options) {\n    if (options === void 0) { options = {}; }\n    var listener = (0,index_js_eager_.useCallback)(function (nextState) {\n        // Only change the current state if:\n        // - the incoming state is the "live" initial state (since it might have new actors)\n        // - OR the incoming state actually changed.\n        //\n        // The "live" initial state will have .changed === undefined.\n        var initialStateChanged = nextState.changed === undefined &&\n            Object.keys(nextState.children).length;\n        if (nextState.changed || initialStateChanged) {\n            setState(nextState);\n        }\n    }, []);\n    var service = useInterpret(getMachine, options, listener);\n    var _a = useMachine_read((0,index_js_eager_.useState)(function () {\n        var initialState = service.machine.initialState;\n        return (options.state\n            ? index_js_.State.create(options.state)\n            : initialState);\n    }), 2), state = _a[0], setState = _a[1];\n    return [state, service.send, service];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useActor.js\nvar useActor_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction isActorWithState(actorRef) {\n    return \'state\' in actorRef;\n}\nfunction isDeferredActor(actorRef) {\n    return \'deferred\' in actorRef;\n}\nvar noop = function () {\n    /* ... */\n};\nfunction defaultGetSnapshot(actorRef) {\n    return \'getSnapshot\' in actorRef\n        ? actorRef.getSnapshot()\n        : isActorWithState(actorRef)\n            ? actorRef.state\n            : undefined;\n}\nfunction useActor(actorRef, getSnapshot) {\n    if (getSnapshot === void 0) { getSnapshot = defaultGetSnapshot; }\n    var actorRefRef = (0,index_js_eager_.useRef)(actorRef);\n    var deferredEventsRef = (0,index_js_eager_.useRef)([]);\n    var _a = useActor_read((0,index_js_eager_.useState)(function () { return getSnapshot(actorRef); }), 2), current = _a[0], setCurrent = _a[1];\n    var send = useConstant(function () { return function (event) {\n        var currentActorRef = actorRefRef.current;\n        // If the previous actor is a deferred actor,\n        // queue the events so that they can be replayed\n        // on the non-deferred actor.\n        if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {\n            deferredEventsRef.current.push(event);\n        }\n        else {\n            currentActorRef.send(event);\n        }\n    }; });\n    use_isomorphic_layout_effect_browser_esm(function () {\n        actorRefRef.current = actorRef;\n        setCurrent(getSnapshot(actorRef));\n        var subscription = actorRef.subscribe({\n            next: function (emitted) { return setCurrent(emitted); },\n            error: noop,\n            complete: noop\n        });\n        // Dequeue deferred events from the previous deferred actorRef\n        while (deferredEventsRef.current.length > 0) {\n            var deferredEvent = deferredEventsRef.current.shift();\n            actorRef.send(deferredEvent);\n        }\n        return function () {\n            subscription.unsubscribe();\n        };\n    }, [actorRef]);\n    return [current, send];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useService.js\nvar useService_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\nfunction getServiceSnapshot(service) {\n    // TODO: remove compat lines in a new major, replace literal number with InterpreterStatus then as well\n    return (\'status\' in service ? service.status : service._status) !== 0\n        ? service.state\n        : service.machine.initialState;\n}\n/**\n * @deprecated Use `useActor` instead.\n *\n * @param service The interpreted machine\n * @returns A tuple of the current `state` of the service and the service\'s `send(event)` method\n */\nfunction useService(service) {\n    if (false) {}\n    var _a = useService_read(useActor(service), 1), state = _a[0];\n    return [state, service.send];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useSelector.js\nvar useSelector_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction isService(actor) {\n    return \'state\' in actor && \'machine\' in actor;\n}\nvar defaultCompare = function (a, b) { return a === b; };\nvar useSelector_defaultGetSnapshot = function (a) {\n    return isService(a)\n        ? getServiceSnapshot(a)\n        : isActorWithState(a)\n            ? a.state\n            : undefined;\n};\nfunction useSelector(actor, selector, compare, getSnapshot) {\n    if (compare === void 0) { compare = defaultCompare; }\n    if (getSnapshot === void 0) { getSnapshot = useSelector_defaultGetSnapshot; }\n    var _a = useSelector_read((0,index_js_eager_.useState)(function () { return selector(getSnapshot(actor)); }), 2), selected = _a[0], setSelected = _a[1];\n    var selectedRef = (0,index_js_eager_.useRef)(selected);\n    (0,index_js_eager_.useEffect)(function () {\n        var updateSelectedIfChanged = function (nextSelected) {\n            if (!compare(selectedRef.current, nextSelected)) {\n                setSelected(nextSelected);\n                selectedRef.current = nextSelected;\n            }\n        };\n        var initialSelected = selector(getSnapshot(actor));\n        updateSelectedIfChanged(initialSelected);\n        var sub = actor.subscribe(function (emitted) {\n            var nextSelected = selector(emitted);\n            updateSelectedIfChanged(nextSelected);\n        });\n        return function () { return sub.unsubscribe(); };\n    }, [selector, compare]);\n    return selected;\n}\n\n// EXTERNAL MODULE: ../../node_modules/xstate/lib/behaviors.js\nvar behaviors = __webpack_require__(26067);\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useSpawn.js\n\n\n/**\n * React hook that spawns an `ActorRef` with the specified `behavior`.\n * The returned `ActorRef` can be used with the `useActor(actorRef)` hook.\n *\n * @param behavior The actor behavior to spawn\n * @returns An ActorRef with the specified `behavior`\n */\nfunction useSpawn(behavior) {\n    var actorRef = useConstant(function () {\n        return (0,behaviors/* spawnBehavior */.Y)(behavior);\n    });\n    return actorRef;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/index.js\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLElBQUksU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO2tCQUNvRDtrQkFDTjtrQkFDSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsSUFBSSw4QkFBa0I7QUFDdEI7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7Y0FDTztBQUNQLDhCQUE4QjtBQUM5QixrQ0FBa0MsY0FBYyw4QkFBa0I7QUFDbEUsYUFBYSxnQkFBTSxDQUFDLDRCQUFRLGVBQWUsc0NBQXNDO0FBQ2pGLHNCQUFzQiwwQkFBTTtBQUM1QixJQUFJLDZCQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0IsS0FBSztBQUNMO0FBQ0E7Ozs7O2tCQ25EcUQ7Z0ZBQ2I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Y0FDTztBQUNQLG1CQUFtQixXQUFXO0FBQzlCLGVBQWUsa0NBQWE7QUFDNUIsS0FBSztBQUNMO0FBQ0E7OztrQkNkb0U7a0JBQzFCO2tCQUNKO2tCQUNRO2tCQUNGO2tCQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy90eXBlcy5qcz84OWRlIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QvZGlzdC91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0LmJyb3dzZXIuZXNtLmpzP2NkYzEiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VDb25zdGFudC5qcz81YzM0Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvdXRpbHMuanM/ZThmMyIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uLy4uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZVJlYWN0RWZmZWN0QWN0aW9ucy5qcz9jMzA5Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvdXNlSW50ZXJwcmV0LmpzP2JkMTQiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VNYWNoaW5lLmpzPzdhNDkiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VBY3Rvci5qcz84NzI0Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvdXNlU2VydmljZS5qcz8wZjM5Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvdXNlU2VsZWN0b3IuanM/NzgxMyIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uLy4uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZVNwYXduLmpzPzUyNDUiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy9pbmRleC5qcz85YTAzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgUmVhY3RFZmZlY3RUeXBlO1xuKGZ1bmN0aW9uIChSZWFjdEVmZmVjdFR5cGUpIHtcbiAgICBSZWFjdEVmZmVjdFR5cGVbUmVhY3RFZmZlY3RUeXBlW1wiRWZmZWN0XCJdID0gMV0gPSBcIkVmZmVjdFwiO1xuICAgIFJlYWN0RWZmZWN0VHlwZVtSZWFjdEVmZmVjdFR5cGVbXCJMYXlvdXRFZmZlY3RcIl0gPSAyXSA9IFwiTGF5b3V0RWZmZWN0XCI7XG59KShSZWFjdEVmZmVjdFR5cGUgfHwgKFJlYWN0RWZmZWN0VHlwZSA9IHt9KSk7XG4iLCJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBpbmRleCA9ICB1c2VMYXlvdXRFZmZlY3QgO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUNvbnN0YW50KGZuKSB7XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB7IHY6IGZuKCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50LnY7XG59XG4iLCJ2YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5leHBvcnQgZnVuY3Rpb24gcGFydGl0aW9uKGl0ZW1zLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoW1tdLCBbXV0sIDIpLCB0cnV0aHkgPSBfYlswXSwgZmFsc3kgPSBfYlsxXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBpdGVtc18xID0gX192YWx1ZXMoaXRlbXMpLCBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKTsgIWl0ZW1zXzFfMS5kb25lOyBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdHJ1dGh5LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWxzeS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNfMV8xICYmICFpdGVtc18xXzEuZG9uZSAmJiAoX2EgPSBpdGVtc18xLnJldHVybikpIF9hLmNhbGwoaXRlbXNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICB0b1tqXSA9IGZyb21baV07XG4gICAgcmV0dXJuIHRvO1xufTtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAndXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgeyBSZWFjdEVmZmVjdFR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHBhcnRpdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuZnVuY3Rpb24gZXhlY3V0ZUVmZmVjdChhY3Rpb24sIHN0YXRlKSB7XG4gICAgdmFyIGV4ZWMgPSBhY3Rpb24uZXhlYztcbiAgICB2YXIgb3JpZ2luYWxFeGVjID0gZXhlYyhzdGF0ZS5jb250ZXh0LCBzdGF0ZS5fZXZlbnQuZGF0YSwge1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBfZXZlbnQ6IHN0YXRlLl9ldmVudFxuICAgIH0pO1xuICAgIG9yaWdpbmFsRXhlYygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlYWN0RWZmZWN0QWN0aW9ucyhzZXJ2aWNlKSB7XG4gICAgdmFyIGVmZmVjdEFjdGlvbnNSZWYgPSB1c2VSZWYoW10pO1xuICAgIHZhciBsYXlvdXRFZmZlY3RBY3Rpb25zUmVmID0gdXNlUmVmKFtdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YiA9IHNlcnZpY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlLmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWN0RWZmZWN0QWN0aW9ucyA9IGN1cnJlbnRTdGF0ZS5hY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIGFjdGlvbi5leGVjID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAnX19lZmZlY3QnIGluIGFjdGlvbi5leGVjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBfX3JlYWQocGFydGl0aW9uKHJlYWN0RWZmZWN0QWN0aW9ucywgZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV4ZWMuX19lZmZlY3QgPT09IFJlYWN0RWZmZWN0VHlwZS5FZmZlY3Q7XG4gICAgICAgICAgICAgICAgfSksIDIpLCBlZmZlY3RBY3Rpb25zID0gX2NbMF0sIGxheW91dEVmZmVjdEFjdGlvbnMgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICAoX2EgPSBlZmZlY3RBY3Rpb25zUmVmLmN1cnJlbnQpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChlZmZlY3RBY3Rpb25zLm1hcChmdW5jdGlvbiAoZWZmZWN0QWN0aW9uKSB7IHJldHVybiBbZWZmZWN0QWN0aW9uLCBjdXJyZW50U3RhdGVdOyB9KSkpKTtcbiAgICAgICAgICAgICAgICAoX2IgPSBsYXlvdXRFZmZlY3RBY3Rpb25zUmVmLmN1cnJlbnQpLnB1c2guYXBwbHkoX2IsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChsYXlvdXRFZmZlY3RBY3Rpb25zLm1hcChmdW5jdGlvbiAobGF5b3V0RWZmZWN0QWN0aW9uKSB7IHJldHVybiBbbGF5b3V0RWZmZWN0QWN0aW9uLCBjdXJyZW50U3RhdGVdOyB9KSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gdGhpcyBpcyBzb21ld2hhdCB3ZWlyZCAtIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBmbHVzaGVkIHdpdGhpbiB1c2VMYXlvdXRFZmZlY3RcbiAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0byByZWNlaXZlIHdhcm5pbmdzIGFib3V0IHVzZUxheW91dEVmZmVjdCBiZWluZyB1c2VkIG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHVzZSBgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdGAgdG8gc2lsZW5jZSB0aG9zZSB3YXJuaW5nc1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAobGF5b3V0RWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGxheW91dEVmZmVjdEFjdGlvbnNSZWYuY3VycmVudC5zaGlmdCgpLCAyKSwgbGF5b3V0RWZmZWN0QWN0aW9uID0gX2FbMF0sIGVmZmVjdFN0YXRlID0gX2FbMV07XG4gICAgICAgICAgICBleGVjdXRlRWZmZWN0KGxheW91dEVmZmVjdEFjdGlvbiwgZWZmZWN0U3RhdGUpO1xuICAgICAgICB9XG4gICAgfSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGtwaWFuby94c3RhdGUvcHVsbC8xMjAyI2Rpc2N1c3Npb25fcjQyOTY3Nzc3M1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlIChlZmZlY3RBY3Rpb25zUmVmLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50LnNoaWZ0KCksIDIpLCBlZmZlY3RBY3Rpb24gPSBfYVswXSwgZWZmZWN0U3RhdGUgPSBfYVsxXTtcbiAgICAgICAgICAgIGV4ZWN1dGVFZmZlY3QoZWZmZWN0QWN0aW9uLCBlZmZlY3RTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJ3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgaW50ZXJwcmV0LCBTdGF0ZSB9IGZyb20gJ3hzdGF0ZSc7XG5pbXBvcnQgdXNlQ29uc3RhbnQgZnJvbSAnLi91c2VDb25zdGFudCc7XG5pbXBvcnQgeyB1c2VSZWFjdEVmZmVjdEFjdGlvbnMgfSBmcm9tICcuL3VzZVJlYWN0RWZmZWN0QWN0aW9ucyc7XG4vLyBjb3BpZWQgZnJvbSBjb3JlL3NyYy91dGlscy50c1xuLy8gaXQgYXZvaWRzIGEgYnJlYWtpbmcgY2hhbmdlIGJldHdlZW4gdGhpcyBwYWNrYWdlIGFuZCBYU3RhdGUgd2hpY2ggaXMgaXRzIHBlZXIgZGVwXG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0SGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5leHRIYW5kbGVyO1xuICAgIH1cbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgMDsgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBuZXh0SGFuZGxlcixcbiAgICAgICAgZXJyb3I6IGVycm9ySGFuZGxlciB8fCBub29wLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGlvbkhhbmRsZXIgfHwgbm9vcFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJwcmV0KGdldE1hY2hpbmUsIG9wdGlvbnMsIG9ic2VydmVyT3JMaXN0ZW5lcikge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG1hY2hpbmUgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZ2V0TWFjaGluZSA9PT0gJ2Z1bmN0aW9uJyA/IGdldE1hY2hpbmUoKSA6IGdldE1hY2hpbmU7XG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIGdldE1hY2hpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKG1hY2hpbmUpLCAxKSwgaW5pdGlhbE1hY2hpbmUgPSBfYVswXTtcbiAgICAgICAgaWYgKG1hY2hpbmUgIT09IGluaXRpYWxNYWNoaW5lKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01hY2hpbmUgZ2l2ZW4gdG8gYHVzZU1hY2hpbmVgIGhhcyBjaGFuZ2VkIGJldHdlZW4gcmVuZGVycy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy5cXG4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdSBwYXNzIHRoZSBzYW1lIE1hY2hpbmUgYXMgYXJndW1lbnQgZWFjaCB0aW1lLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBndWFyZHMgPSBvcHRpb25zLmd1YXJkcywgYWN0aW9ucyA9IG9wdGlvbnMuYWN0aW9ucywgYWN0aXZpdGllcyA9IG9wdGlvbnMuYWN0aXZpdGllcywgc2VydmljZXMgPSBvcHRpb25zLnNlcnZpY2VzLCBkZWxheXMgPSBvcHRpb25zLmRlbGF5cywgcmVoeWRyYXRlZFN0YXRlID0gb3B0aW9ucy5zdGF0ZSwgaW50ZXJwcmV0ZXJPcHRpb25zID0gX19yZXN0KG9wdGlvbnMsIFtcImNvbnRleHRcIiwgXCJndWFyZHNcIiwgXCJhY3Rpb25zXCIsIFwiYWN0aXZpdGllc1wiLCBcInNlcnZpY2VzXCIsIFwiZGVsYXlzXCIsIFwic3RhdGVcIl0pO1xuICAgIHZhciBzZXJ2aWNlID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFjaGluZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBndWFyZHM6IGd1YXJkcyxcbiAgICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICAgICAgICBhY3Rpdml0aWVzOiBhY3Rpdml0aWVzLFxuICAgICAgICAgICAgc2VydmljZXM6IHNlcnZpY2VzLFxuICAgICAgICAgICAgZGVsYXlzOiBkZWxheXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1hY2hpbmVXaXRoQ29uZmlnID0gbWFjaGluZS53aXRoQ29uZmlnKG1hY2hpbmVDb25maWcsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBtYWNoaW5lLmNvbnRleHQpLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiBpbnRlcnByZXQobWFjaGluZVdpdGhDb25maWcsIF9fYXNzaWduKHsgZGVmZXJFdmVudHM6IHRydWUgfSwgaW50ZXJwcmV0ZXJPcHRpb25zKSk7XG4gICAgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWI7XG4gICAgICAgIGlmIChvYnNlcnZlck9yTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHN1YiA9IHNlcnZpY2Uuc3Vic2NyaWJlKHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YiA9PT0gbnVsbCB8fCBzdWIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtvYnNlcnZlck9yTGlzdGVuZXJdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VydmljZS5zdGFydChyZWh5ZHJhdGVkU3RhdGUgPyBTdGF0ZS5jcmVhdGUocmVoeWRyYXRlZFN0YXRlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gTWFrZSBzdXJlIGFjdGlvbnMgYW5kIHNlcnZpY2VzIGFyZSBrZXB0IHVwZGF0ZWQgd2hlbiB0aGV5IGNoYW5nZS5cbiAgICAvLyBUaGlzIG11dGF0aW9uIGFzc2lnbm1lbnQgaXMgc2FmZSBiZWNhdXNlIHRoZSBzZXJ2aWNlIGluc3RhbmNlIGlzIG9ubHkgdXNlZFxuICAgIC8vIGluIG9uZSBwbGFjZSAtLSB0aGlzIGhvb2sncyBjYWxsZXIuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmljZS5tYWNoaW5lLm9wdGlvbnMuYWN0aW9ucywgYWN0aW9ucyk7XG4gICAgfSwgW2FjdGlvbnNdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2aWNlLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlcywgc2VydmljZXMpO1xuICAgIH0sIFtzZXJ2aWNlc10pO1xuICAgIHVzZVJlYWN0RWZmZWN0QWN0aW9ucyhzZXJ2aWNlKTtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJ3hzdGF0ZSc7XG5pbXBvcnQgeyBSZWFjdEVmZmVjdFR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZUludGVycHJldCB9IGZyb20gJy4vdXNlSW50ZXJwcmV0JztcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0QWN0aW9uRnVuY3Rpb24oZXhlYywgdGFnKSB7XG4gICAgdmFyIGVmZmVjdEV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgZXhlY3V0ZTsganVzdCByZXR1cm5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlZmZlY3RFeGVjLCB7XG4gICAgICAgIG5hbWU6IHsgdmFsdWU6IFwiZWZmZWN0OlwiICsgZXhlYy5uYW1lIH0sXG4gICAgICAgIF9fZWZmZWN0OiB7IHZhbHVlOiB0YWcgfVxuICAgIH0pO1xuICAgIHJldHVybiBlZmZlY3RFeGVjO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzRWZmZWN0KGV4ZWMpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RBY3Rpb25GdW5jdGlvbihleGVjLCBSZWFjdEVmZmVjdFR5cGUuRWZmZWN0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc0xheW91dEVmZmVjdChleGVjKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0QWN0aW9uRnVuY3Rpb24oZXhlYywgUmVhY3RFZmZlY3RUeXBlLkxheW91dEVmZmVjdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlTWFjaGluZShnZXRNYWNoaW5lLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgbGlzdGVuZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgIC8vIE9ubHkgY2hhbmdlIHRoZSBjdXJyZW50IHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbmNvbWluZyBzdGF0ZSBpcyB0aGUgXCJsaXZlXCIgaW5pdGlhbCBzdGF0ZSAoc2luY2UgaXQgbWlnaHQgaGF2ZSBuZXcgYWN0b3JzKVxuICAgICAgICAvLyAtIE9SIHRoZSBpbmNvbWluZyBzdGF0ZSBhY3R1YWxseSBjaGFuZ2VkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgXCJsaXZlXCIgaW5pdGlhbCBzdGF0ZSB3aWxsIGhhdmUgLmNoYW5nZWQgPT09IHVuZGVmaW5lZC5cbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZUNoYW5nZWQgPSBuZXh0U3RhdGUuY2hhbmdlZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXh0U3RhdGUuY2hpbGRyZW4pLmxlbmd0aDtcbiAgICAgICAgaWYgKG5leHRTdGF0ZS5jaGFuZ2VkIHx8IGluaXRpYWxTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIHNlcnZpY2UgPSB1c2VJbnRlcnByZXQoZ2V0TWFjaGluZSwgb3B0aW9ucywgbGlzdGVuZXIpO1xuICAgIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBzZXJ2aWNlLm1hY2hpbmUuaW5pdGlhbFN0YXRlO1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuc3RhdGVcbiAgICAgICAgICAgID8gU3RhdGUuY3JlYXRlKG9wdGlvbnMuc3RhdGUpXG4gICAgICAgICAgICA6IGluaXRpYWxTdGF0ZSk7XG4gICAgfSksIDIpLCBzdGF0ZSA9IF9hWzBdLCBzZXRTdGF0ZSA9IF9hWzFdO1xuICAgIHJldHVybiBbc3RhdGUsIHNlcnZpY2Uuc2VuZCwgc2VydmljZV07XG59XG4iLCJ2YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAndXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgdXNlQ29uc3RhbnQgZnJvbSAnLi91c2VDb25zdGFudCc7XG5leHBvcnQgZnVuY3Rpb24gaXNBY3RvcldpdGhTdGF0ZShhY3RvclJlZikge1xuICAgIHJldHVybiAnc3RhdGUnIGluIGFjdG9yUmVmO1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZEFjdG9yKGFjdG9yUmVmKSB7XG4gICAgcmV0dXJuICdkZWZlcnJlZCcgaW4gYWN0b3JSZWY7XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiAuLi4gKi9cbn07XG5mdW5jdGlvbiBkZWZhdWx0R2V0U25hcHNob3QoYWN0b3JSZWYpIHtcbiAgICByZXR1cm4gJ2dldFNuYXBzaG90JyBpbiBhY3RvclJlZlxuICAgICAgICA/IGFjdG9yUmVmLmdldFNuYXBzaG90KClcbiAgICAgICAgOiBpc0FjdG9yV2l0aFN0YXRlKGFjdG9yUmVmKVxuICAgICAgICAgICAgPyBhY3RvclJlZi5zdGF0ZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0b3IoYWN0b3JSZWYsIGdldFNuYXBzaG90KSB7XG4gICAgaWYgKGdldFNuYXBzaG90ID09PSB2b2lkIDApIHsgZ2V0U25hcHNob3QgPSBkZWZhdWx0R2V0U25hcHNob3Q7IH1cbiAgICB2YXIgYWN0b3JSZWZSZWYgPSB1c2VSZWYoYWN0b3JSZWYpO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50c1JlZiA9IHVzZVJlZihbXSk7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldFNuYXBzaG90KGFjdG9yUmVmKTsgfSksIDIpLCBjdXJyZW50ID0gX2FbMF0sIHNldEN1cnJlbnQgPSBfYVsxXTtcbiAgICB2YXIgc2VuZCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY3VycmVudEFjdG9yUmVmID0gYWN0b3JSZWZSZWYuY3VycmVudDtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGFjdG9yIGlzIGEgZGVmZXJyZWQgYWN0b3IsXG4gICAgICAgIC8vIHF1ZXVlIHRoZSBldmVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXBsYXllZFxuICAgICAgICAvLyBvbiB0aGUgbm9uLWRlZmVycmVkIGFjdG9yLlxuICAgICAgICBpZiAoaXNEZWZlcnJlZEFjdG9yKGN1cnJlbnRBY3RvclJlZikgJiYgY3VycmVudEFjdG9yUmVmLmRlZmVycmVkKSB7XG4gICAgICAgICAgICBkZWZlcnJlZEV2ZW50c1JlZi5jdXJyZW50LnB1c2goZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEFjdG9yUmVmLnNlbmQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTsgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdG9yUmVmUmVmLmN1cnJlbnQgPSBhY3RvclJlZjtcbiAgICAgICAgc2V0Q3VycmVudChnZXRTbmFwc2hvdChhY3RvclJlZikpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gYWN0b3JSZWYuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChlbWl0dGVkKSB7IHJldHVybiBzZXRDdXJyZW50KGVtaXR0ZWQpOyB9LFxuICAgICAgICAgICAgZXJyb3I6IG5vb3AsXG4gICAgICAgICAgICBjb21wbGV0ZTogbm9vcFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGVxdWV1ZSBkZWZlcnJlZCBldmVudHMgZnJvbSB0aGUgcHJldmlvdXMgZGVmZXJyZWQgYWN0b3JSZWZcbiAgICAgICAgd2hpbGUgKGRlZmVycmVkRXZlbnRzUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnQgPSBkZWZlcnJlZEV2ZW50c1JlZi5jdXJyZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICBhY3RvclJlZi5zZW5kKGRlZmVycmVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWN0b3JSZWZdKTtcbiAgICByZXR1cm4gW2N1cnJlbnQsIHNlbmRdO1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuaW1wb3J0IHsgdXNlQWN0b3IgfSBmcm9tICcuL3VzZUFjdG9yJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXJ2aWNlU25hcHNob3Qoc2VydmljZSkge1xuICAgIC8vIFRPRE86IHJlbW92ZSBjb21wYXQgbGluZXMgaW4gYSBuZXcgbWFqb3IsIHJlcGxhY2UgbGl0ZXJhbCBudW1iZXIgd2l0aCBJbnRlcnByZXRlclN0YXR1cyB0aGVuIGFzIHdlbGxcbiAgICByZXR1cm4gKCdzdGF0dXMnIGluIHNlcnZpY2UgPyBzZXJ2aWNlLnN0YXR1cyA6IHNlcnZpY2UuX3N0YXR1cykgIT09IDBcbiAgICAgICAgPyBzZXJ2aWNlLnN0YXRlXG4gICAgICAgIDogc2VydmljZS5tYWNoaW5lLmluaXRpYWxTdGF0ZTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB1c2VBY3RvcmAgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gc2VydmljZSBUaGUgaW50ZXJwcmV0ZWQgbWFjaGluZVxuICogQHJldHVybnMgQSB0dXBsZSBvZiB0aGUgY3VycmVudCBgc3RhdGVgIG9mIHRoZSBzZXJ2aWNlIGFuZCB0aGUgc2VydmljZSdzIGBzZW5kKGV2ZW50KWAgbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKCdtYWNoaW5lJyBpbiBzZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdXNlIGFuIGFjdG9yLWxpa2Ugb2JqZWN0IGluc3RlYWQgb2YgYSBzZXJ2aWNlIGluIHRoZSB1c2VTZXJ2aWNlKCkgaG9vay4gUGxlYXNlIHVzZSB0aGUgdXNlQWN0b3IoKSBob29rIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlQWN0b3Ioc2VydmljZSksIDEpLCBzdGF0ZSA9IF9hWzBdO1xuICAgIHJldHVybiBbc3RhdGUsIHNlcnZpY2Uuc2VuZF07XG59XG4iLCJ2YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0FjdG9yV2l0aFN0YXRlIH0gZnJvbSAnLi91c2VBY3Rvcic7XG5pbXBvcnQgeyBnZXRTZXJ2aWNlU25hcHNob3QgfSBmcm9tICcuL3VzZVNlcnZpY2UnO1xuZnVuY3Rpb24gaXNTZXJ2aWNlKGFjdG9yKSB7XG4gICAgcmV0dXJuICdzdGF0ZScgaW4gYWN0b3IgJiYgJ21hY2hpbmUnIGluIGFjdG9yO1xufVxudmFyIGRlZmF1bHRDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH07XG52YXIgZGVmYXVsdEdldFNuYXBzaG90ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gaXNTZXJ2aWNlKGEpXG4gICAgICAgID8gZ2V0U2VydmljZVNuYXBzaG90KGEpXG4gICAgICAgIDogaXNBY3RvcldpdGhTdGF0ZShhKVxuICAgICAgICAgICAgPyBhLnN0YXRlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5leHBvcnQgZnVuY3Rpb24gdXNlU2VsZWN0b3IoYWN0b3IsIHNlbGVjdG9yLCBjb21wYXJlLCBnZXRTbmFwc2hvdCkge1xuICAgIGlmIChjb21wYXJlID09PSB2b2lkIDApIHsgY29tcGFyZSA9IGRlZmF1bHRDb21wYXJlOyB9XG4gICAgaWYgKGdldFNuYXBzaG90ID09PSB2b2lkIDApIHsgZ2V0U25hcHNob3QgPSBkZWZhdWx0R2V0U25hcHNob3Q7IH1cbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0b3IoZ2V0U25hcHNob3QoYWN0b3IpKTsgfSksIDIpLCBzZWxlY3RlZCA9IF9hWzBdLCBzZXRTZWxlY3RlZCA9IF9hWzFdO1xuICAgIHZhciBzZWxlY3RlZFJlZiA9IHVzZVJlZihzZWxlY3RlZCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVwZGF0ZVNlbGVjdGVkSWZDaGFuZ2VkID0gZnVuY3Rpb24gKG5leHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKCFjb21wYXJlKHNlbGVjdGVkUmVmLmN1cnJlbnQsIG5leHRTZWxlY3RlZCkpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChuZXh0U2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUmVmLmN1cnJlbnQgPSBuZXh0U2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbml0aWFsU2VsZWN0ZWQgPSBzZWxlY3RvcihnZXRTbmFwc2hvdChhY3RvcikpO1xuICAgICAgICB1cGRhdGVTZWxlY3RlZElmQ2hhbmdlZChpbml0aWFsU2VsZWN0ZWQpO1xuICAgICAgICB2YXIgc3ViID0gYWN0b3Iuc3Vic2NyaWJlKGZ1bmN0aW9uIChlbWl0dGVkKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNlbGVjdGVkID0gc2VsZWN0b3IoZW1pdHRlZCk7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3RlZElmQ2hhbmdlZChuZXh0U2VsZWN0ZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9O1xuICAgIH0sIFtzZWxlY3RvciwgY29tcGFyZV0pO1xuICAgIHJldHVybiBzZWxlY3RlZDtcbn1cbiIsImltcG9ydCB7IHNwYXduQmVoYXZpb3IgfSBmcm9tICd4c3RhdGUvbGliL2JlaGF2aW9ycyc7XG5pbXBvcnQgdXNlQ29uc3RhbnQgZnJvbSAnLi91c2VDb25zdGFudCc7XG4vKipcbiAqIFJlYWN0IGhvb2sgdGhhdCBzcGF3bnMgYW4gYEFjdG9yUmVmYCB3aXRoIHRoZSBzcGVjaWZpZWQgYGJlaGF2aW9yYC5cbiAqIFRoZSByZXR1cm5lZCBgQWN0b3JSZWZgIGNhbiBiZSB1c2VkIHdpdGggdGhlIGB1c2VBY3RvcihhY3RvclJlZilgIGhvb2suXG4gKlxuICogQHBhcmFtIGJlaGF2aW9yIFRoZSBhY3RvciBiZWhhdmlvciB0byBzcGF3blxuICogQHJldHVybnMgQW4gQWN0b3JSZWYgd2l0aCB0aGUgc3BlY2lmaWVkIGBiZWhhdmlvcmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNwYXduKGJlaGF2aW9yKSB7XG4gICAgdmFyIGFjdG9yUmVmID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3Bhd25CZWhhdmlvcihiZWhhdmlvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdG9yUmVmO1xufVxuIiwiZXhwb3J0IHsgdXNlTWFjaGluZSwgYXNFZmZlY3QsIGFzTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi91c2VNYWNoaW5lJztcbmV4cG9ydCB7IHVzZVNlcnZpY2UgfSBmcm9tICcuL3VzZVNlcnZpY2UnO1xuZXhwb3J0IHsgdXNlQWN0b3IgfSBmcm9tICcuL3VzZUFjdG9yJztcbmV4cG9ydCB7IHVzZUludGVycHJldCB9IGZyb20gJy4vdXNlSW50ZXJwcmV0JztcbmV4cG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAnLi91c2VTZWxlY3Rvcic7XG5leHBvcnQgeyB1c2VTcGF3biB9IGZyb20gJy4vdXNlU3Bhd24nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///80439\n')},26067:(__unused_webpack_module,exports,__webpack_require__)=>{eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({ value: true });\n\n__webpack_require__(78664);\nvar utils = __webpack_require__(60035);\n__webpack_require__(94309);\n__webpack_require__(83521);\nvar Actor = __webpack_require__(10557);\n\nfunction spawnBehavior(behavior, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var state = behavior.initialState;\n  var observers = new Set();\n  var mailbox = [];\n  var flushing = false;\n\n  var flush = function () {\n    if (flushing) {\n      return;\n    }\n\n    flushing = true;\n\n    while (mailbox.length > 0) {\n      var event_1 = mailbox.shift();\n      state = behavior.transition(state, event_1, actorCtx);\n      observers.forEach(function (observer) {\n        return observer.next(state);\n      });\n    }\n\n    flushing = false;\n  };\n\n  var actor = Actor.toActorRef({\n    id: options.id,\n    send: function (event) {\n      mailbox.push(event);\n      flush();\n    },\n    getSnapshot: function () {\n      return state;\n    },\n    subscribe: function (next, handleError, complete) {\n      var observer = utils.toObserver(next, handleError, complete);\n      observers.add(observer);\n      observer.next(state);\n      return {\n        unsubscribe: function () {\n          observers.delete(observer);\n        }\n      };\n    }\n  });\n  var actorCtx = {\n    parent: options.parent,\n    self: actor,\n    id: options.id || 'anonymous',\n    observers: observers\n  };\n  state = behavior.start ? behavior.start(actorCtx) : state;\n  return actor;\n}\n\nexports.Y = spawnBehavior;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYwNjcuanMiLCJtYXBwaW5ncyI6IjswQkFBYTs7QUFFYiw2QkFBNkMsRUFBRSxhQUFhLENBQUM7O0FBRTdELG1CQUFPLENBQUMsS0FBa0I7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLEtBQVk7QUFDaEMsbUJBQU8sQ0FBQyxLQUFZO0FBQ3BCLG1CQUFPLENBQUMsS0FBa0I7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLEtBQVk7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi8uLi9ub2RlX21vZHVsZXMveHN0YXRlL2xpYi9iZWhhdmlvcnMuanM/MzIwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4vZW52aXJvbm1lbnQuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnJlcXVpcmUoJy4vdHlwZXMuanMnKTtcbnJlcXVpcmUoJy4vYWN0aW9uVHlwZXMuanMnKTtcbnZhciBBY3RvciA9IHJlcXVpcmUoJy4vQWN0b3IuanMnKTtcblxuZnVuY3Rpb24gc3Bhd25CZWhhdmlvcihiZWhhdmlvciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHN0YXRlID0gYmVoYXZpb3IuaW5pdGlhbFN0YXRlO1xuICB2YXIgb2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICB2YXIgbWFpbGJveCA9IFtdO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZsdXNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gICAgd2hpbGUgKG1haWxib3gubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50XzEgPSBtYWlsYm94LnNoaWZ0KCk7XG4gICAgICBzdGF0ZSA9IGJlaGF2aW9yLnRyYW5zaXRpb24oc3RhdGUsIGV2ZW50XzEsIGFjdG9yQ3R4KTtcbiAgICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChzdGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmbHVzaGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBhY3RvciA9IEFjdG9yLnRvQWN0b3JSZWYoe1xuICAgIGlkOiBvcHRpb25zLmlkLFxuICAgIHNlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWFpbGJveC5wdXNoKGV2ZW50KTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSB1dGlscy50b09ic2VydmVyKG5leHQsIGhhbmRsZUVycm9yLCBjb21wbGV0ZSk7XG4gICAgICBvYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIG9ic2VydmVyLm5leHQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB2YXIgYWN0b3JDdHggPSB7XG4gICAgcGFyZW50OiBvcHRpb25zLnBhcmVudCxcbiAgICBzZWxmOiBhY3RvcixcbiAgICBpZDogb3B0aW9ucy5pZCB8fCAnYW5vbnltb3VzJyxcbiAgICBvYnNlcnZlcnM6IG9ic2VydmVyc1xuICB9O1xuICBzdGF0ZSA9IGJlaGF2aW9yLnN0YXJ0ID8gYmVoYXZpb3Iuc3RhcnQoYWN0b3JDdHgpIDogc3RhdGU7XG4gIHJldHVybiBhY3Rvcjtcbn1cblxuZXhwb3J0cy5zcGF3bkJlaGF2aW9yID0gc3Bhd25CZWhhdmlvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26067\n")}}]);