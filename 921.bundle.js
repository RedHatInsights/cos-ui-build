(self.webpackChunk_cos_ui_apps_cos_ui=self.webpackChunk_cos_ui_apps_cos_ui||[]).push([[921],{40921:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Auto\": () => (/* reexport */ Auto),\n  \"AutoForm\": () => (/* reexport */ AutoForm),\n  \"BaseForm\": () => (/* reexport */ BaseForm),\n  \"Bridge\": () => (/* reexport */ Bridge),\n  \"Quick\": () => (/* reexport */ Quick),\n  \"QuickForm\": () => (/* reexport */ QuickForm),\n  \"Validated\": () => (/* reexport */ Validated),\n  \"ValidatedForm\": () => (/* reexport */ ValidatedForm),\n  \"ValidatedQuickForm\": () => (/* reexport */ ValidatedQuickForm),\n  \"changedKeys\": () => (/* reexport */ changedKeys),\n  \"connectField\": () => (/* reexport */ connectField),\n  \"context\": () => (/* reexport */ context_context),\n  \"createAutoField\": () => (/* reexport */ createAutoField),\n  \"filterDOMProps\": () => (/* reexport */ filterDOMProps),\n  \"joinName\": () => (/* reexport */ joinName),\n  \"randomIds\": () => (/* reexport */ randomIds),\n  \"useField\": () => (/* reexport */ useField),\n  \"useForm\": () => (/* reexport */ useForm)\n});\n\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/clone.js\nvar clone = __webpack_require__(54624);\nvar clone_default = /*#__PURE__*/__webpack_require__.n(clone);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/isEqual.js\nvar isEqual = __webpack_require__(62119);\nvar isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/omit.js\nvar omit = __webpack_require__(34864);\nvar omit_default = /*#__PURE__*/__webpack_require__.n(omit);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/setWith.js\nvar setWith = __webpack_require__(61420);\nvar setWith_default = /*#__PURE__*/__webpack_require__.n(setWith);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/get.js\nvar get = __webpack_require__(24546);\nvar get_default = /*#__PURE__*/__webpack_require__.n(get);\n// EXTERNAL MODULE: consume shared module (default) react@^16.13.1 (singleton) (fallback: ../../node_modules/react/index.js)\nvar index_js_ = __webpack_require__(42403);\nvar index_js_default = /*#__PURE__*/__webpack_require__.n(index_js_);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/xorWith.js\nvar xorWith = __webpack_require__(37339);\nvar xorWith_default = /*#__PURE__*/__webpack_require__.n(xorWith);\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/joinName.js\nfunction joinName(...parts) {\n    const name = [];\n    for (let index = 0; index !== parts.length; ++index) {\n        const part = parts[index];\n        if (part || part === 0) {\n            if (typeof part === 'string') {\n                if (part.indexOf('.') !== -1) {\n                    name.push(...part.split('.'));\n                }\n                else {\n                    name.push(part);\n                }\n            }\n            else if (Array.isArray(part)) {\n                parts.splice(index--, 1, ...part);\n            }\n            else {\n                name.push('' + part);\n            }\n        }\n    }\n    return parts[0] === null ? name : name.join('.');\n}\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/changedKeys.js\n\n\n\nfunction changedKeys(root, valueA, valueB) {\n    if (!valueA || valueA !== Object(valueA) || valueA instanceof Date) {\n        return isEqual_default()(valueA, valueB) ? [] : [root];\n    }\n    if (!valueB) {\n        return [root, ...Object.keys(valueA).map(key => joinName(root, key))];\n    }\n    const changed = xorWith_default()(Object.entries(valueA), Object.entries(valueB), (isEqual_default())).map(pair => joinName(root, pair[0]));\n    if (changed.length) {\n        changed.unshift(root);\n    }\n    return changed;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/context.js\n\nconst context_context = (0,index_js_.createContext)(null);\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/randomIds.js\n// Workaround for SSR\n// https://github.com/vazco/uniforms/issues/40\n// https://github.com/facebook/react/issues/4000\nfunction randomIdsGenerator(prefix) {\n    let counter = 0;\n    return () => `${prefix}-${('000' + (counter++).toString(36)).slice(-4)}`;\n}\nconst randomIdPrefix = randomIdsGenerator('uniforms');\nfunction randomIds(prefix = randomIdPrefix()) {\n    return randomIdsGenerator(prefix);\n}\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/BaseForm.js\n\n\n\n\n\n\n\n\nclass BaseForm extends index_js_.Component {\n    constructor(props) {\n        super(props);\n        // @ts-expect-error: State may be bigger, but it'll be covered by the subclasses.\n        this.state = {\n            changed: false,\n            changedMap: Object.create(null),\n            resetCount: 0,\n            submitted: false,\n            submitting: false,\n        };\n        this.mounted = false;\n        this.randomId = randomIds(this.props.id);\n        this.onReset = this.reset = this.onReset.bind(this);\n        this.onChange = this.change = this.onChange.bind(this);\n        this.onSubmit = this.submit = this.onSubmit.bind(this);\n        // TODO: It shouldn't be here\n        const getModel = this.getModel.bind(this);\n        this.getModel = (mode, model = getModel(mode)) => mode !== undefined && this.props.modelTransform\n            ? this.props.modelTransform(mode, model)\n            : model;\n    }\n    componentDidMount() {\n        this.mounted = true;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    componentDidUpdate(prevProps, prevState, snapshot) { }\n    componentWillUnmount() {\n        this.mounted = false;\n        if (this.delayId) {\n            clearTimeout(this.delayId);\n        }\n    }\n    getContext() {\n        return {\n            changed: this.state.changed,\n            changedMap: this.state.changedMap,\n            error: this.getContextError(),\n            model: this.getContextModel(),\n            name: this.getContextName(),\n            onChange: this.getContextOnChange(),\n            onSubmit: this.getContextOnSubmit(),\n            randomId: this.randomId,\n            schema: this.getContextSchema(),\n            state: this.getContextState(),\n            submitting: this.state.submitting,\n            validating: false,\n            submitted: this.state.submitted,\n        };\n    }\n    getContextName() {\n        return [];\n    }\n    getContextError() {\n        return this.props.error;\n    }\n    getContextModel() {\n        return this.getModel('form');\n    }\n    getContextState() {\n        return {\n            disabled: !!this.props.disabled,\n            label: !!this.props.label,\n            placeholder: !!this.props.placeholder,\n            readOnly: !!this.props.readOnly,\n            showInlineError: !!this.props.showInlineError,\n        };\n    }\n    getContextSchema() {\n        return this.props.schema;\n    }\n    getContextOnChange() {\n        // It's bound in constructor.\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        return this.onChange;\n    }\n    getContextOnSubmit() {\n        // It's bound in constructor.\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        return this.onSubmit;\n    }\n    getModel(mode, model = this.props.model) {\n        return model;\n    }\n    getNativeFormProps() {\n        const props = omit_default()(this.props, [\n            'autosave',\n            'autosaveDelay',\n            'disabled',\n            'error',\n            'label',\n            'model',\n            'modelTransform',\n            'onChange',\n            'onSubmit',\n            'placeholder',\n            'readOnly',\n            'schema',\n            'showInlineError',\n        ]);\n        return Object.assign(Object.assign({}, props), { \n            // It's bound in constructor.\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            onSubmit: this.onSubmit, key: `reset-${this.state.resetCount}` });\n    }\n    onChange(key, value) {\n        // Do not set `changed` before componentDidMount\n        if (this.mounted) {\n            const keys = changedKeys(key, value, get_default()(this.getModel(), key));\n            if (keys.length !== 0) {\n                this.setState(state => \n                // If all are already marked, we can skip the update completely.\n                state.changed && keys.every(key => !!get_default()(state.changedMap, key))\n                    ? null\n                    : {\n                        changed: true,\n                        changedMap: keys.reduce((changedMap, key) => setWith_default()(changedMap, key, {}, (clone_default())), clone_default()(state.changedMap)),\n                    });\n            }\n        }\n        if (this.props.onChange) {\n            this.props.onChange(key, value);\n        }\n        // Do not call `onSubmit` before componentDidMount\n        if (this.mounted && this.props.autosave) {\n            if (this.delayId) {\n                this.delayId = clearTimeout(this.delayId);\n            }\n            // Delay autosave by `autosaveDelay` milliseconds...\n            this.delayId = setTimeout(() => {\n                // ...and wait for all scheduled `setState`s to commit. This is required\n                // for AutoForm to validate correct model, waiting in `onChange`.\n                this.setState(() => null, () => {\n                    this.onSubmit();\n                });\n            }, this.props.autosaveDelay);\n        }\n    }\n    __reset(state) {\n        return {\n            changed: false,\n            changedMap: Object.create(null),\n            resetCount: state.resetCount + 1,\n            submitted: false,\n            submitting: false,\n        };\n    }\n    onReset() {\n        // @ts-expect-error\n        // It's bound in constructor.\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        this.setState(this.__reset);\n    }\n    onSubmit(event) {\n        if (event) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        this.setState(state => (state.submitted ? null : { submitted: true }));\n        const result = this.props.onSubmit(this.getModel('submit'));\n        if (!(result instanceof Promise)) {\n            return Promise.resolve();\n        }\n        this.setState({ submitting: true });\n        return result.finally(() => {\n            this.setState({ submitting: false });\n        });\n    }\n    render() {\n        return (index_js_default().createElement(context_context.Provider, { value: this.getContext() },\n            index_js_default().createElement(\"form\", Object.assign({}, this.getNativeFormProps()))));\n    }\n}\nBaseForm.displayName = 'Form';\nBaseForm.defaultProps = {\n    autosave: false,\n    autosaveDelay: 0,\n    error: null,\n    label: true,\n    model: Object.create(null),\n    noValidate: true,\n    onSubmit() { },\n};\n\n// EXTERNAL MODULE: ../../node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(5163);\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/QuickForm.js\n\n\n\nfunction Quick(Base) {\n    // @ts-expect-error: Mixin class problem.\n    class QuickForm extends Base {\n        getNativeFormProps() {\n            const _a = super.getNativeFormProps(), { autoField: AutoField = this.getAutoField(), errorsField: ErrorsField = this.getErrorsField(), submitField: SubmitField = this.getSubmitField() } = _a, props = (0,tslib_es6.__rest)(_a, [\"autoField\", \"errorsField\", \"submitField\"]);\n            if (!props.children) {\n                props.children = this.getContextSchema()\n                    .getSubfields()\n                    .map(key => index_js_default().createElement(AutoField, { key: key, name: key }))\n                    .concat([\n                    index_js_default().createElement(ErrorsField, { key: \"$ErrorsField\" }),\n                    index_js_default().createElement(SubmitField, { key: \"$SubmitField\" }),\n                ]);\n            }\n            return props;\n        }\n        getAutoField() {\n            return () => null;\n        }\n        getErrorsField() {\n            return () => null;\n        }\n        getSubmitField() {\n            return () => null;\n        }\n    }\n    QuickForm.Quick = Quick;\n    QuickForm.displayName = `Quick${Base.displayName}`;\n    return QuickForm;\n}\nconst QuickForm = Quick(BaseForm);\n\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/cloneDeep.js\nvar cloneDeep = __webpack_require__(79506);\nvar cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/noop.js\nvar noop = __webpack_require__(75637);\nvar noop_default = /*#__PURE__*/__webpack_require__.n(noop);\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/ValidatedForm.js\n\n\n\n\n\n\n\nfunction Validated(Base) {\n    // @ts-expect-error: Mixin class problem.\n    class ValidatedForm extends Base {\n        constructor(props) {\n            super(props);\n            this.state = Object.assign(Object.assign({}, this.state), { error: null, validate: false, validating: false, validator: this.getContextSchema().getValidator(props.validator) });\n            this.onValidate = this.validate = this.onValidate.bind(this);\n            this.onValidateModel = this.validateModel = this.onValidateModel.bind(this);\n        }\n        getContextError() {\n            var _a;\n            return (_a = super.getContextError()) !== null && _a !== void 0 ? _a : this.state.error;\n        }\n        getContext() {\n            return Object.assign(Object.assign({}, super.getContext()), { validating: this.state.validating });\n        }\n        getNativeFormProps() {\n            return omit_default()(super.getNativeFormProps(), [\n                'onValidate',\n                'validate',\n                'validator',\n            ]);\n        }\n        componentDidUpdate(prevProps, prevState, snapshot) {\n            super.componentDidUpdate(prevProps, prevState, snapshot);\n            const { model, schema, validate, validator } = this.props;\n            if (schema !== prevProps.schema || validator !== prevProps.validator) {\n                this.setState({ validator: schema.getValidator(validator) }, () => {\n                    if (shouldRevalidate(validate, this.state.validate)) {\n                        this.onValidate();\n                    }\n                });\n            }\n            else if (!isEqual_default()(model, prevProps.model) &&\n                shouldRevalidate(validate, this.state.validate)) {\n                this.onValidateModel(model);\n            }\n        }\n        onChange(key, value) {\n            if (shouldRevalidate(this.props.validate, this.state.validate)) {\n                this.onValidate(key, value);\n            }\n            super.onChange(key, value);\n        }\n        __reset(state) {\n            return Object.assign(Object.assign({}, super.__reset(state)), { error: null, validate: false, validating: false });\n        }\n        onSubmit(event) {\n            if (event) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            this.setState({ submitted: true, validate: true });\n            const result = this.onValidate().then(error => {\n                if (error !== null) {\n                    return Promise.reject(error);\n                }\n                // Validation failed (i.e. returned an error), so no error is present\n                // both in the props nor the state.\n                return super.onSubmit().catch(error => {\n                    this.setState({ error });\n                    throw error;\n                });\n            });\n            result.catch((noop_default()));\n            return result;\n        }\n        onValidate(key, value) {\n            let model = this.getContextModel();\n            if (model && key) {\n                model = setWith_default()(clone_default()(model), key, cloneDeep_default()(value), (clone_default()));\n            }\n            return this.onValidateModel(model);\n        }\n        onValidateModel(originalModel) {\n            const model = this.getModel('validate', originalModel);\n            // Using `then` allows using the same code for both synchronous and\n            // asynchronous cases. We could use `await` here, but it would make all\n            // calls asynchronous, unnecessary delaying synchronous validation.\n            const then = makeThen(() => {\n                this.setState({ validating: true });\n            });\n            return then(this.state.validator(model), (error = null) => then(this.props.onValidate(model, error), (error = null) => {\n                var _a;\n                // Do not copy the error from props to the state.\n                error = this.props.error === error ? null : error;\n                // If the whole operation was synchronous and resulted in the same\n                // error, we can skip the re-render.\n                this.setState(state => state.error === error && !state.validating\n                    ? null\n                    : { error, validating: false });\n                // A predefined error takes precedence over the validation one.\n                return Promise.resolve((_a = this.props.error) !== null && _a !== void 0 ? _a : error);\n            }));\n        }\n    }\n    ValidatedForm.Validated = Validated;\n    ValidatedForm.displayName = `Validated${Base.displayName}`;\n    ValidatedForm.defaultProps = Object.assign(Object.assign({}, Base.defaultProps), { onValidate(model, error) {\n            return error;\n        }, validate: 'onChangeAfterSubmit' });\n    return ValidatedForm;\n}\nfunction makeThen(callIfAsync) {\n    function then(value, fn) {\n        if (value instanceof Promise) {\n            callIfAsync();\n            return value.then(fn);\n        }\n        return fn(value);\n    }\n    return then;\n}\nfunction shouldRevalidate(inProps, inState) {\n    return (inProps === 'onChange' || (inProps === 'onChangeAfterSubmit' && inState));\n}\nconst ValidatedForm = Validated(BaseForm);\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/ValidatedQuickForm.js\n\n\n\nconst ValidatedQuickForm = Validated(Quick(BaseForm));\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/AutoForm.js\n\n\n\n\n\nfunction Auto(Base) {\n    // @ts-expect-error: Mixin class problem.\n    class AutoForm extends Base {\n        constructor(props) {\n            super(props);\n            this.state = Object.assign(Object.assign({}, this.state), { model: props.model });\n        }\n        componentDidUpdate(prevProps, prevState, snapshot) {\n            const { model } = this.props;\n            if (!isEqual_default()(model, prevProps.model)) {\n                this.setState({ model });\n            }\n            super.componentDidUpdate(prevProps, prevState, snapshot);\n        }\n        getNativeFormProps() {\n            return omit_default()(super.getNativeFormProps(), ['onChangeModel']);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        getModel(mode) {\n            return this.state.model;\n        }\n        onChange(key, value) {\n            super.onChange(key, value);\n            this.setState(state => ({ model: setWith_default()(clone_default()(state.model), key, value, (clone_default())) }), () => {\n                if (this.props.onChangeModel) {\n                    this.props.onChangeModel(this.state.model);\n                }\n            });\n        }\n        __reset(state) {\n            return Object.assign(Object.assign({}, super.__reset(state)), { model: this.props.model });\n        }\n    }\n    AutoForm.Auto = Auto;\n    AutoForm.displayName = `Auto${Base.displayName}`;\n    return AutoForm;\n}\nconst AutoForm = Auto(ValidatedQuickForm);\n\n// EXTERNAL MODULE: ../../node_modules/invariant/browser.js\nvar browser = __webpack_require__(47677);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/Bridge.js\n\nclass Bridge {\n    // Each bridge can have a different set of parameters.\n    constructor(...args) {\n        browser_default()(this.constructor !== Bridge, 'Bridge cannot be instantiated (args=%o).', { args });\n    }\n    // Get an error for field `name` out of `error`. There is no standarized\n    // format, but fields treat truthy values as a sign of being invalid. Fields\n    // receive this as a `error` guaranteed prop.\n    getError(name, error) {\n        return browser_default()(false, '%s have not implemented `getError` method (args=%o).', this.constructor.name, { name, error });\n    }\n    // Get an error message for field `name` out of `error`. If there is no error,\n    // return an empty string. Fields receive this as a `errorMessage` guaranteed\n    // prop.\n    getErrorMessage(name, error) {\n        return browser_default()(false, '%s have not implemented `getErrorMessage` method (args=%o).', this.constructor.name, { name, error });\n    }\n    // Get all error messages from `error`. Only `ErrorsField` make use of that\n    // (in builtin themes).\n    getErrorMessages(error) {\n        return browser_default()(false, '%s have not implemented `getErrorMessages` method (args=%o).', this.constructor.name, { error });\n    }\n    // Get internal field definition for field `name`. Fields receive this as a\n    // `field` guaranteed prop.\n    getField(name) {\n        return browser_default()(false, '%s have not implemented `getField` method (args=%o).', this.constructor.name, { name });\n    }\n    // Get initial value of field `name`. It is used as a default when no value is\n    // set (e.g. the form is rendered with an empty `model`). Additionally,\n    // `props` are this field instance props. If a field is rendered multiple\n    // times, this function will be called multiple times, possibly with different\n    // `props`.\n    getInitialValue(name, props) {\n        return browser_default()(false, '%s have not implemented `getInitialValue` method (args=%o).', this.constructor.name, { name, props });\n    }\n    // Get props defined in schema for a field `name`. There are no required nor\n    // banned fields, however properties like `required` are often available.\n    // Additionally, `props` are this field instance props. If a field is rendered\n    // multiple times, this function will be called multiple times, possibly with\n    // different `props`.\n    getProps(name, props) {\n        return browser_default()(false, '%s have not implemented `getProps` method (args=%o).', this.constructor.name, { name, props });\n    }\n    // Get a list of subfields of field `name` or top-level fields, if no `name`\n    // is passed.\n    getSubfields(name) {\n        return browser_default()(false, '%s have not implemented `getSubfields` method (args=%o).', this.constructor.name, { name });\n    }\n    // Get a type of field `name`. See `FieldTypeType` for details.\n    getType(name) {\n        return browser_default()(false, '%s have not implemented `getType` method (args=%o).', this.constructor.name, { name });\n    }\n    // Get a validator function. The `options` here are from the `validator` prop\n    // of the form. A validator function receives a model and returns an error or\n    // a promise that will resolve (not reject!) with an error. If there is no\n    // error, return (or resolve with) a `null` value instead.\n    // eslint-disable-next-line prettier/prettier\n    getValidator(options) {\n        return browser_default()(false, '%s have not implemented `getValidator` method (args=%o).', this.constructor.name, { options });\n    }\n}\n\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/mapValues.js\nvar mapValues = __webpack_require__(78179);\nvar mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/some.js\nvar some = __webpack_require__(1000);\nvar some_default = /*#__PURE__*/__webpack_require__.n(some);\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/useForm.js\n\n\n\nfunction useForm() {\n    const context = (0,index_js_.useContext)(context_context);\n    browser_default()(context !== null, 'useForm must be used within a form.');\n    return context;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/useField.js\n\n\n\n\n\nfunction propagate(prop, schema, state, fallback) {\n    const forcedFallbackInProp = prop === true || prop === undefined;\n    const forcedFallbackInSchema = schema === true || schema === undefined;\n    const schemaValue = forcedFallbackInSchema ? fallback : schema;\n    const value = prop === '' ||\n        prop === false ||\n        (forcedFallbackInProp && (forcedFallbackInSchema || !state))\n        ? ''\n        : forcedFallbackInProp\n            ? schemaValue\n            : prop;\n    return [value, schemaValue];\n}\nfunction useField(fieldName, props, options) {\n    var _a;\n    const context = useForm();\n    const name = joinName((options === null || options === void 0 ? void 0 : options.absoluteName) ? '' : context.name, fieldName);\n    const state = mapValues_default()(context.state, (prev, key) => {\n        const next = props[key];\n        return next === null || next === undefined ? prev : !!next;\n    });\n    const changed = !!get_default()(context.changedMap, name);\n    const error = context.schema.getError(name, context.error);\n    const errorMessage = context.schema.getErrorMessage(name, context.error);\n    const field = context.schema.getField(name);\n    const fieldType = context.schema.getType(name);\n    const fields = context.schema.getSubfields(name);\n    const schemaProps = context.schema.getProps(name, Object.assign(Object.assign({}, state), props));\n    const [label, labelFallback] = propagate(props.label, schemaProps.label, state.label, '');\n    const [placeholder] = propagate(props.placeholder, schemaProps.placeholder, state.placeholder, label || labelFallback);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const id = (0,index_js_.useMemo)(() => context.randomId(), []);\n    const onChange = (0,index_js_.useCallback)((value, key = name) => {\n        context.onChange(key, value);\n    }, \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [context.onChange, name]);\n    const valueFromModel = get_default()(context.model, name);\n    let initialValue;\n    let value = (_a = props.value) !== null && _a !== void 0 ? _a : valueFromModel;\n    if (value === undefined) {\n        value = context.schema.getInitialValue(name, props);\n        initialValue = value;\n    }\n    else if (props.value !== undefined && props.value !== valueFromModel) {\n        initialValue = props.value;\n    }\n    if ((options === null || options === void 0 ? void 0 : options.initialValue) !== false) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,index_js_.useEffect)(() => {\n            var _a;\n            const required = (_a = props.required) !== null && _a !== void 0 ? _a : schemaProps.required;\n            if (required && initialValue !== undefined) {\n                onChange(initialValue);\n            }\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n    }\n    const fieldProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ id }, state), { changed,\n        error,\n        errorMessage,\n        field,\n        fieldType,\n        fields,\n        onChange,\n        value }), schemaProps), props), { label,\n        name, \n        // TODO: Should we assert `typeof placeholder === 'string'`?\n        placeholder: placeholder });\n    return [fieldProps, context];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/connectField.js\n\n\n\n\n\nfunction connectField(Component, options) {\n    function Field(props) {\n        const [fieldProps, context] = useField(props.name, props, options);\n        const hasChainName = props.name !== '';\n        const anyFlowingPropertySet = some_default()(context.state, \n        // @ts-expect-error: `props` has no index signature.\n        (_, key) => props[key] !== null && props[key] !== undefined);\n        if (!anyFlowingPropertySet && !hasChainName) {\n            return index_js_default().createElement(Component, Object.assign({}, props, fieldProps));\n        }\n        const nextContext = Object.assign({}, context);\n        if (anyFlowingPropertySet) {\n            nextContext.state = mapValues_default()(nextContext.state, (value, key) => \n            // @ts-expect-error: `props` has no index signature.\n            props[key] !== null && props[key] !== undefined ? !!props[key] : value);\n        }\n        if (hasChainName) {\n            nextContext.name = nextContext.name.concat(props.name);\n        }\n        return (index_js_default().createElement(context_context.Provider, { value: nextContext },\n            index_js_default().createElement(Component, Object.assign({}, props, fieldProps))));\n    }\n    Field.displayName = `${Component.displayName || Component.name}Field`;\n    return Object.assign(Field, {\n        Component,\n        options,\n    });\n}\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/createAutoField.js\n\n\n\nfunction createAutoField(defaultComponentDetector) {\n    const context = (0,index_js_.createContext)(defaultComponentDetector);\n    function AutoField(rawProps) {\n        var _a, _b;\n        const [props, uniforms] = useField(rawProps.name, rawProps);\n        const componentDetector = (0,index_js_.useContext)(context);\n        const component = (_a = props.component) !== null && _a !== void 0 ? _a : componentDetector(props, uniforms);\n        browser_default()(component, 'AutoField received no component for: %s', props.name);\n        return 'options' in component && ((_b = component.options) === null || _b === void 0 ? void 0 : _b.kind) === 'leaf'\n            ? (0,index_js_.createElement)(component.Component, props)\n            : (0,index_js_.createElement)(component, rawProps);\n    }\n    AutoField.componentDetectorContext = context;\n    AutoField.defaultComponentDetector = defaultComponentDetector;\n    return AutoField;\n}\n\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/pickBy.js\nvar pickBy = __webpack_require__(30552);\nvar pickBy_default = /*#__PURE__*/__webpack_require__.n(pickBy);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/sortedIndex.js\nvar sortedIndex = __webpack_require__(69573);\nvar sortedIndex_default = /*#__PURE__*/__webpack_require__.n(sortedIndex);\n// EXTERNAL MODULE: ../../node_modules/uniforms/node_modules/lodash/sortedIndexOf.js\nvar sortedIndexOf = __webpack_require__(69219);\nvar sortedIndexOf_default = /*#__PURE__*/__webpack_require__.n(sortedIndexOf);\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/filterDOMProps.js\n\n\n\nconst registered = [];\nfunction filter(props) {\n    return pickBy_default()(props, filterOne);\n}\nfunction filterOne(value, prop) {\n    return sortedIndexOf_default()(registered, prop) === -1;\n}\nfunction register(...props) {\n    props.forEach(prop => {\n        if (sortedIndexOf_default()(registered, prop) === -1) {\n            registered.splice(sortedIndex_default()(registered, prop), 0, prop);\n        }\n    });\n}\nconst filterDOMProps = Object.assign(filter, {\n    register,\n    registered: registered,\n});\nregister(\n// These props are provided by useField directly.\n'changed', 'error', 'errorMessage', 'field', 'fieldType', 'fields', 'initialCount', 'name', 'onChange', 'transform', 'value', \n// These props are provided by useField through context.state.\n'disabled', 'label', 'placeholder', 'showInlineError', \n// This is used by AutoField.\n'component', \n// These is used by AutoField and bridges.\n'allowedValues');\n\n;// CONCATENATED MODULE: ../../node_modules/uniforms/es6/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvam9pbk5hbWUuanM/MzhkOSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvY2hhbmdlZEtleXMuanM/MWZjYSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvY29udGV4dC5qcz8yODM2Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zL2VzNi9yYW5kb21JZHMuanM/NDEwOSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvQmFzZUZvcm0uanM/OTJmYSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvUXVpY2tGb3JtLmpzPzY0ZDQiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMvZXM2L1ZhbGlkYXRlZEZvcm0uanM/NjY3NiIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvVmFsaWRhdGVkUXVpY2tGb3JtLmpzPzhjZTQiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMvZXM2L0F1dG9Gb3JtLmpzPzEzYTgiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMvZXM2L0JyaWRnZS5qcz9jY2YxIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zL2VzNi91c2VGb3JtLmpzPzgyMTUiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMvZXM2L3VzZUZpZWxkLmpzPzgwMzQiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMvZXM2L2Nvbm5lY3RGaWVsZC5qcz8wYjVlIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zL2VzNi9jcmVhdGVBdXRvRmllbGQuanM/NTIxMyIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvZmlsdGVyRE9NUHJvcHMuanM/ODM3YyIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy9lczYvaW5kZXguanM/YTczYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCcUM7QUFDQTtBQUNDO0FBQy9CO0FBQ1A7QUFDQSxlQUFlLGlCQUFPO0FBQ3RCO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBLG9CQUFvQixpQkFBTyxpREFBaUQsbUJBQU8sY0FBYyxRQUFRO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZzQztBQUMvQixNQUFNLGVBQU8sR0FBRywyQkFBYTs7O0FDRHBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxHQUFHLDZDQUE2QztBQUMzRTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7QUNWaUM7QUFDSjtBQUNFO0FBQ007QUFDSTtBQUNH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QW9CLDJCQUFhO0FBQ2pDO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQyxrQ0FBa0Msd0JBQVU7QUFDNUM7QUFDQSxRQUFRLGlCQUFTO0FBQ2pCO0FBQ0EsY0FBYywyQkFBYTtBQUMzQixjQUFjLDJCQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xCbUM7QUFDVTtBQUNJO0FBQ2pEO0FBQ0E7QUFDQSxXQUFXLGdCQUFNO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXLHVCQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQWE7QUFDekIsOEJBQThCLHFCQUFXO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0IyQjtBQUNBO0FBQ0Y7QUFDRztBQUNJO0FBQ0s7QUFDUDtBQUNDO0FBQ0w7QUFDUTtBQUNEO0FBQ047QUFDQztBQUNKO0FBQ0c7QUFDRCIsImZpbGUiOiI0MDkyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBqb2luTmFtZSguLi5wYXJ0cykge1xuICAgIGNvbnN0IG5hbWUgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ICE9PSBwYXJ0cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICAgICAgaWYgKHBhcnQgfHwgcGFydCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5wdXNoKC4uLnBhcnQuc3BsaXQoJy4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpbmRleC0tLCAxLCAuLi5wYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hbWUucHVzaCgnJyArIHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0c1swXSA9PT0gbnVsbCA/IG5hbWUgOiBuYW1lLmpvaW4oJy4nKTtcbn1cbiIsImltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCB4b3JXaXRoIGZyb20gJ2xvZGFzaC94b3JXaXRoJztcbmltcG9ydCB7IGpvaW5OYW1lIH0gZnJvbSAnLi9qb2luTmFtZSc7XG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlZEtleXMocm9vdCwgdmFsdWVBLCB2YWx1ZUIpIHtcbiAgICBpZiAoIXZhbHVlQSB8fCB2YWx1ZUEgIT09IE9iamVjdCh2YWx1ZUEpIHx8IHZhbHVlQSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwodmFsdWVBLCB2YWx1ZUIpID8gW10gOiBbcm9vdF07XG4gICAgfVxuICAgIGlmICghdmFsdWVCKSB7XG4gICAgICAgIHJldHVybiBbcm9vdCwgLi4uT2JqZWN0LmtleXModmFsdWVBKS5tYXAoa2V5ID0+IGpvaW5OYW1lKHJvb3QsIGtleSkpXTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IHhvcldpdGgoT2JqZWN0LmVudHJpZXModmFsdWVBKSwgT2JqZWN0LmVudHJpZXModmFsdWVCKSwgaXNFcXVhbCkubWFwKHBhaXIgPT4gam9pbk5hbWUocm9vdCwgcGFpclswXSkpO1xuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCkge1xuICAgICAgICBjaGFuZ2VkLnVuc2hpZnQocm9vdCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbiIsIi8vIFdvcmthcm91bmQgZm9yIFNTUlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZhemNvL3VuaWZvcm1zL2lzc3Vlcy80MFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy80MDAwXG5mdW5jdGlvbiByYW5kb21JZHNHZW5lcmF0b3IocHJlZml4KSB7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIHJldHVybiAoKSA9PiBgJHtwcmVmaXh9LSR7KCcwMDAnICsgKGNvdW50ZXIrKykudG9TdHJpbmcoMzYpKS5zbGljZSgtNCl9YDtcbn1cbmNvbnN0IHJhbmRvbUlkUHJlZml4ID0gcmFuZG9tSWRzR2VuZXJhdG9yKCd1bmlmb3JtcycpO1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUlkcyhwcmVmaXggPSByYW5kb21JZFByZWZpeCgpKSB7XG4gICAgcmV0dXJuIHJhbmRvbUlkc0dlbmVyYXRvcihwcmVmaXgpO1xufVxuIiwiaW1wb3J0IGNsb25lIGZyb20gJ2xvZGFzaC9jbG9uZSc7XG5pbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoL29taXQnO1xuaW1wb3J0IHNldFdpdGggZnJvbSAnbG9kYXNoL3NldFdpdGgnO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNoYW5nZWRLZXlzIH0gZnJvbSAnLi9jaGFuZ2VkS2V5cyc7XG5pbXBvcnQgeyBjb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7IHJhbmRvbUlkcyB9IGZyb20gJy4vcmFuZG9tSWRzJztcbmV4cG9ydCBjbGFzcyBCYXNlRm9ybSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdGF0ZSBtYXkgYmUgYmlnZ2VyLCBidXQgaXQnbGwgYmUgY292ZXJlZCBieSB0aGUgc3ViY2xhc3Nlcy5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2hhbmdlZE1hcDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIHJlc2V0Q291bnQ6IDAsXG4gICAgICAgICAgICBzdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJhbmRvbUlkID0gcmFuZG9tSWRzKHRoaXMucHJvcHMuaWQpO1xuICAgICAgICB0aGlzLm9uUmVzZXQgPSB0aGlzLnJlc2V0ID0gdGhpcy5vblJlc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLmNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN1Ym1pdCA9IHRoaXMuc3VibWl0ID0gdGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBUT0RPOiBJdCBzaG91bGRuJ3QgYmUgaGVyZVxuICAgICAgICBjb25zdCBnZXRNb2RlbCA9IHRoaXMuZ2V0TW9kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRNb2RlbCA9IChtb2RlLCBtb2RlbCA9IGdldE1vZGVsKG1vZGUpKSA9PiBtb2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcy5tb2RlbFRyYW5zZm9ybVxuICAgICAgICAgICAgPyB0aGlzLnByb3BzLm1vZGVsVHJhbnNmb3JtKG1vZGUsIG1vZGVsKVxuICAgICAgICAgICAgOiBtb2RlbDtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KSB7IH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VkOiB0aGlzLnN0YXRlLmNoYW5nZWQsXG4gICAgICAgICAgICBjaGFuZ2VkTWFwOiB0aGlzLnN0YXRlLmNoYW5nZWRNYXAsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDb250ZXh0RXJyb3IoKSxcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldENvbnRleHRNb2RlbCgpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRDb250ZXh0TmFtZSgpLFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuZ2V0Q29udGV4dE9uQ2hhbmdlKCksXG4gICAgICAgICAgICBvblN1Ym1pdDogdGhpcy5nZXRDb250ZXh0T25TdWJtaXQoKSxcbiAgICAgICAgICAgIHJhbmRvbUlkOiB0aGlzLnJhbmRvbUlkLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLmdldENvbnRleHRTY2hlbWEoKSxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmdldENvbnRleHRTdGF0ZSgpLFxuICAgICAgICAgICAgc3VibWl0dGluZzogdGhpcy5zdGF0ZS5zdWJtaXR0aW5nLFxuICAgICAgICAgICAgdmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgICAgICBzdWJtaXR0ZWQ6IHRoaXMuc3RhdGUuc3VibWl0dGVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDb250ZXh0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXRDb250ZXh0RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmVycm9yO1xuICAgIH1cbiAgICBnZXRDb250ZXh0TW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vZGVsKCdmb3JtJyk7XG4gICAgfVxuICAgIGdldENvbnRleHRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiAhIXRoaXMucHJvcHMuZGlzYWJsZWQsXG4gICAgICAgICAgICBsYWJlbDogISF0aGlzLnByb3BzLmxhYmVsLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICEhdGhpcy5wcm9wcy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgIHJlYWRPbmx5OiAhIXRoaXMucHJvcHMucmVhZE9ubHksXG4gICAgICAgICAgICBzaG93SW5saW5lRXJyb3I6ICEhdGhpcy5wcm9wcy5zaG93SW5saW5lRXJyb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENvbnRleHRTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNjaGVtYTtcbiAgICB9XG4gICAgZ2V0Q29udGV4dE9uQ2hhbmdlKCkge1xuICAgICAgICAvLyBJdCdzIGJvdW5kIGluIGNvbnN0cnVjdG9yLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHJldHVybiB0aGlzLm9uQ2hhbmdlO1xuICAgIH1cbiAgICBnZXRDb250ZXh0T25TdWJtaXQoKSB7XG4gICAgICAgIC8vIEl0J3MgYm91bmQgaW4gY29uc3RydWN0b3IuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgcmV0dXJuIHRoaXMub25TdWJtaXQ7XG4gICAgfVxuICAgIGdldE1vZGVsKG1vZGUsIG1vZGVsID0gdGhpcy5wcm9wcy5tb2RlbCkge1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuICAgIGdldE5hdGl2ZUZvcm1Qcm9wcygpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBvbWl0KHRoaXMucHJvcHMsIFtcbiAgICAgICAgICAgICdhdXRvc2F2ZScsXG4gICAgICAgICAgICAnYXV0b3NhdmVEZWxheScsXG4gICAgICAgICAgICAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAnbW9kZWwnLFxuICAgICAgICAgICAgJ21vZGVsVHJhbnNmb3JtJyxcbiAgICAgICAgICAgICdvbkNoYW5nZScsXG4gICAgICAgICAgICAnb25TdWJtaXQnLFxuICAgICAgICAgICAgJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICdyZWFkT25seScsXG4gICAgICAgICAgICAnc2NoZW1hJyxcbiAgICAgICAgICAgICdzaG93SW5saW5lRXJyb3InLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IFxuICAgICAgICAgICAgLy8gSXQncyBib3VuZCBpbiBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIG9uU3VibWl0OiB0aGlzLm9uU3VibWl0LCBrZXk6IGByZXNldC0ke3RoaXMuc3RhdGUucmVzZXRDb3VudH1gIH0pO1xuICAgIH1cbiAgICBvbkNoYW5nZShrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIERvIG5vdCBzZXQgYGNoYW5nZWRgIGJlZm9yZSBjb21wb25lbnREaWRNb3VudFxuICAgICAgICBpZiAodGhpcy5tb3VudGVkKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gY2hhbmdlZEtleXMoa2V5LCB2YWx1ZSwgZ2V0KHRoaXMuZ2V0TW9kZWwoKSwga2V5KSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+IFxuICAgICAgICAgICAgICAgIC8vIElmIGFsbCBhcmUgYWxyZWFkeSBtYXJrZWQsIHdlIGNhbiBza2lwIHRoZSB1cGRhdGUgY29tcGxldGVseS5cbiAgICAgICAgICAgICAgICBzdGF0ZS5jaGFuZ2VkICYmIGtleXMuZXZlcnkoa2V5ID0+ICEhZ2V0KHN0YXRlLmNoYW5nZWRNYXAsIGtleSkpXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkTWFwOiBrZXlzLnJlZHVjZSgoY2hhbmdlZE1hcCwga2V5KSA9PiBzZXRXaXRoKGNoYW5nZWRNYXAsIGtleSwge30sIGNsb25lKSwgY2xvbmUoc3RhdGUuY2hhbmdlZE1hcCkpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgY2FsbCBgb25TdWJtaXRgIGJlZm9yZSBjb21wb25lbnREaWRNb3VudFxuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIHRoaXMucHJvcHMuYXV0b3NhdmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGF5SWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5SWQgPSBjbGVhclRpbWVvdXQodGhpcy5kZWxheUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGF5IGF1dG9zYXZlIGJ5IGBhdXRvc2F2ZURlbGF5YCBtaWxsaXNlY29uZHMuLi5cbiAgICAgICAgICAgIHRoaXMuZGVsYXlJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIC4uLmFuZCB3YWl0IGZvciBhbGwgc2NoZWR1bGVkIGBzZXRTdGF0ZWBzIHRvIGNvbW1pdC4gVGhpcyBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIC8vIGZvciBBdXRvRm9ybSB0byB2YWxpZGF0ZSBjb3JyZWN0IG1vZGVsLCB3YWl0aW5nIGluIGBvbkNoYW5nZWAuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMucHJvcHMuYXV0b3NhdmVEZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19yZXNldChzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICBjaGFuZ2VkTWFwOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgcmVzZXRDb3VudDogc3RhdGUucmVzZXRDb3VudCArIDEsXG4gICAgICAgICAgICBzdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgLy8gSXQncyBib3VuZCBpbiBjb25zdHJ1Y3Rvci5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuX19yZXNldCk7XG4gICAgfVxuICAgIG9uU3VibWl0KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUgPT4gKHN0YXRlLnN1Ym1pdHRlZCA/IG51bGwgOiB7IHN1Ym1pdHRlZDogdHJ1ZSB9KSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvcHMub25TdWJtaXQodGhpcy5nZXRNb2RlbCgnc3VibWl0JykpO1xuICAgICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzdWJtaXR0aW5nOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHN1Ym1pdHRpbmc6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5nZXRDb250ZXh0KCkgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0TmF0aXZlRm9ybVByb3BzKCkpKSkpO1xuICAgIH1cbn1cbkJhc2VGb3JtLmRpc3BsYXlOYW1lID0gJ0Zvcm0nO1xuQmFzZUZvcm0uZGVmYXVsdFByb3BzID0ge1xuICAgIGF1dG9zYXZlOiBmYWxzZSxcbiAgICBhdXRvc2F2ZURlbGF5OiAwLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGxhYmVsOiB0cnVlLFxuICAgIG1vZGVsOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG5vVmFsaWRhdGU6IHRydWUsXG4gICAgb25TdWJtaXQoKSB7IH0sXG59O1xuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQmFzZUZvcm0gfSBmcm9tICcuL0Jhc2VGb3JtJztcbmV4cG9ydCBmdW5jdGlvbiBRdWljayhCYXNlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogTWl4aW4gY2xhc3MgcHJvYmxlbS5cbiAgICBjbGFzcyBRdWlja0Zvcm0gZXh0ZW5kcyBCYXNlIHtcbiAgICAgICAgZ2V0TmF0aXZlRm9ybVByb3BzKCkge1xuICAgICAgICAgICAgY29uc3QgX2EgPSBzdXBlci5nZXROYXRpdmVGb3JtUHJvcHMoKSwgeyBhdXRvRmllbGQ6IEF1dG9GaWVsZCA9IHRoaXMuZ2V0QXV0b0ZpZWxkKCksIGVycm9yc0ZpZWxkOiBFcnJvcnNGaWVsZCA9IHRoaXMuZ2V0RXJyb3JzRmllbGQoKSwgc3VibWl0RmllbGQ6IFN1Ym1pdEZpZWxkID0gdGhpcy5nZXRTdWJtaXRGaWVsZCgpIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImF1dG9GaWVsZFwiLCBcImVycm9yc0ZpZWxkXCIsIFwic3VibWl0RmllbGRcIl0pO1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gdGhpcy5nZXRDb250ZXh0U2NoZW1hKClcbiAgICAgICAgICAgICAgICAgICAgLmdldFN1YmZpZWxkcygpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0b0ZpZWxkLCB7IGtleToga2V5LCBuYW1lOiBrZXkgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yc0ZpZWxkLCB7IGtleTogXCIkRXJyb3JzRmllbGRcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTdWJtaXRGaWVsZCwgeyBrZXk6IFwiJFN1Ym1pdEZpZWxkXCIgfSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0QXV0b0ZpZWxkKCkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RXJyb3JzRmllbGQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTdWJtaXRGaWVsZCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFF1aWNrRm9ybS5RdWljayA9IFF1aWNrO1xuICAgIFF1aWNrRm9ybS5kaXNwbGF5TmFtZSA9IGBRdWljayR7QmFzZS5kaXNwbGF5TmFtZX1gO1xuICAgIHJldHVybiBRdWlja0Zvcm07XG59XG5leHBvcnQgY29uc3QgUXVpY2tGb3JtID0gUXVpY2soQmFzZUZvcm0pO1xuIiwiaW1wb3J0IGNsb25lIGZyb20gJ2xvZGFzaC9jbG9uZSc7XG5pbXBvcnQgY2xvbmVEZWVwIGZyb20gJ2xvZGFzaC9jbG9uZURlZXAnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoL2lzRXF1YWwnO1xuaW1wb3J0IG5vb3AgZnJvbSAnbG9kYXNoL25vb3AnO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoL29taXQnO1xuaW1wb3J0IHNldFdpdGggZnJvbSAnbG9kYXNoL3NldFdpdGgnO1xuaW1wb3J0IHsgQmFzZUZvcm0gfSBmcm9tICcuL0Jhc2VGb3JtJztcbmV4cG9ydCBmdW5jdGlvbiBWYWxpZGF0ZWQoQmFzZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IE1peGluIGNsYXNzIHByb2JsZW0uXG4gICAgY2xhc3MgVmFsaWRhdGVkRm9ybSBleHRlbmRzIEJhc2Uge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZSksIHsgZXJyb3I6IG51bGwsIHZhbGlkYXRlOiBmYWxzZSwgdmFsaWRhdGluZzogZmFsc2UsIHZhbGlkYXRvcjogdGhpcy5nZXRDb250ZXh0U2NoZW1hKCkuZ2V0VmFsaWRhdG9yKHByb3BzLnZhbGlkYXRvcikgfSk7XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGUgPSB0aGlzLnZhbGlkYXRlID0gdGhpcy5vblZhbGlkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGVNb2RlbCA9IHRoaXMudmFsaWRhdGVNb2RlbCA9IHRoaXMub25WYWxpZGF0ZU1vZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q29udGV4dEVycm9yKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHN1cGVyLmdldENvbnRleHRFcnJvcigpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGdldENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdXBlci5nZXRDb250ZXh0KCkpLCB7IHZhbGlkYXRpbmc6IHRoaXMuc3RhdGUudmFsaWRhdGluZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXROYXRpdmVGb3JtUHJvcHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gb21pdChzdXBlci5nZXROYXRpdmVGb3JtUHJvcHMoKSwgW1xuICAgICAgICAgICAgICAgICdvblZhbGlkYXRlJyxcbiAgICAgICAgICAgICAgICAndmFsaWRhdGUnLFxuICAgICAgICAgICAgICAgICd2YWxpZGF0b3InLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCkge1xuICAgICAgICAgICAgc3VwZXIuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICBjb25zdCB7IG1vZGVsLCBzY2hlbWEsIHZhbGlkYXRlLCB2YWxpZGF0b3IgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICE9PSBwcmV2UHJvcHMuc2NoZW1hIHx8IHZhbGlkYXRvciAhPT0gcHJldlByb3BzLnZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyB2YWxpZGF0b3I6IHNjaGVtYS5nZXRWYWxpZGF0b3IodmFsaWRhdG9yKSB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKHZhbGlkYXRlLCB0aGlzLnN0YXRlLnZhbGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VxdWFsKG1vZGVsLCBwcmV2UHJvcHMubW9kZWwpICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZSh2YWxpZGF0ZSwgdGhpcy5zdGF0ZS52YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGVNb2RlbChtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2Uoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGUodGhpcy5wcm9wcy52YWxpZGF0ZSwgdGhpcy5zdGF0ZS52YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlci5vbkNoYW5nZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBfX3Jlc2V0KHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fX3Jlc2V0KHN0YXRlKSksIHsgZXJyb3I6IG51bGwsIHZhbGlkYXRlOiBmYWxzZSwgdmFsaWRhdGluZzogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb25TdWJtaXQoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3VibWl0dGVkOiB0cnVlLCB2YWxpZGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMub25WYWxpZGF0ZSgpLnRoZW4oZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0aW9uIGZhaWxlZCAoaS5lLiByZXR1cm5lZCBhbiBlcnJvciksIHNvIG5vIGVycm9yIGlzIHByZXNlbnRcbiAgICAgICAgICAgICAgICAvLyBib3RoIGluIHRoZSBwcm9wcyBub3IgdGhlIHN0YXRlLlxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5vblN1Ym1pdCgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LmNhdGNoKG5vb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBvblZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMuZ2V0Q29udGV4dE1vZGVsKCk7XG4gICAgICAgICAgICBpZiAobW9kZWwgJiYga2V5KSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBzZXRXaXRoKGNsb25lKG1vZGVsKSwga2V5LCBjbG9uZURlZXAodmFsdWUpLCBjbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vblZhbGlkYXRlTW9kZWwobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIG9uVmFsaWRhdGVNb2RlbChvcmlnaW5hbE1vZGVsKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuZ2V0TW9kZWwoJ3ZhbGlkYXRlJywgb3JpZ2luYWxNb2RlbCk7XG4gICAgICAgICAgICAvLyBVc2luZyBgdGhlbmAgYWxsb3dzIHVzaW5nIHRoZSBzYW1lIGNvZGUgZm9yIGJvdGggc3luY2hyb25vdXMgYW5kXG4gICAgICAgICAgICAvLyBhc3luY2hyb25vdXMgY2FzZXMuIFdlIGNvdWxkIHVzZSBgYXdhaXRgIGhlcmUsIGJ1dCBpdCB3b3VsZCBtYWtlIGFsbFxuICAgICAgICAgICAgLy8gY2FsbHMgYXN5bmNocm9ub3VzLCB1bm5lY2Vzc2FyeSBkZWxheWluZyBzeW5jaHJvbm91cyB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgY29uc3QgdGhlbiA9IG1ha2VUaGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgdmFsaWRhdGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoZW4odGhpcy5zdGF0ZS52YWxpZGF0b3IobW9kZWwpLCAoZXJyb3IgPSBudWxsKSA9PiB0aGVuKHRoaXMucHJvcHMub25WYWxpZGF0ZShtb2RlbCwgZXJyb3IpLCAoZXJyb3IgPSBudWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBjb3B5IHRoZSBlcnJvciBmcm9tIHByb3BzIHRvIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMucHJvcHMuZXJyb3IgPT09IGVycm9yID8gbnVsbCA6IGVycm9yO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3aG9sZSBvcGVyYXRpb24gd2FzIHN5bmNocm9ub3VzIGFuZCByZXN1bHRlZCBpbiB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIGVycm9yLCB3ZSBjYW4gc2tpcCB0aGUgcmUtcmVuZGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUgPT4gc3RhdGUuZXJyb3IgPT09IGVycm9yICYmICFzdGF0ZS52YWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHsgZXJyb3IsIHZhbGlkYXRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIC8vIEEgcHJlZGVmaW5lZCBlcnJvciB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIHZhbGlkYXRpb24gb25lLlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKF9hID0gdGhpcy5wcm9wcy5lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXJyb3IpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZhbGlkYXRlZEZvcm0uVmFsaWRhdGVkID0gVmFsaWRhdGVkO1xuICAgIFZhbGlkYXRlZEZvcm0uZGlzcGxheU5hbWUgPSBgVmFsaWRhdGVkJHtCYXNlLmRpc3BsYXlOYW1lfWA7XG4gICAgVmFsaWRhdGVkRm9ybS5kZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEJhc2UuZGVmYXVsdFByb3BzKSwgeyBvblZhbGlkYXRlKG1vZGVsLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9LCB2YWxpZGF0ZTogJ29uQ2hhbmdlQWZ0ZXJTdWJtaXQnIH0pO1xuICAgIHJldHVybiBWYWxpZGF0ZWRGb3JtO1xufVxuZnVuY3Rpb24gbWFrZVRoZW4oY2FsbElmQXN5bmMpIHtcbiAgICBmdW5jdGlvbiB0aGVuKHZhbHVlLCBmbikge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBjYWxsSWZBc3luYygpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRoZW4oZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGVuO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZShpblByb3BzLCBpblN0YXRlKSB7XG4gICAgcmV0dXJuIChpblByb3BzID09PSAnb25DaGFuZ2UnIHx8IChpblByb3BzID09PSAnb25DaGFuZ2VBZnRlclN1Ym1pdCcgJiYgaW5TdGF0ZSkpO1xufVxuZXhwb3J0IGNvbnN0IFZhbGlkYXRlZEZvcm0gPSBWYWxpZGF0ZWQoQmFzZUZvcm0pO1xuIiwiaW1wb3J0IHsgQmFzZUZvcm0gfSBmcm9tICcuL0Jhc2VGb3JtJztcbmltcG9ydCB7IFF1aWNrIH0gZnJvbSAnLi9RdWlja0Zvcm0nO1xuaW1wb3J0IHsgVmFsaWRhdGVkLCB9IGZyb20gJy4vVmFsaWRhdGVkRm9ybSc7XG5leHBvcnQgY29uc3QgVmFsaWRhdGVkUXVpY2tGb3JtID0gVmFsaWRhdGVkKFF1aWNrKEJhc2VGb3JtKSk7XG4iLCJpbXBvcnQgY2xvbmUgZnJvbSAnbG9kYXNoL2Nsb25lJztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCBvbWl0IGZyb20gJ2xvZGFzaC9vbWl0JztcbmltcG9ydCBzZXRXaXRoIGZyb20gJ2xvZGFzaC9zZXRXaXRoJztcbmltcG9ydCB7IFZhbGlkYXRlZFF1aWNrRm9ybSwgfSBmcm9tICcuL1ZhbGlkYXRlZFF1aWNrRm9ybSc7XG5leHBvcnQgZnVuY3Rpb24gQXV0byhCYXNlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogTWl4aW4gY2xhc3MgcHJvYmxlbS5cbiAgICBjbGFzcyBBdXRvRm9ybSBleHRlbmRzIEJhc2Uge1xuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZSksIHsgbW9kZWw6IHByb3BzLm1vZGVsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgc25hcHNob3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwobW9kZWwsIHByZXZQcm9wcy5tb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbW9kZWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlci5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgICAgICBnZXROYXRpdmVGb3JtUHJvcHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gb21pdChzdXBlci5nZXROYXRpdmVGb3JtUHJvcHMoKSwgWydvbkNoYW5nZU1vZGVsJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgZ2V0TW9kZWwobW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2Uoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgc3VwZXIub25DaGFuZ2Uoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+ICh7IG1vZGVsOiBzZXRXaXRoKGNsb25lKHN0YXRlLm1vZGVsKSwga2V5LCB2YWx1ZSwgY2xvbmUpIH0pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2VNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlTW9kZWwodGhpcy5zdGF0ZS5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX19yZXNldChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIuX19yZXNldChzdGF0ZSkpLCB7IG1vZGVsOiB0aGlzLnByb3BzLm1vZGVsIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIEF1dG9Gb3JtLkF1dG8gPSBBdXRvO1xuICAgIEF1dG9Gb3JtLmRpc3BsYXlOYW1lID0gYEF1dG8ke0Jhc2UuZGlzcGxheU5hbWV9YDtcbiAgICByZXR1cm4gQXV0b0Zvcm07XG59XG5leHBvcnQgY29uc3QgQXV0b0Zvcm0gPSBBdXRvKFZhbGlkYXRlZFF1aWNrRm9ybSk7XG4iLCJpbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5leHBvcnQgY2xhc3MgQnJpZGdlIHtcbiAgICAvLyBFYWNoIGJyaWRnZSBjYW4gaGF2ZSBhIGRpZmZlcmVudCBzZXQgb2YgcGFyYW1ldGVycy5cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLmNvbnN0cnVjdG9yICE9PSBCcmlkZ2UsICdCcmlkZ2UgY2Fubm90IGJlIGluc3RhbnRpYXRlZCAoYXJncz0lbykuJywgeyBhcmdzIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgYW4gZXJyb3IgZm9yIGZpZWxkIGBuYW1lYCBvdXQgb2YgYGVycm9yYC4gVGhlcmUgaXMgbm8gc3RhbmRhcml6ZWRcbiAgICAvLyBmb3JtYXQsIGJ1dCBmaWVsZHMgdHJlYXQgdHJ1dGh5IHZhbHVlcyBhcyBhIHNpZ24gb2YgYmVpbmcgaW52YWxpZC4gRmllbGRzXG4gICAgLy8gcmVjZWl2ZSB0aGlzIGFzIGEgYGVycm9yYCBndWFyYW50ZWVkIHByb3AuXG4gICAgZ2V0RXJyb3IobmFtZSwgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGludmFyaWFudChmYWxzZSwgJyVzIGhhdmUgbm90IGltcGxlbWVudGVkIGBnZXRFcnJvcmAgbWV0aG9kIChhcmdzPSVvKS4nLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHsgbmFtZSwgZXJyb3IgfSk7XG4gICAgfVxuICAgIC8vIEdldCBhbiBlcnJvciBtZXNzYWdlIGZvciBmaWVsZCBgbmFtZWAgb3V0IG9mIGBlcnJvcmAuIElmIHRoZXJlIGlzIG5vIGVycm9yLFxuICAgIC8vIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuIEZpZWxkcyByZWNlaXZlIHRoaXMgYXMgYSBgZXJyb3JNZXNzYWdlYCBndWFyYW50ZWVkXG4gICAgLy8gcHJvcC5cbiAgICBnZXRFcnJvck1lc3NhZ2UobmFtZSwgZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGludmFyaWFudChmYWxzZSwgJyVzIGhhdmUgbm90IGltcGxlbWVudGVkIGBnZXRFcnJvck1lc3NhZ2VgIG1ldGhvZCAoYXJncz0lbykuJywgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCB7IG5hbWUsIGVycm9yIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgYWxsIGVycm9yIG1lc3NhZ2VzIGZyb20gYGVycm9yYC4gT25seSBgRXJyb3JzRmllbGRgIG1ha2UgdXNlIG9mIHRoYXRcbiAgICAvLyAoaW4gYnVpbHRpbiB0aGVtZXMpLlxuICAgIGdldEVycm9yTWVzc2FnZXMoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGludmFyaWFudChmYWxzZSwgJyVzIGhhdmUgbm90IGltcGxlbWVudGVkIGBnZXRFcnJvck1lc3NhZ2VzYCBtZXRob2QgKGFyZ3M9JW8pLicsIHRoaXMuY29uc3RydWN0b3IubmFtZSwgeyBlcnJvciB9KTtcbiAgICB9XG4gICAgLy8gR2V0IGludGVybmFsIGZpZWxkIGRlZmluaXRpb24gZm9yIGZpZWxkIGBuYW1lYC4gRmllbGRzIHJlY2VpdmUgdGhpcyBhcyBhXG4gICAgLy8gYGZpZWxkYCBndWFyYW50ZWVkIHByb3AuXG4gICAgZ2V0RmllbGQobmFtZSkge1xuICAgICAgICByZXR1cm4gaW52YXJpYW50KGZhbHNlLCAnJXMgaGF2ZSBub3QgaW1wbGVtZW50ZWQgYGdldEZpZWxkYCBtZXRob2QgKGFyZ3M9JW8pLicsIHRoaXMuY29uc3RydWN0b3IubmFtZSwgeyBuYW1lIH0pO1xuICAgIH1cbiAgICAvLyBHZXQgaW5pdGlhbCB2YWx1ZSBvZiBmaWVsZCBgbmFtZWAuIEl0IGlzIHVzZWQgYXMgYSBkZWZhdWx0IHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBzZXQgKGUuZy4gdGhlIGZvcm0gaXMgcmVuZGVyZWQgd2l0aCBhbiBlbXB0eSBgbW9kZWxgKS4gQWRkaXRpb25hbGx5LFxuICAgIC8vIGBwcm9wc2AgYXJlIHRoaXMgZmllbGQgaW5zdGFuY2UgcHJvcHMuIElmIGEgZmllbGQgaXMgcmVuZGVyZWQgbXVsdGlwbGVcbiAgICAvLyB0aW1lcywgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgcG9zc2libHkgd2l0aCBkaWZmZXJlbnRcbiAgICAvLyBgcHJvcHNgLlxuICAgIGdldEluaXRpYWxWYWx1ZShuYW1lLCBwcm9wcykge1xuICAgICAgICByZXR1cm4gaW52YXJpYW50KGZhbHNlLCAnJXMgaGF2ZSBub3QgaW1wbGVtZW50ZWQgYGdldEluaXRpYWxWYWx1ZWAgbWV0aG9kIChhcmdzPSVvKS4nLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHsgbmFtZSwgcHJvcHMgfSk7XG4gICAgfVxuICAgIC8vIEdldCBwcm9wcyBkZWZpbmVkIGluIHNjaGVtYSBmb3IgYSBmaWVsZCBgbmFtZWAuIFRoZXJlIGFyZSBubyByZXF1aXJlZCBub3JcbiAgICAvLyBiYW5uZWQgZmllbGRzLCBob3dldmVyIHByb3BlcnRpZXMgbGlrZSBgcmVxdWlyZWRgIGFyZSBvZnRlbiBhdmFpbGFibGUuXG4gICAgLy8gQWRkaXRpb25hbGx5LCBgcHJvcHNgIGFyZSB0aGlzIGZpZWxkIGluc3RhbmNlIHByb3BzLiBJZiBhIGZpZWxkIGlzIHJlbmRlcmVkXG4gICAgLy8gbXVsdGlwbGUgdGltZXMsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHBvc3NpYmx5IHdpdGhcbiAgICAvLyBkaWZmZXJlbnQgYHByb3BzYC5cbiAgICBnZXRQcm9wcyhuYW1lLCBwcm9wcykge1xuICAgICAgICByZXR1cm4gaW52YXJpYW50KGZhbHNlLCAnJXMgaGF2ZSBub3QgaW1wbGVtZW50ZWQgYGdldFByb3BzYCBtZXRob2QgKGFyZ3M9JW8pLicsIHRoaXMuY29uc3RydWN0b3IubmFtZSwgeyBuYW1lLCBwcm9wcyB9KTtcbiAgICB9XG4gICAgLy8gR2V0IGEgbGlzdCBvZiBzdWJmaWVsZHMgb2YgZmllbGQgYG5hbWVgIG9yIHRvcC1sZXZlbCBmaWVsZHMsIGlmIG5vIGBuYW1lYFxuICAgIC8vIGlzIHBhc3NlZC5cbiAgICBnZXRTdWJmaWVsZHMobmFtZSkge1xuICAgICAgICByZXR1cm4gaW52YXJpYW50KGZhbHNlLCAnJXMgaGF2ZSBub3QgaW1wbGVtZW50ZWQgYGdldFN1YmZpZWxkc2AgbWV0aG9kIChhcmdzPSVvKS4nLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgLy8gR2V0IGEgdHlwZSBvZiBmaWVsZCBgbmFtZWAuIFNlZSBgRmllbGRUeXBlVHlwZWAgZm9yIGRldGFpbHMuXG4gICAgZ2V0VHlwZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnZhcmlhbnQoZmFsc2UsICclcyBoYXZlIG5vdCBpbXBsZW1lbnRlZCBgZ2V0VHlwZWAgbWV0aG9kIChhcmdzPSVvKS4nLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgLy8gR2V0IGEgdmFsaWRhdG9yIGZ1bmN0aW9uLiBUaGUgYG9wdGlvbnNgIGhlcmUgYXJlIGZyb20gdGhlIGB2YWxpZGF0b3JgIHByb3BcbiAgICAvLyBvZiB0aGUgZm9ybS4gQSB2YWxpZGF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSBtb2RlbCBhbmQgcmV0dXJucyBhbiBlcnJvciBvclxuICAgIC8vIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSAobm90IHJlamVjdCEpIHdpdGggYW4gZXJyb3IuIElmIHRoZXJlIGlzIG5vXG4gICAgLy8gZXJyb3IsIHJldHVybiAob3IgcmVzb2x2ZSB3aXRoKSBhIGBudWxsYCB2YWx1ZSBpbnN0ZWFkLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmV0dGllci9wcmV0dGllclxuICAgIGdldFZhbGlkYXRvcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbnZhcmlhbnQoZmFsc2UsICclcyBoYXZlIG5vdCBpbXBsZW1lbnRlZCBgZ2V0VmFsaWRhdG9yYCBtZXRob2QgKGFyZ3M9JW8pLicsIHRoaXMuY29uc3RydWN0b3IubmFtZSwgeyBvcHRpb25zIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb250ZXh0IGFzIGNvbnRleHRSZWZlcmVuY2UgfSBmcm9tICcuL2NvbnRleHQnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcm0oKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoY29udGV4dFJlZmVyZW5jZSk7XG4gICAgaW52YXJpYW50KGNvbnRleHQgIT09IG51bGwsICd1c2VGb3JtIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBmb3JtLicpO1xuICAgIHJldHVybiBjb250ZXh0O1xufVxuIiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBtYXBWYWx1ZXMgZnJvbSAnbG9kYXNoL21hcFZhbHVlcyc7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgam9pbk5hbWUgfSBmcm9tICcuL2pvaW5OYW1lJztcbmltcG9ydCB7IHVzZUZvcm0gfSBmcm9tICcuL3VzZUZvcm0nO1xuZnVuY3Rpb24gcHJvcGFnYXRlKHByb3AsIHNjaGVtYSwgc3RhdGUsIGZhbGxiYWNrKSB7XG4gICAgY29uc3QgZm9yY2VkRmFsbGJhY2tJblByb3AgPSBwcm9wID09PSB0cnVlIHx8IHByb3AgPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBmb3JjZWRGYWxsYmFja0luU2NoZW1hID0gc2NoZW1hID09PSB0cnVlIHx8IHNjaGVtYSA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNjaGVtYVZhbHVlID0gZm9yY2VkRmFsbGJhY2tJblNjaGVtYSA/IGZhbGxiYWNrIDogc2NoZW1hO1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcCA9PT0gJycgfHxcbiAgICAgICAgcHJvcCA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGZvcmNlZEZhbGxiYWNrSW5Qcm9wICYmIChmb3JjZWRGYWxsYmFja0luU2NoZW1hIHx8ICFzdGF0ZSkpXG4gICAgICAgID8gJydcbiAgICAgICAgOiBmb3JjZWRGYWxsYmFja0luUHJvcFxuICAgICAgICAgICAgPyBzY2hlbWFWYWx1ZVxuICAgICAgICAgICAgOiBwcm9wO1xuICAgIHJldHVybiBbdmFsdWUsIHNjaGVtYVZhbHVlXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VGaWVsZChmaWVsZE5hbWUsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VGb3JtKCk7XG4gICAgY29uc3QgbmFtZSA9IGpvaW5OYW1lKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJzb2x1dGVOYW1lKSA/ICcnIDogY29udGV4dC5uYW1lLCBmaWVsZE5hbWUpO1xuICAgIGNvbnN0IHN0YXRlID0gbWFwVmFsdWVzKGNvbnRleHQuc3RhdGUsIChwcmV2LCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHByb3BzW2tleV07XG4gICAgICAgIHJldHVybiBuZXh0ID09PSBudWxsIHx8IG5leHQgPT09IHVuZGVmaW5lZCA/IHByZXYgOiAhIW5leHQ7XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICEhZ2V0KGNvbnRleHQuY2hhbmdlZE1hcCwgbmFtZSk7XG4gICAgY29uc3QgZXJyb3IgPSBjb250ZXh0LnNjaGVtYS5nZXRFcnJvcihuYW1lLCBjb250ZXh0LmVycm9yKTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBjb250ZXh0LnNjaGVtYS5nZXRFcnJvck1lc3NhZ2UobmFtZSwgY29udGV4dC5lcnJvcik7XG4gICAgY29uc3QgZmllbGQgPSBjb250ZXh0LnNjaGVtYS5nZXRGaWVsZChuYW1lKTtcbiAgICBjb25zdCBmaWVsZFR5cGUgPSBjb250ZXh0LnNjaGVtYS5nZXRUeXBlKG5hbWUpO1xuICAgIGNvbnN0IGZpZWxkcyA9IGNvbnRleHQuc2NoZW1hLmdldFN1YmZpZWxkcyhuYW1lKTtcbiAgICBjb25zdCBzY2hlbWFQcm9wcyA9IGNvbnRleHQuc2NoZW1hLmdldFByb3BzKG5hbWUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCBwcm9wcykpO1xuICAgIGNvbnN0IFtsYWJlbCwgbGFiZWxGYWxsYmFja10gPSBwcm9wYWdhdGUocHJvcHMubGFiZWwsIHNjaGVtYVByb3BzLmxhYmVsLCBzdGF0ZS5sYWJlbCwgJycpO1xuICAgIGNvbnN0IFtwbGFjZWhvbGRlcl0gPSBwcm9wYWdhdGUocHJvcHMucGxhY2Vob2xkZXIsIHNjaGVtYVByb3BzLnBsYWNlaG9sZGVyLCBzdGF0ZS5wbGFjZWhvbGRlciwgbGFiZWwgfHwgbGFiZWxGYWxsYmFjayk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBjb250ZXh0LnJhbmRvbUlkKCksIFtdKTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKCh2YWx1ZSwga2V5ID0gbmFtZSkgPT4ge1xuICAgICAgICBjb250ZXh0Lm9uQ2hhbmdlKGtleSwgdmFsdWUpO1xuICAgIH0sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbY29udGV4dC5vbkNoYW5nZSwgbmFtZV0pO1xuICAgIGNvbnN0IHZhbHVlRnJvbU1vZGVsID0gZ2V0KGNvbnRleHQubW9kZWwsIG5hbWUpO1xuICAgIGxldCBpbml0aWFsVmFsdWU7XG4gICAgbGV0IHZhbHVlID0gKF9hID0gcHJvcHMudmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlRnJvbU1vZGVsO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gY29udGV4dC5zY2hlbWEuZ2V0SW5pdGlhbFZhbHVlKG5hbWUsIHByb3BzKTtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMudmFsdWUgIT09IHZhbHVlRnJvbU1vZGVsKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbml0aWFsVmFsdWUpICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkID0gKF9hID0gcHJvcHMucmVxdWlyZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNjaGVtYVByb3BzLnJlcXVpcmVkO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkICYmIGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQgfSwgc3RhdGUpLCB7IGNoYW5nZWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgIGZpZWxkLFxuICAgICAgICBmaWVsZFR5cGUsXG4gICAgICAgIGZpZWxkcyxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIHZhbHVlIH0pLCBzY2hlbWFQcm9wcyksIHByb3BzKSwgeyBsYWJlbCxcbiAgICAgICAgbmFtZSwgXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBhc3NlcnQgYHR5cGVvZiBwbGFjZWhvbGRlciA9PT0gJ3N0cmluZydgP1xuICAgICAgICBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIgfSk7XG4gICAgcmV0dXJuIFtmaWVsZFByb3BzLCBjb250ZXh0XTtcbn1cbiIsImltcG9ydCBtYXBWYWx1ZXMgZnJvbSAnbG9kYXNoL21hcFZhbHVlcyc7XG5pbXBvcnQgc29tZSBmcm9tICdsb2Rhc2gvc29tZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29udGV4dCBhcyBjb250ZXh0UmVmZXJlbmNlIH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7IHVzZUZpZWxkIH0gZnJvbSAnLi91c2VGaWVsZCc7XG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdEZpZWxkKENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIEZpZWxkKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IFtmaWVsZFByb3BzLCBjb250ZXh0XSA9IHVzZUZpZWxkKHByb3BzLm5hbWUsIHByb3BzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaGFzQ2hhaW5OYW1lID0gcHJvcHMubmFtZSAhPT0gJyc7XG4gICAgICAgIGNvbnN0IGFueUZsb3dpbmdQcm9wZXJ0eVNldCA9IHNvbWUoY29udGV4dC5zdGF0ZSwgXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBwcm9wc2AgaGFzIG5vIGluZGV4IHNpZ25hdHVyZS5cbiAgICAgICAgKF8sIGtleSkgPT4gcHJvcHNba2V5XSAhPT0gbnVsbCAmJiBwcm9wc1trZXldICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoIWFueUZsb3dpbmdQcm9wZXJ0eVNldCAmJiAhaGFzQ2hhaW5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCBmaWVsZFByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGFueUZsb3dpbmdQcm9wZXJ0eVNldCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuc3RhdGUgPSBtYXBWYWx1ZXMobmV4dENvbnRleHQuc3RhdGUsICh2YWx1ZSwga2V5KSA9PiBcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBwcm9wc2AgaGFzIG5vIGluZGV4IHNpZ25hdHVyZS5cbiAgICAgICAgICAgIHByb3BzW2tleV0gIT09IG51bGwgJiYgcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkID8gISFwcm9wc1trZXldIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDaGFpbk5hbWUpIHtcbiAgICAgICAgICAgIG5leHRDb250ZXh0Lm5hbWUgPSBuZXh0Q29udGV4dC5uYW1lLmNvbmNhdChwcm9wcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dFJlZmVyZW5jZS5Qcm92aWRlciwgeyB2YWx1ZTogbmV4dENvbnRleHQgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgZmllbGRQcm9wcykpKSk7XG4gICAgfVxuICAgIEZpZWxkLmRpc3BsYXlOYW1lID0gYCR7Q29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lfUZpZWxkYDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihGaWVsZCwge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgfSk7XG59XG4iLCJpbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRmllbGQgfSBmcm9tICcuL3VzZUZpZWxkJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdXRvRmllbGQoZGVmYXVsdENvbXBvbmVudERldGVjdG9yKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZGVmYXVsdENvbXBvbmVudERldGVjdG9yKTtcbiAgICBmdW5jdGlvbiBBdXRvRmllbGQocmF3UHJvcHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgW3Byb3BzLCB1bmlmb3Jtc10gPSB1c2VGaWVsZChyYXdQcm9wcy5uYW1lLCByYXdQcm9wcyk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudERldGVjdG9yID0gdXNlQ29udGV4dChjb250ZXh0KTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gKF9hID0gcHJvcHMuY29tcG9uZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb21wb25lbnREZXRlY3Rvcihwcm9wcywgdW5pZm9ybXMpO1xuICAgICAgICBpbnZhcmlhbnQoY29tcG9uZW50LCAnQXV0b0ZpZWxkIHJlY2VpdmVkIG5vIGNvbXBvbmVudCBmb3I6ICVzJywgcHJvcHMubmFtZSk7XG4gICAgICAgIHJldHVybiAnb3B0aW9ucycgaW4gY29tcG9uZW50ICYmICgoX2IgPSBjb21wb25lbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmtpbmQpID09PSAnbGVhZidcbiAgICAgICAgICAgID8gY3JlYXRlRWxlbWVudChjb21wb25lbnQuQ29tcG9uZW50LCBwcm9wcylcbiAgICAgICAgICAgIDogY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHJhd1Byb3BzKTtcbiAgICB9XG4gICAgQXV0b0ZpZWxkLmNvbXBvbmVudERldGVjdG9yQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgQXV0b0ZpZWxkLmRlZmF1bHRDb21wb25lbnREZXRlY3RvciA9IGRlZmF1bHRDb21wb25lbnREZXRlY3RvcjtcbiAgICByZXR1cm4gQXV0b0ZpZWxkO1xufVxuIiwiaW1wb3J0IHBpY2tCeSBmcm9tICdsb2Rhc2gvcGlja0J5JztcbmltcG9ydCBzb3J0ZWRJbmRleCBmcm9tICdsb2Rhc2gvc29ydGVkSW5kZXgnO1xuaW1wb3J0IHNvcnRlZEluZGV4T2YgZnJvbSAnbG9kYXNoL3NvcnRlZEluZGV4T2YnO1xuY29uc3QgcmVnaXN0ZXJlZCA9IFtdO1xuZnVuY3Rpb24gZmlsdGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHBpY2tCeShwcm9wcywgZmlsdGVyT25lKTtcbn1cbmZ1bmN0aW9uIGZpbHRlck9uZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiBzb3J0ZWRJbmRleE9mKHJlZ2lzdGVyZWQsIHByb3ApID09PSAtMTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKC4uLnByb3BzKSB7XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgaWYgKHNvcnRlZEluZGV4T2YocmVnaXN0ZXJlZCwgcHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkLnNwbGljZShzb3J0ZWRJbmRleChyZWdpc3RlcmVkLCBwcm9wKSwgMCwgcHJvcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBmaWx0ZXJET01Qcm9wcyA9IE9iamVjdC5hc3NpZ24oZmlsdGVyLCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgcmVnaXN0ZXJlZDogcmVnaXN0ZXJlZCxcbn0pO1xucmVnaXN0ZXIoXG4vLyBUaGVzZSBwcm9wcyBhcmUgcHJvdmlkZWQgYnkgdXNlRmllbGQgZGlyZWN0bHkuXG4nY2hhbmdlZCcsICdlcnJvcicsICdlcnJvck1lc3NhZ2UnLCAnZmllbGQnLCAnZmllbGRUeXBlJywgJ2ZpZWxkcycsICdpbml0aWFsQ291bnQnLCAnbmFtZScsICdvbkNoYW5nZScsICd0cmFuc2Zvcm0nLCAndmFsdWUnLCBcbi8vIFRoZXNlIHByb3BzIGFyZSBwcm92aWRlZCBieSB1c2VGaWVsZCB0aHJvdWdoIGNvbnRleHQuc3RhdGUuXG4nZGlzYWJsZWQnLCAnbGFiZWwnLCAncGxhY2Vob2xkZXInLCAnc2hvd0lubGluZUVycm9yJywgXG4vLyBUaGlzIGlzIHVzZWQgYnkgQXV0b0ZpZWxkLlxuJ2NvbXBvbmVudCcsIFxuLy8gVGhlc2UgaXMgdXNlZCBieSBBdXRvRmllbGQgYW5kIGJyaWRnZXMuXG4nYWxsb3dlZFZhbHVlcycpO1xuIiwiZXhwb3J0ICogZnJvbSAnLi9BdXRvRm9ybSc7XG5leHBvcnQgKiBmcm9tICcuL0Jhc2VGb3JtJztcbmV4cG9ydCAqIGZyb20gJy4vQnJpZGdlJztcbmV4cG9ydCAqIGZyb20gJy4vUXVpY2tGb3JtJztcbmV4cG9ydCAqIGZyb20gJy4vVmFsaWRhdGVkRm9ybSc7XG5leHBvcnQgKiBmcm9tICcuL1ZhbGlkYXRlZFF1aWNrRm9ybSc7XG5leHBvcnQgKiBmcm9tICcuL2NoYW5nZWRLZXlzJztcbmV4cG9ydCAqIGZyb20gJy4vY29ubmVjdEZpZWxkJztcbmV4cG9ydCAqIGZyb20gJy4vY29udGV4dCc7XG5leHBvcnQgKiBmcm9tICcuL2NyZWF0ZUF1dG9GaWVsZCc7XG5leHBvcnQgKiBmcm9tICcuL2ZpbHRlckRPTVByb3BzJztcbmV4cG9ydCAqIGZyb20gJy4vam9pbk5hbWUnO1xuZXhwb3J0ICogZnJvbSAnLi9yYW5kb21JZHMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3VzZUZpZWxkJztcbmV4cG9ydCAqIGZyb20gJy4vdXNlRm9ybSc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40921\n")}}]);