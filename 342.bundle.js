"use strict";(self.webpackChunkcos_ui=self.webpackChunkcos_ui||[]).push([[342],{28342:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "asEffect": () => (/* reexport */ asEffect),\n  "asLayoutEffect": () => (/* reexport */ asLayoutEffect),\n  "useActor": () => (/* reexport */ useActor),\n  "useInterpret": () => (/* reexport */ useInterpret),\n  "useMachine": () => (/* reexport */ useMachine),\n  "useSelector": () => (/* reexport */ useSelector),\n  "useService": () => (/* reexport */ useService),\n  "useSpawn": () => (/* reexport */ useSpawn)\n});\n\n// EXTERNAL MODULE: consume shared module (default) react@^16.8.0 || ^17.0.0 (singleton) (fallback: ./node_modules/react/index.js) (eager)\nvar index_js_eager_ = __webpack_require__(45052);\n// EXTERNAL MODULE: consume shared module (default) xstate@=4.25.0 (strict) (fallback: ./node_modules/xstate/es/index.js)\nvar index_js_ = __webpack_require__(45496);\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/types.js\nvar ReactEffectType;\n(function (ReactEffectType) {\n    ReactEffectType[ReactEffectType["Effect"] = 1] = "Effect";\n    ReactEffectType[ReactEffectType["LayoutEffect"] = 2] = "LayoutEffect";\n})(ReactEffectType || (ReactEffectType = {}));\n\n;// CONCATENATED MODULE: ./node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js\n\n\nvar index =  index_js_eager_.useLayoutEffect ;\n\n/* harmony default export */ const use_isomorphic_layout_effect_browser_esm = (index);\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useConstant.js\n\nfunction useConstant(fn) {\n    var ref = index_js_eager_.useRef();\n    if (!ref.current) {\n        ref.current = { v: fn() };\n    }\n    return ref.current.v;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/utils.js\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === "number") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n};\nfunction partition(items, predicate) {\n    var e_1, _a;\n    var _b = __read([[], []], 2), truthy = _b[0], falsy = _b[1];\n    try {\n        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n            var item = items_1_1.value;\n            if (predicate(item)) {\n                truthy.push(item);\n            }\n            else {\n                falsy.push(item);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return [truthy, falsy];\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useReactEffectActions.js\nvar useReactEffectActions_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\n\n\n\n\nfunction executeEffect(action, state) {\n    var exec = action.exec;\n    var originalExec = exec(state.context, state._event.data, {\n        action: action,\n        state: state,\n        _event: state._event\n    });\n    originalExec();\n}\nfunction useReactEffectActions(service) {\n    var effectActionsRef = (0,index_js_eager_.useRef)([]);\n    var layoutEffectActionsRef = (0,index_js_eager_.useRef)([]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        var sub = service.subscribe(function (currentState) {\n            var _a, _b;\n            if (currentState.actions.length) {\n                var reactEffectActions = currentState.actions.filter(function (action) {\n                    return (typeof action.exec === \'function\' &&\n                        \'__effect\' in action.exec);\n                });\n                var _c = useReactEffectActions_read(partition(reactEffectActions, function (action) {\n                    return action.exec.__effect === ReactEffectType.Effect;\n                }), 2), effectActions = _c[0], layoutEffectActions = _c[1];\n                (_a = effectActionsRef.current).push.apply(_a, __spreadArray([], useReactEffectActions_read(effectActions.map(function (effectAction) { return [effectAction, currentState]; }))));\n                (_b = layoutEffectActionsRef.current).push.apply(_b, __spreadArray([], useReactEffectActions_read(layoutEffectActions.map(function (layoutEffectAction) { return [layoutEffectAction, currentState]; }))));\n            }\n        });\n        return function () {\n            sub.unsubscribe();\n        };\n    }, []);\n    // this is somewhat weird - this should always be flushed within useLayoutEffect\n    // but we don\'t want to receive warnings about useLayoutEffect being used on the server\n    // so we have to use `useIsomorphicLayoutEffect` to silence those warnings\n    use_isomorphic_layout_effect_browser_esm(function () {\n        while (layoutEffectActionsRef.current.length) {\n            var _a = useReactEffectActions_read(layoutEffectActionsRef.current.shift(), 2), layoutEffectAction = _a[0], effectState = _a[1];\n            executeEffect(layoutEffectAction, effectState);\n        }\n    }); // https://github.com/davidkpiano/xstate/pull/1202#discussion_r429677773\n    (0,index_js_eager_.useEffect)(function () {\n        while (effectActionsRef.current.length) {\n            var _a = useReactEffectActions_read(effectActionsRef.current.shift(), 2), effectAction = _a[0], effectState = _a[1];\n            executeEffect(effectAction, effectState);\n        }\n    });\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useInterpret.js\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar useInterpret_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\n\n\n// copied from core/src/utils.ts\n// it avoids a breaking change between this package and XState which is its peer dep\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    if (typeof nextHandler === \'object\') {\n        return nextHandler;\n    }\n    var noop = function () { return void 0; };\n    return {\n        next: nextHandler,\n        error: errorHandler || noop,\n        complete: completionHandler || noop\n    };\n}\nfunction useInterpret(getMachine, options, observerOrListener) {\n    if (options === void 0) { options = {}; }\n    var machine = useConstant(function () {\n        return typeof getMachine === \'function\' ? getMachine() : getMachine;\n    });\n    if (false) { var _a, initialMachine; }\n    var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);\n    var service = useConstant(function () {\n        var machineConfig = {\n            context: context,\n            guards: guards,\n            actions: actions,\n            activities: activities,\n            services: services,\n            delays: delays\n        };\n        var machineWithConfig = machine.withConfig(machineConfig, function () { return (__assign(__assign({}, machine.context), context)); });\n        return (0,index_js_.interpret)(machineWithConfig, __assign({ deferEvents: true }, interpreterOptions));\n    });\n    use_isomorphic_layout_effect_browser_esm(function () {\n        var sub;\n        if (observerOrListener) {\n            sub = service.subscribe(toObserver(observerOrListener));\n        }\n        return function () {\n            sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n        };\n    }, [observerOrListener]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        service.start(rehydratedState ? index_js_.State.create(rehydratedState) : undefined);\n        return function () {\n            service.stop();\n        };\n    }, []);\n    // Make sure options are kept updated when they change.\n    // This mutation assignment is safe because the service instance is only used\n    // in one place -- this hook\'s caller.\n    use_isomorphic_layout_effect_browser_esm(function () {\n        Object.assign(service.machine.options.actions, actions);\n        Object.assign(service.machine.options.guards, guards);\n        Object.assign(service.machine.options.activities, activities);\n        Object.assign(service.machine.options.services, services);\n        Object.assign(service.machine.options.delays, delays);\n    }, [actions, guards, activities, services, delays]);\n    useReactEffectActions(service);\n    return service;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useMachine.js\nvar useMachine_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar useMachine_spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\n\n\n\n\nfunction createReactActionFunction(exec, tag) {\n    var effectExec = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // don\'t execute; just return\n        return function () {\n            return exec.apply(void 0, useMachine_spreadArray([], useMachine_read(args)));\n        };\n    };\n    Object.defineProperties(effectExec, {\n        name: { value: "effect:" + exec.name },\n        __effect: { value: tag }\n    });\n    return effectExec;\n}\nfunction asEffect(exec) {\n    return createReactActionFunction(exec, ReactEffectType.Effect);\n}\nfunction asLayoutEffect(exec) {\n    return createReactActionFunction(exec, ReactEffectType.LayoutEffect);\n}\nfunction useMachine(getMachine, options) {\n    if (options === void 0) { options = {}; }\n    var listener = (0,index_js_eager_.useCallback)(function (nextState) {\n        // Only change the current state if:\n        // - the incoming state is the "live" initial state (since it might have new actors)\n        // - OR the incoming state actually changed.\n        //\n        // The "live" initial state will have .changed === undefined.\n        var initialStateChanged = nextState.changed === undefined &&\n            Object.keys(nextState.children).length;\n        if (nextState.changed || initialStateChanged) {\n            setState(nextState);\n        }\n    }, []);\n    var service = useInterpret(getMachine, options, listener);\n    var _a = useMachine_read((0,index_js_eager_.useState)(function () {\n        var initialState = service.machine.initialState;\n        return (options.state\n            ? index_js_.State.create(options.state)\n            : initialState);\n    }), 2), state = _a[0], setState = _a[1];\n    return [state, service.send, service];\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useActor.js\nvar useActor_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction isActorWithState(actorRef) {\n    return \'state\' in actorRef;\n}\nfunction isDeferredActor(actorRef) {\n    return \'deferred\' in actorRef;\n}\nvar noop = function () {\n    /* ... */\n};\nfunction defaultGetSnapshot(actorRef) {\n    return \'getSnapshot\' in actorRef\n        ? actorRef.getSnapshot()\n        : isActorWithState(actorRef)\n            ? actorRef.state\n            : undefined;\n}\nfunction useActor(actorRef, getSnapshot) {\n    if (getSnapshot === void 0) { getSnapshot = defaultGetSnapshot; }\n    var actorRefRef = (0,index_js_eager_.useRef)(actorRef);\n    var deferredEventsRef = (0,index_js_eager_.useRef)([]);\n    var _a = useActor_read((0,index_js_eager_.useState)(function () { return getSnapshot(actorRef); }), 2), current = _a[0], setCurrent = _a[1];\n    var send = useConstant(function () { return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var event = args[0];\n        if (false) {}\n        var currentActorRef = actorRefRef.current;\n        // If the previous actor is a deferred actor,\n        // queue the events so that they can be replayed\n        // on the non-deferred actor.\n        if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {\n            deferredEventsRef.current.push(event);\n        }\n        else {\n            currentActorRef.send(event);\n        }\n    }; });\n    use_isomorphic_layout_effect_browser_esm(function () {\n        actorRefRef.current = actorRef;\n        setCurrent(getSnapshot(actorRef));\n        var subscription = actorRef.subscribe({\n            next: function (emitted) { return setCurrent(emitted); },\n            error: noop,\n            complete: noop\n        });\n        // Dequeue deferred events from the previous deferred actorRef\n        while (deferredEventsRef.current.length > 0) {\n            var deferredEvent = deferredEventsRef.current.shift();\n            actorRef.send(deferredEvent);\n        }\n        return function () {\n            subscription.unsubscribe();\n        };\n    }, [actorRef]);\n    return [current, send];\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useService.js\nvar useService_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\nfunction getServiceSnapshot(service) {\n    // TODO: remove compat lines in a new major, replace literal number with InterpreterStatus then as well\n    return (\'status\' in service ? service.status : service._status) !== 0\n        ? service.state\n        : service.machine.initialState;\n}\n/**\n * @deprecated Use `useActor` instead.\n *\n * @param service The interpreted machine\n * @returns A tuple of the current `state` of the service and the service\'s `send(event)` method\n */\nfunction useService(service) {\n    if (false) {}\n    var _a = useService_read(useActor(service), 1), state = _a[0];\n    return [state, service.send];\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useSelector.js\nvar useSelector_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction isService(actor) {\n    return \'state\' in actor && \'machine\' in actor;\n}\nvar defaultCompare = function (a, b) { return a === b; };\nvar useSelector_defaultGetSnapshot = function (a) {\n    return isService(a)\n        ? getServiceSnapshot(a)\n        : isActorWithState(a)\n            ? a.state\n            : undefined;\n};\nfunction useSelector(actor, selector, compare, getSnapshot) {\n    if (compare === void 0) { compare = defaultCompare; }\n    if (getSnapshot === void 0) { getSnapshot = useSelector_defaultGetSnapshot; }\n    var _a = useSelector_read((0,index_js_eager_.useState)(function () { return selector(getSnapshot(actor)); }), 2), selected = _a[0], setSelected = _a[1];\n    var selectedRef = (0,index_js_eager_.useRef)(selected);\n    (0,index_js_eager_.useEffect)(function () {\n        var updateSelectedIfChanged = function (nextSelected) {\n            if (!compare(selectedRef.current, nextSelected)) {\n                setSelected(nextSelected);\n                selectedRef.current = nextSelected;\n            }\n        };\n        var initialSelected = selector(getSnapshot(actor));\n        updateSelectedIfChanged(initialSelected);\n        var sub = actor.subscribe(function (emitted) {\n            var nextSelected = selector(emitted);\n            updateSelectedIfChanged(nextSelected);\n        });\n        return function () { return sub.unsubscribe(); };\n    }, [selector, compare]);\n    return selected;\n}\n\n// EXTERNAL MODULE: ./node_modules/xstate/lib/behaviors.js\nvar behaviors = __webpack_require__(76590);\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/useSpawn.js\n\n\n/**\n * React hook that spawns an `ActorRef` with the specified `behavior`.\n * The returned `ActorRef` can be used with the `useActor(actorRef)` hook.\n *\n * @param behavior The actor behavior to spawn\n * @returns An ActorRef with the specified `behavior`\n */\nfunction useSpawn(behavior) {\n    var actorRef = useConstant(function () {\n        return (0,behaviors/* spawnBehavior */.Y)(behavior);\n    });\n    return actorRef;\n}\n\n;// CONCATENATED MODULE: ./node_modules/@xstate/react/es/index.js\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TCxhQUFhLGVBQU0sQ0FBQyxRQUFRO0FBQzVCO0FBQ0E7OztBQ25DQSxJQUFJLGdCQUFNLElBQUksU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ29EO0FBQ047QUFDSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsSUFBSSw4QkFBa0I7QUFDdEI7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQLDhCQUE4QjtBQUM5QixrQ0FBa0MsY0FBYyw4QkFBa0I7QUFDbEUsYUFBYSxnQkFBTSxDQUFDLDRCQUFRLGVBQWUsc0NBQXNDO0FBQ2pGLHNCQUFzQiwwQkFBTTtBQUM1QixJQUFJLDZCQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0IsS0FBSztBQUNMO0FBQ0E7Ozs7O0FDbkRxRDtBQUNiO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsV0FBVztBQUM5QixlQUFlLGtDQUFhO0FBQzVCLEtBQUs7QUFDTDtBQUNBOzs7QUNkb0U7QUFDMUI7QUFDSjtBQUNRO0FBQ0Y7QUFDTiIsInNvdXJjZXMiOlsid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3R5cGVzLmpzPzM0NjgiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QvZGlzdC91c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0LmJyb3dzZXIuZXNtLmpzP2NiYmUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvdXNlQ29uc3RhbnQuanM/YjY1MCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91dGlscy5qcz81NmZiIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZVJlYWN0RWZmZWN0QWN0aW9ucy5qcz9mYTgyIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZUludGVycHJldC5qcz8xNzYwIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZU1hY2hpbmUuanM/ZmJiZCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VBY3Rvci5qcz83NmI3Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZVNlcnZpY2UuanM/OTdhYSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VTZWxlY3Rvci5qcz8xNWJlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZVNwYXduLmpzPzIwMTEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvaW5kZXguanM/Yjk3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIFJlYWN0RWZmZWN0VHlwZTtcbihmdW5jdGlvbiAoUmVhY3RFZmZlY3RUeXBlKSB7XG4gICAgUmVhY3RFZmZlY3RUeXBlW1JlYWN0RWZmZWN0VHlwZVtcIkVmZmVjdFwiXSA9IDFdID0gXCJFZmZlY3RcIjtcbiAgICBSZWFjdEVmZmVjdFR5cGVbUmVhY3RFZmZlY3RUeXBlW1wiTGF5b3V0RWZmZWN0XCJdID0gMl0gPSBcIkxheW91dEVmZmVjdFwiO1xufSkoUmVhY3RFZmZlY3RUeXBlIHx8IChSZWFjdEVmZmVjdFR5cGUgPSB7fSkpO1xuIiwiaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG52YXIgaW5kZXggPSAgdXNlTGF5b3V0RWZmZWN0IDtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDb25zdGFudChmbikge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0geyB2OiBmbigpIH07XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudC52O1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpdGlvbihpdGVtcywgcHJlZGljYXRlKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIF9iID0gX19yZWFkKFtbXSwgW11dLCAyKSwgdHJ1dGh5ID0gX2JbMF0sIGZhbHN5ID0gX2JbMV07XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaXRlbXNfMSA9IF9fdmFsdWVzKGl0ZW1zKSwgaXRlbXNfMV8xID0gaXRlbXNfMS5uZXh0KCk7ICFpdGVtc18xXzEuZG9uZTsgaXRlbXNfMV8xID0gaXRlbXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHRydXRoeS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFsc3kucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGl0ZW1zXzFfMSAmJiAhaXRlbXNfMV8xLmRvbmUgJiYgKF9hID0gaXRlbXNfMS5yZXR1cm4pKSBfYS5jYWxsKGl0ZW1zXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbn1cbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJ3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgUmVhY3RFZmZlY3RUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBwYXJ0aXRpb24gfSBmcm9tICcuL3V0aWxzJztcbmZ1bmN0aW9uIGV4ZWN1dGVFZmZlY3QoYWN0aW9uLCBzdGF0ZSkge1xuICAgIHZhciBleGVjID0gYWN0aW9uLmV4ZWM7XG4gICAgdmFyIG9yaWdpbmFsRXhlYyA9IGV4ZWMoc3RhdGUuY29udGV4dCwgc3RhdGUuX2V2ZW50LmRhdGEsIHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgX2V2ZW50OiBzdGF0ZS5fZXZlbnRcbiAgICB9KTtcbiAgICBvcmlnaW5hbEV4ZWMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFjdEVmZmVjdEFjdGlvbnMoc2VydmljZSkge1xuICAgIHZhciBlZmZlY3RBY3Rpb25zUmVmID0gdXNlUmVmKFtdKTtcbiAgICB2YXIgbGF5b3V0RWZmZWN0QWN0aW9uc1JlZiA9IHVzZVJlZihbXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWIgPSBzZXJ2aWNlLnN1YnNjcmliZShmdW5jdGlvbiAoY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFjdEVmZmVjdEFjdGlvbnMgPSBjdXJyZW50U3RhdGUuYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBhY3Rpb24uZXhlYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJ19fZWZmZWN0JyBpbiBhY3Rpb24uZXhlYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKHBhcnRpdGlvbihyZWFjdEVmZmVjdEFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5leGVjLl9fZWZmZWN0ID09PSBSZWFjdEVmZmVjdFR5cGUuRWZmZWN0O1xuICAgICAgICAgICAgICAgIH0pLCAyKSwgZWZmZWN0QWN0aW9ucyA9IF9jWzBdLCBsYXlvdXRFZmZlY3RBY3Rpb25zID0gX2NbMV07XG4gICAgICAgICAgICAgICAgKF9hID0gZWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50KS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZWZmZWN0QWN0aW9ucy5tYXAoZnVuY3Rpb24gKGVmZmVjdEFjdGlvbikgeyByZXR1cm4gW2VmZmVjdEFjdGlvbiwgY3VycmVudFN0YXRlXTsgfSkpKSk7XG4gICAgICAgICAgICAgICAgKF9iID0gbGF5b3V0RWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50KS5wdXNoLmFwcGx5KF9iLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobGF5b3V0RWZmZWN0QWN0aW9ucy5tYXAoZnVuY3Rpb24gKGxheW91dEVmZmVjdEFjdGlvbikgeyByZXR1cm4gW2xheW91dEVmZmVjdEFjdGlvbiwgY3VycmVudFN0YXRlXTsgfSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIC8vIHRoaXMgaXMgc29tZXdoYXQgd2VpcmQgLSB0aGlzIHNob3VsZCBhbHdheXMgYmUgZmx1c2hlZCB3aXRoaW4gdXNlTGF5b3V0RWZmZWN0XG4gICAgLy8gYnV0IHdlIGRvbid0IHdhbnQgdG8gcmVjZWl2ZSB3YXJuaW5ncyBhYm91dCB1c2VMYXlvdXRFZmZlY3QgYmVpbmcgdXNlZCBvbiB0aGUgc2VydmVyXG4gICAgLy8gc28gd2UgaGF2ZSB0byB1c2UgYHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RgIHRvIHNpbGVuY2UgdGhvc2Ugd2FybmluZ3NcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKGxheW91dEVmZmVjdEFjdGlvbnNSZWYuY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChsYXlvdXRFZmZlY3RBY3Rpb25zUmVmLmN1cnJlbnQuc2hpZnQoKSwgMiksIGxheW91dEVmZmVjdEFjdGlvbiA9IF9hWzBdLCBlZmZlY3RTdGF0ZSA9IF9hWzFdO1xuICAgICAgICAgICAgZXhlY3V0ZUVmZmVjdChsYXlvdXRFZmZlY3RBY3Rpb24sIGVmZmVjdFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH0pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRrcGlhbm8veHN0YXRlL3B1bGwvMTIwMiNkaXNjdXNzaW9uX3I0Mjk2Nzc3NzNcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoZWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGVmZmVjdEFjdGlvbnNSZWYuY3VycmVudC5zaGlmdCgpLCAyKSwgZWZmZWN0QWN0aW9uID0gX2FbMF0sIGVmZmVjdFN0YXRlID0gX2FbMV07XG4gICAgICAgICAgICBleGVjdXRlRWZmZWN0KGVmZmVjdEFjdGlvbiwgZWZmZWN0U3RhdGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBmcm9tICd1c2UtaXNvbW9ycGhpYy1sYXlvdXQtZWZmZWN0JztcbmltcG9ydCB7IGludGVycHJldCwgU3RhdGUgfSBmcm9tICd4c3RhdGUnO1xuaW1wb3J0IHVzZUNvbnN0YW50IGZyb20gJy4vdXNlQ29uc3RhbnQnO1xuaW1wb3J0IHsgdXNlUmVhY3RFZmZlY3RBY3Rpb25zIH0gZnJvbSAnLi91c2VSZWFjdEVmZmVjdEFjdGlvbnMnO1xuLy8gY29waWVkIGZyb20gY29yZS9zcmMvdXRpbHMudHNcbi8vIGl0IGF2b2lkcyBhIGJyZWFraW5nIGNoYW5nZSBiZXR3ZWVuIHRoaXMgcGFja2FnZSBhbmQgWFN0YXRlIHdoaWNoIGlzIGl0cyBwZWVyIGRlcFxuZnVuY3Rpb24gdG9PYnNlcnZlcihuZXh0SGFuZGxlciwgZXJyb3JIYW5kbGVyLCBjb21wbGV0aW9uSGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dEhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlcjtcbiAgICB9XG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2b2lkIDA7IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogbmV4dEhhbmRsZXIsXG4gICAgICAgIGVycm9yOiBlcnJvckhhbmRsZXIgfHwgbm9vcCxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRpb25IYW5kbGVyIHx8IG5vb3BcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVycHJldChnZXRNYWNoaW5lLCBvcHRpb25zLCBvYnNlcnZlck9yTGlzdGVuZXIpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBtYWNoaW5lID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGdldE1hY2hpbmUgPT09ICdmdW5jdGlvbicgPyBnZXRNYWNoaW5lKCkgOiBnZXRNYWNoaW5lO1xuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBnZXRNYWNoaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZShtYWNoaW5lKSwgMSksIGluaXRpYWxNYWNoaW5lID0gX2FbMF07XG4gICAgICAgIGlmIChtYWNoaW5lICE9PSBpbml0aWFsTWFjaGluZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWNoaW5lIGdpdmVuIHRvIGB1c2VNYWNoaW5lYCBoYXMgY2hhbmdlZCBiZXR3ZWVuIHJlbmRlcnMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgbWlnaHQgbGVhZCB0byB1bmV4cGVjdGVkIHJlc3VsdHMuXFxuJyArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgdGhhdCB5b3UgcGFzcyB0aGUgc2FtZSBNYWNoaW5lIGFzIGFyZ3VtZW50IGVhY2ggdGltZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgZ3VhcmRzID0gb3B0aW9ucy5ndWFyZHMsIGFjdGlvbnMgPSBvcHRpb25zLmFjdGlvbnMsIGFjdGl2aXRpZXMgPSBvcHRpb25zLmFjdGl2aXRpZXMsIHNlcnZpY2VzID0gb3B0aW9ucy5zZXJ2aWNlcywgZGVsYXlzID0gb3B0aW9ucy5kZWxheXMsIHJlaHlkcmF0ZWRTdGF0ZSA9IG9wdGlvbnMuc3RhdGUsIGludGVycHJldGVyT3B0aW9ucyA9IF9fcmVzdChvcHRpb25zLCBbXCJjb250ZXh0XCIsIFwiZ3VhcmRzXCIsIFwiYWN0aW9uc1wiLCBcImFjdGl2aXRpZXNcIiwgXCJzZXJ2aWNlc1wiLCBcImRlbGF5c1wiLCBcInN0YXRlXCJdKTtcbiAgICB2YXIgc2VydmljZSA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hY2hpbmVDb25maWcgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgZ3VhcmRzOiBndWFyZHMsXG4gICAgICAgICAgICBhY3Rpb25zOiBhY3Rpb25zLFxuICAgICAgICAgICAgYWN0aXZpdGllczogYWN0aXZpdGllcyxcbiAgICAgICAgICAgIHNlcnZpY2VzOiBzZXJ2aWNlcyxcbiAgICAgICAgICAgIGRlbGF5czogZGVsYXlzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWNoaW5lV2l0aENvbmZpZyA9IG1hY2hpbmUud2l0aENvbmZpZyhtYWNoaW5lQ29uZmlnLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG1hY2hpbmUuY29udGV4dCksIGNvbnRleHQpKTsgfSk7XG4gICAgICAgIHJldHVybiBpbnRlcnByZXQobWFjaGluZVdpdGhDb25maWcsIF9fYXNzaWduKHsgZGVmZXJFdmVudHM6IHRydWUgfSwgaW50ZXJwcmV0ZXJPcHRpb25zKSk7XG4gICAgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWI7XG4gICAgICAgIGlmIChvYnNlcnZlck9yTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHN1YiA9IHNlcnZpY2Uuc3Vic2NyaWJlKHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YiA9PT0gbnVsbCB8fCBzdWIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtvYnNlcnZlck9yTGlzdGVuZXJdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VydmljZS5zdGFydChyZWh5ZHJhdGVkU3RhdGUgPyBTdGF0ZS5jcmVhdGUocmVoeWRyYXRlZFN0YXRlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gTWFrZSBzdXJlIG9wdGlvbnMgYXJlIGtlcHQgdXBkYXRlZCB3aGVuIHRoZXkgY2hhbmdlLlxuICAgIC8vIFRoaXMgbXV0YXRpb24gYXNzaWdubWVudCBpcyBzYWZlIGJlY2F1c2UgdGhlIHNlcnZpY2UgaW5zdGFuY2UgaXMgb25seSB1c2VkXG4gICAgLy8gaW4gb25lIHBsYWNlIC0tIHRoaXMgaG9vaydzIGNhbGxlci5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2aWNlLm1hY2hpbmUub3B0aW9ucy5hY3Rpb25zLCBhY3Rpb25zKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2aWNlLm1hY2hpbmUub3B0aW9ucy5ndWFyZHMsIGd1YXJkcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmljZS5tYWNoaW5lLm9wdGlvbnMuYWN0aXZpdGllcywgYWN0aXZpdGllcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmljZS5tYWNoaW5lLm9wdGlvbnMuc2VydmljZXMsIHNlcnZpY2VzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2aWNlLm1hY2hpbmUub3B0aW9ucy5kZWxheXMsIGRlbGF5cyk7XG4gICAgfSwgW2FjdGlvbnMsIGd1YXJkcywgYWN0aXZpdGllcywgc2VydmljZXMsIGRlbGF5c10pO1xuICAgIHVzZVJlYWN0RWZmZWN0QWN0aW9ucyhzZXJ2aWNlKTtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBmcm9tLmxlbmd0aCwgaiA9IHRvLmxlbmd0aDsgaSA8IGlsOyBpKyssIGorKylcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xuICAgIHJldHVybiB0bztcbn07XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJ3hzdGF0ZSc7XG5pbXBvcnQgeyBSZWFjdEVmZmVjdFR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZUludGVycHJldCB9IGZyb20gJy4vdXNlSW50ZXJwcmV0JztcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0QWN0aW9uRnVuY3Rpb24oZXhlYywgdGFnKSB7XG4gICAgdmFyIGVmZmVjdEV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgZXhlY3V0ZTsganVzdCByZXR1cm5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlZmZlY3RFeGVjLCB7XG4gICAgICAgIG5hbWU6IHsgdmFsdWU6IFwiZWZmZWN0OlwiICsgZXhlYy5uYW1lIH0sXG4gICAgICAgIF9fZWZmZWN0OiB7IHZhbHVlOiB0YWcgfVxuICAgIH0pO1xuICAgIHJldHVybiBlZmZlY3RFeGVjO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzRWZmZWN0KGV4ZWMpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RBY3Rpb25GdW5jdGlvbihleGVjLCBSZWFjdEVmZmVjdFR5cGUuRWZmZWN0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc0xheW91dEVmZmVjdChleGVjKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0QWN0aW9uRnVuY3Rpb24oZXhlYywgUmVhY3RFZmZlY3RUeXBlLkxheW91dEVmZmVjdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlTWFjaGluZShnZXRNYWNoaW5lLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgbGlzdGVuZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgIC8vIE9ubHkgY2hhbmdlIHRoZSBjdXJyZW50IHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbmNvbWluZyBzdGF0ZSBpcyB0aGUgXCJsaXZlXCIgaW5pdGlhbCBzdGF0ZSAoc2luY2UgaXQgbWlnaHQgaGF2ZSBuZXcgYWN0b3JzKVxuICAgICAgICAvLyAtIE9SIHRoZSBpbmNvbWluZyBzdGF0ZSBhY3R1YWxseSBjaGFuZ2VkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgXCJsaXZlXCIgaW5pdGlhbCBzdGF0ZSB3aWxsIGhhdmUgLmNoYW5nZWQgPT09IHVuZGVmaW5lZC5cbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZUNoYW5nZWQgPSBuZXh0U3RhdGUuY2hhbmdlZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXh0U3RhdGUuY2hpbGRyZW4pLmxlbmd0aDtcbiAgICAgICAgaWYgKG5leHRTdGF0ZS5jaGFuZ2VkIHx8IGluaXRpYWxTdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIHNlcnZpY2UgPSB1c2VJbnRlcnByZXQoZ2V0TWFjaGluZSwgb3B0aW9ucywgbGlzdGVuZXIpO1xuICAgIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBzZXJ2aWNlLm1hY2hpbmUuaW5pdGlhbFN0YXRlO1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuc3RhdGVcbiAgICAgICAgICAgID8gU3RhdGUuY3JlYXRlKG9wdGlvbnMuc3RhdGUpXG4gICAgICAgICAgICA6IGluaXRpYWxTdGF0ZSk7XG4gICAgfSksIDIpLCBzdGF0ZSA9IF9hWzBdLCBzZXRTdGF0ZSA9IF9hWzFdO1xuICAgIHJldHVybiBbc3RhdGUsIHNlcnZpY2Uuc2VuZCwgc2VydmljZV07XG59XG4iLCJ2YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgZnJvbSAndXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdCc7XG5pbXBvcnQgdXNlQ29uc3RhbnQgZnJvbSAnLi91c2VDb25zdGFudCc7XG5leHBvcnQgZnVuY3Rpb24gaXNBY3RvcldpdGhTdGF0ZShhY3RvclJlZikge1xuICAgIHJldHVybiAnc3RhdGUnIGluIGFjdG9yUmVmO1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZEFjdG9yKGFjdG9yUmVmKSB7XG4gICAgcmV0dXJuICdkZWZlcnJlZCcgaW4gYWN0b3JSZWY7XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiAuLi4gKi9cbn07XG5mdW5jdGlvbiBkZWZhdWx0R2V0U25hcHNob3QoYWN0b3JSZWYpIHtcbiAgICByZXR1cm4gJ2dldFNuYXBzaG90JyBpbiBhY3RvclJlZlxuICAgICAgICA/IGFjdG9yUmVmLmdldFNuYXBzaG90KClcbiAgICAgICAgOiBpc0FjdG9yV2l0aFN0YXRlKGFjdG9yUmVmKVxuICAgICAgICAgICAgPyBhY3RvclJlZi5zdGF0ZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0b3IoYWN0b3JSZWYsIGdldFNuYXBzaG90KSB7XG4gICAgaWYgKGdldFNuYXBzaG90ID09PSB2b2lkIDApIHsgZ2V0U25hcHNob3QgPSBkZWZhdWx0R2V0U25hcHNob3Q7IH1cbiAgICB2YXIgYWN0b3JSZWZSZWYgPSB1c2VSZWYoYWN0b3JSZWYpO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50c1JlZiA9IHVzZVJlZihbXSk7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldFNuYXBzaG90KGFjdG9yUmVmKTsgfSksIDIpLCBjdXJyZW50ID0gX2FbMF0sIHNldEN1cnJlbnQgPSBfYVsxXTtcbiAgICB2YXIgc2VuZCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSBhcmdzWzBdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuZXhwZWN0ZWQgcGF5bG9hZDogXCIgKyBKU09OLnN0cmluZ2lmeShhcmdzWzFdKSArIFwiLiBPbmx5IGEgc2luZ2xlIGV2ZW50IG9iamVjdCBjYW4gYmUgc2VudCB0byBhY3RvciBzZW5kKCkgZnVuY3Rpb25zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudEFjdG9yUmVmID0gYWN0b3JSZWZSZWYuY3VycmVudDtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGFjdG9yIGlzIGEgZGVmZXJyZWQgYWN0b3IsXG4gICAgICAgIC8vIHF1ZXVlIHRoZSBldmVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXBsYXllZFxuICAgICAgICAvLyBvbiB0aGUgbm9uLWRlZmVycmVkIGFjdG9yLlxuICAgICAgICBpZiAoaXNEZWZlcnJlZEFjdG9yKGN1cnJlbnRBY3RvclJlZikgJiYgY3VycmVudEFjdG9yUmVmLmRlZmVycmVkKSB7XG4gICAgICAgICAgICBkZWZlcnJlZEV2ZW50c1JlZi5jdXJyZW50LnB1c2goZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEFjdG9yUmVmLnNlbmQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTsgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdG9yUmVmUmVmLmN1cnJlbnQgPSBhY3RvclJlZjtcbiAgICAgICAgc2V0Q3VycmVudChnZXRTbmFwc2hvdChhY3RvclJlZikpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gYWN0b3JSZWYuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChlbWl0dGVkKSB7IHJldHVybiBzZXRDdXJyZW50KGVtaXR0ZWQpOyB9LFxuICAgICAgICAgICAgZXJyb3I6IG5vb3AsXG4gICAgICAgICAgICBjb21wbGV0ZTogbm9vcFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGVxdWV1ZSBkZWZlcnJlZCBldmVudHMgZnJvbSB0aGUgcHJldmlvdXMgZGVmZXJyZWQgYWN0b3JSZWZcbiAgICAgICAgd2hpbGUgKGRlZmVycmVkRXZlbnRzUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnQgPSBkZWZlcnJlZEV2ZW50c1JlZi5jdXJyZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICBhY3RvclJlZi5zZW5kKGRlZmVycmVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWN0b3JSZWZdKTtcbiAgICByZXR1cm4gW2N1cnJlbnQsIHNlbmRdO1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuaW1wb3J0IHsgdXNlQWN0b3IgfSBmcm9tICcuL3VzZUFjdG9yJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXJ2aWNlU25hcHNob3Qoc2VydmljZSkge1xuICAgIC8vIFRPRE86IHJlbW92ZSBjb21wYXQgbGluZXMgaW4gYSBuZXcgbWFqb3IsIHJlcGxhY2UgbGl0ZXJhbCBudW1iZXIgd2l0aCBJbnRlcnByZXRlclN0YXR1cyB0aGVuIGFzIHdlbGxcbiAgICByZXR1cm4gKCdzdGF0dXMnIGluIHNlcnZpY2UgPyBzZXJ2aWNlLnN0YXR1cyA6IHNlcnZpY2UuX3N0YXR1cykgIT09IDBcbiAgICAgICAgPyBzZXJ2aWNlLnN0YXRlXG4gICAgICAgIDogc2VydmljZS5tYWNoaW5lLmluaXRpYWxTdGF0ZTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB1c2VBY3RvcmAgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gc2VydmljZSBUaGUgaW50ZXJwcmV0ZWQgbWFjaGluZVxuICogQHJldHVybnMgQSB0dXBsZSBvZiB0aGUgY3VycmVudCBgc3RhdGVgIG9mIHRoZSBzZXJ2aWNlIGFuZCB0aGUgc2VydmljZSdzIGBzZW5kKGV2ZW50KWAgbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKCdtYWNoaW5lJyBpbiBzZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdXNlIGFuIGFjdG9yLWxpa2Ugb2JqZWN0IGluc3RlYWQgb2YgYSBzZXJ2aWNlIGluIHRoZSB1c2VTZXJ2aWNlKCkgaG9vay4gUGxlYXNlIHVzZSB0aGUgdXNlQWN0b3IoKSBob29rIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlQWN0b3Ioc2VydmljZSksIDEpLCBzdGF0ZSA9IF9hWzBdO1xuICAgIHJldHVybiBbc3RhdGUsIHNlcnZpY2Uuc2VuZF07XG59XG4iLCJ2YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0FjdG9yV2l0aFN0YXRlIH0gZnJvbSAnLi91c2VBY3Rvcic7XG5pbXBvcnQgeyBnZXRTZXJ2aWNlU25hcHNob3QgfSBmcm9tICcuL3VzZVNlcnZpY2UnO1xuZnVuY3Rpb24gaXNTZXJ2aWNlKGFjdG9yKSB7XG4gICAgcmV0dXJuICdzdGF0ZScgaW4gYWN0b3IgJiYgJ21hY2hpbmUnIGluIGFjdG9yO1xufVxudmFyIGRlZmF1bHRDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH07XG52YXIgZGVmYXVsdEdldFNuYXBzaG90ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gaXNTZXJ2aWNlKGEpXG4gICAgICAgID8gZ2V0U2VydmljZVNuYXBzaG90KGEpXG4gICAgICAgIDogaXNBY3RvcldpdGhTdGF0ZShhKVxuICAgICAgICAgICAgPyBhLnN0YXRlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5leHBvcnQgZnVuY3Rpb24gdXNlU2VsZWN0b3IoYWN0b3IsIHNlbGVjdG9yLCBjb21wYXJlLCBnZXRTbmFwc2hvdCkge1xuICAgIGlmIChjb21wYXJlID09PSB2b2lkIDApIHsgY29tcGFyZSA9IGRlZmF1bHRDb21wYXJlOyB9XG4gICAgaWYgKGdldFNuYXBzaG90ID09PSB2b2lkIDApIHsgZ2V0U25hcHNob3QgPSBkZWZhdWx0R2V0U25hcHNob3Q7IH1cbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZWN0b3IoZ2V0U25hcHNob3QoYWN0b3IpKTsgfSksIDIpLCBzZWxlY3RlZCA9IF9hWzBdLCBzZXRTZWxlY3RlZCA9IF9hWzFdO1xuICAgIHZhciBzZWxlY3RlZFJlZiA9IHVzZVJlZihzZWxlY3RlZCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVwZGF0ZVNlbGVjdGVkSWZDaGFuZ2VkID0gZnVuY3Rpb24gKG5leHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKCFjb21wYXJlKHNlbGVjdGVkUmVmLmN1cnJlbnQsIG5leHRTZWxlY3RlZCkpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChuZXh0U2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUmVmLmN1cnJlbnQgPSBuZXh0U2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbml0aWFsU2VsZWN0ZWQgPSBzZWxlY3RvcihnZXRTbmFwc2hvdChhY3RvcikpO1xuICAgICAgICB1cGRhdGVTZWxlY3RlZElmQ2hhbmdlZChpbml0aWFsU2VsZWN0ZWQpO1xuICAgICAgICB2YXIgc3ViID0gYWN0b3Iuc3Vic2NyaWJlKGZ1bmN0aW9uIChlbWl0dGVkKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNlbGVjdGVkID0gc2VsZWN0b3IoZW1pdHRlZCk7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3RlZElmQ2hhbmdlZChuZXh0U2VsZWN0ZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9O1xuICAgIH0sIFtzZWxlY3RvciwgY29tcGFyZV0pO1xuICAgIHJldHVybiBzZWxlY3RlZDtcbn1cbiIsImltcG9ydCB7IHNwYXduQmVoYXZpb3IgfSBmcm9tICd4c3RhdGUvbGliL2JlaGF2aW9ycyc7XG5pbXBvcnQgdXNlQ29uc3RhbnQgZnJvbSAnLi91c2VDb25zdGFudCc7XG4vKipcbiAqIFJlYWN0IGhvb2sgdGhhdCBzcGF3bnMgYW4gYEFjdG9yUmVmYCB3aXRoIHRoZSBzcGVjaWZpZWQgYGJlaGF2aW9yYC5cbiAqIFRoZSByZXR1cm5lZCBgQWN0b3JSZWZgIGNhbiBiZSB1c2VkIHdpdGggdGhlIGB1c2VBY3RvcihhY3RvclJlZilgIGhvb2suXG4gKlxuICogQHBhcmFtIGJlaGF2aW9yIFRoZSBhY3RvciBiZWhhdmlvciB0byBzcGF3blxuICogQHJldHVybnMgQW4gQWN0b3JSZWYgd2l0aCB0aGUgc3BlY2lmaWVkIGBiZWhhdmlvcmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNwYXduKGJlaGF2aW9yKSB7XG4gICAgdmFyIGFjdG9yUmVmID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3Bhd25CZWhhdmlvcihiZWhhdmlvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdG9yUmVmO1xufVxuIiwiZXhwb3J0IHsgdXNlTWFjaGluZSwgYXNFZmZlY3QsIGFzTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi91c2VNYWNoaW5lJztcbmV4cG9ydCB7IHVzZVNlcnZpY2UgfSBmcm9tICcuL3VzZVNlcnZpY2UnO1xuZXhwb3J0IHsgdXNlQWN0b3IgfSBmcm9tICcuL3VzZUFjdG9yJztcbmV4cG9ydCB7IHVzZUludGVycHJldCB9IGZyb20gJy4vdXNlSW50ZXJwcmV0JztcbmV4cG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAnLi91c2VTZWxlY3Rvcic7XG5leHBvcnQgeyB1c2VTcGF3biB9IGZyb20gJy4vdXNlU3Bhd24nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28342\n')},76590:(__unused_webpack_module,exports,__webpack_require__)=>{eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({ value: true });\n\n__webpack_require__(29660);\nvar utils = __webpack_require__(50509);\n__webpack_require__(27108);\n__webpack_require__(73487);\nvar Actor = __webpack_require__(70880);\n\nfunction spawnBehavior(behavior, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var state = behavior.initialState;\n  var observers = new Set();\n  var mailbox = [];\n  var flushing = false;\n\n  var flush = function () {\n    if (flushing) {\n      return;\n    }\n\n    flushing = true;\n\n    while (mailbox.length > 0) {\n      var event_1 = mailbox.shift();\n      state = behavior.transition(state, event_1, actorCtx);\n      observers.forEach(function (observer) {\n        return observer.next(state);\n      });\n    }\n\n    flushing = false;\n  };\n\n  var actor = Actor.toActorRef({\n    id: options.id,\n    send: function (event) {\n      mailbox.push(event);\n      flush();\n    },\n    getSnapshot: function () {\n      return state;\n    },\n    subscribe: function (next, handleError, complete) {\n      var observer = utils.toObserver(next, handleError, complete);\n      observers.add(observer);\n      observer.next(state);\n      return {\n        unsubscribe: function () {\n          observers.delete(observer);\n        }\n      };\n    }\n  });\n  var actorCtx = {\n    parent: options.parent,\n    self: actor,\n    id: options.id || 'anonymous',\n    observers: observers\n  };\n  state = behavior.start ? behavior.start(actorCtx) : state;\n  return actor;\n}\n\nexports.Y = spawnBehavior;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY1OTAuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDZCQUE2QyxFQUFFLGFBQWEsQ0FBQzs7QUFFN0QsbUJBQU8sQ0FBQyxLQUFrQjtBQUMxQixZQUFZLG1CQUFPLENBQUMsS0FBWTtBQUNoQyxtQkFBTyxDQUFDLEtBQVk7QUFDcEIsbUJBQU8sQ0FBQyxLQUFrQjtBQUMxQixZQUFZLG1CQUFPLENBQUMsS0FBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMveHN0YXRlL2xpYi9iZWhhdmlvcnMuanM/NThjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4vZW52aXJvbm1lbnQuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnJlcXVpcmUoJy4vdHlwZXMuanMnKTtcbnJlcXVpcmUoJy4vYWN0aW9uVHlwZXMuanMnKTtcbnZhciBBY3RvciA9IHJlcXVpcmUoJy4vQWN0b3IuanMnKTtcblxuZnVuY3Rpb24gc3Bhd25CZWhhdmlvcihiZWhhdmlvciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHN0YXRlID0gYmVoYXZpb3IuaW5pdGlhbFN0YXRlO1xuICB2YXIgb2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICB2YXIgbWFpbGJveCA9IFtdO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZsdXNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gICAgd2hpbGUgKG1haWxib3gubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50XzEgPSBtYWlsYm94LnNoaWZ0KCk7XG4gICAgICBzdGF0ZSA9IGJlaGF2aW9yLnRyYW5zaXRpb24oc3RhdGUsIGV2ZW50XzEsIGFjdG9yQ3R4KTtcbiAgICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChzdGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmbHVzaGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBhY3RvciA9IEFjdG9yLnRvQWN0b3JSZWYoe1xuICAgIGlkOiBvcHRpb25zLmlkLFxuICAgIHNlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWFpbGJveC5wdXNoKGV2ZW50KTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSB1dGlscy50b09ic2VydmVyKG5leHQsIGhhbmRsZUVycm9yLCBjb21wbGV0ZSk7XG4gICAgICBvYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIG9ic2VydmVyLm5leHQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB2YXIgYWN0b3JDdHggPSB7XG4gICAgcGFyZW50OiBvcHRpb25zLnBhcmVudCxcbiAgICBzZWxmOiBhY3RvcixcbiAgICBpZDogb3B0aW9ucy5pZCB8fCAnYW5vbnltb3VzJyxcbiAgICBvYnNlcnZlcnM6IG9ic2VydmVyc1xuICB9O1xuICBzdGF0ZSA9IGJlaGF2aW9yLnN0YXJ0ID8gYmVoYXZpb3Iuc3RhcnQoYWN0b3JDdHgpIDogc3RhdGU7XG4gIHJldHVybiBhY3Rvcjtcbn1cblxuZXhwb3J0cy5zcGF3bkJlaGF2aW9yID0gc3Bhd25CZWhhdmlvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///76590\n")}}]);