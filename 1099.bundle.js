"use strict";(self.webpackChunkcos_ui=self.webpackChunkcos_ui||[]).push([[1099],{51099:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"setupMode\": () => (/* binding */ setupMode)\n});\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/language/json/fillers/monaco-editor-core.js\nvar monaco_editor_core = __webpack_require__(61174);\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/workerManager.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nvar STOP_WHEN_IDLE_FOR = 2 * 60 * 1000; // 2min\r\nvar WorkerManager = /** @class */ (function () {\r\n    function WorkerManager(defaults) {\r\n        var _this = this;\r\n        this._defaults = defaults;\r\n        this._worker = null;\r\n        this._idleCheckInterval = setInterval(function () { return _this._checkIfIdle(); }, 30 * 1000);\r\n        this._lastUsedTime = 0;\r\n        this._configChangeListener = this._defaults.onDidChange(function () { return _this._stopWorker(); });\r\n    }\r\n    WorkerManager.prototype._stopWorker = function () {\r\n        if (this._worker) {\r\n            this._worker.dispose();\r\n            this._worker = null;\r\n        }\r\n        this._client = null;\r\n    };\r\n    WorkerManager.prototype.dispose = function () {\r\n        clearInterval(this._idleCheckInterval);\r\n        this._configChangeListener.dispose();\r\n        this._stopWorker();\r\n    };\r\n    WorkerManager.prototype._checkIfIdle = function () {\r\n        if (!this._worker) {\r\n            return;\r\n        }\r\n        var timePassedSinceLastUsed = Date.now() - this._lastUsedTime;\r\n        if (timePassedSinceLastUsed > STOP_WHEN_IDLE_FOR) {\r\n            this._stopWorker();\r\n        }\r\n    };\r\n    WorkerManager.prototype._getClient = function () {\r\n        this._lastUsedTime = Date.now();\r\n        if (!this._client) {\r\n            this._worker = monaco_editor_core/* editor.createWebWorker */.j6.createWebWorker({\r\n                // module that exports the create() method and returns a `JSONWorker` instance\r\n                moduleId: 'vs/language/json/jsonWorker',\r\n                label: this._defaults.languageId,\r\n                // passed in to the create() method\r\n                createData: {\r\n                    languageSettings: this._defaults.diagnosticsOptions,\r\n                    languageId: this._defaults.languageId,\r\n                    enableSchemaRequest: this._defaults.diagnosticsOptions.enableSchemaRequest\r\n                }\r\n            });\r\n            this._client = this._worker.getProxy();\r\n        }\r\n        return this._client;\r\n    };\r\n    WorkerManager.prototype.getLanguageServiceWorker = function () {\r\n        var _this = this;\r\n        var resources = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            resources[_i] = arguments[_i];\r\n        }\r\n        var _client;\r\n        return this._getClient()\r\n            .then(function (client) {\r\n            _client = client;\r\n        })\r\n            .then(function (_) {\r\n            return _this._worker.withSyncedResources(resources);\r\n        })\r\n            .then(function (_) { return _client; });\r\n    };\r\n    return WorkerManager;\r\n}());\r\n\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/scanner.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nfunction scanner_createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var len = text.length;\n    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* Unknown */;\n        scanError = 0 /* None */;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* UnexpectedEndOfString */;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                var ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* EOF */;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = 1 /* OpenBraceToken */;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = 2 /* CloseBraceToken */;\n            case 91 /* openBracket */:\n                pos++;\n                return token = 3 /* OpenBracketToken */;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = 4 /* CloseBracketToken */;\n            case 58 /* colon */:\n                pos++;\n                return token = 6 /* ColonToken */;\n            case 44 /* comma */:\n                pos++;\n                return token = 5 /* CommaToken */;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* StringLiteral */;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var safeLength = len - 1; // For lookahead.\n                    var commentClosed = false;\n                    while (pos < safeLength) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = 11 /* NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* TrueKeyword */;\n                        case 'false': return token = 9 /* FalseKeyword */;\n                        case 'null': return token = 7 /* NullKeyword */;\n                    }\n                    return token = 16 /* Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n            case 47 /* slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenStartLine: function () { return lineStartOffset; },\n        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },\n        getTokenError: function () { return scanError; },\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/parser.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nfunction getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nfunction parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nfunction parser_parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nfunction parser_findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nfunction getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nfunction getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nfunction contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nfunction findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nfunction visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = scanner_createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var tokenValue = _scanner.getTokenValue();\n                var value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nfunction stripComments(text, replaceCh) {\n    var _scanner = scanner_createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nfunction getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/edit.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nfunction removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nfunction setProperty(text, originalPath, value, options) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            var removalIndex = lastSegment;\n            var toRemove = parent.children[removalIndex];\n            var edit = void 0;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                var previous = parent.children[removalIndex - 1];\n                var offset = previous.offset + previous.length;\n                var parentEndOffset = parent.offset + parent.length;\n                edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            var edit = void 0;\n            var newProperty = \"\" + JSON.stringify(value);\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                var toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(\"Can not \" + (value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')) + \" Array index \" + insertIndex + \" as length is not sufficient\");\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, options.formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nfunction applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nfunction isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/main.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nvar main_createScanner = scanner_createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nvar main_getLocation = getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nvar main_parse = parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nvar main_parseTree = parser_parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nvar main_findNodeAtLocation = parser_findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nvar main_findNodeAtOffset = findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nvar main_getNodePath = getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nvar main_getNodeValue = getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nvar main_visit = visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nvar main_stripComments = stripComments;\nfunction printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ValueExpected */: return 'ValueExpected';\n        case 5 /* ColonExpected */: return 'ColonExpected';\n        case 6 /* CommaExpected */: return 'CommaExpected';\n        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nfunction main_format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nfunction modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to a input string.\n */\nfunction applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = edit.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/objects.js\n/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nfunction equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if ((Array.isArray(one)) !== (Array.isArray(other))) {\n        return false;\n    }\n    var i, key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        var oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        var otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction objects_isNumber(val) {\n    return typeof val === 'number';\n}\nfunction isDefined(val) {\n    return typeof val !== 'undefined';\n}\nfunction isBoolean(val) {\n    return typeof val === 'boolean';\n}\nfunction isString(val) {\n    return typeof val === 'string';\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/strings.js\n/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nfunction startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    for (var i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\nfunction endsWith(haystack, needle) {\n    var diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.lastIndexOf(needle) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\nfunction convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nfunction repeat(value, count) {\n    var s = '';\n    while (count > 0) {\n        if ((count & 1) === 1) {\n            s += value;\n        }\n        value += value;\n        count = count >>> 1;\n    }\n    return s;\n}\nfunction extendedRegExp(pattern) {\n    if (startsWith(pattern, '(?i)')) {\n        return new RegExp(pattern.substring(4), 'i');\n    }\n    else {\n        return new RegExp(pattern);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-languageserver-types/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n})(integer || (integer = {}));\nvar uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * [Position](#Position) literals.\n */\nvar main_Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line: line, character: character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Position](#Position) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(main_Position || (main_Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * [Range](#Range) literals.\n */\nvar main_Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: main_Position.create(one, two), end: main_Position.create(three, four) };\n        }\n        else if (main_Position.is(one) && main_Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && main_Position.is(candidate.start) && main_Position.is(candidate.end);\n    }\n    Range.is = is;\n})(main_Range || (main_Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * [Location](#Location) literals.\n */\nvar Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri: uri, range: range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * [LocationLink](#LocationLink) literals.\n */\nvar LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && (main_Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))\n            && (main_Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [Color](#Color) literals.\n */\nvar Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * [ColorInformation](#ColorInformation) literals.\n */\nvar ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range: range,\n            color: color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return main_Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [ColorPresentation](#ColorPresentation) literals.\n */\nvar ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || main_TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, main_TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * Enum of known range kinds\n */\nvar main_FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind[\"Comment\"] = \"comment\";\n    /**\n     * Folding range for a imports or includes\n     */\n    FoldingRangeKind[\"Imports\"] = \"imports\";\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind[\"Region\"] = \"region\";\n})(main_FoldingRangeKind || (main_FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * [FoldingRange](#FoldingRange) literals.\n */\nvar FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\n        var result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\n */\nvar DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nvar main_DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(main_DiagnosticSeverity || (main_DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nvar DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nvar CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * [Diagnostic](#Diagnostic) literals.\n */\nvar main_Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        var result = { range: range, message: message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\n     */\n    function is(value) {\n        var _a;\n        var candidate = value;\n        return Is.defined(candidate)\n            && main_Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(main_Diagnostic || (main_Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * [Command](#Command) literals.\n */\nvar Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var result = { title: title, command: command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nvar main_TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range: range, newText: newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates a insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText: newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range: range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && main_Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(main_TextEdit || (main_TextEdit = {}));\nvar ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        var result = { label: label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        var candidate = value;\n        return typeof candidate === 'string';\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range: range, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range: range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return main_TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nvar TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument: textDocument, edits: edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'create',\n            uri: uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        var result = {\n            kind: 'rename',\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'delete',\n            uri: uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = /** @class */ (function () {\n    function TextEditChangeImpl(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = main_TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = main_TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.delete = function (range, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = main_TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.add = function (edit) {\n        this.edits.push(edit);\n    };\n    TextEditChangeImpl.prototype.all = function () {\n        return this.edits;\n    };\n    TextEditChangeImpl.prototype.clear = function () {\n        this.edits.splice(0, this.edits.length);\n    };\n    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n        if (value === undefined) {\n            throw new Error(\"Text edit change is not configured to manage change annotations.\");\n        }\n    };\n    return TextEditChangeImpl;\n}());\n/**\n * A helper class\n */\nvar ChangeAnnotations = /** @class */ (function () {\n    function ChangeAnnotations(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    ChangeAnnotations.prototype.all = function () {\n        return this._annotations;\n    };\n    Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n        var id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(\"Id \" + id + \" is already in use.\");\n        }\n        if (annotation === undefined) {\n            throw new Error(\"No annotation provided for id \" + id);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    };\n    ChangeAnnotations.prototype.nextId = function () {\n        this._counter++;\n        return this._counter.toString();\n    };\n    return ChangeAnnotations;\n}());\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nvar WorkspaceChange = /** @class */ (function () {\n    function WorkspaceChange(workspaceEdit) {\n        var _this = this;\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach(function (change) {\n                    if (TextDocumentEdit.is(change)) {\n                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n        /**\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\n         * use to be returned from a workspace edit operation like rename.\n         */\n        get: function () {\n            this.initDocumentChanges();\n            if (this._changeAnnotations !== undefined) {\n                if (this._changeAnnotations.size === 0) {\n                    this._workspaceEdit.changeAnnotations = undefined;\n                }\n                else {\n                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n            }\n            return this._workspaceEdit;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var textDocument = { uri: key.uri, version: key.version };\n            var result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                var edits = [];\n                var textDocumentEdit = {\n                    textDocument: textDocument,\n                    edits: edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            var result = this._textEditChanges[key];\n            if (!result) {\n                var edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    };\n    WorkspaceChange.prototype.initDocumentChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    };\n    WorkspaceChange.prototype.initChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    };\n    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    return WorkspaceChange;\n}());\n\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\n */\nvar TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri: uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\n */\nvar VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param uri The document's text.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.\n */\nvar OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param uri The document's text.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * [TextDocumentItem](#TextDocumentItem) literals.\n */\nvar TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri: uri, languageId: languageId, version: version, text: text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nvar MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n})(MarkupKind || (MarkupKind = {}));\n(function (MarkupKind) {\n    /**\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nvar CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nvar InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nvar CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nvar InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText: newText, insert: insert, replace: replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.newText) && main_Range.is(candidate.insert) && main_Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nvar InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nvar CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label: label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nvar CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || main_Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * [ParameterInformation](#ParameterInformation) literals.\n */\nvar ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label: label, documentation: documentation } : { label: label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * [SignatureInformation](#SignatureInformation) literals.\n */\nvar SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation) {\n        var parameters = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            parameters[_i - 2] = arguments[_i];\n        }\n        var result = { label: label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nvar DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * [DocumentHighlight](#DocumentHighlight) literals.\n */\nvar DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     */\n    function create(range, kind) {\n        var result = { range: range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nvar SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n * @since 3.16\n */\nvar SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol, defaults to the current document.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        var result = {\n            name: name,\n            kind: kind,\n            location: { uri: uri, range: range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        var result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            main_Range.is(candidate.range) && main_Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nvar CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * [CodeActionContext](#CodeActionContext) literals.\n */\nvar CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only) {\n        var result = { diagnostics: diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, main_Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        var result = { title: title };\n        var checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, main_Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * [CodeLens](#CodeLens) literals.\n */\nvar CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        var result = { range: range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * [FormattingOptions](#FormattingOptions) literals.\n */\nvar FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * [DocumentLink](#DocumentLink) literals.\n */\nvar DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range: range, target: target, data: data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nvar main_SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range: range, parent: parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && main_Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(main_SelectionRange || (main_SelectionRange = {}));\nvar EOL = (/* unused pure expression or super */ null && (['\\n', '\\r\\n', '\\r']));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits, function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = text.length;\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\n            var e = sortedEdits[i];\n            var startOffset = document.offsetAt(e.range.start);\n            var endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            var lineOffsets = [];\n            var text = this._content;\n            var isLineStart = true;\n            for (var i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                var ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return main_Position.create(0, offset);\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return main_Position.create(line, offset - lineOffsets[line]);\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return FullTextDocument;\n}());\nvar Is;\n(function (Is) {\n    var toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-languageserver-textdocument/lib/esm/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar main_FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (changes, version) {\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n            var change = changes_1[_i];\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                var range = getWellformedRange(change.range);\n                // update content\n                var startOffset = this.offsetAt(range.start);\n                var endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                var startLine = Math.max(range.start.line, 0);\n                var endLine = Math.max(range.end.line, 0);\n                var lineOffsets = this._lineOffsets;\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                var diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return { line: line, character: offset - lineOffsets[line] };\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.isIncremental = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    };\n    FullTextDocument.isFull = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    };\n    return FullTextDocument;\n}());\nvar main_TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new main_FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifing its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof main_FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = 0;\n        var spans = [];\n        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n            var e = sortedEdits_1[_i];\n            var startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(main_TextDocument || (main_TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    var p = (data.length / 2) | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        var ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n    if (textOffset === void 0) { textOffset = 0; }\n    var result = isAtLineStart ? [textOffset] : [];\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charCodeAt(i);\n        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\n            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    var start = range.start;\n    var end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    var range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range: range };\n    }\n    return textEdit;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/jsonLanguageTypes.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n/**\n * Error codes used by diagnostics\n */\nvar jsonLanguageTypes_ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"Undefined\"] = 0] = \"Undefined\";\n    ErrorCode[ErrorCode[\"EnumValueMismatch\"] = 1] = \"EnumValueMismatch\";\n    ErrorCode[ErrorCode[\"Deprecated\"] = 2] = \"Deprecated\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfComment\"] = 257] = \"UnexpectedEndOfComment\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfString\"] = 258] = \"UnexpectedEndOfString\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfNumber\"] = 259] = \"UnexpectedEndOfNumber\";\n    ErrorCode[ErrorCode[\"InvalidUnicode\"] = 260] = \"InvalidUnicode\";\n    ErrorCode[ErrorCode[\"InvalidEscapeCharacter\"] = 261] = \"InvalidEscapeCharacter\";\n    ErrorCode[ErrorCode[\"InvalidCharacter\"] = 262] = \"InvalidCharacter\";\n    ErrorCode[ErrorCode[\"PropertyExpected\"] = 513] = \"PropertyExpected\";\n    ErrorCode[ErrorCode[\"CommaExpected\"] = 514] = \"CommaExpected\";\n    ErrorCode[ErrorCode[\"ColonExpected\"] = 515] = \"ColonExpected\";\n    ErrorCode[ErrorCode[\"ValueExpected\"] = 516] = \"ValueExpected\";\n    ErrorCode[ErrorCode[\"CommaOrCloseBacketExpected\"] = 517] = \"CommaOrCloseBacketExpected\";\n    ErrorCode[ErrorCode[\"CommaOrCloseBraceExpected\"] = 518] = \"CommaOrCloseBraceExpected\";\n    ErrorCode[ErrorCode[\"TrailingComma\"] = 519] = \"TrailingComma\";\n    ErrorCode[ErrorCode[\"DuplicateKey\"] = 520] = \"DuplicateKey\";\n    ErrorCode[ErrorCode[\"CommentNotPermitted\"] = 521] = \"CommentNotPermitted\";\n    ErrorCode[ErrorCode[\"SchemaResolveError\"] = 768] = \"SchemaResolveError\";\n})(jsonLanguageTypes_ErrorCode || (jsonLanguageTypes_ErrorCode = {}));\nvar ClientCapabilities;\n(function (ClientCapabilities) {\n    ClientCapabilities.LATEST = {\n        textDocument: {\n            completion: {\n                completionItem: {\n                    documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],\n                    commitCharactersSupport: true\n                }\n            }\n        }\n    };\n})(ClientCapabilities || (ClientCapabilities = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/fillers/vscode-nls.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction vscode_nls_format(message, args) {\r\n    var result;\r\n    if (args.length === 0) {\r\n        result = message;\r\n    }\r\n    else {\r\n        result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\r\n            var index = rest[0];\r\n            return typeof args[index] !== 'undefined' ? args[index] : match;\r\n        });\r\n    }\r\n    return result;\r\n}\r\nfunction localize(key, message) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    return vscode_nls_format(message, args);\r\n}\r\nfunction loadMessageBundle(file) {\r\n    return localize;\r\n}\r\nfunction config(opt) {\r\n    return loadMessageBundle;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/parser/jsonParser.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar jsonParser_localize = loadMessageBundle();\nvar formats = {\n    'color-hex': { errorMessage: jsonParser_localize('colorHexFormatWarning', 'Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },\n    'date-time': { errorMessage: jsonParser_localize('dateTimeFormatWarning', 'String is not a RFC3339 date-time.'), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n    'date': { errorMessage: jsonParser_localize('dateFormatWarning', 'String is not a RFC3339 date.'), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },\n    'time': { errorMessage: jsonParser_localize('timeFormatWarning', 'String is not a RFC3339 time.'), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n    'email': { errorMessage: jsonParser_localize('emailFormatWarning', 'String is not an e-mail address.'), pattern: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ }\n};\nvar ASTNodeImpl = /** @class */ (function () {\n    function ASTNodeImpl(parent, offset, length) {\n        if (length === void 0) { length = 0; }\n        this.offset = offset;\n        this.length = length;\n        this.parent = parent;\n    }\n    Object.defineProperty(ASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return [];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ASTNodeImpl.prototype.toString = function () {\n        return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');\n    };\n    return ASTNodeImpl;\n}());\n\nvar NullASTNodeImpl = /** @class */ (function (_super) {\n    __extends(NullASTNodeImpl, _super);\n    function NullASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'null';\n        _this.value = null;\n        return _this;\n    }\n    return NullASTNodeImpl;\n}(ASTNodeImpl));\n\nvar BooleanASTNodeImpl = /** @class */ (function (_super) {\n    __extends(BooleanASTNodeImpl, _super);\n    function BooleanASTNodeImpl(parent, boolValue, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'boolean';\n        _this.value = boolValue;\n        return _this;\n    }\n    return BooleanASTNodeImpl;\n}(ASTNodeImpl));\n\nvar ArrayASTNodeImpl = /** @class */ (function (_super) {\n    __extends(ArrayASTNodeImpl, _super);\n    function ArrayASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'array';\n        _this.items = [];\n        return _this;\n    }\n    Object.defineProperty(ArrayASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return this.items;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ArrayASTNodeImpl;\n}(ASTNodeImpl));\n\nvar NumberASTNodeImpl = /** @class */ (function (_super) {\n    __extends(NumberASTNodeImpl, _super);\n    function NumberASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'number';\n        _this.isInteger = true;\n        _this.value = Number.NaN;\n        return _this;\n    }\n    return NumberASTNodeImpl;\n}(ASTNodeImpl));\n\nvar StringASTNodeImpl = /** @class */ (function (_super) {\n    __extends(StringASTNodeImpl, _super);\n    function StringASTNodeImpl(parent, offset, length) {\n        var _this = _super.call(this, parent, offset, length) || this;\n        _this.type = 'string';\n        _this.value = '';\n        return _this;\n    }\n    return StringASTNodeImpl;\n}(ASTNodeImpl));\n\nvar PropertyASTNodeImpl = /** @class */ (function (_super) {\n    __extends(PropertyASTNodeImpl, _super);\n    function PropertyASTNodeImpl(parent, offset, keyNode) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'property';\n        _this.colonOffset = -1;\n        _this.keyNode = keyNode;\n        return _this;\n    }\n    Object.defineProperty(PropertyASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return PropertyASTNodeImpl;\n}(ASTNodeImpl));\n\nvar ObjectASTNodeImpl = /** @class */ (function (_super) {\n    __extends(ObjectASTNodeImpl, _super);\n    function ObjectASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'object';\n        _this.properties = [];\n        return _this;\n    }\n    Object.defineProperty(ObjectASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return this.properties;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ObjectASTNodeImpl;\n}(ASTNodeImpl));\n\nfunction asSchema(schema) {\n    if (isBoolean(schema)) {\n        return schema ? {} : { \"not\": {} };\n    }\n    return schema;\n}\nvar EnumMatch;\n(function (EnumMatch) {\n    EnumMatch[EnumMatch[\"Key\"] = 0] = \"Key\";\n    EnumMatch[EnumMatch[\"Enum\"] = 1] = \"Enum\";\n})(EnumMatch || (EnumMatch = {}));\nvar SchemaCollector = /** @class */ (function () {\n    function SchemaCollector(focusOffset, exclude) {\n        if (focusOffset === void 0) { focusOffset = -1; }\n        this.focusOffset = focusOffset;\n        this.exclude = exclude;\n        this.schemas = [];\n    }\n    SchemaCollector.prototype.add = function (schema) {\n        this.schemas.push(schema);\n    };\n    SchemaCollector.prototype.merge = function (other) {\n        Array.prototype.push.apply(this.schemas, other.schemas);\n    };\n    SchemaCollector.prototype.include = function (node) {\n        return (this.focusOffset === -1 || jsonParser_contains(node, this.focusOffset)) && (node !== this.exclude);\n    };\n    SchemaCollector.prototype.newSub = function () {\n        return new SchemaCollector(-1, this.exclude);\n    };\n    return SchemaCollector;\n}());\nvar NoOpSchemaCollector = /** @class */ (function () {\n    function NoOpSchemaCollector() {\n    }\n    Object.defineProperty(NoOpSchemaCollector.prototype, \"schemas\", {\n        get: function () { return []; },\n        enumerable: false,\n        configurable: true\n    });\n    NoOpSchemaCollector.prototype.add = function (schema) { };\n    NoOpSchemaCollector.prototype.merge = function (other) { };\n    NoOpSchemaCollector.prototype.include = function (node) { return true; };\n    NoOpSchemaCollector.prototype.newSub = function () { return this; };\n    NoOpSchemaCollector.instance = new NoOpSchemaCollector();\n    return NoOpSchemaCollector;\n}());\nvar ValidationResult = /** @class */ (function () {\n    function ValidationResult() {\n        this.problems = [];\n        this.propertiesMatches = 0;\n        this.propertiesValueMatches = 0;\n        this.primaryValueMatches = 0;\n        this.enumValueMatch = false;\n        this.enumValues = undefined;\n    }\n    ValidationResult.prototype.hasProblems = function () {\n        return !!this.problems.length;\n    };\n    ValidationResult.prototype.mergeAll = function (validationResults) {\n        for (var _i = 0, validationResults_1 = validationResults; _i < validationResults_1.length; _i++) {\n            var validationResult = validationResults_1[_i];\n            this.merge(validationResult);\n        }\n    };\n    ValidationResult.prototype.merge = function (validationResult) {\n        this.problems = this.problems.concat(validationResult.problems);\n    };\n    ValidationResult.prototype.mergeEnumValues = function (validationResult) {\n        if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {\n            this.enumValues = this.enumValues.concat(validationResult.enumValues);\n            for (var _i = 0, _a = this.problems; _i < _a.length; _i++) {\n                var error = _a[_i];\n                if (error.code === jsonLanguageTypes_ErrorCode.EnumValueMismatch) {\n                    error.message = jsonParser_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', this.enumValues.map(function (v) { return JSON.stringify(v); }).join(', '));\n                }\n            }\n        }\n    };\n    ValidationResult.prototype.mergePropertyMatch = function (propertyValidationResult) {\n        this.merge(propertyValidationResult);\n        this.propertiesMatches++;\n        if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {\n            this.propertiesValueMatches++;\n        }\n        if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {\n            this.primaryValueMatches++;\n        }\n    };\n    ValidationResult.prototype.compare = function (other) {\n        var hasProblems = this.hasProblems();\n        if (hasProblems !== other.hasProblems()) {\n            return hasProblems ? -1 : 1;\n        }\n        if (this.enumValueMatch !== other.enumValueMatch) {\n            return other.enumValueMatch ? -1 : 1;\n        }\n        if (this.primaryValueMatches !== other.primaryValueMatches) {\n            return this.primaryValueMatches - other.primaryValueMatches;\n        }\n        if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n            return this.propertiesValueMatches - other.propertiesValueMatches;\n        }\n        return this.propertiesMatches - other.propertiesMatches;\n    };\n    return ValidationResult;\n}());\n\nfunction jsonParser_newJSONDocument(root, diagnostics) {\n    if (diagnostics === void 0) { diagnostics = []; }\n    return new JSONDocument(root, diagnostics, []);\n}\nfunction jsonParser_getNodeValue(node) {\n    return main_getNodeValue(node);\n}\nfunction jsonParser_getNodePath(node) {\n    return main_getNodePath(node);\n}\nfunction jsonParser_contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return offset >= node.offset && offset < (node.offset + node.length) || includeRightBound && offset === (node.offset + node.length);\n}\nvar JSONDocument = /** @class */ (function () {\n    function JSONDocument(root, syntaxErrors, comments) {\n        if (syntaxErrors === void 0) { syntaxErrors = []; }\n        if (comments === void 0) { comments = []; }\n        this.root = root;\n        this.syntaxErrors = syntaxErrors;\n        this.comments = comments;\n    }\n    JSONDocument.prototype.getNodeFromOffset = function (offset, includeRightBound) {\n        if (includeRightBound === void 0) { includeRightBound = false; }\n        if (this.root) {\n            return main_findNodeAtOffset(this.root, offset, includeRightBound);\n        }\n        return undefined;\n    };\n    JSONDocument.prototype.visit = function (visitor) {\n        if (this.root) {\n            var doVisit_1 = function (node) {\n                var ctn = visitor(node);\n                var children = node.children;\n                if (Array.isArray(children)) {\n                    for (var i = 0; i < children.length && ctn; i++) {\n                        ctn = doVisit_1(children[i]);\n                    }\n                }\n                return ctn;\n            };\n            doVisit_1(this.root);\n        }\n    };\n    JSONDocument.prototype.validate = function (textDocument, schema, severity) {\n        if (severity === void 0) { severity = main_DiagnosticSeverity.Warning; }\n        if (this.root && schema) {\n            var validationResult = new ValidationResult();\n            validate(this.root, schema, validationResult, NoOpSchemaCollector.instance);\n            return validationResult.problems.map(function (p) {\n                var _a;\n                var range = main_Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\n                return main_Diagnostic.create(range, p.message, (_a = p.severity) !== null && _a !== void 0 ? _a : severity, p.code);\n            });\n        }\n        return undefined;\n    };\n    JSONDocument.prototype.getMatchingSchemas = function (schema, focusOffset, exclude) {\n        if (focusOffset === void 0) { focusOffset = -1; }\n        var matchingSchemas = new SchemaCollector(focusOffset, exclude);\n        if (this.root && schema) {\n            validate(this.root, schema, new ValidationResult(), matchingSchemas);\n        }\n        return matchingSchemas.schemas;\n    };\n    return JSONDocument;\n}());\n\nfunction validate(n, schema, validationResult, matchingSchemas) {\n    if (!n || !matchingSchemas.include(n)) {\n        return;\n    }\n    var node = n;\n    switch (node.type) {\n        case 'object':\n            _validateObjectNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'array':\n            _validateArrayNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'string':\n            _validateStringNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'number':\n            _validateNumberNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'property':\n            return validate(node.valueNode, schema, validationResult, matchingSchemas);\n    }\n    _validateNode();\n    matchingSchemas.add({ node: node, schema: schema });\n    function _validateNode() {\n        function matchesType(type) {\n            return node.type === type || (type === 'integer' && node.type === 'number' && node.isInteger);\n        }\n        if (Array.isArray(schema.type)) {\n            if (!schema.type.some(matchesType)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || jsonParser_localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', '))\n                });\n            }\n        }\n        else if (schema.type) {\n            if (!matchesType(schema.type)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || jsonParser_localize('typeMismatchWarning', 'Incorrect type. Expected \"{0}\".', schema.type)\n                });\n            }\n        }\n        if (Array.isArray(schema.allOf)) {\n            for (var _i = 0, _a = schema.allOf; _i < _a.length; _i++) {\n                var subSchemaRef = _a[_i];\n                validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);\n            }\n        }\n        var notSchema = asSchema(schema.not);\n        if (notSchema) {\n            var subValidationResult = new ValidationResult();\n            var subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, notSchema, subValidationResult, subMatchingSchemas);\n            if (!subValidationResult.hasProblems()) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('notSchemaWarning', \"Matches a schema that is not allowed.\")\n                });\n            }\n            for (var _b = 0, _c = subMatchingSchemas.schemas; _b < _c.length; _b++) {\n                var ms = _c[_b];\n                ms.inverted = !ms.inverted;\n                matchingSchemas.add(ms);\n            }\n        }\n        var testAlternatives = function (alternatives, maxOneMatch) {\n            var matches = [];\n            // remember the best match that is used for error messages\n            var bestMatch = undefined;\n            for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {\n                var subSchemaRef = alternatives_1[_i];\n                var subSchema = asSchema(subSchemaRef);\n                var subValidationResult = new ValidationResult();\n                var subMatchingSchemas = matchingSchemas.newSub();\n                validate(node, subSchema, subValidationResult, subMatchingSchemas);\n                if (!subValidationResult.hasProblems()) {\n                    matches.push(subSchema);\n                }\n                if (!bestMatch) {\n                    bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\n                }\n                else {\n                    if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {\n                        // no errors, both are equally good matches\n                        bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                        bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n                        bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n                    }\n                    else {\n                        var compareResult = subValidationResult.compare(bestMatch.validationResult);\n                        if (compareResult > 0) {\n                            // our node is the best matching so far\n                            bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\n                        }\n                        else if (compareResult === 0) {\n                            // there's already a best matching but we are as good\n                            bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                            bestMatch.validationResult.mergeEnumValues(subValidationResult);\n                        }\n                    }\n                }\n            }\n            if (matches.length > 1 && maxOneMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: 1 },\n                    message: jsonParser_localize('oneOfWarning', \"Matches multiple schemas when only one must validate.\")\n                });\n            }\n            if (bestMatch) {\n                validationResult.merge(bestMatch.validationResult);\n                validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;\n                validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;\n                matchingSchemas.merge(bestMatch.matchingSchemas);\n            }\n            return matches.length;\n        };\n        if (Array.isArray(schema.anyOf)) {\n            testAlternatives(schema.anyOf, false);\n        }\n        if (Array.isArray(schema.oneOf)) {\n            testAlternatives(schema.oneOf, true);\n        }\n        var testBranch = function (schema) {\n            var subValidationResult = new ValidationResult();\n            var subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, asSchema(schema), subValidationResult, subMatchingSchemas);\n            validationResult.merge(subValidationResult);\n            validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n            validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n            matchingSchemas.merge(subMatchingSchemas);\n        };\n        var testCondition = function (ifSchema, thenSchema, elseSchema) {\n            var subSchema = asSchema(ifSchema);\n            var subValidationResult = new ValidationResult();\n            var subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, subSchema, subValidationResult, subMatchingSchemas);\n            matchingSchemas.merge(subMatchingSchemas);\n            if (!subValidationResult.hasProblems()) {\n                if (thenSchema) {\n                    testBranch(thenSchema);\n                }\n            }\n            else if (elseSchema) {\n                testBranch(elseSchema);\n            }\n        };\n        var ifSchema = asSchema(schema.if);\n        if (ifSchema) {\n            testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));\n        }\n        if (Array.isArray(schema.enum)) {\n            var val = jsonParser_getNodeValue(node);\n            var enumValueMatch = false;\n            for (var _d = 0, _e = schema.enum; _d < _e.length; _d++) {\n                var e = _e[_d];\n                if (equals(val, e)) {\n                    enumValueMatch = true;\n                    break;\n                }\n            }\n            validationResult.enumValues = schema.enum;\n            validationResult.enumValueMatch = enumValueMatch;\n            if (!enumValueMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    code: jsonLanguageTypes_ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage || jsonParser_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum.map(function (v) { return JSON.stringify(v); }).join(', '))\n                });\n            }\n        }\n        if (isDefined(schema.const)) {\n            var val = jsonParser_getNodeValue(node);\n            if (!equals(val, schema.const)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    code: jsonLanguageTypes_ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage || jsonParser_localize('constWarning', 'Value must be {0}.', JSON.stringify(schema.const))\n                });\n                validationResult.enumValueMatch = false;\n            }\n            else {\n                validationResult.enumValueMatch = true;\n            }\n            validationResult.enumValues = [schema.const];\n        }\n        if (schema.deprecationMessage && node.parent) {\n            validationResult.problems.push({\n                location: { offset: node.parent.offset, length: node.parent.length },\n                severity: main_DiagnosticSeverity.Warning,\n                message: schema.deprecationMessage,\n                code: jsonLanguageTypes_ErrorCode.Deprecated\n            });\n        }\n    }\n    function _validateNumberNode(node, schema, validationResult, matchingSchemas) {\n        var val = node.value;\n        function normalizeFloats(float) {\n            var _a;\n            var parts = /^(-?\\d+)(?:\\.(\\d+))?(?:e([-+]\\d+))?$/.exec(float.toString());\n            return parts && {\n                value: Number(parts[1] + (parts[2] || '')),\n                multiplier: (((_a = parts[2]) === null || _a === void 0 ? void 0 : _a.length) || 0) - (parseInt(parts[3]) || 0)\n            };\n        }\n        ;\n        if (objects_isNumber(schema.multipleOf)) {\n            var remainder = -1;\n            if (Number.isInteger(schema.multipleOf)) {\n                remainder = val % schema.multipleOf;\n            }\n            else {\n                var normMultipleOf = normalizeFloats(schema.multipleOf);\n                var normValue = normalizeFloats(val);\n                if (normMultipleOf && normValue) {\n                    var multiplier = Math.pow(10, Math.abs(normValue.multiplier - normMultipleOf.multiplier));\n                    if (normValue.multiplier < normMultipleOf.multiplier) {\n                        normValue.value *= multiplier;\n                    }\n                    else {\n                        normMultipleOf.value *= multiplier;\n                    }\n                    remainder = normValue.value % normMultipleOf.value;\n                }\n            }\n            if (remainder !== 0) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf)\n                });\n            }\n        }\n        function getExclusiveLimit(limit, exclusive) {\n            if (objects_isNumber(exclusive)) {\n                return exclusive;\n            }\n            if (isBoolean(exclusive) && exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        function getLimit(limit, exclusive) {\n            if (!isBoolean(exclusive) || !exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        var exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);\n        if (objects_isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', exclusiveMinimum)\n            });\n        }\n        var exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);\n        if (objects_isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', exclusiveMaximum)\n            });\n        }\n        var minimum = getLimit(schema.minimum, schema.exclusiveMinimum);\n        if (objects_isNumber(minimum) && val < minimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('minimumWarning', 'Value is below the minimum of {0}.', minimum)\n            });\n        }\n        var maximum = getLimit(schema.maximum, schema.exclusiveMaximum);\n        if (objects_isNumber(maximum) && val > maximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('maximumWarning', 'Value is above the maximum of {0}.', maximum)\n            });\n        }\n    }\n    function _validateStringNode(node, schema, validationResult, matchingSchemas) {\n        if (objects_isNumber(schema.minLength) && node.value.length < schema.minLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength)\n            });\n        }\n        if (objects_isNumber(schema.maxLength) && node.value.length > schema.maxLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength)\n            });\n        }\n        if (isString(schema.pattern)) {\n            var regex = extendedRegExp(schema.pattern);\n            if (!regex.test(node.value)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.patternErrorMessage || schema.errorMessage || jsonParser_localize('patternWarning', 'String does not match the pattern of \"{0}\".', schema.pattern)\n                });\n            }\n        }\n        if (schema.format) {\n            switch (schema.format) {\n                case 'uri':\n                case 'uri-reference':\n                    {\n                        var errorMessage = void 0;\n                        if (!node.value) {\n                            errorMessage = jsonParser_localize('uriEmpty', 'URI expected.');\n                        }\n                        else {\n                            var match = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(node.value);\n                            if (!match) {\n                                errorMessage = jsonParser_localize('uriMissing', 'URI is expected.');\n                            }\n                            else if (!match[2] && schema.format === 'uri') {\n                                errorMessage = jsonParser_localize('uriSchemeMissing', 'URI with a scheme is expected.');\n                            }\n                        }\n                        if (errorMessage) {\n                            validationResult.problems.push({\n                                location: { offset: node.offset, length: node.length },\n                                message: schema.patternErrorMessage || schema.errorMessage || jsonParser_localize('uriFormatWarning', 'String is not a URI: {0}', errorMessage)\n                            });\n                        }\n                    }\n                    break;\n                case 'color-hex':\n                case 'date-time':\n                case 'date':\n                case 'time':\n                case 'email':\n                    var format = formats[schema.format];\n                    if (!node.value || !format.pattern.exec(node.value)) {\n                        validationResult.problems.push({\n                            location: { offset: node.offset, length: node.length },\n                            message: schema.patternErrorMessage || schema.errorMessage || format.errorMessage\n                        });\n                    }\n                default:\n            }\n        }\n    }\n    function _validateArrayNode(node, schema, validationResult, matchingSchemas) {\n        if (Array.isArray(schema.items)) {\n            var subSchemas = schema.items;\n            for (var index = 0; index < subSchemas.length; index++) {\n                var subSchemaRef = subSchemas[index];\n                var subSchema = asSchema(subSchemaRef);\n                var itemValidationResult = new ValidationResult();\n                var item = node.items[index];\n                if (item) {\n                    validate(item, subSchema, itemValidationResult, matchingSchemas);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                }\n                else if (node.items.length >= subSchemas.length) {\n                    validationResult.propertiesValueMatches++;\n                }\n            }\n            if (node.items.length > subSchemas.length) {\n                if (typeof schema.additionalItems === 'object') {\n                    for (var i = subSchemas.length; i < node.items.length; i++) {\n                        var itemValidationResult = new ValidationResult();\n                        validate(node.items[i], schema.additionalItems, itemValidationResult, matchingSchemas);\n                        validationResult.mergePropertyMatch(itemValidationResult);\n                    }\n                }\n                else if (schema.additionalItems === false) {\n                    validationResult.problems.push({\n                        location: { offset: node.offset, length: node.length },\n                        message: jsonParser_localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas.length)\n                    });\n                }\n            }\n        }\n        else {\n            var itemSchema = asSchema(schema.items);\n            if (itemSchema) {\n                for (var _i = 0, _a = node.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    var itemValidationResult = new ValidationResult();\n                    validate(item, itemSchema, itemValidationResult, matchingSchemas);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                }\n            }\n        }\n        var containsSchema = asSchema(schema.contains);\n        if (containsSchema) {\n            var doesContain = node.items.some(function (item) {\n                var itemValidationResult = new ValidationResult();\n                validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance);\n                return !itemValidationResult.hasProblems();\n            });\n            if (!doesContain) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || jsonParser_localize('requiredItemMissingWarning', 'Array does not contain required item.')\n                });\n            }\n        }\n        if (objects_isNumber(schema.minItems) && node.items.length < schema.minItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems)\n            });\n        }\n        if (objects_isNumber(schema.maxItems) && node.items.length > schema.maxItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.maxItems)\n            });\n        }\n        if (schema.uniqueItems === true) {\n            var values_1 = jsonParser_getNodeValue(node);\n            var duplicates = values_1.some(function (value, index) {\n                return index !== values_1.lastIndexOf(value);\n            });\n            if (duplicates) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('uniqueItemsWarning', 'Array has duplicate items.')\n                });\n            }\n        }\n    }\n    function _validateObjectNode(node, schema, validationResult, matchingSchemas) {\n        var seenKeys = Object.create(null);\n        var unprocessedProperties = [];\n        for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {\n            var propertyNode = _a[_i];\n            var key = propertyNode.keyNode.value;\n            seenKeys[key] = propertyNode.valueNode;\n            unprocessedProperties.push(key);\n        }\n        if (Array.isArray(schema.required)) {\n            for (var _b = 0, _c = schema.required; _b < _c.length; _b++) {\n                var propertyName = _c[_b];\n                if (!seenKeys[propertyName]) {\n                    var keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;\n                    var location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node.offset, length: 1 };\n                    validationResult.problems.push({\n                        location: location,\n                        message: jsonParser_localize('MissingRequiredPropWarning', 'Missing property \"{0}\".', propertyName)\n                    });\n                }\n            }\n        }\n        var propertyProcessed = function (prop) {\n            var index = unprocessedProperties.indexOf(prop);\n            while (index >= 0) {\n                unprocessedProperties.splice(index, 1);\n                index = unprocessedProperties.indexOf(prop);\n            }\n        };\n        if (schema.properties) {\n            for (var _d = 0, _e = Object.keys(schema.properties); _d < _e.length; _d++) {\n                var propertyName = _e[_d];\n                propertyProcessed(propertyName);\n                var propertySchema = schema.properties[propertyName];\n                var child = seenKeys[propertyName];\n                if (child) {\n                    if (isBoolean(propertySchema)) {\n                        if (!propertySchema) {\n                            var propertyNode = child.parent;\n                            validationResult.problems.push({\n                                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                            });\n                        }\n                        else {\n                            validationResult.propertiesMatches++;\n                            validationResult.propertiesValueMatches++;\n                        }\n                    }\n                    else {\n                        var propertyValidationResult = new ValidationResult();\n                        validate(child, propertySchema, propertyValidationResult, matchingSchemas);\n                        validationResult.mergePropertyMatch(propertyValidationResult);\n                    }\n                }\n            }\n        }\n        if (schema.patternProperties) {\n            for (var _f = 0, _g = Object.keys(schema.patternProperties); _f < _g.length; _f++) {\n                var propertyPattern = _g[_f];\n                var regex = extendedRegExp(propertyPattern);\n                for (var _h = 0, _j = unprocessedProperties.slice(0); _h < _j.length; _h++) {\n                    var propertyName = _j[_h];\n                    if (regex.test(propertyName)) {\n                        propertyProcessed(propertyName);\n                        var child = seenKeys[propertyName];\n                        if (child) {\n                            var propertySchema = schema.patternProperties[propertyPattern];\n                            if (isBoolean(propertySchema)) {\n                                if (!propertySchema) {\n                                    var propertyNode = child.parent;\n                                    validationResult.problems.push({\n                                        location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                        message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                                    });\n                                }\n                                else {\n                                    validationResult.propertiesMatches++;\n                                    validationResult.propertiesValueMatches++;\n                                }\n                            }\n                            else {\n                                var propertyValidationResult = new ValidationResult();\n                                validate(child, propertySchema, propertyValidationResult, matchingSchemas);\n                                validationResult.mergePropertyMatch(propertyValidationResult);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k < unprocessedProperties_1.length; _k++) {\n                var propertyName = unprocessedProperties_1[_k];\n                var child = seenKeys[propertyName];\n                if (child) {\n                    var propertyValidationResult = new ValidationResult();\n                    validate(child, schema.additionalProperties, propertyValidationResult, matchingSchemas);\n                    validationResult.mergePropertyMatch(propertyValidationResult);\n                }\n            }\n        }\n        else if (schema.additionalProperties === false) {\n            if (unprocessedProperties.length > 0) {\n                for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l < unprocessedProperties_2.length; _l++) {\n                    var propertyName = unprocessedProperties_2[_l];\n                    var child = seenKeys[propertyName];\n                    if (child) {\n                        var propertyNode = child.parent;\n                        validationResult.problems.push({\n                            location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                            message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                        });\n                    }\n                }\n            }\n        }\n        if (objects_isNumber(schema.maxProperties)) {\n            if (node.properties.length > schema.maxProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties)\n                });\n            }\n        }\n        if (objects_isNumber(schema.minProperties)) {\n            if (node.properties.length < schema.minProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties)\n                });\n            }\n        }\n        if (schema.dependencies) {\n            for (var _m = 0, _o = Object.keys(schema.dependencies); _m < _o.length; _m++) {\n                var key = _o[_m];\n                var prop = seenKeys[key];\n                if (prop) {\n                    var propertyDep = schema.dependencies[key];\n                    if (Array.isArray(propertyDep)) {\n                        for (var _p = 0, propertyDep_1 = propertyDep; _p < propertyDep_1.length; _p++) {\n                            var requiredProp = propertyDep_1[_p];\n                            if (!seenKeys[requiredProp]) {\n                                validationResult.problems.push({\n                                    location: { offset: node.offset, length: node.length },\n                                    message: jsonParser_localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key)\n                                });\n                            }\n                            else {\n                                validationResult.propertiesValueMatches++;\n                            }\n                        }\n                    }\n                    else {\n                        var propertySchema = asSchema(propertyDep);\n                        if (propertySchema) {\n                            var propertyValidationResult = new ValidationResult();\n                            validate(node, propertySchema, propertyValidationResult, matchingSchemas);\n                            validationResult.mergePropertyMatch(propertyValidationResult);\n                        }\n                    }\n                }\n            }\n        }\n        var propertyNames = asSchema(schema.propertyNames);\n        if (propertyNames) {\n            for (var _q = 0, _r = node.properties; _q < _r.length; _q++) {\n                var f = _r[_q];\n                var key = f.keyNode;\n                if (key) {\n                    validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance);\n                }\n            }\n        }\n    }\n}\nfunction jsonParser_parse(textDocument, config) {\n    var problems = [];\n    var lastProblemOffset = -1;\n    var text = textDocument.getText();\n    var scanner = Json.createScanner(text, false);\n    var commentRanges = config && config.collectComments ? [] : undefined;\n    function _scanNext() {\n        while (true) {\n            var token_1 = scanner.scan();\n            _checkScanError();\n            switch (token_1) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (Array.isArray(commentRanges)) {\n                        commentRanges.push(Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));\n                    }\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token_1;\n            }\n        }\n    }\n    function _accept(token) {\n        if (scanner.getToken() === token) {\n            _scanNext();\n            return true;\n        }\n        return false;\n    }\n    function _errorAtRange(message, code, startOffset, endOffset, severity) {\n        if (severity === void 0) { severity = DiagnosticSeverity.Error; }\n        if (problems.length === 0 || startOffset !== lastProblemOffset) {\n            var range = Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));\n            problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));\n            lastProblemOffset = startOffset;\n        }\n    }\n    function _error(message, code, node, skipUntilAfter, skipUntil) {\n        if (node === void 0) { node = undefined; }\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        var start = scanner.getTokenOffset();\n        var end = scanner.getTokenOffset() + scanner.getTokenLength();\n        if (start === end && start > 0) {\n            start--;\n            while (start > 0 && /\\s/.test(text.charAt(start))) {\n                start--;\n            }\n            end = start + 1;\n        }\n        _errorAtRange(message, code, start, end);\n        if (node) {\n            _finalize(node, false);\n        }\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token_2 = scanner.getToken();\n            while (token_2 !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token_2) !== -1) {\n                    _scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token_2) !== -1) {\n                    break;\n                }\n                token_2 = _scanNext();\n            }\n        }\n        return node;\n    }\n    function _checkScanError() {\n        switch (scanner.getTokenError()) {\n            case 4 /* InvalidUnicode */:\n                _error(jsonParser_localize('InvalidUnicode', 'Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);\n                return true;\n            case 5 /* InvalidEscapeCharacter */:\n                _error(jsonParser_localize('InvalidEscapeCharacter', 'Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);\n                return true;\n            case 3 /* UnexpectedEndOfNumber */:\n                _error(jsonParser_localize('UnexpectedEndOfNumber', 'Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);\n                return true;\n            case 1 /* UnexpectedEndOfComment */:\n                _error(jsonParser_localize('UnexpectedEndOfComment', 'Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);\n                return true;\n            case 2 /* UnexpectedEndOfString */:\n                _error(jsonParser_localize('UnexpectedEndOfString', 'Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);\n                return true;\n            case 6 /* InvalidCharacter */:\n                _error(jsonParser_localize('InvalidCharacter', 'Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);\n                return true;\n        }\n        return false;\n    }\n    function _finalize(node, scanNext) {\n        node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;\n        if (scanNext) {\n            _scanNext();\n        }\n        return node;\n    }\n    function _parseArray(parent) {\n        if (scanner.getToken() !== 3 /* OpenBracketToken */) {\n            return undefined;\n        }\n        var node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());\n        _scanNext(); // consume OpenBracketToken\n        var count = 0;\n        var needsComma = false;\n        while (scanner.getToken() !== 4 /* CloseBracketToken */ && scanner.getToken() !== 17 /* EOF */) {\n            if (scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    _error(jsonParser_localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected);\n                }\n                var commaOffset = scanner.getTokenOffset();\n                _scanNext(); // consume comma\n                if (scanner.getToken() === 4 /* CloseBracketToken */) {\n                    if (needsComma) {\n                        _errorAtRange(jsonParser_localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n                    }\n                    continue;\n                }\n            }\n            else if (needsComma) {\n                _error(jsonParser_localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);\n            }\n            var item = _parseValue(node);\n            if (!item) {\n                _error(jsonParser_localize('PropertyExpected', 'Value expected'), ErrorCode.ValueExpected, undefined, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            else {\n                node.items.push(item);\n            }\n            needsComma = true;\n        }\n        if (scanner.getToken() !== 4 /* CloseBracketToken */) {\n            return _error(jsonParser_localize('ExpectedCloseBracket', 'Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);\n        }\n        return _finalize(node, true);\n    }\n    var keyPlaceholder = new StringASTNodeImpl(undefined, 0, 0);\n    function _parseProperty(parent, keysSeen) {\n        var node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);\n        var key = _parseString(node);\n        if (!key) {\n            if (scanner.getToken() === 16 /* Unknown */) {\n                // give a more helpful error message\n                _error(jsonParser_localize('DoubleQuotesExpected', 'Property keys must be doublequoted'), ErrorCode.Undefined);\n                var keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());\n                keyNode.value = scanner.getTokenValue();\n                key = keyNode;\n                _scanNext(); // consume Unknown\n            }\n            else {\n                return undefined;\n            }\n        }\n        node.keyNode = key;\n        var seen = keysSeen[key.value];\n        if (seen) {\n            _errorAtRange(jsonParser_localize('DuplicateKeyWarning', \"Duplicate object key\"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);\n            if (typeof seen === 'object') {\n                _errorAtRange(jsonParser_localize('DuplicateKeyWarning', \"Duplicate object key\"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);\n            }\n            keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting\n        }\n        else {\n            keysSeen[key.value] = node;\n        }\n        if (scanner.getToken() === 6 /* ColonToken */) {\n            node.colonOffset = scanner.getTokenOffset();\n            _scanNext(); // consume ColonToken\n        }\n        else {\n            _error(jsonParser_localize('ColonExpected', 'Colon expected'), ErrorCode.ColonExpected);\n            if (scanner.getToken() === 10 /* StringLiteral */ && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {\n                node.length = key.length;\n                return node;\n            }\n        }\n        var value = _parseValue(node);\n        if (!value) {\n            return _error(jsonParser_localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected, node, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        node.valueNode = value;\n        node.length = value.offset + value.length - node.offset;\n        return node;\n    }\n    function _parseObject(parent) {\n        if (scanner.getToken() !== 1 /* OpenBraceToken */) {\n            return undefined;\n        }\n        var node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());\n        var keysSeen = Object.create(null);\n        _scanNext(); // consume OpenBraceToken\n        var needsComma = false;\n        while (scanner.getToken() !== 2 /* CloseBraceToken */ && scanner.getToken() !== 17 /* EOF */) {\n            if (scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    _error(jsonParser_localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected);\n                }\n                var commaOffset = scanner.getTokenOffset();\n                _scanNext(); // consume comma\n                if (scanner.getToken() === 2 /* CloseBraceToken */) {\n                    if (needsComma) {\n                        _errorAtRange(jsonParser_localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n                    }\n                    continue;\n                }\n            }\n            else if (needsComma) {\n                _error(jsonParser_localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);\n            }\n            var property = _parseProperty(node, keysSeen);\n            if (!property) {\n                _error(jsonParser_localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected, undefined, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            else {\n                node.properties.push(property);\n            }\n            needsComma = true;\n        }\n        if (scanner.getToken() !== 2 /* CloseBraceToken */) {\n            return _error(jsonParser_localize('ExpectedCloseBrace', 'Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);\n        }\n        return _finalize(node, true);\n    }\n    function _parseString(parent) {\n        if (scanner.getToken() !== 10 /* StringLiteral */) {\n            return undefined;\n        }\n        var node = new StringASTNodeImpl(parent, scanner.getTokenOffset());\n        node.value = scanner.getTokenValue();\n        return _finalize(node, true);\n    }\n    function _parseNumber(parent) {\n        if (scanner.getToken() !== 11 /* NumericLiteral */) {\n            return undefined;\n        }\n        var node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());\n        if (scanner.getTokenError() === 0 /* None */) {\n            var tokenValue = scanner.getTokenValue();\n            try {\n                var numberValue = JSON.parse(tokenValue);\n                if (!isNumber(numberValue)) {\n                    return _error(jsonParser_localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);\n                }\n                node.value = numberValue;\n            }\n            catch (e) {\n                return _error(jsonParser_localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);\n            }\n            node.isInteger = tokenValue.indexOf('.') === -1;\n        }\n        return _finalize(node, true);\n    }\n    function _parseLiteral(parent) {\n        var node;\n        switch (scanner.getToken()) {\n            case 7 /* NullKeyword */:\n                return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);\n            case 8 /* TrueKeyword */:\n                return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);\n            case 9 /* FalseKeyword */:\n                return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);\n            default:\n                return undefined;\n        }\n    }\n    function _parseValue(parent) {\n        return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);\n    }\n    var _root = undefined;\n    var token = _scanNext();\n    if (token !== 17 /* EOF */) {\n        _root = _parseValue(_root);\n        if (!_root) {\n            _error(jsonParser_localize('Invalid symbol', 'Expected a JSON object, array or literal.'), ErrorCode.Undefined);\n        }\n        else if (scanner.getToken() !== 17 /* EOF */) {\n            _error(jsonParser_localize('End of file expected', 'End of file expected.'), ErrorCode.Undefined);\n        }\n    }\n    return new JSONDocument(_root, problems, commentRanges);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/json.js\n/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nfunction stringifyObject(obj, indent, stringifyLiteral) {\n    if (obj !== null && typeof obj === 'object') {\n        var newIndent = indent + '\\t';\n        if (Array.isArray(obj)) {\n            if (obj.length === 0) {\n                return '[]';\n            }\n            var result = '[\\n';\n            for (var i = 0; i < obj.length; i++) {\n                result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);\n                if (i < obj.length - 1) {\n                    result += ',';\n                }\n                result += '\\n';\n            }\n            result += indent + ']';\n            return result;\n        }\n        else {\n            var keys = Object.keys(obj);\n            if (keys.length === 0) {\n                return '{}';\n            }\n            var result = '{\\n';\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);\n                if (i < keys.length - 1) {\n                    result += ',';\n                }\n                result += '\\n';\n            }\n            result += indent + '}';\n            return result;\n        }\n    }\n    return stringifyLiteral(obj);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonCompletion.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nvar jsonCompletion_localize = loadMessageBundle();\nvar valueCommitCharacters = [',', '}', ']'];\nvar propertyCommitCharacters = [':'];\nvar jsonCompletion_JSONCompletion = /** @class */ (function () {\n    function JSONCompletion(schemaService, contributions, promiseConstructor, clientCapabilities) {\n        if (contributions === void 0) { contributions = []; }\n        if (promiseConstructor === void 0) { promiseConstructor = Promise; }\n        if (clientCapabilities === void 0) { clientCapabilities = {}; }\n        this.schemaService = schemaService;\n        this.contributions = contributions;\n        this.promiseConstructor = promiseConstructor;\n        this.clientCapabilities = clientCapabilities;\n    }\n    JSONCompletion.prototype.doResolve = function (item) {\n        for (var i = this.contributions.length - 1; i >= 0; i--) {\n            var resolveCompletion = this.contributions[i].resolveCompletion;\n            if (resolveCompletion) {\n                var resolver = resolveCompletion(item);\n                if (resolver) {\n                    return resolver;\n                }\n            }\n        }\n        return this.promiseConstructor.resolve(item);\n    };\n    JSONCompletion.prototype.doComplete = function (document, position, doc) {\n        var _this = this;\n        var result = {\n            items: [],\n            isIncomplete: false\n        };\n        var text = document.getText();\n        var offset = document.offsetAt(position);\n        var node = doc.getNodeFromOffset(offset, true);\n        if (this.isInComment(document, node ? node.offset : 0, offset)) {\n            return Promise.resolve(result);\n        }\n        if (node && (offset === node.offset + node.length) && offset > 0) {\n            var ch = text[offset - 1];\n            if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {\n                // after ] or }\n                node = node.parent;\n            }\n        }\n        var currentWord = this.getCurrentWord(document, offset);\n        var overwriteRange;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            overwriteRange = main_Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n        }\n        else {\n            var overwriteStart = offset - currentWord.length;\n            if (overwriteStart > 0 && text[overwriteStart - 1] === '\"') {\n                overwriteStart--;\n            }\n            overwriteRange = main_Range.create(document.positionAt(overwriteStart), position);\n        }\n        var supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544\n        var proposed = {};\n        var collector = {\n            add: function (suggestion) {\n                var label = suggestion.label;\n                var existing = proposed[label];\n                if (!existing) {\n                    label = label.replace(/[\\n]/g, '↵');\n                    if (label.length > 60) {\n                        var shortendedLabel = label.substr(0, 57).trim() + '...';\n                        if (!proposed[shortendedLabel]) {\n                            label = shortendedLabel;\n                        }\n                    }\n                    if (overwriteRange && suggestion.insertText !== undefined) {\n                        suggestion.textEdit = main_TextEdit.replace(overwriteRange, suggestion.insertText);\n                    }\n                    if (supportsCommitCharacters) {\n                        suggestion.commitCharacters = suggestion.kind === CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;\n                    }\n                    suggestion.label = label;\n                    proposed[label] = suggestion;\n                    result.items.push(suggestion);\n                }\n                else {\n                    if (!existing.documentation) {\n                        existing.documentation = suggestion.documentation;\n                    }\n                    if (!existing.detail) {\n                        existing.detail = suggestion.detail;\n                    }\n                }\n            },\n            setAsIncomplete: function () {\n                result.isIncomplete = true;\n            },\n            error: function (message) {\n                console.error(message);\n            },\n            log: function (message) {\n                console.log(message);\n            },\n            getNumberOfProposals: function () {\n                return result.items.length;\n            }\n        };\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n            var collectionPromises = [];\n            var addValue = true;\n            var currentKey = '';\n            var currentProperty = undefined;\n            if (node) {\n                if (node.type === 'string') {\n                    var parent = node.parent;\n                    if (parent && parent.type === 'property' && parent.keyNode === node) {\n                        addValue = !parent.valueNode;\n                        currentProperty = parent;\n                        currentKey = text.substr(node.offset + 1, node.length - 2);\n                        if (parent) {\n                            node = parent.parent;\n                        }\n                    }\n                }\n            }\n            // proposals for properties\n            if (node && node.type === 'object') {\n                // don't suggest keys when the cursor is just before the opening curly brace\n                if (node.offset === offset) {\n                    return result;\n                }\n                // don't suggest properties that are already present\n                var properties = node.properties;\n                properties.forEach(function (p) {\n                    if (!currentProperty || currentProperty !== p) {\n                        proposed[p.keyNode.value] = CompletionItem.create('__');\n                    }\n                });\n                var separatorAfter_1 = '';\n                if (addValue) {\n                    separatorAfter_1 = _this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));\n                }\n                if (schema) {\n                    // property proposals with schema\n                    _this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter_1, collector);\n                }\n                else {\n                    // property proposals without schema\n                    _this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);\n                }\n                var location_1 = jsonParser_getNodePath(node);\n                _this.contributions.forEach(function (contribution) {\n                    var collectPromise = contribution.collectPropertyCompletions(document.uri, location_1, currentWord, addValue, separatorAfter_1 === '', collector);\n                    if (collectPromise) {\n                        collectionPromises.push(collectPromise);\n                    }\n                });\n                if ((!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '\"')) {\n                    collector.add({\n                        kind: CompletionItemKind.Property,\n                        label: _this.getLabelForValue(currentWord),\n                        insertText: _this.getInsertTextForProperty(currentWord, undefined, false, separatorAfter_1),\n                        insertTextFormat: InsertTextFormat.Snippet, documentation: '',\n                    });\n                    collector.setAsIncomplete();\n                }\n            }\n            // proposals for values\n            var types = {};\n            if (schema) {\n                // value proposals with schema\n                _this.getValueCompletions(schema, doc, node, offset, document, collector, types);\n            }\n            else {\n                // value proposals without schema\n                _this.getSchemaLessValueCompletions(doc, node, offset, document, collector);\n            }\n            if (_this.contributions.length > 0) {\n                _this.getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises);\n            }\n            return _this.promiseConstructor.all(collectionPromises).then(function () {\n                if (collector.getNumberOfProposals() === 0) {\n                    var offsetForSeparator = offset;\n                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n                        offsetForSeparator = node.offset + node.length;\n                    }\n                    var separatorAfter = _this.evaluateSeparatorAfter(document, offsetForSeparator);\n                    _this.addFillerValueCompletions(types, separatorAfter, collector);\n                }\n                return result;\n            });\n        });\n    };\n    JSONCompletion.prototype.getPropertyCompletions = function (schema, doc, node, addValue, separatorAfter, collector) {\n        var _this = this;\n        var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n        matchingSchemas.forEach(function (s) {\n            if (s.node === node && !s.inverted) {\n                var schemaProperties_1 = s.schema.properties;\n                if (schemaProperties_1) {\n                    Object.keys(schemaProperties_1).forEach(function (key) {\n                        var propertySchema = schemaProperties_1[key];\n                        if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {\n                            var proposal = {\n                                kind: CompletionItemKind.Property,\n                                label: key,\n                                insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),\n                                insertTextFormat: InsertTextFormat.Snippet,\n                                filterText: _this.getFilterTextForValue(key),\n                                documentation: _this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || '',\n                            };\n                            if (propertySchema.suggestSortText !== undefined) {\n                                proposal.sortText = propertySchema.suggestSortText;\n                            }\n                            if (proposal.insertText && endsWith(proposal.insertText, \"$1\" + separatorAfter)) {\n                                proposal.command = {\n                                    title: 'Suggest',\n                                    command: 'editor.action.triggerSuggest'\n                                };\n                            }\n                            collector.add(proposal);\n                        }\n                    });\n                }\n                var schemaPropertyNames_1 = s.schema.propertyNames;\n                if (typeof schemaPropertyNames_1 === 'object' && !schemaPropertyNames_1.deprecationMessage && !schemaPropertyNames_1.doNotSuggest) {\n                    var propertyNameCompletionItem = function (name, enumDescription) {\n                        if (enumDescription === void 0) { enumDescription = undefined; }\n                        var proposal = {\n                            kind: CompletionItemKind.Property,\n                            label: name,\n                            insertText: _this.getInsertTextForProperty(name, undefined, addValue, separatorAfter),\n                            insertTextFormat: InsertTextFormat.Snippet,\n                            filterText: _this.getFilterTextForValue(name),\n                            documentation: enumDescription || _this.fromMarkup(schemaPropertyNames_1.markdownDescription) || schemaPropertyNames_1.description || '',\n                        };\n                        if (schemaPropertyNames_1.suggestSortText !== undefined) {\n                            proposal.sortText = schemaPropertyNames_1.suggestSortText;\n                        }\n                        if (proposal.insertText && endsWith(proposal.insertText, \"$1\" + separatorAfter)) {\n                            proposal.command = {\n                                title: 'Suggest',\n                                command: 'editor.action.triggerSuggest'\n                            };\n                        }\n                        collector.add(proposal);\n                    };\n                    if (schemaPropertyNames_1.enum) {\n                        for (var i = 0; i < schemaPropertyNames_1.enum.length; i++) {\n                            var enumDescription = undefined;\n                            if (schemaPropertyNames_1.markdownEnumDescriptions && i < schemaPropertyNames_1.markdownEnumDescriptions.length) {\n                                enumDescription = _this.fromMarkup(schemaPropertyNames_1.markdownEnumDescriptions[i]);\n                            }\n                            else if (schemaPropertyNames_1.enumDescriptions && i < schemaPropertyNames_1.enumDescriptions.length) {\n                                enumDescription = schemaPropertyNames_1.enumDescriptions[i];\n                            }\n                            propertyNameCompletionItem(schemaPropertyNames_1.enum[i], enumDescription);\n                        }\n                    }\n                    if (schemaPropertyNames_1.const) {\n                        propertyNameCompletionItem(schemaPropertyNames_1.const);\n                    }\n                }\n            }\n        });\n    };\n    JSONCompletion.prototype.getSchemaLessPropertyCompletions = function (doc, node, currentKey, collector) {\n        var _this = this;\n        var collectCompletionsForSimilarObject = function (obj) {\n            obj.properties.forEach(function (p) {\n                var key = p.keyNode.value;\n                collector.add({\n                    kind: CompletionItemKind.Property,\n                    label: key,\n                    insertText: _this.getInsertTextForValue(key, ''),\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    filterText: _this.getFilterTextForValue(key),\n                    documentation: ''\n                });\n            });\n        };\n        if (node.parent) {\n            if (node.parent.type === 'property') {\n                // if the object is a property value, check the tree for other objects that hang under a property of the same name\n                var parentKey_1 = node.parent.keyNode.value;\n                doc.visit(function (n) {\n                    if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey_1 && n.valueNode && n.valueNode.type === 'object') {\n                        collectCompletionsForSimilarObject(n.valueNode);\n                    }\n                    return true;\n                });\n            }\n            else if (node.parent.type === 'array') {\n                // if the object is in an array, use all other array elements as similar objects\n                node.parent.items.forEach(function (n) {\n                    if (n.type === 'object' && n !== node) {\n                        collectCompletionsForSimilarObject(n);\n                    }\n                });\n            }\n        }\n        else if (node.type === 'object') {\n            collector.add({\n                kind: CompletionItemKind.Property,\n                label: '$schema',\n                insertText: this.getInsertTextForProperty('$schema', undefined, true, ''),\n                insertTextFormat: InsertTextFormat.Snippet, documentation: '',\n                filterText: this.getFilterTextForValue(\"$schema\")\n            });\n        }\n    };\n    JSONCompletion.prototype.getSchemaLessValueCompletions = function (doc, node, offset, document, collector) {\n        var _this = this;\n        var offsetForSeparator = offset;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n            node = node.parent;\n        }\n        if (!node) {\n            collector.add({\n                kind: this.getSuggestionKind('object'),\n                label: 'Empty object',\n                insertText: this.getInsertTextForValue({}, ''),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: ''\n            });\n            collector.add({\n                kind: this.getSuggestionKind('array'),\n                label: 'Empty array',\n                insertText: this.getInsertTextForValue([], ''),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: ''\n            });\n            return;\n        }\n        var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n        var collectSuggestionsForValues = function (value) {\n            if (value.parent && !jsonParser_contains(value.parent, offset, true)) {\n                collector.add({\n                    kind: _this.getSuggestionKind(value.type),\n                    label: _this.getLabelTextForMatchingNode(value, document),\n                    insertText: _this.getInsertTextForMatchingNode(value, document, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet, documentation: ''\n                });\n            }\n            if (value.type === 'boolean') {\n                _this.addBooleanValueCompletion(!value.value, separatorAfter, collector);\n            }\n        };\n        if (node.type === 'property') {\n            if (offset > (node.colonOffset || 0)) {\n                var valueNode = node.valueNode;\n                if (valueNode && (offset > (valueNode.offset + valueNode.length) || valueNode.type === 'object' || valueNode.type === 'array')) {\n                    return;\n                }\n                // suggest values at the same key\n                var parentKey_2 = node.keyNode.value;\n                doc.visit(function (n) {\n                    if (n.type === 'property' && n.keyNode.value === parentKey_2 && n.valueNode) {\n                        collectSuggestionsForValues(n.valueNode);\n                    }\n                    return true;\n                });\n                if (parentKey_2 === '$schema' && node.parent && !node.parent.parent) {\n                    this.addDollarSchemaCompletions(separatorAfter, collector);\n                }\n            }\n        }\n        if (node.type === 'array') {\n            if (node.parent && node.parent.type === 'property') {\n                // suggest items of an array at the same key\n                var parentKey_3 = node.parent.keyNode.value;\n                doc.visit(function (n) {\n                    if (n.type === 'property' && n.keyNode.value === parentKey_3 && n.valueNode && n.valueNode.type === 'array') {\n                        n.valueNode.items.forEach(collectSuggestionsForValues);\n                    }\n                    return true;\n                });\n            }\n            else {\n                // suggest items in the same array\n                node.items.forEach(collectSuggestionsForValues);\n            }\n        }\n    };\n    JSONCompletion.prototype.getValueCompletions = function (schema, doc, node, offset, document, collector, types) {\n        var offsetForSeparator = offset;\n        var parentKey = undefined;\n        var valueNode = undefined;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n            valueNode = node;\n            node = node.parent;\n        }\n        if (!node) {\n            this.addSchemaValueCompletions(schema.schema, '', collector, types);\n            return;\n        }\n        if ((node.type === 'property') && offset > (node.colonOffset || 0)) {\n            var valueNode_1 = node.valueNode;\n            if (valueNode_1 && offset > (valueNode_1.offset + valueNode_1.length)) {\n                return; // we are past the value node\n            }\n            parentKey = node.keyNode.value;\n            node = node.parent;\n        }\n        if (node && (parentKey !== undefined || node.type === 'array')) {\n            var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n            var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);\n            for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {\n                var s = matchingSchemas_1[_i];\n                if (s.node === node && !s.inverted && s.schema) {\n                    if (node.type === 'array' && s.schema.items) {\n                        if (Array.isArray(s.schema.items)) {\n                            var index = this.findItemAtOffset(node, document, offset);\n                            if (index < s.schema.items.length) {\n                                this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types);\n                            }\n                        }\n                        else {\n                            this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types);\n                        }\n                    }\n                    if (parentKey !== undefined) {\n                        var propertyMatched = false;\n                        if (s.schema.properties) {\n                            var propertySchema = s.schema.properties[parentKey];\n                            if (propertySchema) {\n                                propertyMatched = true;\n                                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                            }\n                        }\n                        if (s.schema.patternProperties && !propertyMatched) {\n                            for (var _a = 0, _b = Object.keys(s.schema.patternProperties); _a < _b.length; _a++) {\n                                var pattern = _b[_a];\n                                var regex = extendedRegExp(pattern);\n                                if (regex.test(parentKey)) {\n                                    propertyMatched = true;\n                                    var propertySchema = s.schema.patternProperties[pattern];\n                                    this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                                }\n                            }\n                        }\n                        if (s.schema.additionalProperties && !propertyMatched) {\n                            var propertySchema = s.schema.additionalProperties;\n                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                        }\n                    }\n                }\n            }\n            if (parentKey === '$schema' && !node.parent) {\n                this.addDollarSchemaCompletions(separatorAfter, collector);\n            }\n            if (types['boolean']) {\n                this.addBooleanValueCompletion(true, separatorAfter, collector);\n                this.addBooleanValueCompletion(false, separatorAfter, collector);\n            }\n            if (types['null']) {\n                this.addNullValueCompletion(separatorAfter, collector);\n            }\n        }\n    };\n    JSONCompletion.prototype.getContributedValueCompletions = function (doc, node, offset, document, collector, collectionPromises) {\n        if (!node) {\n            this.contributions.forEach(function (contribution) {\n                var collectPromise = contribution.collectDefaultCompletions(document.uri, collector);\n                if (collectPromise) {\n                    collectionPromises.push(collectPromise);\n                }\n            });\n        }\n        else {\n            if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {\n                node = node.parent;\n            }\n            if (node && (node.type === 'property') && offset > (node.colonOffset || 0)) {\n                var parentKey_4 = node.keyNode.value;\n                var valueNode = node.valueNode;\n                if ((!valueNode || offset <= (valueNode.offset + valueNode.length)) && node.parent) {\n                    var location_2 = jsonParser_getNodePath(node.parent);\n                    this.contributions.forEach(function (contribution) {\n                        var collectPromise = contribution.collectValueCompletions(document.uri, location_2, parentKey_4, collector);\n                        if (collectPromise) {\n                            collectionPromises.push(collectPromise);\n                        }\n                    });\n                }\n            }\n        }\n    };\n    JSONCompletion.prototype.addSchemaValueCompletions = function (schema, separatorAfter, collector, types) {\n        var _this = this;\n        if (typeof schema === 'object') {\n            this.addEnumValueCompletions(schema, separatorAfter, collector);\n            this.addDefaultValueCompletions(schema, separatorAfter, collector);\n            this.collectTypes(schema, types);\n            if (Array.isArray(schema.allOf)) {\n                schema.allOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });\n            }\n            if (Array.isArray(schema.anyOf)) {\n                schema.anyOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });\n            }\n            if (Array.isArray(schema.oneOf)) {\n                schema.oneOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });\n            }\n        }\n    };\n    JSONCompletion.prototype.addDefaultValueCompletions = function (schema, separatorAfter, collector, arrayDepth) {\n        var _this = this;\n        if (arrayDepth === void 0) { arrayDepth = 0; }\n        var hasProposals = false;\n        if (isDefined(schema.default)) {\n            var type = schema.type;\n            var value = schema.default;\n            for (var i = arrayDepth; i > 0; i--) {\n                value = [value];\n                type = 'array';\n            }\n            collector.add({\n                kind: this.getSuggestionKind(type),\n                label: this.getLabelForValue(value),\n                insertText: this.getInsertTextForValue(value, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: jsonCompletion_localize('json.suggest.default', 'Default value')\n            });\n            hasProposals = true;\n        }\n        if (Array.isArray(schema.examples)) {\n            schema.examples.forEach(function (example) {\n                var type = schema.type;\n                var value = example;\n                for (var i = arrayDepth; i > 0; i--) {\n                    value = [value];\n                    type = 'array';\n                }\n                collector.add({\n                    kind: _this.getSuggestionKind(type),\n                    label: _this.getLabelForValue(value),\n                    insertText: _this.getInsertTextForValue(value, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet\n                });\n                hasProposals = true;\n            });\n        }\n        if (Array.isArray(schema.defaultSnippets)) {\n            schema.defaultSnippets.forEach(function (s) {\n                var type = schema.type;\n                var value = s.body;\n                var label = s.label;\n                var insertText;\n                var filterText;\n                if (isDefined(value)) {\n                    var type_1 = schema.type;\n                    for (var i = arrayDepth; i > 0; i--) {\n                        value = [value];\n                        type_1 = 'array';\n                    }\n                    insertText = _this.getInsertTextForSnippetValue(value, separatorAfter);\n                    filterText = _this.getFilterTextForSnippetValue(value);\n                    label = label || _this.getLabelForSnippetValue(value);\n                }\n                else if (typeof s.bodyText === 'string') {\n                    var prefix = '', suffix = '', indent = '';\n                    for (var i = arrayDepth; i > 0; i--) {\n                        prefix = prefix + indent + '[\\n';\n                        suffix = suffix + '\\n' + indent + ']';\n                        indent += '\\t';\n                        type = 'array';\n                    }\n                    insertText = prefix + indent + s.bodyText.split('\\n').join('\\n' + indent) + suffix + separatorAfter;\n                    label = label || insertText,\n                        filterText = insertText.replace(/[\\n]/g, ''); // remove new lines\n                }\n                else {\n                    return;\n                }\n                collector.add({\n                    kind: _this.getSuggestionKind(type),\n                    label: label,\n                    documentation: _this.fromMarkup(s.markdownDescription) || s.description,\n                    insertText: insertText,\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    filterText: filterText\n                });\n                hasProposals = true;\n            });\n        }\n        if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items) && arrayDepth < 5 /* beware of recursion */) {\n            this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);\n        }\n    };\n    JSONCompletion.prototype.addEnumValueCompletions = function (schema, separatorAfter, collector) {\n        if (isDefined(schema.const)) {\n            collector.add({\n                kind: this.getSuggestionKind(schema.type),\n                label: this.getLabelForValue(schema.const),\n                insertText: this.getInsertTextForValue(schema.const, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: this.fromMarkup(schema.markdownDescription) || schema.description\n            });\n        }\n        if (Array.isArray(schema.enum)) {\n            for (var i = 0, length = schema.enum.length; i < length; i++) {\n                var enm = schema.enum[i];\n                var documentation = this.fromMarkup(schema.markdownDescription) || schema.description;\n                if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {\n                    documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);\n                }\n                else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {\n                    documentation = schema.enumDescriptions[i];\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(schema.type),\n                    label: this.getLabelForValue(enm),\n                    insertText: this.getInsertTextForValue(enm, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    documentation: documentation\n                });\n            }\n        }\n    };\n    JSONCompletion.prototype.collectTypes = function (schema, types) {\n        if (Array.isArray(schema.enum) || isDefined(schema.const)) {\n            return;\n        }\n        var type = schema.type;\n        if (Array.isArray(type)) {\n            type.forEach(function (t) { return types[t] = true; });\n        }\n        else if (type) {\n            types[type] = true;\n        }\n    };\n    JSONCompletion.prototype.addFillerValueCompletions = function (types, separatorAfter, collector) {\n        if (types['object']) {\n            collector.add({\n                kind: this.getSuggestionKind('object'),\n                label: '{}',\n                insertText: this.getInsertTextForGuessedValue({}, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: jsonCompletion_localize('defaults.object', 'New object'),\n                documentation: ''\n            });\n        }\n        if (types['array']) {\n            collector.add({\n                kind: this.getSuggestionKind('array'),\n                label: '[]',\n                insertText: this.getInsertTextForGuessedValue([], separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: jsonCompletion_localize('defaults.array', 'New array'),\n                documentation: ''\n            });\n        }\n    };\n    JSONCompletion.prototype.addBooleanValueCompletion = function (value, separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('boolean'),\n            label: value ? 'true' : 'false',\n            insertText: this.getInsertTextForValue(value, separatorAfter),\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n        });\n    };\n    JSONCompletion.prototype.addNullValueCompletion = function (separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('null'),\n            label: 'null',\n            insertText: 'null' + separatorAfter,\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n        });\n    };\n    JSONCompletion.prototype.addDollarSchemaCompletions = function (separatorAfter, collector) {\n        var _this = this;\n        var schemaIds = this.schemaService.getRegisteredSchemaIds(function (schema) { return schema === 'http' || schema === 'https'; });\n        schemaIds.forEach(function (schemaId) { return collector.add({\n            kind: CompletionItemKind.Module,\n            label: _this.getLabelForValue(schemaId),\n            filterText: _this.getFilterTextForValue(schemaId),\n            insertText: _this.getInsertTextForValue(schemaId, separatorAfter),\n            insertTextFormat: InsertTextFormat.Snippet, documentation: ''\n        }); });\n    };\n    JSONCompletion.prototype.getLabelForValue = function (value) {\n        return JSON.stringify(value);\n    };\n    JSONCompletion.prototype.getFilterTextForValue = function (value) {\n        return JSON.stringify(value);\n    };\n    JSONCompletion.prototype.getFilterTextForSnippetValue = function (value) {\n        return JSON.stringify(value).replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    };\n    JSONCompletion.prototype.getLabelForSnippetValue = function (value) {\n        var label = JSON.stringify(value);\n        return label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    };\n    JSONCompletion.prototype.getInsertTextForPlainText = function (text) {\n        return text.replace(/[\\\\\\$\\}]/g, '\\\\$&'); // escape $, \\ and } \n    };\n    JSONCompletion.prototype.getInsertTextForValue = function (value, separatorAfter) {\n        var text = JSON.stringify(value, null, '\\t');\n        if (text === '{}') {\n            return '{$1}' + separatorAfter;\n        }\n        else if (text === '[]') {\n            return '[$1]' + separatorAfter;\n        }\n        return this.getInsertTextForPlainText(text + separatorAfter);\n    };\n    JSONCompletion.prototype.getInsertTextForSnippetValue = function (value, separatorAfter) {\n        var replacer = function (value) {\n            if (typeof value === 'string') {\n                if (value[0] === '^') {\n                    return value.substr(1);\n                }\n            }\n            return JSON.stringify(value);\n        };\n        return stringifyObject(value, '', replacer) + separatorAfter;\n    };\n    JSONCompletion.prototype.getInsertTextForGuessedValue = function (value, separatorAfter) {\n        switch (typeof value) {\n            case 'object':\n                if (value === null) {\n                    return '${1:null}' + separatorAfter;\n                }\n                return this.getInsertTextForValue(value, separatorAfter);\n            case 'string':\n                var snippetValue = JSON.stringify(value);\n                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes\n                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \\ and }\n                return '\"${1:' + snippetValue + '}\"' + separatorAfter;\n            case 'number':\n            case 'boolean':\n                return '${1:' + JSON.stringify(value) + '}' + separatorAfter;\n        }\n        return this.getInsertTextForValue(value, separatorAfter);\n    };\n    JSONCompletion.prototype.getSuggestionKind = function (type) {\n        if (Array.isArray(type)) {\n            var array = type;\n            type = array.length > 0 ? array[0] : undefined;\n        }\n        if (!type) {\n            return CompletionItemKind.Value;\n        }\n        switch (type) {\n            case 'string': return CompletionItemKind.Value;\n            case 'object': return CompletionItemKind.Module;\n            case 'property': return CompletionItemKind.Property;\n            default: return CompletionItemKind.Value;\n        }\n    };\n    JSONCompletion.prototype.getLabelTextForMatchingNode = function (node, document) {\n        switch (node.type) {\n            case 'array':\n                return '[]';\n            case 'object':\n                return '{}';\n            default:\n                var content = document.getText().substr(node.offset, node.length);\n                return content;\n        }\n    };\n    JSONCompletion.prototype.getInsertTextForMatchingNode = function (node, document, separatorAfter) {\n        switch (node.type) {\n            case 'array':\n                return this.getInsertTextForValue([], separatorAfter);\n            case 'object':\n                return this.getInsertTextForValue({}, separatorAfter);\n            default:\n                var content = document.getText().substr(node.offset, node.length) + separatorAfter;\n                return this.getInsertTextForPlainText(content);\n        }\n    };\n    JSONCompletion.prototype.getInsertTextForProperty = function (key, propertySchema, addValue, separatorAfter) {\n        var propertyText = this.getInsertTextForValue(key, '');\n        if (!addValue) {\n            return propertyText;\n        }\n        var resultText = propertyText + ': ';\n        var value;\n        var nValueProposals = 0;\n        if (propertySchema) {\n            if (Array.isArray(propertySchema.defaultSnippets)) {\n                if (propertySchema.defaultSnippets.length === 1) {\n                    var body = propertySchema.defaultSnippets[0].body;\n                    if (isDefined(body)) {\n                        value = this.getInsertTextForSnippetValue(body, '');\n                    }\n                }\n                nValueProposals += propertySchema.defaultSnippets.length;\n            }\n            if (propertySchema.enum) {\n                if (!value && propertySchema.enum.length === 1) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');\n                }\n                nValueProposals += propertySchema.enum.length;\n            }\n            if (isDefined(propertySchema.default)) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.default, '');\n                }\n                nValueProposals++;\n            }\n            if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');\n                }\n                nValueProposals += propertySchema.examples.length;\n            }\n            if (nValueProposals === 0) {\n                var type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n                if (!type) {\n                    if (propertySchema.properties) {\n                        type = 'object';\n                    }\n                    else if (propertySchema.items) {\n                        type = 'array';\n                    }\n                }\n                switch (type) {\n                    case 'boolean':\n                        value = '$1';\n                        break;\n                    case 'string':\n                        value = '\"$1\"';\n                        break;\n                    case 'object':\n                        value = '{$1}';\n                        break;\n                    case 'array':\n                        value = '[$1]';\n                        break;\n                    case 'number':\n                    case 'integer':\n                        value = '${1:0}';\n                        break;\n                    case 'null':\n                        value = '${1:null}';\n                        break;\n                    default:\n                        return propertyText;\n                }\n            }\n        }\n        if (!value || nValueProposals > 1) {\n            value = '$1';\n        }\n        return resultText + value + separatorAfter;\n    };\n    JSONCompletion.prototype.getCurrentWord = function (document, offset) {\n        var i = offset - 1;\n        var text = document.getText();\n        while (i >= 0 && ' \\t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\n            i--;\n        }\n        return text.substring(i + 1, offset);\n    };\n    JSONCompletion.prototype.evaluateSeparatorAfter = function (document, offset) {\n        var scanner = main_createScanner(document.getText(), true);\n        scanner.setPosition(offset);\n        var token = scanner.scan();\n        switch (token) {\n            case 5 /* CommaToken */:\n            case 2 /* CloseBraceToken */:\n            case 4 /* CloseBracketToken */:\n            case 17 /* EOF */:\n                return '';\n            default:\n                return ',';\n        }\n    };\n    JSONCompletion.prototype.findItemAtOffset = function (node, document, offset) {\n        var scanner = main_createScanner(document.getText(), true);\n        var children = node.items;\n        for (var i = children.length - 1; i >= 0; i--) {\n            var child = children[i];\n            if (offset > child.offset + child.length) {\n                scanner.setPosition(child.offset + child.length);\n                var token = scanner.scan();\n                if (token === 5 /* CommaToken */ && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {\n                    return i + 1;\n                }\n                return i;\n            }\n            else if (offset >= child.offset) {\n                return i;\n            }\n        }\n        return 0;\n    };\n    JSONCompletion.prototype.isInComment = function (document, start, offset) {\n        var scanner = main_createScanner(document.getText(), false);\n        scanner.setPosition(start);\n        var token = scanner.scan();\n        while (token !== 17 /* EOF */ && (scanner.getTokenOffset() + scanner.getTokenLength() < offset)) {\n            token = scanner.scan();\n        }\n        return (token === 12 /* LineCommentTrivia */ || token === 13 /* BlockCommentTrivia */) && scanner.getTokenOffset() <= offset;\n    };\n    JSONCompletion.prototype.fromMarkup = function (markupString) {\n        if (markupString && this.doesSupportMarkdown()) {\n            return {\n                kind: MarkupKind.Markdown,\n                value: markupString\n            };\n        }\n        return undefined;\n    };\n    JSONCompletion.prototype.doesSupportMarkdown = function () {\n        if (!isDefined(this.supportsMarkdown)) {\n            var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;\n            this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    };\n    JSONCompletion.prototype.doesSupportsCommitCharacters = function () {\n        if (!isDefined(this.supportsCommitCharacters)) {\n            var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;\n            this.supportsCommitCharacters = completion && completion.completionItem && !!completion.completionItem.commitCharactersSupport;\n        }\n        return this.supportsCommitCharacters;\n    };\n    return JSONCompletion;\n}());\n\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonHover.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar jsonHover_JSONHover = /** @class */ (function () {\n    function JSONHover(schemaService, contributions, promiseConstructor) {\n        if (contributions === void 0) { contributions = []; }\n        this.schemaService = schemaService;\n        this.contributions = contributions;\n        this.promise = promiseConstructor || Promise;\n    }\n    JSONHover.prototype.doHover = function (document, position, doc) {\n        var offset = document.offsetAt(position);\n        var node = doc.getNodeFromOffset(offset);\n        if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {\n            return this.promise.resolve(null);\n        }\n        var hoverRangeNode = node;\n        // use the property description when hovering over an object key\n        if (node.type === 'string') {\n            var parent = node.parent;\n            if (parent && parent.type === 'property' && parent.keyNode === node) {\n                node = parent.valueNode;\n                if (!node) {\n                    return this.promise.resolve(null);\n                }\n            }\n        }\n        var hoverRange = main_Range.create(document.positionAt(hoverRangeNode.offset), document.positionAt(hoverRangeNode.offset + hoverRangeNode.length));\n        var createHover = function (contents) {\n            var result = {\n                contents: contents,\n                range: hoverRange\n            };\n            return result;\n        };\n        var location = jsonParser_getNodePath(node);\n        for (var i = this.contributions.length - 1; i >= 0; i--) {\n            var contribution = this.contributions[i];\n            var promise = contribution.getInfoContribution(document.uri, location);\n            if (promise) {\n                return promise.then(function (htmlContent) { return createHover(htmlContent); });\n            }\n        }\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n            if (schema && node) {\n                var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n                var title_1 = undefined;\n                var markdownDescription_1 = undefined;\n                var markdownEnumValueDescription_1 = undefined, enumValue_1 = undefined;\n                matchingSchemas.every(function (s) {\n                    if (s.node === node && !s.inverted && s.schema) {\n                        title_1 = title_1 || s.schema.title;\n                        markdownDescription_1 = markdownDescription_1 || s.schema.markdownDescription || toMarkdown(s.schema.description);\n                        if (s.schema.enum) {\n                            var idx = s.schema.enum.indexOf(jsonParser_getNodeValue(node));\n                            if (s.schema.markdownEnumDescriptions) {\n                                markdownEnumValueDescription_1 = s.schema.markdownEnumDescriptions[idx];\n                            }\n                            else if (s.schema.enumDescriptions) {\n                                markdownEnumValueDescription_1 = toMarkdown(s.schema.enumDescriptions[idx]);\n                            }\n                            if (markdownEnumValueDescription_1) {\n                                enumValue_1 = s.schema.enum[idx];\n                                if (typeof enumValue_1 !== 'string') {\n                                    enumValue_1 = JSON.stringify(enumValue_1);\n                                }\n                            }\n                        }\n                    }\n                    return true;\n                });\n                var result = '';\n                if (title_1) {\n                    result = toMarkdown(title_1);\n                }\n                if (markdownDescription_1) {\n                    if (result.length > 0) {\n                        result += \"\\n\\n\";\n                    }\n                    result += markdownDescription_1;\n                }\n                if (markdownEnumValueDescription_1) {\n                    if (result.length > 0) {\n                        result += \"\\n\\n\";\n                    }\n                    result += \"`\" + toMarkdownCodeBlock(enumValue_1) + \"`: \" + markdownEnumValueDescription_1;\n                }\n                return createHover([result]);\n            }\n            return null;\n        });\n    };\n    return JSONHover;\n}());\n\nfunction toMarkdown(plain) {\n    if (plain) {\n        var res = plain.replace(/([^\\n\\r])(\\r?\\n)([^\\n\\r])/gm, '$1\\n\\n$3'); // single new lines to \\n\\n (Markdown paragraph)\n        return res.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    return undefined;\n}\nfunction toMarkdownCodeBlock(content) {\n    // see https://daringfireball.net/projects/markdown/syntax#precode\n    if (content.indexOf('`') !== -1) {\n        return '`` ' + content + ' ``';\n    }\n    return content;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-uri/index.js\nvar LIB;LIB=(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",o=0,i=-1,a=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(i===h-1||1===a);else if(i!==h-1&&2===a){if(n.length<2||2!==o||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var s=n.lastIndexOf(\"/\");if(s!==n.length-1){-1===s?(n=\"\",o=0):o=(n=n.slice(0,s)).length-1-n.lastIndexOf(\"/\"),i=h,a=0;continue}}else if(2===n.length||1===n.length){n=\"\",o=0,i=h,a=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",o=2)}else n.length>0?n+=\"/\"+t.slice(i+1,h):n=t.slice(i+1,h),o=h-i-1;i=h,a=0}else 46===r&&-1!==a?++a:a=-1}return n}var n={resolve:function(){for(var t,n=\"\",o=!1,i=arguments.length-1;i>=-1&&!o;i--){var a;i>=0?a=arguments[i]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(n=a+\"/\"+n,o=47===a.charCodeAt(0))}return n=r(n,!o),o?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),o=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&o&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var o=arguments[r];e(o),o.length>0&&(void 0===t?t=o:t+=\"/\"+o)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var o=1;o<t.length&&47===t.charCodeAt(o);++o);for(var i=t.length,a=i-o,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var s=r.length-h,f=a<s?a:s,u=-1,c=0;c<=f;++c){if(c===f){if(s>f){if(47===r.charCodeAt(h+c))return r.slice(h+c+1);if(0===c)return r.slice(h+c)}else a>f&&(47===t.charCodeAt(o+c)?u=c:0===c&&(u=0));break}var l=t.charCodeAt(o+c);if(l!==r.charCodeAt(h+c))break;47===l&&(u=c)}var p=\"\";for(c=o+u+1;c<=i;++c)c!==i&&47!==t.charCodeAt(c)||(0===p.length?p+=\"..\":p+=\"/..\");return p.length>0?p+r.slice(h+u):(h+=u,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,o=-1,i=!0,a=t.length-1;a>=1;--a)if(47===(r=t.charCodeAt(a))){if(!i){o=a;break}}else i=!1;return-1===o?n?\"/\":\".\":n&&1===o?\"//\":t.slice(0,o)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,o=0,i=-1,a=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var h=r.length-1,s=-1;for(n=t.length-1;n>=0;--n){var f=t.charCodeAt(n);if(47===f){if(!a){o=n+1;break}}else-1===s&&(a=!1,s=n+1),h>=0&&(f===r.charCodeAt(h)?-1==--h&&(i=n):(h=-1,i=s))}return o===i?i=s:-1===i&&(i=t.length),t.slice(o,i)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!a){o=n+1;break}}else-1===i&&(a=!1,i=n+1);return-1===i?\"\":t.slice(o,i)},extname:function(t){e(t);for(var r=-1,n=0,o=-1,i=!0,a=0,h=t.length-1;h>=0;--h){var s=t.charCodeAt(h);if(47!==s)-1===o&&(i=!1,o=h+1),46===s?-1===r?r=h:1!==a&&(a=1):-1!==r&&(a=-1);else if(!i){n=h+1;break}}return-1===r||-1===o||0===a||1===a&&r===o-1&&r===n+1?\"\":t.slice(r,o)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,o=t.charCodeAt(0),i=47===o;i?(r.root=\"/\",n=1):n=0;for(var a=-1,h=0,s=-1,f=!0,u=t.length-1,c=0;u>=n;--u)if(47!==(o=t.charCodeAt(u)))-1===s&&(f=!1,s=u+1),46===o?-1===a?a=u:1!==c&&(c=1):-1!==a&&(c=-1);else if(!f){h=u+1;break}return-1===a||-1===s||0===c||1===c&&a===s-1&&a===h+1?-1!==s&&(r.base=r.name=0===h&&i?t.slice(1,s):t.slice(h,s)):(0===h&&i?(r.name=t.slice(1,a),r.base=t.slice(1,s)):(r.name=t.slice(h,a),r.base=t.slice(h,s)),r.ext=t.slice(a,s)),h>0?r.dir=t.slice(0,h-1):i&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n},447:(t,e,r)=>{var n;if(r.r(e),r.d(e,{URI:()=>g,Utils:()=>O}),\"object\"==typeof process)n=\"win32\"===process.platform;else if(\"object\"==typeof navigator){var o=navigator.userAgent;n=o.indexOf(\"Windows\")>=0}var i,a,h=(i=function(t,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(t,e)},function(t,e){function r(){this.constructor=t}i(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}),s=/^\\w[\\w\\d+.-]*$/,f=/^\\//,u=/^\\/\\//,c=\"\",l=\"/\",p=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/,g=function(){function t(t,e,r,n,o,i){void 0===i&&(i=!1),\"object\"==typeof t?(this.scheme=t.scheme||c,this.authority=t.authority||c,this.path=t.path||c,this.query=t.query||c,this.fragment=t.fragment||c):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,i),this.authority=e||c,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==l&&(e=l+e):e=l}return e}(this.scheme,r||c),this.query=n||c,this.fragment=o||c,function(t,e){if(!t.scheme&&e)throw new Error('[UriError]: Scheme is missing: {scheme: \"\", authority: \"'+t.authority+'\", path: \"'+t.path+'\", query: \"'+t.query+'\", fragment: \"'+t.fragment+'\"}');if(t.scheme&&!s.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!f.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(u.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}(this,i))}return t.isUri=function(e){return e instanceof t||!!e&&\"string\"==typeof e.authority&&\"string\"==typeof e.fragment&&\"string\"==typeof e.path&&\"string\"==typeof e.query&&\"string\"==typeof e.scheme&&\"function\"==typeof e.fsPath&&\"function\"==typeof e.with&&\"function\"==typeof e.toString},Object.defineProperty(t.prototype,\"fsPath\",{get:function(){return C(this,!1)},enumerable:!1,configurable:!0}),t.prototype.with=function(t){if(!t)return this;var e=t.scheme,r=t.authority,n=t.path,o=t.query,i=t.fragment;return void 0===e?e=this.scheme:null===e&&(e=c),void 0===r?r=this.authority:null===r&&(r=c),void 0===n?n=this.path:null===n&&(n=c),void 0===o?o=this.query:null===o&&(o=c),void 0===i?i=this.fragment:null===i&&(i=c),e===this.scheme&&r===this.authority&&n===this.path&&o===this.query&&i===this.fragment?this:new v(e,r,n,o,i)},t.parse=function(t,e){void 0===e&&(e=!1);var r=p.exec(t);return r?new v(r[2]||c,x(r[4]||c),x(r[5]||c),x(r[7]||c),x(r[9]||c),e):new v(c,c,c,c,c)},t.file=function(t){var e=c;if(n&&(t=t.replace(/\\\\/g,l)),t[0]===l&&t[1]===l){var r=t.indexOf(l,2);-1===r?(e=t.substring(2),t=l):(e=t.substring(2,r),t=t.substring(r)||l)}return new v(\"file\",e,t,c,c)},t.from=function(t){return new v(t.scheme,t.authority,t.path,t.query,t.fragment)},t.prototype.toString=function(t){return void 0===t&&(t=!1),A(this,t)},t.prototype.toJSON=function(){return this},t.revive=function(e){if(e){if(e instanceof t)return e;var r=new v(e);return r._formatted=e.external,r._fsPath=e._sep===d?e.fsPath:null,r}return e},t}(),d=n?1:void 0,v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._formatted=null,e._fsPath=null,e}return h(e,t),Object.defineProperty(e.prototype,\"fsPath\",{get:function(){return this._fsPath||(this._fsPath=C(this,!1)),this._fsPath},enumerable:!1,configurable:!0}),e.prototype.toString=function(t){return void 0===t&&(t=!1),t?A(this,!0):(this._formatted||(this._formatted=A(this,!1)),this._formatted)},e.prototype.toJSON=function(){var t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=d),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t},e}(g),m=((a={})[58]=\"%3A\",a[47]=\"%2F\",a[63]=\"%3F\",a[35]=\"%23\",a[91]=\"%5B\",a[93]=\"%5D\",a[64]=\"%40\",a[33]=\"%21\",a[36]=\"%24\",a[38]=\"%26\",a[39]=\"%27\",a[40]=\"%28\",a[41]=\"%29\",a[42]=\"%2A\",a[43]=\"%2B\",a[44]=\"%2C\",a[59]=\"%3B\",a[61]=\"%3D\",a[32]=\"%20\",a);function y(t,e){for(var r=void 0,n=-1,o=0;o<t.length;o++){var i=t.charCodeAt(o);if(i>=97&&i<=122||i>=65&&i<=90||i>=48&&i<=57||45===i||46===i||95===i||126===i||e&&47===i)-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),void 0!==r&&(r+=t.charAt(o));else{void 0===r&&(r=t.substr(0,o));var a=m[i];void 0!==a?(-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),r+=a):-1===n&&(n=o)}}return-1!==n&&(r+=encodeURIComponent(t.substring(n))),void 0!==r?r:t}function b(t){for(var e=void 0,r=0;r<t.length;r++){var n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=m[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function C(t,e){var r;return r=t.authority&&t.path.length>1&&\"file\"===t.scheme?\"//\"+t.authority+t.path:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n&&(r=r.replace(/\\//g,\"\\\\\")),r}function A(t,e){var r=e?b:y,n=\"\",o=t.scheme,i=t.authority,a=t.path,h=t.query,s=t.fragment;if(o&&(n+=o,n+=\":\"),(i||\"file\"===o)&&(n+=l,n+=l),i){var f=i.indexOf(\"@\");if(-1!==f){var u=i.substr(0,f);i=i.substr(f+1),-1===(f=u.indexOf(\":\"))?n+=r(u,!1):(n+=r(u.substr(0,f),!1),n+=\":\",n+=r(u.substr(f+1),!1)),n+=\"@\"}-1===(f=(i=i.toLowerCase()).indexOf(\":\"))?n+=r(i,!1):(n+=r(i.substr(0,f),!1),n+=i.substr(f))}if(a){if(a.length>=3&&47===a.charCodeAt(0)&&58===a.charCodeAt(2))(c=a.charCodeAt(1))>=65&&c<=90&&(a=\"/\"+String.fromCharCode(c+32)+\":\"+a.substr(3));else if(a.length>=2&&58===a.charCodeAt(1)){var c;(c=a.charCodeAt(0))>=65&&c<=90&&(a=String.fromCharCode(c+32)+\":\"+a.substr(2))}n+=r(a,!0)}return h&&(n+=\"?\",n+=r(h,!1)),s&&(n+=\"#\",n+=e?s:y(s,!1)),n}function w(t){try{return decodeURIComponent(t)}catch(e){return t.length>3?t.substr(0,3)+w(t.substr(3)):t}}var _=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function x(t){return t.match(_)?t.replace(_,(function(t){return w(t)})):t}var O,P=r(470),j=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),o=0;for(e=0;e<r;e++)for(var i=arguments[e],a=0,h=i.length;a<h;a++,o++)n[o]=i[a];return n},U=P.posix||P;!function(t){t.joinPath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return t.with({path:U.join.apply(U,j([t.path],e))})},t.resolvePath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var n=t.path||\"/\";return t.with({path:U.resolve.apply(U,j([n],e))})},t.dirname=function(t){var e=U.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)?t:t.with({path:e})},t.basename=function(t){return U.basename(t.path)},t.extname=function(t){return U.extname(t.path)}}(O||(O={}))}},e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}return r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},r(447)})();const{URI,Utils}=LIB;\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/glob.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Copyright (c) 2013, Nick Fitzgerald\n *  Licensed under the MIT License. See LICENCE.md in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction createRegex(glob, opts) {\n    if (typeof glob !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    var str = String(glob);\n    // The regexp we are building, as a string.\n    var reStr = \"\";\n    // Whether we are matching so called \"extended\" globs (like bash) and should\n    // support single character matching, matching ranges of characters, group\n    // matching, etc.\n    var extended = opts ? !!opts.extended : false;\n    // When globstar is _false_ (default), '/foo/*' is translated a regexp like\n    // '^\\/foo\\/.*$' which will match any string beginning with '/foo/'\n    // When globstar is _true_, '/foo/*' is translated to regexp like\n    // '^\\/foo\\/[^/]*$' which will match any string beginning with '/foo/' BUT\n    // which does not have a '/' to the right of it.\n    // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but\n    // these will not '/foo/bar/baz', '/foo/bar/baz.txt'\n    // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when\n    // globstar is _false_\n    var globstar = opts ? !!opts.globstar : false;\n    // If we are doing extended matching, this boolean is true when we are inside\n    // a group (eg {*.html,*.js}), and false otherwise.\n    var inGroup = false;\n    // RegExp flags (eg \"i\" ) to pass in to RegExp constructor.\n    var flags = opts && typeof (opts.flags) === \"string\" ? opts.flags : \"\";\n    var c;\n    for (var i = 0, len = str.length; i < len; i++) {\n        c = str[i];\n        switch (c) {\n            case \"/\":\n            case \"$\":\n            case \"^\":\n            case \"+\":\n            case \".\":\n            case \"(\":\n            case \")\":\n            case \"=\":\n            case \"!\":\n            case \"|\":\n                reStr += \"\\\\\" + c;\n                break;\n            case \"?\":\n                if (extended) {\n                    reStr += \".\";\n                    break;\n                }\n            case \"[\":\n            case \"]\":\n                if (extended) {\n                    reStr += c;\n                    break;\n                }\n            case \"{\":\n                if (extended) {\n                    inGroup = true;\n                    reStr += \"(\";\n                    break;\n                }\n            case \"}\":\n                if (extended) {\n                    inGroup = false;\n                    reStr += \")\";\n                    break;\n                }\n            case \",\":\n                if (inGroup) {\n                    reStr += \"|\";\n                    break;\n                }\n                reStr += \"\\\\\" + c;\n                break;\n            case \"*\":\n                // Move over all consecutive \"*\"'s.\n                // Also store the previous and next characters\n                var prevChar = str[i - 1];\n                var starCount = 1;\n                while (str[i + 1] === \"*\") {\n                    starCount++;\n                    i++;\n                }\n                var nextChar = str[i + 1];\n                if (!globstar) {\n                    // globstar is disabled, so treat any number of \"*\" as one\n                    reStr += \".*\";\n                }\n                else {\n                    // globstar is enabled, so determine if this is a globstar segment\n                    var isGlobstar = starCount > 1 // multiple \"*\"'s\n                        && (prevChar === \"/\" || prevChar === undefined || prevChar === '{' || prevChar === ',') // from the start of the segment\n                        && (nextChar === \"/\" || nextChar === undefined || nextChar === ',' || nextChar === '}'); // to the end of the segment\n                    if (isGlobstar) {\n                        if (nextChar === \"/\") {\n                            i++; // move over the \"/\"\n                        }\n                        else if (prevChar === '/' && reStr.endsWith('\\\\/')) {\n                            reStr = reStr.substr(0, reStr.length - 2);\n                        }\n                        // it's a globstar, so match zero or more path segments\n                        reStr += \"((?:[^/]*(?:\\/|$))*)\";\n                    }\n                    else {\n                        // it's not a globstar, so only match one path segment\n                        reStr += \"([^/]*)\";\n                    }\n                }\n                break;\n            default:\n                reStr += c;\n        }\n    }\n    // When regexp 'g' flag is specified don't\n    // constrain the regular expression with ^ & $\n    if (!flags || !~flags.indexOf('g')) {\n        reStr = \"^\" + reStr + \"$\";\n    }\n    return new RegExp(reStr, flags);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonSchemaService.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nvar jsonSchemaService_localize = loadMessageBundle();\nvar BANG = '!';\nvar PATH_SEP = '/';\nvar FilePatternAssociation = /** @class */ (function () {\n    function FilePatternAssociation(pattern, uris) {\n        this.globWrappers = [];\n        try {\n            for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n                var patternString = pattern_1[_i];\n                var include = patternString[0] !== BANG;\n                if (!include) {\n                    patternString = patternString.substring(1);\n                }\n                if (patternString.length > 0) {\n                    if (patternString[0] === PATH_SEP) {\n                        patternString = patternString.substring(1);\n                    }\n                    this.globWrappers.push({\n                        regexp: createRegex('**/' + patternString, { extended: true, globstar: true }),\n                        include: include,\n                    });\n                }\n            }\n            ;\n            this.uris = uris;\n        }\n        catch (e) {\n            this.globWrappers.length = 0;\n            this.uris = [];\n        }\n    }\n    FilePatternAssociation.prototype.matchesPattern = function (fileName) {\n        var match = false;\n        for (var _i = 0, _a = this.globWrappers; _i < _a.length; _i++) {\n            var _b = _a[_i], regexp = _b.regexp, include = _b.include;\n            if (regexp.test(fileName)) {\n                match = include;\n            }\n        }\n        return match;\n    };\n    FilePatternAssociation.prototype.getURIs = function () {\n        return this.uris;\n    };\n    return FilePatternAssociation;\n}());\nvar SchemaHandle = /** @class */ (function () {\n    function SchemaHandle(service, url, unresolvedSchemaContent) {\n        this.service = service;\n        this.url = url;\n        this.dependencies = {};\n        if (unresolvedSchemaContent) {\n            this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\n        }\n    }\n    SchemaHandle.prototype.getUnresolvedSchema = function () {\n        if (!this.unresolvedSchema) {\n            this.unresolvedSchema = this.service.loadSchema(this.url);\n        }\n        return this.unresolvedSchema;\n    };\n    SchemaHandle.prototype.getResolvedSchema = function () {\n        var _this = this;\n        if (!this.resolvedSchema) {\n            this.resolvedSchema = this.getUnresolvedSchema().then(function (unresolved) {\n                return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);\n            });\n        }\n        return this.resolvedSchema;\n    };\n    SchemaHandle.prototype.clearSchema = function () {\n        this.resolvedSchema = undefined;\n        this.unresolvedSchema = undefined;\n        this.dependencies = {};\n    };\n    return SchemaHandle;\n}());\nvar UnresolvedSchema = /** @class */ (function () {\n    function UnresolvedSchema(schema, errors) {\n        if (errors === void 0) { errors = []; }\n        this.schema = schema;\n        this.errors = errors;\n    }\n    return UnresolvedSchema;\n}());\n\nvar ResolvedSchema = /** @class */ (function () {\n    function ResolvedSchema(schema, errors) {\n        if (errors === void 0) { errors = []; }\n        this.schema = schema;\n        this.errors = errors;\n    }\n    ResolvedSchema.prototype.getSection = function (path) {\n        var schemaRef = this.getSectionRecursive(path, this.schema);\n        if (schemaRef) {\n            return asSchema(schemaRef);\n        }\n        return undefined;\n    };\n    ResolvedSchema.prototype.getSectionRecursive = function (path, schema) {\n        if (!schema || typeof schema === 'boolean' || path.length === 0) {\n            return schema;\n        }\n        var next = path.shift();\n        if (schema.properties && typeof schema.properties[next]) {\n            return this.getSectionRecursive(path, schema.properties[next]);\n        }\n        else if (schema.patternProperties) {\n            for (var _i = 0, _a = Object.keys(schema.patternProperties); _i < _a.length; _i++) {\n                var pattern = _a[_i];\n                var regex = extendedRegExp(pattern);\n                if (regex.test(next)) {\n                    return this.getSectionRecursive(path, schema.patternProperties[pattern]);\n                }\n            }\n        }\n        else if (typeof schema.additionalProperties === 'object') {\n            return this.getSectionRecursive(path, schema.additionalProperties);\n        }\n        else if (next.match('[0-9]+')) {\n            if (Array.isArray(schema.items)) {\n                var index = parseInt(next, 10);\n                if (!isNaN(index) && schema.items[index]) {\n                    return this.getSectionRecursive(path, schema.items[index]);\n                }\n            }\n            else if (schema.items) {\n                return this.getSectionRecursive(path, schema.items);\n            }\n        }\n        return undefined;\n    };\n    return ResolvedSchema;\n}());\n\nvar jsonSchemaService_JSONSchemaService = /** @class */ (function () {\n    function JSONSchemaService(requestService, contextService, promiseConstructor) {\n        this.contextService = contextService;\n        this.requestService = requestService;\n        this.promiseConstructor = promiseConstructor || Promise;\n        this.callOnDispose = [];\n        this.contributionSchemas = {};\n        this.contributionAssociations = [];\n        this.schemasById = {};\n        this.filePatternAssociations = [];\n        this.registeredSchemasIds = {};\n    }\n    JSONSchemaService.prototype.getRegisteredSchemaIds = function (filter) {\n        return Object.keys(this.registeredSchemasIds).filter(function (id) {\n            var scheme = URI.parse(id).scheme;\n            return scheme !== 'schemaservice' && (!filter || filter(scheme));\n        });\n    };\n    Object.defineProperty(JSONSchemaService.prototype, \"promise\", {\n        get: function () {\n            return this.promiseConstructor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    JSONSchemaService.prototype.dispose = function () {\n        while (this.callOnDispose.length > 0) {\n            this.callOnDispose.pop()();\n        }\n    };\n    JSONSchemaService.prototype.onResourceChange = function (uri) {\n        var _this = this;\n        var hasChanges = false;\n        uri = normalizeId(uri);\n        var toWalk = [uri];\n        var all = Object.keys(this.schemasById).map(function (key) { return _this.schemasById[key]; });\n        while (toWalk.length) {\n            var curr = toWalk.pop();\n            for (var i = 0; i < all.length; i++) {\n                var handle = all[i];\n                if (handle && (handle.url === curr || handle.dependencies[curr])) {\n                    if (handle.url !== curr) {\n                        toWalk.push(handle.url);\n                    }\n                    handle.clearSchema();\n                    all[i] = undefined;\n                    hasChanges = true;\n                }\n            }\n        }\n        return hasChanges;\n    };\n    JSONSchemaService.prototype.setSchemaContributions = function (schemaContributions) {\n        if (schemaContributions.schemas) {\n            var schemas = schemaContributions.schemas;\n            for (var id in schemas) {\n                var normalizedId = normalizeId(id);\n                this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\n            }\n        }\n        if (Array.isArray(schemaContributions.schemaAssociations)) {\n            var schemaAssociations = schemaContributions.schemaAssociations;\n            for (var _i = 0, schemaAssociations_1 = schemaAssociations; _i < schemaAssociations_1.length; _i++) {\n                var schemaAssociation = schemaAssociations_1[_i];\n                var uris = schemaAssociation.uris.map(normalizeId);\n                var association = this.addFilePatternAssociation(schemaAssociation.pattern, uris);\n                this.contributionAssociations.push(association);\n            }\n        }\n    };\n    JSONSchemaService.prototype.addSchemaHandle = function (id, unresolvedSchemaContent) {\n        var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\n        this.schemasById[id] = schemaHandle;\n        return schemaHandle;\n    };\n    JSONSchemaService.prototype.getOrAddSchemaHandle = function (id, unresolvedSchemaContent) {\n        return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\n    };\n    JSONSchemaService.prototype.addFilePatternAssociation = function (pattern, uris) {\n        var fpa = new FilePatternAssociation(pattern, uris);\n        this.filePatternAssociations.push(fpa);\n        return fpa;\n    };\n    JSONSchemaService.prototype.registerExternalSchema = function (uri, filePatterns, unresolvedSchemaContent) {\n        var id = normalizeId(uri);\n        this.registeredSchemasIds[id] = true;\n        this.cachedSchemaForResource = undefined;\n        if (filePatterns) {\n            this.addFilePatternAssociation(filePatterns, [uri]);\n        }\n        return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);\n    };\n    JSONSchemaService.prototype.clearExternalSchemas = function () {\n        this.schemasById = {};\n        this.filePatternAssociations = [];\n        this.registeredSchemasIds = {};\n        this.cachedSchemaForResource = undefined;\n        for (var id in this.contributionSchemas) {\n            this.schemasById[id] = this.contributionSchemas[id];\n            this.registeredSchemasIds[id] = true;\n        }\n        for (var _i = 0, _a = this.contributionAssociations; _i < _a.length; _i++) {\n            var contributionAssociation = _a[_i];\n            this.filePatternAssociations.push(contributionAssociation);\n        }\n    };\n    JSONSchemaService.prototype.getResolvedSchema = function (schemaId) {\n        var id = normalizeId(schemaId);\n        var schemaHandle = this.schemasById[id];\n        if (schemaHandle) {\n            return schemaHandle.getResolvedSchema();\n        }\n        return this.promise.resolve(undefined);\n    };\n    JSONSchemaService.prototype.loadSchema = function (url) {\n        if (!this.requestService) {\n            var errorMessage = jsonSchemaService_localize('json.schema.norequestservice', 'Unable to load schema from \\'{0}\\'. No schema request service available', toDisplayString(url));\n            return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\n        }\n        return this.requestService(url).then(function (content) {\n            if (!content) {\n                var errorMessage = jsonSchemaService_localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': No content.', toDisplayString(url));\n                return new UnresolvedSchema({}, [errorMessage]);\n            }\n            var schemaContent = {};\n            var jsonErrors = [];\n            schemaContent = main_parse(content, jsonErrors);\n            var errors = jsonErrors.length ? [jsonSchemaService_localize('json.schema.invalidFormat', 'Unable to parse content from \\'{0}\\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset)] : [];\n            return new UnresolvedSchema(schemaContent, errors);\n        }, function (error) {\n            var errorMessage = error.toString();\n            var errorSplit = error.toString().split('Error: ');\n            if (errorSplit.length > 1) {\n                // more concise error message, URL and context are attached by caller anyways\n                errorMessage = errorSplit[1];\n            }\n            if (endsWith(errorMessage, '.')) {\n                errorMessage = errorMessage.substr(0, errorMessage.length - 1);\n            }\n            return new UnresolvedSchema({}, [jsonSchemaService_localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': {1}.', toDisplayString(url), errorMessage)]);\n        });\n    };\n    JSONSchemaService.prototype.resolveSchemaContent = function (schemaToResolve, schemaURL, dependencies) {\n        var _this = this;\n        var resolveErrors = schemaToResolve.errors.slice(0);\n        var schema = schemaToResolve.schema;\n        if (schema.$schema) {\n            var id = normalizeId(schema.$schema);\n            if (id === 'http://json-schema.org/draft-03/schema') {\n                return this.promise.resolve(new ResolvedSchema({}, [jsonSchemaService_localize('json.schema.draft03.notsupported', \"Draft-03 schemas are not supported.\")]));\n            }\n            else if (id === 'https://json-schema.org/draft/2019-09/schema') {\n                resolveErrors.push(jsonSchemaService_localize('json.schema.draft201909.notsupported', \"Draft 2019-09 schemas are not yet fully supported.\"));\n            }\n        }\n        var contextService = this.contextService;\n        var findSection = function (schema, path) {\n            if (!path) {\n                return schema;\n            }\n            var current = schema;\n            if (path[0] === '/') {\n                path = path.substr(1);\n            }\n            path.split('/').some(function (part) {\n                part = part.replace(/~1/g, '/').replace(/~0/g, '~');\n                current = current[part];\n                return !current;\n            });\n            return current;\n        };\n        var merge = function (target, sourceRoot, sourceURI, refSegment) {\n            var path = refSegment ? decodeURIComponent(refSegment) : undefined;\n            var section = findSection(sourceRoot, path);\n            if (section) {\n                for (var key in section) {\n                    if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n                        target[key] = section[key];\n                    }\n                }\n            }\n            else {\n                resolveErrors.push(jsonSchemaService_localize('json.schema.invalidref', '$ref \\'{0}\\' in \\'{1}\\' can not be resolved.', path, sourceURI));\n            }\n        };\n        var resolveExternalLink = function (node, uri, refSegment, parentSchemaURL, parentSchemaDependencies) {\n            if (contextService && !/^[A-Za-z][A-Za-z0-9+\\-.+]*:\\/\\/.*/.test(uri)) {\n                uri = contextService.resolveRelativePath(uri, parentSchemaURL);\n            }\n            uri = normalizeId(uri);\n            var referencedHandle = _this.getOrAddSchemaHandle(uri);\n            return referencedHandle.getUnresolvedSchema().then(function (unresolvedSchema) {\n                parentSchemaDependencies[uri] = true;\n                if (unresolvedSchema.errors.length) {\n                    var loc = refSegment ? uri + '#' + refSegment : uri;\n                    resolveErrors.push(jsonSchemaService_localize('json.schema.problemloadingref', 'Problems loading reference \\'{0}\\': {1}', loc, unresolvedSchema.errors[0]));\n                }\n                merge(node, unresolvedSchema.schema, uri, refSegment);\n                return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);\n            });\n        };\n        var resolveRefs = function (node, parentSchema, parentSchemaURL, parentSchemaDependencies) {\n            if (!node || typeof node !== 'object') {\n                return Promise.resolve(null);\n            }\n            var toWalk = [node];\n            var seen = [];\n            var openPromises = [];\n            var collectEntries = function () {\n                var entries = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    entries[_i] = arguments[_i];\n                }\n                for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {\n                    var entry = entries_1[_a];\n                    if (typeof entry === 'object') {\n                        toWalk.push(entry);\n                    }\n                }\n            };\n            var collectMapEntries = function () {\n                var maps = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    maps[_i] = arguments[_i];\n                }\n                for (var _a = 0, maps_1 = maps; _a < maps_1.length; _a++) {\n                    var map = maps_1[_a];\n                    if (typeof map === 'object') {\n                        for (var k in map) {\n                            var key = k;\n                            var entry = map[key];\n                            if (typeof entry === 'object') {\n                                toWalk.push(entry);\n                            }\n                        }\n                    }\n                }\n            };\n            var collectArrayEntries = function () {\n                var arrays = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    arrays[_i] = arguments[_i];\n                }\n                for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {\n                    var array = arrays_1[_a];\n                    if (Array.isArray(array)) {\n                        for (var _b = 0, array_1 = array; _b < array_1.length; _b++) {\n                            var entry = array_1[_b];\n                            if (typeof entry === 'object') {\n                                toWalk.push(entry);\n                            }\n                        }\n                    }\n                }\n            };\n            var handleRef = function (next) {\n                var seenRefs = [];\n                while (next.$ref) {\n                    var ref = next.$ref;\n                    var segments = ref.split('#', 2);\n                    delete next.$ref;\n                    if (segments[0].length > 0) {\n                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));\n                        return;\n                    }\n                    else {\n                        if (seenRefs.indexOf(ref) === -1) {\n                            merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle\n                            seenRefs.push(ref);\n                        }\n                    }\n                }\n                collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);\n                collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);\n                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);\n            };\n            while (toWalk.length) {\n                var next = toWalk.pop();\n                if (seen.indexOf(next) >= 0) {\n                    continue;\n                }\n                seen.push(next);\n                handleRef(next);\n            }\n            return _this.promise.all(openPromises);\n        };\n        return resolveRefs(schema, schema, schemaURL, dependencies).then(function (_) { return new ResolvedSchema(schema, resolveErrors); });\n    };\n    JSONSchemaService.prototype.getSchemaForResource = function (resource, document) {\n        // first use $schema if present\n        if (document && document.root && document.root.type === 'object') {\n            var schemaProperties = document.root.properties.filter(function (p) { return (p.keyNode.value === '$schema') && p.valueNode && p.valueNode.type === 'string'; });\n            if (schemaProperties.length > 0) {\n                var valueNode = schemaProperties[0].valueNode;\n                if (valueNode && valueNode.type === 'string') {\n                    var schemeId = jsonParser_getNodeValue(valueNode);\n                    if (schemeId && startsWith(schemeId, '.') && this.contextService) {\n                        schemeId = this.contextService.resolveRelativePath(schemeId, resource);\n                    }\n                    if (schemeId) {\n                        var id = normalizeId(schemeId);\n                        return this.getOrAddSchemaHandle(id).getResolvedSchema();\n                    }\n                }\n            }\n        }\n        if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {\n            return this.cachedSchemaForResource.resolvedSchema;\n        }\n        var seen = Object.create(null);\n        var schemas = [];\n        var normalizedResource = normalizeResourceForMatching(resource);\n        for (var _i = 0, _a = this.filePatternAssociations; _i < _a.length; _i++) {\n            var entry = _a[_i];\n            if (entry.matchesPattern(normalizedResource)) {\n                for (var _b = 0, _c = entry.getURIs(); _b < _c.length; _b++) {\n                    var schemaId = _c[_b];\n                    if (!seen[schemaId]) {\n                        schemas.push(schemaId);\n                        seen[schemaId] = true;\n                    }\n                }\n            }\n        }\n        var resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);\n        this.cachedSchemaForResource = { resource: resource, resolvedSchema: resolvedSchema };\n        return resolvedSchema;\n    };\n    JSONSchemaService.prototype.createCombinedSchema = function (resource, schemaIds) {\n        if (schemaIds.length === 1) {\n            return this.getOrAddSchemaHandle(schemaIds[0]);\n        }\n        else {\n            var combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);\n            var combinedSchema = {\n                allOf: schemaIds.map(function (schemaId) { return ({ $ref: schemaId }); })\n            };\n            return this.addSchemaHandle(combinedSchemaId, combinedSchema);\n        }\n    };\n    JSONSchemaService.prototype.getMatchingSchemas = function (document, jsonDocument, schema) {\n        if (schema) {\n            var id = schema.id || ('schemaservice://untitled/matchingSchemas/' + idCounter++);\n            return this.resolveSchemaContent(new UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {\n                return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(function (s) { return !s.inverted; });\n            });\n        }\n        return this.getSchemaForResource(document.uri, jsonDocument).then(function (schema) {\n            if (schema) {\n                return jsonDocument.getMatchingSchemas(schema.schema).filter(function (s) { return !s.inverted; });\n            }\n            return [];\n        });\n    };\n    return JSONSchemaService;\n}());\n\nvar idCounter = 0;\nfunction normalizeId(id) {\n    // remove trailing '#', normalize drive capitalization\n    try {\n        return URI.parse(id).toString();\n    }\n    catch (e) {\n        return id;\n    }\n}\nfunction normalizeResourceForMatching(resource) {\n    // remove queries and fragments, normalize drive capitalization\n    try {\n        return URI.parse(resource).with({ fragment: null, query: null }).toString();\n    }\n    catch (e) {\n        return resource;\n    }\n}\nfunction toDisplayString(url) {\n    try {\n        var uri = URI.parse(url);\n        if (uri.scheme === 'file') {\n            return uri.fsPath;\n        }\n    }\n    catch (e) {\n        // ignore\n    }\n    return url;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonValidation.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\nvar jsonValidation_localize = loadMessageBundle();\nvar jsonValidation_JSONValidation = /** @class */ (function () {\n    function JSONValidation(jsonSchemaService, promiseConstructor) {\n        this.jsonSchemaService = jsonSchemaService;\n        this.promise = promiseConstructor;\n        this.validationEnabled = true;\n    }\n    JSONValidation.prototype.configure = function (raw) {\n        if (raw) {\n            this.validationEnabled = raw.validate !== false;\n            this.commentSeverity = raw.allowComments ? undefined : main_DiagnosticSeverity.Error;\n        }\n    };\n    JSONValidation.prototype.doValidation = function (textDocument, jsonDocument, documentSettings, schema) {\n        var _this = this;\n        if (!this.validationEnabled) {\n            return this.promise.resolve([]);\n        }\n        var diagnostics = [];\n        var added = {};\n        var addProblem = function (problem) {\n            // remove duplicated messages\n            var signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;\n            if (!added[signature]) {\n                added[signature] = true;\n                diagnostics.push(problem);\n            }\n        };\n        var getDiagnostics = function (schema) {\n            var trailingCommaSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : main_DiagnosticSeverity.Error;\n            var commentSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.comments) ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;\n            var schemaValidation = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : main_DiagnosticSeverity.Warning;\n            var schemaRequest = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : main_DiagnosticSeverity.Warning;\n            if (schema) {\n                if (schema.errors.length && jsonDocument.root && schemaRequest) {\n                    var astRoot = jsonDocument.root;\n                    var property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;\n                    if (property && property.keyNode.value === '$schema') {\n                        var node = property.valueNode || property;\n                        var range = main_Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));\n                        addProblem(main_Diagnostic.create(range, schema.errors[0], schemaRequest, jsonLanguageTypes_ErrorCode.SchemaResolveError));\n                    }\n                    else {\n                        var range = main_Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));\n                        addProblem(main_Diagnostic.create(range, schema.errors[0], schemaRequest, jsonLanguageTypes_ErrorCode.SchemaResolveError));\n                    }\n                }\n                else if (schemaValidation) {\n                    var semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation);\n                    if (semanticErrors) {\n                        semanticErrors.forEach(addProblem);\n                    }\n                }\n                if (schemaAllowsComments(schema.schema)) {\n                    commentSeverity = undefined;\n                }\n                if (schemaAllowsTrailingCommas(schema.schema)) {\n                    trailingCommaSeverity = undefined;\n                }\n            }\n            for (var _i = 0, _a = jsonDocument.syntaxErrors; _i < _a.length; _i++) {\n                var p = _a[_i];\n                if (p.code === jsonLanguageTypes_ErrorCode.TrailingComma) {\n                    if (typeof trailingCommaSeverity !== 'number') {\n                        continue;\n                    }\n                    p.severity = trailingCommaSeverity;\n                }\n                addProblem(p);\n            }\n            if (typeof commentSeverity === 'number') {\n                var message_1 = jsonValidation_localize('InvalidCommentToken', 'Comments are not permitted in JSON.');\n                jsonDocument.comments.forEach(function (c) {\n                    addProblem(main_Diagnostic.create(c, message_1, commentSeverity, jsonLanguageTypes_ErrorCode.CommentNotPermitted));\n                });\n            }\n            return diagnostics;\n        };\n        if (schema) {\n            var id = schema.id || ('schemaservice://untitled/' + jsonValidation_idCounter++);\n            return this.jsonSchemaService.resolveSchemaContent(new UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {\n                return getDiagnostics(resolvedSchema);\n            });\n        }\n        return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function (schema) {\n            return getDiagnostics(schema);\n        });\n    };\n    return JSONValidation;\n}());\n\nvar jsonValidation_idCounter = 0;\nfunction schemaAllowsComments(schemaRef) {\n    if (schemaRef && typeof schemaRef === 'object') {\n        if (isBoolean(schemaRef.allowComments)) {\n            return schemaRef.allowComments;\n        }\n        if (schemaRef.allOf) {\n            for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {\n                var schema = _a[_i];\n                var allow = schemaAllowsComments(schema);\n                if (isBoolean(allow)) {\n                    return allow;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction schemaAllowsTrailingCommas(schemaRef) {\n    if (schemaRef && typeof schemaRef === 'object') {\n        if (isBoolean(schemaRef.allowTrailingCommas)) {\n            return schemaRef.allowTrailingCommas;\n        }\n        var deprSchemaRef = schemaRef;\n        if (isBoolean(deprSchemaRef['allowsTrailingCommas'])) { // deprecated\n            return deprSchemaRef['allowsTrailingCommas'];\n        }\n        if (schemaRef.allOf) {\n            for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {\n                var schema = _a[_i];\n                var allow = schemaAllowsTrailingCommas(schema);\n                if (isBoolean(allow)) {\n                    return allow;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction toDiagnosticSeverity(severityLevel) {\n    switch (severityLevel) {\n        case 'error': return main_DiagnosticSeverity.Error;\n        case 'warning': return main_DiagnosticSeverity.Warning;\n        case 'ignore': return undefined;\n    }\n    return undefined;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/colors.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar Digit0 = 48;\nvar Digit9 = 57;\nvar A = 65;\nvar a = 97;\nvar f = 102;\nfunction hexDigit(charCode) {\n    if (charCode < Digit0) {\n        return 0;\n    }\n    if (charCode <= Digit9) {\n        return charCode - Digit0;\n    }\n    if (charCode < a) {\n        charCode += (a - A);\n    }\n    if (charCode >= a && charCode <= f) {\n        return charCode - a + 10;\n    }\n    return 0;\n}\nfunction colorFromHex(text) {\n    if (text[0] !== '#') {\n        return undefined;\n    }\n    switch (text.length) {\n        case 4:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,\n                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,\n                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,\n                alpha: 1\n            };\n        case 5:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,\n                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,\n                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,\n                alpha: (hexDigit(text.charCodeAt(4)) * 0x11) / 255.0,\n            };\n        case 7:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,\n                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,\n                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,\n                alpha: 1\n            };\n        case 9:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,\n                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,\n                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,\n                alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0\n            };\n    }\n    return undefined;\n}\nfunction colorFrom256RGB(red, green, blue, alpha) {\n    if (alpha === void 0) { alpha = 1.0; }\n    return {\n        red: red / 255.0,\n        green: green / 255.0,\n        blue: blue / 255.0,\n        alpha: alpha\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonDocumentSymbols.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\nvar jsonDocumentSymbols_JSONDocumentSymbols = /** @class */ (function () {\n    function JSONDocumentSymbols(schemaService) {\n        this.schemaService = schemaService;\n    }\n    JSONDocumentSymbols.prototype.findDocumentSymbols = function (document, doc, context) {\n        var _this = this;\n        if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }\n        var root = doc.root;\n        if (!root) {\n            return [];\n        }\n        var limit = context.resultLimit || Number.MAX_VALUE;\n        // special handling for key bindings\n        var resourceString = document.uri;\n        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n            if (root.type === 'array') {\n                var result_1 = [];\n                for (var _i = 0, _a = root.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.type === 'object') {\n                        for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {\n                            var property = _c[_b];\n                            if (property.keyNode.value === 'key' && property.valueNode) {\n                                var location = Location.create(document.uri, getRange(document, item));\n                                result_1.push({ name: jsonParser_getNodeValue(property.valueNode), kind: SymbolKind.Function, location: location });\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(resourceString);\n                                    }\n                                    return result_1;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result_1;\n            }\n        }\n        var toVisit = [\n            { node: root, containerName: '' }\n        ];\n        var nextToVisit = 0;\n        var limitExceeded = false;\n        var result = [];\n        var collectOutlineEntries = function (node, containerName) {\n            if (node.type === 'array') {\n                node.items.forEach(function (node) {\n                    if (node) {\n                        toVisit.push({ node: node, containerName: containerName });\n                    }\n                });\n            }\n            else if (node.type === 'object') {\n                node.properties.forEach(function (property) {\n                    var valueNode = property.valueNode;\n                    if (valueNode) {\n                        if (limit > 0) {\n                            limit--;\n                            var location = Location.create(document.uri, getRange(document, property));\n                            var childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;\n                            result.push({ name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), location: location, containerName: containerName });\n                            toVisit.push({ node: valueNode, containerName: childContainerName });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n        };\n        // breath first traversal\n        while (nextToVisit < toVisit.length) {\n            var next = toVisit[nextToVisit++];\n            collectOutlineEntries(next.node, next.containerName);\n        }\n        if (limitExceeded && context && context.onResultLimitExceeded) {\n            context.onResultLimitExceeded(resourceString);\n        }\n        return result;\n    };\n    JSONDocumentSymbols.prototype.findDocumentSymbols2 = function (document, doc, context) {\n        var _this = this;\n        if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }\n        var root = doc.root;\n        if (!root) {\n            return [];\n        }\n        var limit = context.resultLimit || Number.MAX_VALUE;\n        // special handling for key bindings\n        var resourceString = document.uri;\n        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n            if (root.type === 'array') {\n                var result_2 = [];\n                for (var _i = 0, _a = root.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.type === 'object') {\n                        for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {\n                            var property = _c[_b];\n                            if (property.keyNode.value === 'key' && property.valueNode) {\n                                var range = getRange(document, item);\n                                var selectionRange = getRange(document, property.keyNode);\n                                result_2.push({ name: jsonParser_getNodeValue(property.valueNode), kind: SymbolKind.Function, range: range, selectionRange: selectionRange });\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(resourceString);\n                                    }\n                                    return result_2;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result_2;\n            }\n        }\n        var result = [];\n        var toVisit = [\n            { node: root, result: result }\n        ];\n        var nextToVisit = 0;\n        var limitExceeded = false;\n        var collectOutlineEntries = function (node, result) {\n            if (node.type === 'array') {\n                node.items.forEach(function (node, index) {\n                    if (node) {\n                        if (limit > 0) {\n                            limit--;\n                            var range = getRange(document, node);\n                            var selectionRange = range;\n                            var name = String(index);\n                            var symbol = { name: name, kind: _this.getSymbolKind(node.type), range: range, selectionRange: selectionRange, children: [] };\n                            result.push(symbol);\n                            toVisit.push({ result: symbol.children, node: node });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n            else if (node.type === 'object') {\n                node.properties.forEach(function (property) {\n                    var valueNode = property.valueNode;\n                    if (valueNode) {\n                        if (limit > 0) {\n                            limit--;\n                            var range = getRange(document, property);\n                            var selectionRange = getRange(document, property.keyNode);\n                            var children = [];\n                            var symbol = { name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), range: range, selectionRange: selectionRange, children: children, detail: _this.getDetail(valueNode) };\n                            result.push(symbol);\n                            toVisit.push({ result: children, node: valueNode });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n        };\n        // breath first traversal\n        while (nextToVisit < toVisit.length) {\n            var next = toVisit[nextToVisit++];\n            collectOutlineEntries(next.node, next.result);\n        }\n        if (limitExceeded && context && context.onResultLimitExceeded) {\n            context.onResultLimitExceeded(resourceString);\n        }\n        return result;\n    };\n    JSONDocumentSymbols.prototype.getSymbolKind = function (nodeType) {\n        switch (nodeType) {\n            case 'object':\n                return SymbolKind.Module;\n            case 'string':\n                return SymbolKind.String;\n            case 'number':\n                return SymbolKind.Number;\n            case 'array':\n                return SymbolKind.Array;\n            case 'boolean':\n                return SymbolKind.Boolean;\n            default: // 'null'\n                return SymbolKind.Variable;\n        }\n    };\n    JSONDocumentSymbols.prototype.getKeyLabel = function (property) {\n        var name = property.keyNode.value;\n        if (name) {\n            name = name.replace(/[\\n]/g, '↵');\n        }\n        if (name && name.trim()) {\n            return name;\n        }\n        return \"\\\"\" + name + \"\\\"\";\n    };\n    JSONDocumentSymbols.prototype.getDetail = function (node) {\n        if (!node) {\n            return undefined;\n        }\n        if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {\n            return String(node.value);\n        }\n        else {\n            if (node.type === 'array') {\n                return node.children.length ? undefined : '[]';\n            }\n            else if (node.type === 'object') {\n                return node.children.length ? undefined : '{}';\n            }\n        }\n        return undefined;\n    };\n    JSONDocumentSymbols.prototype.findDocumentColors = function (document, doc, context) {\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n            var result = [];\n            if (schema) {\n                var limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;\n                var matchingSchemas = doc.getMatchingSchemas(schema.schema);\n                var visitedNode = {};\n                for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {\n                    var s = matchingSchemas_1[_i];\n                    if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {\n                        var nodeId = String(s.node.offset);\n                        if (!visitedNode[nodeId]) {\n                            var color = colorFromHex(jsonParser_getNodeValue(s.node));\n                            if (color) {\n                                var range = getRange(document, s.node);\n                                result.push({ color: color, range: range });\n                            }\n                            visitedNode[nodeId] = true;\n                            limit--;\n                            if (limit <= 0) {\n                                if (context && context.onResultLimitExceeded) {\n                                    context.onResultLimitExceeded(document.uri);\n                                }\n                                return result;\n                            }\n                        }\n                    }\n                }\n            }\n            return result;\n        });\n    };\n    JSONDocumentSymbols.prototype.getColorPresentations = function (document, doc, color, range) {\n        var result = [];\n        var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);\n        function toTwoDigitHex(n) {\n            var r = n.toString(16);\n            return r.length !== 2 ? '0' + r : r;\n        }\n        var label;\n        if (color.alpha === 1) {\n            label = \"#\" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256);\n        }\n        else {\n            label = \"#\" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256) + toTwoDigitHex(Math.round(color.alpha * 255));\n        }\n        result.push({ label: label, textEdit: main_TextEdit.replace(range, JSON.stringify(label)) });\n        return result;\n    };\n    return JSONDocumentSymbols;\n}());\n\nfunction getRange(document, node) {\n    return main_Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/configuration.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar configuration_localize = loadMessageBundle();\nvar configuration_schemaContributions = {\n    schemaAssociations: [],\n    schemas: {\n        // refer to the latest schema\n        'http://json-schema.org/schema#': {\n            $ref: 'http://json-schema.org/draft-07/schema#'\n        },\n        // bundle the schema-schema to include (localized) descriptions\n        'http://json-schema.org/draft-04/schema#': {\n            'title': configuration_localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),\n            '$schema': 'http://json-schema.org/draft-04/schema#',\n            'definitions': {\n                'schemaArray': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'items': {\n                        '$ref': '#'\n                    }\n                },\n                'positiveInteger': {\n                    'type': 'integer',\n                    'minimum': 0\n                },\n                'positiveIntegerDefault0': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        },\n                        {\n                            'default': 0\n                        }\n                    ]\n                },\n                'simpleTypes': {\n                    'type': 'string',\n                    'enum': [\n                        'array',\n                        'boolean',\n                        'integer',\n                        'null',\n                        'number',\n                        'object',\n                        'string'\n                    ]\n                },\n                'stringArray': {\n                    'type': 'array',\n                    'items': {\n                        'type': 'string'\n                    },\n                    'minItems': 1,\n                    'uniqueItems': true\n                }\n            },\n            'type': 'object',\n            'properties': {\n                'id': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                '$schema': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                'title': {\n                    'type': 'string'\n                },\n                'description': {\n                    'type': 'string'\n                },\n                'default': {},\n                'multipleOf': {\n                    'type': 'number',\n                    'minimum': 0,\n                    'exclusiveMinimum': true\n                },\n                'maximum': {\n                    'type': 'number'\n                },\n                'exclusiveMaximum': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'minimum': {\n                    'type': 'number'\n                },\n                'exclusiveMinimum': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'maxLength': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minLength': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'pattern': {\n                    'type': 'string',\n                    'format': 'regex'\n                },\n                'additionalItems': {\n                    'anyOf': [\n                        {\n                            'type': 'boolean'\n                        },\n                        {\n                            '$ref': '#'\n                        }\n                    ],\n                    'default': {}\n                },\n                'items': {\n                    'anyOf': [\n                        {\n                            '$ref': '#'\n                        },\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ],\n                    'default': {}\n                },\n                'maxItems': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minItems': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'uniqueItems': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'maxProperties': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minProperties': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'required': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/stringArray'\n                        }\n                    ]\n                },\n                'additionalProperties': {\n                    'anyOf': [\n                        {\n                            'type': 'boolean'\n                        },\n                        {\n                            '$ref': '#'\n                        }\n                    ],\n                    'default': {}\n                },\n                'definitions': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'properties': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'patternProperties': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'dependencies': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        'anyOf': [\n                            {\n                                '$ref': '#'\n                            },\n                            {\n                                '$ref': '#/definitions/stringArray'\n                            }\n                        ]\n                    }\n                },\n                'enum': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'uniqueItems': true\n                },\n                'type': {\n                    'anyOf': [\n                        {\n                            '$ref': '#/definitions/simpleTypes'\n                        },\n                        {\n                            'type': 'array',\n                            'items': {\n                                '$ref': '#/definitions/simpleTypes'\n                            },\n                            'minItems': 1,\n                            'uniqueItems': true\n                        }\n                    ]\n                },\n                'format': {\n                    'anyOf': [\n                        {\n                            'type': 'string',\n                            'enum': [\n                                'date-time',\n                                'uri',\n                                'email',\n                                'hostname',\n                                'ipv4',\n                                'ipv6',\n                                'regex'\n                            ]\n                        },\n                        {\n                            'type': 'string'\n                        }\n                    ]\n                },\n                'allOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'anyOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'oneOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'not': {\n                    'allOf': [\n                        {\n                            '$ref': '#'\n                        }\n                    ]\n                }\n            },\n            'dependencies': {\n                'exclusiveMaximum': [\n                    'maximum'\n                ],\n                'exclusiveMinimum': [\n                    'minimum'\n                ]\n            },\n            'default': {}\n        },\n        'http://json-schema.org/draft-07/schema#': {\n            'title': configuration_localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),\n            'definitions': {\n                'schemaArray': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'items': { '$ref': '#' }\n                },\n                'nonNegativeInteger': {\n                    'type': 'integer',\n                    'minimum': 0\n                },\n                'nonNegativeIntegerDefault0': {\n                    'allOf': [\n                        { '$ref': '#/definitions/nonNegativeInteger' },\n                        { 'default': 0 }\n                    ]\n                },\n                'simpleTypes': {\n                    'enum': [\n                        'array',\n                        'boolean',\n                        'integer',\n                        'null',\n                        'number',\n                        'object',\n                        'string'\n                    ]\n                },\n                'stringArray': {\n                    'type': 'array',\n                    'items': { 'type': 'string' },\n                    'uniqueItems': true,\n                    'default': []\n                }\n            },\n            'type': ['object', 'boolean'],\n            'properties': {\n                '$id': {\n                    'type': 'string',\n                    'format': 'uri-reference'\n                },\n                '$schema': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                '$ref': {\n                    'type': 'string',\n                    'format': 'uri-reference'\n                },\n                '$comment': {\n                    'type': 'string'\n                },\n                'title': {\n                    'type': 'string'\n                },\n                'description': {\n                    'type': 'string'\n                },\n                'default': true,\n                'readOnly': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'examples': {\n                    'type': 'array',\n                    'items': true\n                },\n                'multipleOf': {\n                    'type': 'number',\n                    'exclusiveMinimum': 0\n                },\n                'maximum': {\n                    'type': 'number'\n                },\n                'exclusiveMaximum': {\n                    'type': 'number'\n                },\n                'minimum': {\n                    'type': 'number'\n                },\n                'exclusiveMinimum': {\n                    'type': 'number'\n                },\n                'maxLength': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minLength': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'pattern': {\n                    'type': 'string',\n                    'format': 'regex'\n                },\n                'additionalItems': { '$ref': '#' },\n                'items': {\n                    'anyOf': [\n                        { '$ref': '#' },\n                        { '$ref': '#/definitions/schemaArray' }\n                    ],\n                    'default': true\n                },\n                'maxItems': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minItems': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'uniqueItems': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'contains': { '$ref': '#' },\n                'maxProperties': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minProperties': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'required': { '$ref': '#/definitions/stringArray' },\n                'additionalProperties': { '$ref': '#' },\n                'definitions': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'default': {}\n                },\n                'properties': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'default': {}\n                },\n                'patternProperties': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'propertyNames': { 'format': 'regex' },\n                    'default': {}\n                },\n                'dependencies': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        'anyOf': [\n                            { '$ref': '#' },\n                            { '$ref': '#/definitions/stringArray' }\n                        ]\n                    }\n                },\n                'propertyNames': { '$ref': '#' },\n                'const': true,\n                'enum': {\n                    'type': 'array',\n                    'items': true,\n                    'minItems': 1,\n                    'uniqueItems': true\n                },\n                'type': {\n                    'anyOf': [\n                        { '$ref': '#/definitions/simpleTypes' },\n                        {\n                            'type': 'array',\n                            'items': { '$ref': '#/definitions/simpleTypes' },\n                            'minItems': 1,\n                            'uniqueItems': true\n                        }\n                    ]\n                },\n                'format': { 'type': 'string' },\n                'contentMediaType': { 'type': 'string' },\n                'contentEncoding': { 'type': 'string' },\n                'if': { '$ref': '#' },\n                'then': { '$ref': '#' },\n                'else': { '$ref': '#' },\n                'allOf': { '$ref': '#/definitions/schemaArray' },\n                'anyOf': { '$ref': '#/definitions/schemaArray' },\n                'oneOf': { '$ref': '#/definitions/schemaArray' },\n                'not': { '$ref': '#' }\n            },\n            'default': true\n        }\n    }\n};\nvar descriptions = {\n    id: configuration_localize('schema.json.id', \"A unique identifier for the schema.\"),\n    $schema: configuration_localize('schema.json.$schema', \"The schema to verify this document against.\"),\n    title: configuration_localize('schema.json.title', \"A descriptive title of the element.\"),\n    description: configuration_localize('schema.json.description', \"A long description of the element. Used in hover menus and suggestions.\"),\n    default: configuration_localize('schema.json.default', \"A default value. Used by suggestions.\"),\n    multipleOf: configuration_localize('schema.json.multipleOf', \"A number that should cleanly divide the current value (i.e. have no remainder).\"),\n    maximum: configuration_localize('schema.json.maximum', \"The maximum numerical value, inclusive by default.\"),\n    exclusiveMaximum: configuration_localize('schema.json.exclusiveMaximum', \"Makes the maximum property exclusive.\"),\n    minimum: configuration_localize('schema.json.minimum', \"The minimum numerical value, inclusive by default.\"),\n    exclusiveMinimum: configuration_localize('schema.json.exclusiveMininum', \"Makes the minimum property exclusive.\"),\n    maxLength: configuration_localize('schema.json.maxLength', \"The maximum length of a string.\"),\n    minLength: configuration_localize('schema.json.minLength', \"The minimum length of a string.\"),\n    pattern: configuration_localize('schema.json.pattern', \"A regular expression to match the string against. It is not implicitly anchored.\"),\n    additionalItems: configuration_localize('schema.json.additionalItems', \"For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail.\"),\n    items: configuration_localize('schema.json.items', \"For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on.\"),\n    maxItems: configuration_localize('schema.json.maxItems', \"The maximum number of items that can be inside an array. Inclusive.\"),\n    minItems: configuration_localize('schema.json.minItems', \"The minimum number of items that can be inside an array. Inclusive.\"),\n    uniqueItems: configuration_localize('schema.json.uniqueItems', \"If all of the items in the array must be unique. Defaults to false.\"),\n    maxProperties: configuration_localize('schema.json.maxProperties', \"The maximum number of properties an object can have. Inclusive.\"),\n    minProperties: configuration_localize('schema.json.minProperties', \"The minimum number of properties an object can have. Inclusive.\"),\n    required: configuration_localize('schema.json.required', \"An array of strings that lists the names of all properties required on this object.\"),\n    additionalProperties: configuration_localize('schema.json.additionalProperties', \"Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail.\"),\n    definitions: configuration_localize('schema.json.definitions', \"Not used for validation. Place subschemas here that you wish to reference inline with $ref.\"),\n    properties: configuration_localize('schema.json.properties', \"A map of property names to schemas for each property.\"),\n    patternProperties: configuration_localize('schema.json.patternProperties', \"A map of regular expressions on property names to schemas for matching properties.\"),\n    dependencies: configuration_localize('schema.json.dependencies', \"A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object.\"),\n    enum: configuration_localize('schema.json.enum', \"The set of literal values that are valid.\"),\n    type: configuration_localize('schema.json.type', \"Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types.\"),\n    format: configuration_localize('schema.json.format', \"Describes the format expected for the value.\"),\n    allOf: configuration_localize('schema.json.allOf', \"An array of schemas, all of which must match.\"),\n    anyOf: configuration_localize('schema.json.anyOf', \"An array of schemas, where at least one must match.\"),\n    oneOf: configuration_localize('schema.json.oneOf', \"An array of schemas, exactly one of which must match.\"),\n    not: configuration_localize('schema.json.not', \"A schema which must not match.\"),\n    $id: configuration_localize('schema.json.$id', \"A unique identifier for the schema.\"),\n    $ref: configuration_localize('schema.json.$ref', \"Reference a definition hosted on any location.\"),\n    $comment: configuration_localize('schema.json.$comment', \"Comments from schema authors to readers or maintainers of the schema.\"),\n    readOnly: configuration_localize('schema.json.readOnly', \"Indicates that the value of the instance is managed exclusively by the owning authority.\"),\n    examples: configuration_localize('schema.json.examples', \"Sample JSON values associated with a particular schema, for the purpose of illustrating usage.\"),\n    contains: configuration_localize('schema.json.contains', \"An array instance is valid against \\\"contains\\\" if at least one of its elements is valid against the given schema.\"),\n    propertyNames: configuration_localize('schema.json.propertyNames', \"If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema.\"),\n    const: configuration_localize('schema.json.const', \"An instance validates successfully against this keyword if its value is equal to the value of the keyword.\"),\n    contentMediaType: configuration_localize('schema.json.contentMediaType', \"Describes the media type of a string property.\"),\n    contentEncoding: configuration_localize('schema.json.contentEncoding', \"Describes the content encoding of a string property.\"),\n    if: configuration_localize('schema.json.if', \"The validation outcome of the \\\"if\\\" subschema controls which of the \\\"then\\\" or \\\"else\\\" keywords are evaluated.\"),\n    then: configuration_localize('schema.json.then', \"The \\\"if\\\" subschema is used for validation when the \\\"if\\\" subschema succeeds.\"),\n    else: configuration_localize('schema.json.else', \"The \\\"else\\\" subschema is used for validation when the \\\"if\\\" subschema fails.\")\n};\nfor (var schemaName in configuration_schemaContributions.schemas) {\n    var schema = configuration_schemaContributions.schemas[schemaName];\n    for (var property in schema.properties) {\n        var propertyObject = schema.properties[property];\n        if (typeof propertyObject === 'boolean') {\n            propertyObject = schema.properties[property] = {};\n        }\n        var description = descriptions[property];\n        if (description) {\n            propertyObject['description'] = description;\n        }\n        else {\n            console.log(property + \": localize('schema.json.\" + property + \"', \\\"\\\")\");\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonFolding.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction jsonFolding_getFoldingRanges(document, context) {\n    var ranges = [];\n    var nestingLevels = [];\n    var stack = [];\n    var prevStart = -1;\n    var scanner = createScanner(document.getText(), false);\n    var token = scanner.scan();\n    function addRange(range) {\n        ranges.push(range);\n        nestingLevels.push(stack.length);\n    }\n    while (token !== 17 /* EOF */) {\n        switch (token) {\n            case 1 /* OpenBraceToken */:\n            case 3 /* OpenBracketToken */: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var range = { startLine: startLine, endLine: startLine, kind: token === 1 /* OpenBraceToken */ ? 'object' : 'array' };\n                stack.push(range);\n                break;\n            }\n            case 2 /* CloseBraceToken */:\n            case 4 /* CloseBracketToken */: {\n                var kind = token === 2 /* CloseBraceToken */ ? 'object' : 'array';\n                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\n                    var range = stack.pop();\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\n                        range.endLine = line - 1;\n                        addRange(range);\n                        prevStart = range.startLine;\n                    }\n                }\n                break;\n            }\n            case 13 /* BlockCommentTrivia */: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n                if (scanner.getTokenError() === 1 /* UnexpectedEndOfComment */ && startLine + 1 < document.lineCount) {\n                    scanner.setPosition(document.offsetAt(Position.create(startLine + 1, 0)));\n                }\n                else {\n                    if (startLine < endLine) {\n                        addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Comment });\n                        prevStart = startLine;\n                    }\n                }\n                break;\n            }\n            case 12 /* LineCommentTrivia */: {\n                var text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n                var m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n                if (m) {\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (m[1]) { // start pattern match\n                        var range = { startLine: line, endLine: line, kind: FoldingRangeKind.Region };\n                        stack.push(range);\n                    }\n                    else {\n                        var i = stack.length - 1;\n                        while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\n                            i--;\n                        }\n                        if (i >= 0) {\n                            var range = stack[i];\n                            stack.length = i;\n                            if (line > range.startLine && prevStart !== range.startLine) {\n                                range.endLine = line;\n                                addRange(range);\n                                prevStart = range.startLine;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    var rangeLimit = context && context.rangeLimit;\n    if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {\n        return ranges;\n    }\n    if (context && context.onRangeLimitExceeded) {\n        context.onRangeLimitExceeded(document.uri);\n    }\n    var counts = [];\n    for (var _i = 0, nestingLevels_1 = nestingLevels; _i < nestingLevels_1.length; _i++) {\n        var level = nestingLevels_1[_i];\n        if (level < 30) {\n            counts[level] = (counts[level] || 0) + 1;\n        }\n    }\n    var entries = 0;\n    var maxLevel = 0;\n    for (var i = 0; i < counts.length; i++) {\n        var n = counts[i];\n        if (n) {\n            if (n + entries > rangeLimit) {\n                maxLevel = i;\n                break;\n            }\n            entries += n;\n        }\n    }\n    var result = [];\n    for (var i = 0; i < ranges.length; i++) {\n        var level = nestingLevels[i];\n        if (typeof level === 'number') {\n            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {\n                result.push(ranges[i]);\n            }\n        }\n    }\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonSelectionRanges.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction jsonSelectionRanges_getSelectionRanges(document, positions, doc) {\n    function getSelectionRange(position) {\n        var offset = document.offsetAt(position);\n        var node = doc.getNodeFromOffset(offset, true);\n        var result = [];\n        while (node) {\n            switch (node.type) {\n                case 'string':\n                case 'object':\n                case 'array':\n                    // range without \", [ or {\n                    var cStart = node.offset + 1, cEnd = node.offset + node.length - 1;\n                    if (cStart < cEnd && offset >= cStart && offset <= cEnd) {\n                        result.push(newRange(cStart, cEnd));\n                    }\n                    result.push(newRange(node.offset, node.offset + node.length));\n                    break;\n                case 'number':\n                case 'boolean':\n                case 'null':\n                case 'property':\n                    result.push(newRange(node.offset, node.offset + node.length));\n                    break;\n            }\n            if (node.type === 'property' || node.parent && node.parent.type === 'array') {\n                var afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* CommaToken */);\n                if (afterCommaOffset !== -1) {\n                    result.push(newRange(node.offset, afterCommaOffset));\n                }\n            }\n            node = node.parent;\n        }\n        var current = undefined;\n        for (var index = result.length - 1; index >= 0; index--) {\n            current = SelectionRange.create(result[index], current);\n        }\n        if (!current) {\n            current = SelectionRange.create(Range.create(position, position));\n        }\n        return current;\n    }\n    function newRange(start, end) {\n        return Range.create(document.positionAt(start), document.positionAt(end));\n    }\n    var scanner = createScanner(document.getText(), true);\n    function getOffsetAfterNextToken(offset, expectedToken) {\n        scanner.setPosition(offset);\n        var token = scanner.scan();\n        if (token === expectedToken) {\n            return scanner.getTokenOffset() + scanner.getTokenLength();\n        }\n        return -1;\n    }\n    return positions.map(getSelectionRange);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonLinks.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nfunction jsonLinks_findLinks(document, doc) {\n    var links = [];\n    doc.visit(function (node) {\n        var _a;\n        if (node.type === \"property\" && node.keyNode.value === \"$ref\" && ((_a = node.valueNode) === null || _a === void 0 ? void 0 : _a.type) === 'string') {\n            var path = node.valueNode.value;\n            var targetNode = findTargetNode(doc, path);\n            if (targetNode) {\n                var targetPos = document.positionAt(targetNode.offset);\n                links.push({\n                    target: document.uri + \"#\" + (targetPos.line + 1) + \",\" + (targetPos.character + 1),\n                    range: createRange(document, node.valueNode)\n                });\n            }\n        }\n        return true;\n    });\n    return Promise.resolve(links);\n}\nfunction createRange(document, node) {\n    return Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + node.length - 1));\n}\nfunction findTargetNode(doc, path) {\n    var tokens = parseJSONPointer(path);\n    if (!tokens) {\n        return null;\n    }\n    return findNode(tokens, doc.root);\n}\nfunction findNode(pointer, node) {\n    if (!node) {\n        return null;\n    }\n    if (pointer.length === 0) {\n        return node;\n    }\n    var token = pointer.shift();\n    if (node && node.type === 'object') {\n        var propertyNode = node.properties.find(function (propertyNode) { return propertyNode.keyNode.value === token; });\n        if (!propertyNode) {\n            return null;\n        }\n        return findNode(pointer, propertyNode.valueNode);\n    }\n    else if (node && node.type === 'array') {\n        if (token.match(/^(0|[1-9][0-9]*)$/)) {\n            var index = Number.parseInt(token);\n            var arrayItem = node.items[index];\n            if (!arrayItem) {\n                return null;\n            }\n            return findNode(pointer, arrayItem);\n        }\n    }\n    return null;\n}\nfunction parseJSONPointer(path) {\n    if (path === \"#\") {\n        return [];\n    }\n    if (path[0] !== '#' || path[1] !== '/') {\n        return null;\n    }\n    return path.substring(2).split(/\\//).map(jsonLinks_unescape);\n}\nfunction jsonLinks_unescape(str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/jsonLanguageService.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getLanguageService(params) {\n    var promise = params.promiseConstructor || Promise;\n    var jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);\n    jsonSchemaService.setSchemaContributions(schemaContributions);\n    var jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);\n    var jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);\n    var jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);\n    var jsonValidation = new JSONValidation(jsonSchemaService, promise);\n    return {\n        configure: function (settings) {\n            jsonSchemaService.clearExternalSchemas();\n            if (settings.schemas) {\n                settings.schemas.forEach(function (settings) {\n                    jsonSchemaService.registerExternalSchema(settings.uri, settings.fileMatch, settings.schema);\n                });\n            }\n            jsonValidation.configure(settings);\n        },\n        resetSchema: function (uri) { return jsonSchemaService.onResourceChange(uri); },\n        doValidation: jsonValidation.doValidation.bind(jsonValidation),\n        parseJSONDocument: function (document) { return parseJSON(document, { collectComments: true }); },\n        newJSONDocument: function (root, diagnostics) { return newJSONDocument(root, diagnostics); },\n        getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),\n        doResolve: jsonCompletion.doResolve.bind(jsonCompletion),\n        doComplete: jsonCompletion.doComplete.bind(jsonCompletion),\n        findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),\n        findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),\n        findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),\n        getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),\n        doHover: jsonHover.doHover.bind(jsonHover),\n        getFoldingRanges: getFoldingRanges,\n        getSelectionRanges: getSelectionRanges,\n        findDefinition: function () { return Promise.resolve([]); },\n        findLinks: findLinks,\n        format: function (d, r, o) {\n            var range = undefined;\n            if (r) {\n                var offset = d.offsetAt(r.start);\n                var length = d.offsetAt(r.end) - offset;\n                range = { offset: offset, length: length };\n            }\n            var options = { tabSize: o ? o.tabSize : 4, insertSpaces: (o === null || o === void 0 ? void 0 : o.insertSpaces) === true, insertFinalNewline: (o === null || o === void 0 ? void 0 : o.insertFinalNewline) === true, eol: '\\n' };\n            return formatJSON(d.getText(), range, options).map(function (e) {\n                return TextEdit.replace(Range.create(d.positionAt(e.offset), d.positionAt(e.offset + e.length)), e.content);\n            });\n        }\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/languageFeatures.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n// --- diagnostics --- ---\r\nvar DiagnosticsAdapter = /** @class */ (function () {\r\n    function DiagnosticsAdapter(_languageId, _worker, defaults) {\r\n        var _this = this;\r\n        this._languageId = _languageId;\r\n        this._worker = _worker;\r\n        this._disposables = [];\r\n        this._listener = Object.create(null);\r\n        var onModelAdd = function (model) {\r\n            var modeId = model.getModeId();\r\n            if (modeId !== _this._languageId) {\r\n                return;\r\n            }\r\n            var handle;\r\n            _this._listener[model.uri.toString()] = model.onDidChangeContent(function () {\r\n                clearTimeout(handle);\r\n                handle = setTimeout(function () { return _this._doValidate(model.uri, modeId); }, 500);\r\n            });\r\n            _this._doValidate(model.uri, modeId);\r\n        };\r\n        var onModelRemoved = function (model) {\r\n            monaco_editor_core/* editor.setModelMarkers */.j6.setModelMarkers(model, _this._languageId, []);\r\n            var uriStr = model.uri.toString();\r\n            var listener = _this._listener[uriStr];\r\n            if (listener) {\r\n                listener.dispose();\r\n                delete _this._listener[uriStr];\r\n            }\r\n        };\r\n        this._disposables.push(monaco_editor_core/* editor.onDidCreateModel */.j6.onDidCreateModel(onModelAdd));\r\n        this._disposables.push(monaco_editor_core/* editor.onWillDisposeModel */.j6.onWillDisposeModel(function (model) {\r\n            onModelRemoved(model);\r\n            _this._resetSchema(model.uri);\r\n        }));\r\n        this._disposables.push(monaco_editor_core/* editor.onDidChangeModelLanguage */.j6.onDidChangeModelLanguage(function (event) {\r\n            onModelRemoved(event.model);\r\n            onModelAdd(event.model);\r\n            _this._resetSchema(event.model.uri);\r\n        }));\r\n        this._disposables.push(defaults.onDidChange(function (_) {\r\n            monaco_editor_core/* editor.getModels */.j6.getModels().forEach(function (model) {\r\n                if (model.getModeId() === _this._languageId) {\r\n                    onModelRemoved(model);\r\n                    onModelAdd(model);\r\n                }\r\n            });\r\n        }));\r\n        this._disposables.push({\r\n            dispose: function () {\r\n                monaco_editor_core/* editor.getModels */.j6.getModels().forEach(onModelRemoved);\r\n                for (var key in _this._listener) {\r\n                    _this._listener[key].dispose();\r\n                }\r\n            }\r\n        });\r\n        monaco_editor_core/* editor.getModels */.j6.getModels().forEach(onModelAdd);\r\n    }\r\n    DiagnosticsAdapter.prototype.dispose = function () {\r\n        this._disposables.forEach(function (d) { return d && d.dispose(); });\r\n        this._disposables = [];\r\n    };\r\n    DiagnosticsAdapter.prototype._resetSchema = function (resource) {\r\n        this._worker().then(function (worker) {\r\n            worker.resetSchema(resource.toString());\r\n        });\r\n    };\r\n    DiagnosticsAdapter.prototype._doValidate = function (resource, languageId) {\r\n        this._worker(resource)\r\n            .then(function (worker) {\r\n            return worker.doValidation(resource.toString()).then(function (diagnostics) {\r\n                var markers = diagnostics.map(function (d) { return toDiagnostics(resource, d); });\r\n                var model = monaco_editor_core/* editor.getModel */.j6.getModel(resource);\r\n                if (model && model.getModeId() === languageId) {\r\n                    monaco_editor_core/* editor.setModelMarkers */.j6.setModelMarkers(model, languageId, markers);\r\n                }\r\n            });\r\n        })\r\n            .then(undefined, function (err) {\r\n            console.error(err);\r\n        });\r\n    };\r\n    return DiagnosticsAdapter;\r\n}());\r\n\r\nfunction toSeverity(lsSeverity) {\r\n    switch (lsSeverity) {\r\n        case main_DiagnosticSeverity.Error:\r\n            return monaco_editor_core/* MarkerSeverity.Error */.ZL.Error;\r\n        case main_DiagnosticSeverity.Warning:\r\n            return monaco_editor_core/* MarkerSeverity.Warning */.ZL.Warning;\r\n        case main_DiagnosticSeverity.Information:\r\n            return monaco_editor_core/* MarkerSeverity.Info */.ZL.Info;\r\n        case main_DiagnosticSeverity.Hint:\r\n            return monaco_editor_core/* MarkerSeverity.Hint */.ZL.Hint;\r\n        default:\r\n            return monaco_editor_core/* MarkerSeverity.Info */.ZL.Info;\r\n    }\r\n}\r\nfunction toDiagnostics(resource, diag) {\r\n    var code = typeof diag.code === 'number' ? String(diag.code) : diag.code;\r\n    return {\r\n        severity: toSeverity(diag.severity),\r\n        startLineNumber: diag.range.start.line + 1,\r\n        startColumn: diag.range.start.character + 1,\r\n        endLineNumber: diag.range.end.line + 1,\r\n        endColumn: diag.range.end.character + 1,\r\n        message: diag.message,\r\n        code: code,\r\n        source: diag.source\r\n    };\r\n}\r\n// --- completion ------\r\nfunction fromPosition(position) {\r\n    if (!position) {\r\n        return void 0;\r\n    }\r\n    return { character: position.column - 1, line: position.lineNumber - 1 };\r\n}\r\nfunction fromRange(range) {\r\n    if (!range) {\r\n        return void 0;\r\n    }\r\n    return {\r\n        start: {\r\n            line: range.startLineNumber - 1,\r\n            character: range.startColumn - 1\r\n        },\r\n        end: { line: range.endLineNumber - 1, character: range.endColumn - 1 }\r\n    };\r\n}\r\nfunction toRange(range) {\r\n    if (!range) {\r\n        return void 0;\r\n    }\r\n    return new monaco_editor_core/* Range */.e6(range.start.line + 1, range.start.character + 1, range.end.line + 1, range.end.character + 1);\r\n}\r\nfunction isInsertReplaceEdit(edit) {\r\n    return (typeof edit.insert !== 'undefined' &&\r\n        typeof edit.replace !== 'undefined');\r\n}\r\nfunction toCompletionItemKind(kind) {\r\n    var mItemKind = monaco_editor_core/* languages.CompletionItemKind */.Mj.CompletionItemKind;\r\n    switch (kind) {\r\n        case CompletionItemKind.Text:\r\n            return mItemKind.Text;\r\n        case CompletionItemKind.Method:\r\n            return mItemKind.Method;\r\n        case CompletionItemKind.Function:\r\n            return mItemKind.Function;\r\n        case CompletionItemKind.Constructor:\r\n            return mItemKind.Constructor;\r\n        case CompletionItemKind.Field:\r\n            return mItemKind.Field;\r\n        case CompletionItemKind.Variable:\r\n            return mItemKind.Variable;\r\n        case CompletionItemKind.Class:\r\n            return mItemKind.Class;\r\n        case CompletionItemKind.Interface:\r\n            return mItemKind.Interface;\r\n        case CompletionItemKind.Module:\r\n            return mItemKind.Module;\r\n        case CompletionItemKind.Property:\r\n            return mItemKind.Property;\r\n        case CompletionItemKind.Unit:\r\n            return mItemKind.Unit;\r\n        case CompletionItemKind.Value:\r\n            return mItemKind.Value;\r\n        case CompletionItemKind.Enum:\r\n            return mItemKind.Enum;\r\n        case CompletionItemKind.Keyword:\r\n            return mItemKind.Keyword;\r\n        case CompletionItemKind.Snippet:\r\n            return mItemKind.Snippet;\r\n        case CompletionItemKind.Color:\r\n            return mItemKind.Color;\r\n        case CompletionItemKind.File:\r\n            return mItemKind.File;\r\n        case CompletionItemKind.Reference:\r\n            return mItemKind.Reference;\r\n    }\r\n    return mItemKind.Property;\r\n}\r\nfunction fromCompletionItemKind(kind) {\r\n    var mItemKind = languages.CompletionItemKind;\r\n    switch (kind) {\r\n        case mItemKind.Text:\r\n            return jsonService.CompletionItemKind.Text;\r\n        case mItemKind.Method:\r\n            return jsonService.CompletionItemKind.Method;\r\n        case mItemKind.Function:\r\n            return jsonService.CompletionItemKind.Function;\r\n        case mItemKind.Constructor:\r\n            return jsonService.CompletionItemKind.Constructor;\r\n        case mItemKind.Field:\r\n            return jsonService.CompletionItemKind.Field;\r\n        case mItemKind.Variable:\r\n            return jsonService.CompletionItemKind.Variable;\r\n        case mItemKind.Class:\r\n            return jsonService.CompletionItemKind.Class;\r\n        case mItemKind.Interface:\r\n            return jsonService.CompletionItemKind.Interface;\r\n        case mItemKind.Module:\r\n            return jsonService.CompletionItemKind.Module;\r\n        case mItemKind.Property:\r\n            return jsonService.CompletionItemKind.Property;\r\n        case mItemKind.Unit:\r\n            return jsonService.CompletionItemKind.Unit;\r\n        case mItemKind.Value:\r\n            return jsonService.CompletionItemKind.Value;\r\n        case mItemKind.Enum:\r\n            return jsonService.CompletionItemKind.Enum;\r\n        case mItemKind.Keyword:\r\n            return jsonService.CompletionItemKind.Keyword;\r\n        case mItemKind.Snippet:\r\n            return jsonService.CompletionItemKind.Snippet;\r\n        case mItemKind.Color:\r\n            return jsonService.CompletionItemKind.Color;\r\n        case mItemKind.File:\r\n            return jsonService.CompletionItemKind.File;\r\n        case mItemKind.Reference:\r\n            return jsonService.CompletionItemKind.Reference;\r\n    }\r\n    return jsonService.CompletionItemKind.Property;\r\n}\r\nfunction toTextEdit(textEdit) {\r\n    if (!textEdit) {\r\n        return void 0;\r\n    }\r\n    return {\r\n        range: toRange(textEdit.range),\r\n        text: textEdit.newText\r\n    };\r\n}\r\nfunction toCommand(c) {\r\n    return c && c.command === 'editor.action.triggerSuggest' ? { id: c.command, title: c.title, arguments: c.arguments } : undefined;\r\n}\r\nvar CompletionAdapter = /** @class */ (function () {\r\n    function CompletionAdapter(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    Object.defineProperty(CompletionAdapter.prototype, \"triggerCharacters\", {\r\n        get: function () {\r\n            return [' ', ':', '\"'];\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    CompletionAdapter.prototype.provideCompletionItems = function (model, position, context, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) {\r\n            return worker.doComplete(resource.toString(), fromPosition(position));\r\n        })\r\n            .then(function (info) {\r\n            if (!info) {\r\n                return;\r\n            }\r\n            var wordInfo = model.getWordUntilPosition(position);\r\n            var wordRange = new monaco_editor_core/* Range */.e6(position.lineNumber, wordInfo.startColumn, position.lineNumber, wordInfo.endColumn);\r\n            var items = info.items.map(function (entry) {\r\n                var item = {\r\n                    label: entry.label,\r\n                    insertText: entry.insertText || entry.label,\r\n                    sortText: entry.sortText,\r\n                    filterText: entry.filterText,\r\n                    documentation: entry.documentation,\r\n                    detail: entry.detail,\r\n                    command: toCommand(entry.command),\r\n                    range: wordRange,\r\n                    kind: toCompletionItemKind(entry.kind)\r\n                };\r\n                if (entry.textEdit) {\r\n                    if (isInsertReplaceEdit(entry.textEdit)) {\r\n                        item.range = {\r\n                            insert: toRange(entry.textEdit.insert),\r\n                            replace: toRange(entry.textEdit.replace)\r\n                        };\r\n                    }\r\n                    else {\r\n                        item.range = toRange(entry.textEdit.range);\r\n                    }\r\n                    item.insertText = entry.textEdit.newText;\r\n                }\r\n                if (entry.additionalTextEdits) {\r\n                    item.additionalTextEdits = entry.additionalTextEdits.map(toTextEdit);\r\n                }\r\n                if (entry.insertTextFormat === InsertTextFormat.Snippet) {\r\n                    item.insertTextRules = monaco_editor_core/* languages.CompletionItemInsertTextRule.InsertAsSnippet */.Mj.CompletionItemInsertTextRule.InsertAsSnippet;\r\n                }\r\n                return item;\r\n            });\r\n            return {\r\n                isIncomplete: info.isIncomplete,\r\n                suggestions: items\r\n            };\r\n        });\r\n    };\r\n    return CompletionAdapter;\r\n}());\r\n\r\nfunction isMarkupContent(thing) {\r\n    return (thing &&\r\n        typeof thing === 'object' &&\r\n        typeof thing.kind === 'string');\r\n}\r\nfunction toMarkdownString(entry) {\r\n    if (typeof entry === 'string') {\r\n        return {\r\n            value: entry\r\n        };\r\n    }\r\n    if (isMarkupContent(entry)) {\r\n        if (entry.kind === 'plaintext') {\r\n            return {\r\n                value: entry.value.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&')\r\n            };\r\n        }\r\n        return {\r\n            value: entry.value\r\n        };\r\n    }\r\n    return { value: '```' + entry.language + '\\n' + entry.value + '\\n```\\n' };\r\n}\r\nfunction toMarkedStringArray(contents) {\r\n    if (!contents) {\r\n        return void 0;\r\n    }\r\n    if (Array.isArray(contents)) {\r\n        return contents.map(toMarkdownString);\r\n    }\r\n    return [toMarkdownString(contents)];\r\n}\r\n// --- hover ------\r\nvar HoverAdapter = /** @class */ (function () {\r\n    function HoverAdapter(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    HoverAdapter.prototype.provideHover = function (model, position, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) {\r\n            return worker.doHover(resource.toString(), fromPosition(position));\r\n        })\r\n            .then(function (info) {\r\n            if (!info) {\r\n                return;\r\n            }\r\n            return {\r\n                range: toRange(info.range),\r\n                contents: toMarkedStringArray(info.contents)\r\n            };\r\n        });\r\n    };\r\n    return HoverAdapter;\r\n}());\r\n\r\n// --- definition ------\r\nfunction toLocation(location) {\r\n    return {\r\n        uri: Uri.parse(location.uri),\r\n        range: toRange(location.range)\r\n    };\r\n}\r\n// --- document symbols ------\r\nfunction toSymbolKind(kind) {\r\n    var mKind = monaco_editor_core/* languages.SymbolKind */.Mj.SymbolKind;\r\n    switch (kind) {\r\n        case SymbolKind.File:\r\n            return mKind.Array;\r\n        case SymbolKind.Module:\r\n            return mKind.Module;\r\n        case SymbolKind.Namespace:\r\n            return mKind.Namespace;\r\n        case SymbolKind.Package:\r\n            return mKind.Package;\r\n        case SymbolKind.Class:\r\n            return mKind.Class;\r\n        case SymbolKind.Method:\r\n            return mKind.Method;\r\n        case SymbolKind.Property:\r\n            return mKind.Property;\r\n        case SymbolKind.Field:\r\n            return mKind.Field;\r\n        case SymbolKind.Constructor:\r\n            return mKind.Constructor;\r\n        case SymbolKind.Enum:\r\n            return mKind.Enum;\r\n        case SymbolKind.Interface:\r\n            return mKind.Interface;\r\n        case SymbolKind.Function:\r\n            return mKind.Function;\r\n        case SymbolKind.Variable:\r\n            return mKind.Variable;\r\n        case SymbolKind.Constant:\r\n            return mKind.Constant;\r\n        case SymbolKind.String:\r\n            return mKind.String;\r\n        case SymbolKind.Number:\r\n            return mKind.Number;\r\n        case SymbolKind.Boolean:\r\n            return mKind.Boolean;\r\n        case SymbolKind.Array:\r\n            return mKind.Array;\r\n    }\r\n    return mKind.Function;\r\n}\r\nvar DocumentSymbolAdapter = /** @class */ (function () {\r\n    function DocumentSymbolAdapter(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    DocumentSymbolAdapter.prototype.provideDocumentSymbols = function (model, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) { return worker.findDocumentSymbols(resource.toString()); })\r\n            .then(function (items) {\r\n            if (!items) {\r\n                return;\r\n            }\r\n            return items.map(function (item) { return ({\r\n                name: item.name,\r\n                detail: '',\r\n                containerName: item.containerName,\r\n                kind: toSymbolKind(item.kind),\r\n                range: toRange(item.location.range),\r\n                selectionRange: toRange(item.location.range),\r\n                tags: []\r\n            }); });\r\n        });\r\n    };\r\n    return DocumentSymbolAdapter;\r\n}());\r\n\r\nfunction fromFormattingOptions(options) {\r\n    return {\r\n        tabSize: options.tabSize,\r\n        insertSpaces: options.insertSpaces\r\n    };\r\n}\r\nvar DocumentFormattingEditProvider = /** @class */ (function () {\r\n    function DocumentFormattingEditProvider(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    DocumentFormattingEditProvider.prototype.provideDocumentFormattingEdits = function (model, options, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource).then(function (worker) {\r\n            return worker\r\n                .format(resource.toString(), null, fromFormattingOptions(options))\r\n                .then(function (edits) {\r\n                if (!edits || edits.length === 0) {\r\n                    return;\r\n                }\r\n                return edits.map(toTextEdit);\r\n            });\r\n        });\r\n    };\r\n    return DocumentFormattingEditProvider;\r\n}());\r\n\r\nvar DocumentRangeFormattingEditProvider = /** @class */ (function () {\r\n    function DocumentRangeFormattingEditProvider(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    DocumentRangeFormattingEditProvider.prototype.provideDocumentRangeFormattingEdits = function (model, range, options, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource).then(function (worker) {\r\n            return worker\r\n                .format(resource.toString(), fromRange(range), fromFormattingOptions(options))\r\n                .then(function (edits) {\r\n                if (!edits || edits.length === 0) {\r\n                    return;\r\n                }\r\n                return edits.map(toTextEdit);\r\n            });\r\n        });\r\n    };\r\n    return DocumentRangeFormattingEditProvider;\r\n}());\r\n\r\nvar DocumentColorAdapter = /** @class */ (function () {\r\n    function DocumentColorAdapter(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    DocumentColorAdapter.prototype.provideDocumentColors = function (model, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) { return worker.findDocumentColors(resource.toString()); })\r\n            .then(function (infos) {\r\n            if (!infos) {\r\n                return;\r\n            }\r\n            return infos.map(function (item) { return ({\r\n                color: item.color,\r\n                range: toRange(item.range)\r\n            }); });\r\n        });\r\n    };\r\n    DocumentColorAdapter.prototype.provideColorPresentations = function (model, info, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) {\r\n            return worker.getColorPresentations(resource.toString(), info.color, fromRange(info.range));\r\n        })\r\n            .then(function (presentations) {\r\n            if (!presentations) {\r\n                return;\r\n            }\r\n            return presentations.map(function (presentation) {\r\n                var item = {\r\n                    label: presentation.label\r\n                };\r\n                if (presentation.textEdit) {\r\n                    item.textEdit = toTextEdit(presentation.textEdit);\r\n                }\r\n                if (presentation.additionalTextEdits) {\r\n                    item.additionalTextEdits = presentation.additionalTextEdits.map(toTextEdit);\r\n                }\r\n                return item;\r\n            });\r\n        });\r\n    };\r\n    return DocumentColorAdapter;\r\n}());\r\n\r\nvar FoldingRangeAdapter = /** @class */ (function () {\r\n    function FoldingRangeAdapter(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    FoldingRangeAdapter.prototype.provideFoldingRanges = function (model, context, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) { return worker.getFoldingRanges(resource.toString(), context); })\r\n            .then(function (ranges) {\r\n            if (!ranges) {\r\n                return;\r\n            }\r\n            return ranges.map(function (range) {\r\n                var result = {\r\n                    start: range.startLine + 1,\r\n                    end: range.endLine + 1\r\n                };\r\n                if (typeof range.kind !== 'undefined') {\r\n                    result.kind = toFoldingRangeKind(range.kind);\r\n                }\r\n                return result;\r\n            });\r\n        });\r\n    };\r\n    return FoldingRangeAdapter;\r\n}());\r\n\r\nfunction toFoldingRangeKind(kind) {\r\n    switch (kind) {\r\n        case main_FoldingRangeKind.Comment:\r\n            return monaco_editor_core/* languages.FoldingRangeKind.Comment */.Mj.FoldingRangeKind.Comment;\r\n        case main_FoldingRangeKind.Imports:\r\n            return monaco_editor_core/* languages.FoldingRangeKind.Imports */.Mj.FoldingRangeKind.Imports;\r\n        case main_FoldingRangeKind.Region:\r\n            return monaco_editor_core/* languages.FoldingRangeKind.Region */.Mj.FoldingRangeKind.Region;\r\n    }\r\n    return void 0;\r\n}\r\nvar SelectionRangeAdapter = /** @class */ (function () {\r\n    function SelectionRangeAdapter(_worker) {\r\n        this._worker = _worker;\r\n    }\r\n    SelectionRangeAdapter.prototype.provideSelectionRanges = function (model, positions, token) {\r\n        var resource = model.uri;\r\n        return this._worker(resource)\r\n            .then(function (worker) { return worker.getSelectionRanges(resource.toString(), positions.map(fromPosition)); })\r\n            .then(function (selectionRanges) {\r\n            if (!selectionRanges) {\r\n                return;\r\n            }\r\n            return selectionRanges.map(function (selectionRange) {\r\n                var result = [];\r\n                while (selectionRange) {\r\n                    result.push({ range: toRange(selectionRange.range) });\r\n                    selectionRange = selectionRange.parent;\r\n                }\r\n                return result;\r\n            });\r\n        });\r\n    };\r\n    return SelectionRangeAdapter;\r\n}());\r\n\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/tokenization.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nfunction createTokenizationSupport(supportComments) {\r\n    return {\r\n        getInitialState: function () { return new JSONState(null, null, false, null); },\r\n        tokenize: function (line, state, offsetDelta, stopAtOffset) {\r\n            return tokenize(supportComments, line, state, offsetDelta, stopAtOffset);\r\n        }\r\n    };\r\n}\r\nvar TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\r\nvar TOKEN_DELIM_ARRAY = 'delimiter.array.json';\r\nvar TOKEN_DELIM_COLON = 'delimiter.colon.json';\r\nvar TOKEN_DELIM_COMMA = 'delimiter.comma.json';\r\nvar TOKEN_VALUE_BOOLEAN = 'keyword.json';\r\nvar TOKEN_VALUE_NULL = 'keyword.json';\r\nvar TOKEN_VALUE_STRING = 'string.value.json';\r\nvar TOKEN_VALUE_NUMBER = 'number.json';\r\nvar TOKEN_PROPERTY_NAME = 'string.key.json';\r\nvar TOKEN_COMMENT_BLOCK = 'comment.block.json';\r\nvar TOKEN_COMMENT_LINE = 'comment.line.json';\r\nvar ParentsStack = /** @class */ (function () {\r\n    function ParentsStack(parent, type) {\r\n        this.parent = parent;\r\n        this.type = type;\r\n    }\r\n    ParentsStack.pop = function (parents) {\r\n        if (parents) {\r\n            return parents.parent;\r\n        }\r\n        return null;\r\n    };\r\n    ParentsStack.push = function (parents, type) {\r\n        return new ParentsStack(parents, type);\r\n    };\r\n    ParentsStack.equals = function (a, b) {\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        if (!a || !b) {\r\n            return false;\r\n        }\r\n        while (a && b) {\r\n            if (a === b) {\r\n                return true;\r\n            }\r\n            if (a.type !== b.type) {\r\n                return false;\r\n            }\r\n            a = a.parent;\r\n            b = b.parent;\r\n        }\r\n        return true;\r\n    };\r\n    return ParentsStack;\r\n}());\r\nvar JSONState = /** @class */ (function () {\r\n    function JSONState(state, scanError, lastWasColon, parents) {\r\n        this._state = state;\r\n        this.scanError = scanError;\r\n        this.lastWasColon = lastWasColon;\r\n        this.parents = parents;\r\n    }\r\n    JSONState.prototype.clone = function () {\r\n        return new JSONState(this._state, this.scanError, this.lastWasColon, this.parents);\r\n    };\r\n    JSONState.prototype.equals = function (other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        if (!other || !(other instanceof JSONState)) {\r\n            return false;\r\n        }\r\n        return (this.scanError === other.scanError &&\r\n            this.lastWasColon === other.lastWasColon &&\r\n            ParentsStack.equals(this.parents, other.parents));\r\n    };\r\n    JSONState.prototype.getStateData = function () {\r\n        return this._state;\r\n    };\r\n    JSONState.prototype.setStateData = function (state) {\r\n        this._state = state;\r\n    };\r\n    return JSONState;\r\n}());\r\nfunction tokenize(comments, line, state, offsetDelta, stopAtOffset) {\r\n    if (offsetDelta === void 0) { offsetDelta = 0; }\r\n    // handle multiline strings and block comments\r\n    var numberOfInsertedCharacters = 0;\r\n    var adjustOffset = false;\r\n    switch (state.scanError) {\r\n        case 2 /* UnexpectedEndOfString */:\r\n            line = '\"' + line;\r\n            numberOfInsertedCharacters = 1;\r\n            break;\r\n        case 1 /* UnexpectedEndOfComment */:\r\n            line = '/*' + line;\r\n            numberOfInsertedCharacters = 2;\r\n            break;\r\n    }\r\n    var scanner = main_createScanner(line);\r\n    var lastWasColon = state.lastWasColon;\r\n    var parents = state.parents;\r\n    var ret = {\r\n        tokens: [],\r\n        endState: state.clone()\r\n    };\r\n    while (true) {\r\n        var offset = offsetDelta + scanner.getPosition();\r\n        var type = '';\r\n        var kind = scanner.scan();\r\n        if (kind === 17 /* EOF */) {\r\n            break;\r\n        }\r\n        // Check that the scanner has advanced\r\n        if (offset === offsetDelta + scanner.getPosition()) {\r\n            throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\r\n        }\r\n        // In case we inserted /* or \" character, we need to\r\n        // adjust the offset of all tokens (except the first)\r\n        if (adjustOffset) {\r\n            offset -= numberOfInsertedCharacters;\r\n        }\r\n        adjustOffset = numberOfInsertedCharacters > 0;\r\n        // brackets and type\r\n        switch (kind) {\r\n            case 1 /* OpenBraceToken */:\r\n                parents = ParentsStack.push(parents, 0 /* Object */);\r\n                type = TOKEN_DELIM_OBJECT;\r\n                lastWasColon = false;\r\n                break;\r\n            case 2 /* CloseBraceToken */:\r\n                parents = ParentsStack.pop(parents);\r\n                type = TOKEN_DELIM_OBJECT;\r\n                lastWasColon = false;\r\n                break;\r\n            case 3 /* OpenBracketToken */:\r\n                parents = ParentsStack.push(parents, 1 /* Array */);\r\n                type = TOKEN_DELIM_ARRAY;\r\n                lastWasColon = false;\r\n                break;\r\n            case 4 /* CloseBracketToken */:\r\n                parents = ParentsStack.pop(parents);\r\n                type = TOKEN_DELIM_ARRAY;\r\n                lastWasColon = false;\r\n                break;\r\n            case 6 /* ColonToken */:\r\n                type = TOKEN_DELIM_COLON;\r\n                lastWasColon = true;\r\n                break;\r\n            case 5 /* CommaToken */:\r\n                type = TOKEN_DELIM_COMMA;\r\n                lastWasColon = false;\r\n                break;\r\n            case 8 /* TrueKeyword */:\r\n            case 9 /* FalseKeyword */:\r\n                type = TOKEN_VALUE_BOOLEAN;\r\n                lastWasColon = false;\r\n                break;\r\n            case 7 /* NullKeyword */:\r\n                type = TOKEN_VALUE_NULL;\r\n                lastWasColon = false;\r\n                break;\r\n            case 10 /* StringLiteral */:\r\n                var currentParent = parents ? parents.type : 0 /* Object */;\r\n                var inArray = currentParent === 1 /* Array */;\r\n                type =\r\n                    lastWasColon || inArray ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\r\n                lastWasColon = false;\r\n                break;\r\n            case 11 /* NumericLiteral */:\r\n                type = TOKEN_VALUE_NUMBER;\r\n                lastWasColon = false;\r\n                break;\r\n        }\r\n        // comments, iff enabled\r\n        if (comments) {\r\n            switch (kind) {\r\n                case 12 /* LineCommentTrivia */:\r\n                    type = TOKEN_COMMENT_LINE;\r\n                    break;\r\n                case 13 /* BlockCommentTrivia */:\r\n                    type = TOKEN_COMMENT_BLOCK;\r\n                    break;\r\n            }\r\n        }\r\n        ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon, parents);\r\n        ret.tokens.push({\r\n            startIndex: offset,\r\n            scopes: type\r\n        });\r\n    }\r\n    return ret;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/jsonMode.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nfunction setupMode(defaults) {\r\n    var disposables = [];\r\n    var providers = [];\r\n    var client = new WorkerManager(defaults);\r\n    disposables.push(client);\r\n    var worker = function () {\r\n        var uris = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            uris[_i] = arguments[_i];\r\n        }\r\n        return client.getLanguageServiceWorker.apply(client, uris);\r\n    };\r\n    function registerProviders() {\r\n        var languageId = defaults.languageId, modeConfiguration = defaults.modeConfiguration;\r\n        disposeAll(providers);\r\n        if (modeConfiguration.documentFormattingEdits) {\r\n            providers.push(monaco_editor_core/* languages.registerDocumentFormattingEditProvider */.Mj.registerDocumentFormattingEditProvider(languageId, new DocumentFormattingEditProvider(worker)));\r\n        }\r\n        if (modeConfiguration.documentRangeFormattingEdits) {\r\n            providers.push(monaco_editor_core/* languages.registerDocumentRangeFormattingEditProvider */.Mj.registerDocumentRangeFormattingEditProvider(languageId, new DocumentRangeFormattingEditProvider(worker)));\r\n        }\r\n        if (modeConfiguration.completionItems) {\r\n            providers.push(monaco_editor_core/* languages.registerCompletionItemProvider */.Mj.registerCompletionItemProvider(languageId, new CompletionAdapter(worker)));\r\n        }\r\n        if (modeConfiguration.hovers) {\r\n            providers.push(monaco_editor_core/* languages.registerHoverProvider */.Mj.registerHoverProvider(languageId, new HoverAdapter(worker)));\r\n        }\r\n        if (modeConfiguration.documentSymbols) {\r\n            providers.push(monaco_editor_core/* languages.registerDocumentSymbolProvider */.Mj.registerDocumentSymbolProvider(languageId, new DocumentSymbolAdapter(worker)));\r\n        }\r\n        if (modeConfiguration.tokens) {\r\n            providers.push(monaco_editor_core/* languages.setTokensProvider */.Mj.setTokensProvider(languageId, createTokenizationSupport(true)));\r\n        }\r\n        if (modeConfiguration.colors) {\r\n            providers.push(monaco_editor_core/* languages.registerColorProvider */.Mj.registerColorProvider(languageId, new DocumentColorAdapter(worker)));\r\n        }\r\n        if (modeConfiguration.foldingRanges) {\r\n            providers.push(monaco_editor_core/* languages.registerFoldingRangeProvider */.Mj.registerFoldingRangeProvider(languageId, new FoldingRangeAdapter(worker)));\r\n        }\r\n        if (modeConfiguration.diagnostics) {\r\n            providers.push(new DiagnosticsAdapter(languageId, worker, defaults));\r\n        }\r\n        if (modeConfiguration.selectionRanges) {\r\n            providers.push(monaco_editor_core/* languages.registerSelectionRangeProvider */.Mj.registerSelectionRangeProvider(languageId, new SelectionRangeAdapter(worker)));\r\n        }\r\n    }\r\n    registerProviders();\r\n    disposables.push(monaco_editor_core/* languages.setLanguageConfiguration */.Mj.setLanguageConfiguration(defaults.languageId, richEditConfiguration));\r\n    var modeConfiguration = defaults.modeConfiguration;\r\n    defaults.onDidChange(function (newDefaults) {\r\n        if (newDefaults.modeConfiguration !== modeConfiguration) {\r\n            modeConfiguration = newDefaults.modeConfiguration;\r\n            registerProviders();\r\n        }\r\n    });\r\n    disposables.push(asDisposable(providers));\r\n    return asDisposable(disposables);\r\n}\r\nfunction asDisposable(disposables) {\r\n    return { dispose: function () { return disposeAll(disposables); } };\r\n}\r\nfunction disposeAll(disposables) {\r\n    while (disposables.length) {\r\n        disposables.pop().dispose();\r\n    }\r\n}\r\nvar richEditConfiguration = {\r\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\[\\{\\]\\}\\:\\\"\\,\\s]+)/g,\r\n    comments: {\r\n        lineComment: '//',\r\n        blockComment: ['/*', '*/']\r\n    },\r\n    brackets: [\r\n        ['{', '}'],\r\n        ['[', ']']\r\n    ],\r\n    autoClosingPairs: [\r\n        { open: '{', close: '}', notIn: ['string'] },\r\n        { open: '[', close: ']', notIn: ['string'] },\r\n        { open: '\"', close: '\"', notIn: ['string'] }\r\n    ]\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEwOTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RDtBQUN6RCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw4QkFBOEI7QUFDMUY7QUFDQSw4RUFBOEUsNkJBQTZCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBLENBQUM7QUFDd0I7OztBQ3hFekI7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxxQkFBYTtBQUM3QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQ3hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBSyx3QkFBd0IsVUFBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGVBQVU7QUFDdkY7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLGVBQVU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQUs7QUFDN0M7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBSztBQUM3QztBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFJLG1CQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQUs7QUFDL0M7QUFDQTtBQUNBLENBQUMsRUFBRSxtQkFBYyxLQUFLLG1CQUFjLEtBQUs7QUFDbEMsVUFBVSxvRUFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBUTtBQUMzQjtB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O0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pC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a0dBQXdDLGlCQUFpQixxQkFBc0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNGQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVEsWUFBWSxzQkFBc0I7QUFDcEQsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi93b3JrZXJNYW5hZ2VyLmpzPzU0ZjkiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvanNvbmMtcGFyc2VyL2ltcGwvc2Nhbm5lci5qcz80NTRlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL2pzb25jLXBhcnNlci9pbXBsL3BhcnNlci5qcz8yODU2Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL2pzb25jLXBhcnNlci9pbXBsL2VkaXQuanM/NzA5ZSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy9qc29uYy1wYXJzZXIvbWFpbi5qcz9jMmZjIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS91dGlscy9vYmplY3RzLmpzP2UzMTUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3V0aWxzL3N0cmluZ3MuanM/MDM5NSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbWFpbi5qcz9lNjk3Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQvbGliL2VzbS9tYWluLmpzP2VjYzkiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2pzb25MYW5ndWFnZVR5cGVzLmpzPzJjOTEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vZmlsbGVycy92c2NvZGUtbmxzLmpzPzAwMmUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3BhcnNlci9qc29uUGFyc2VyLmpzPzZhMWIiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3V0aWxzL2pzb24uanM/NWJlYiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvbkNvbXBsZXRpb24uanM/MzA4ZCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvbkhvdmVyLmpzPzBiNjMiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLXVyaS9pbmRleC5qcz9jNjIzIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS91dGlscy9nbG9iLmpzPzkxM2MiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3NlcnZpY2VzL2pzb25TY2hlbWFTZXJ2aWNlLmpzP2JhMjMiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3NlcnZpY2VzL2pzb25WYWxpZGF0aW9uLmpzP2IyZjciLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3V0aWxzL2NvbG9ycy5qcz9iNzdlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9zZXJ2aWNlcy9qc29uRG9jdW1lbnRTeW1ib2xzLmpzP2QxOWQiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3NlcnZpY2VzL2NvbmZpZ3VyYXRpb24uanM/OWU0ZCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvbkZvbGRpbmcuanM/YjdkMSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvblNlbGVjdGlvblJhbmdlcy5qcz9iMWE2Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9zZXJ2aWNlcy9qc29uTGlua3MuanM/NTU2MSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvanNvbkxhbmd1YWdlU2VydmljZS5qcz81MmJjIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL2xhbmd1YWdlRmVhdHVyZXMuanM/ZmYzNiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi90b2tlbml6YXRpb24uanM/MzYxYSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9qc29uTW9kZS5qcz80N2I5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBlZGl0b3IgfSBmcm9tICcuL2ZpbGxlcnMvbW9uYWNvLWVkaXRvci1jb3JlLmpzJztcclxudmFyIFNUT1BfV0hFTl9JRExFX0ZPUiA9IDIgKiA2MCAqIDEwMDA7IC8vIDJtaW5cclxudmFyIFdvcmtlck1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBXb3JrZXJNYW5hZ2VyKGRlZmF1bHRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9kZWZhdWx0cyA9IGRlZmF1bHRzO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faWRsZUNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY2hlY2tJZklkbGUoKTsgfSwgMzAgKiAxMDAwKTtcclxuICAgICAgICB0aGlzLl9sYXN0VXNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZ0NoYW5nZUxpc3RlbmVyID0gdGhpcy5fZGVmYXVsdHMub25EaWRDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3N0b3BXb3JrZXIoKTsgfSk7XHJcbiAgICB9XHJcbiAgICBXb3JrZXJNYW5hZ2VyLnByb3RvdHlwZS5fc3RvcFdvcmtlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NsaWVudCA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgV29ya2VyTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2lkbGVDaGVja0ludGVydmFsKTtcclxuICAgICAgICB0aGlzLl9jb25maWdDaGFuZ2VMaXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcFdvcmtlcigpO1xyXG4gICAgfTtcclxuICAgIFdvcmtlck1hbmFnZXIucHJvdG90eXBlLl9jaGVja0lmSWRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3dvcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0aW1lUGFzc2VkU2luY2VMYXN0VXNlZCA9IERhdGUubm93KCkgLSB0aGlzLl9sYXN0VXNlZFRpbWU7XHJcbiAgICAgICAgaWYgKHRpbWVQYXNzZWRTaW5jZUxhc3RVc2VkID4gU1RPUF9XSEVOX0lETEVfRk9SKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXb3JrZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgV29ya2VyTWFuYWdlci5wcm90b3R5cGUuX2dldENsaWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9sYXN0VXNlZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmICghdGhpcy5fY2xpZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IGVkaXRvci5jcmVhdGVXZWJXb3JrZXIoe1xyXG4gICAgICAgICAgICAgICAgLy8gbW9kdWxlIHRoYXQgZXhwb3J0cyB0aGUgY3JlYXRlKCkgbWV0aG9kIGFuZCByZXR1cm5zIGEgYEpTT05Xb3JrZXJgIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogJ3ZzL2xhbmd1YWdlL2pzb24vanNvbldvcmtlcicsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5fZGVmYXVsdHMubGFuZ3VhZ2VJZCxcclxuICAgICAgICAgICAgICAgIC8vIHBhc3NlZCBpbiB0byB0aGUgY3JlYXRlKCkgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICBjcmVhdGVEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VTZXR0aW5nczogdGhpcy5fZGVmYXVsdHMuZGlhZ25vc3RpY3NPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlSWQ6IHRoaXMuX2RlZmF1bHRzLmxhbmd1YWdlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlU2NoZW1hUmVxdWVzdDogdGhpcy5fZGVmYXVsdHMuZGlhZ25vc3RpY3NPcHRpb25zLmVuYWJsZVNjaGVtYVJlcXVlc3RcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudCA9IHRoaXMuX3dvcmtlci5nZXRQcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50O1xyXG4gICAgfTtcclxuICAgIFdvcmtlck1hbmFnZXIucHJvdG90eXBlLmdldExhbmd1YWdlU2VydmljZVdvcmtlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICByZXNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9jbGllbnQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENsaWVudCgpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjbGllbnQpIHtcclxuICAgICAgICAgICAgX2NsaWVudCA9IGNsaWVudDtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3dvcmtlci53aXRoU3luY2VkUmVzb3VyY2VzKHJlc291cmNlcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF9jbGllbnQ7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBXb3JrZXJNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBXb3JrZXJNYW5hZ2VyIH07XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2FubmVyKHRleHQsIGlnbm9yZVRyaXZpYSkge1xuICAgIGlmIChpZ25vcmVUcml2aWEgPT09IHZvaWQgMCkgeyBpZ25vcmVUcml2aWEgPSBmYWxzZTsgfVxuICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICB2YXIgcG9zID0gMCwgdmFsdWUgPSAnJywgdG9rZW5PZmZzZXQgPSAwLCB0b2tlbiA9IDE2IC8qIFVua25vd24gKi8sIGxpbmVOdW1iZXIgPSAwLCBsaW5lU3RhcnRPZmZzZXQgPSAwLCB0b2tlbkxpbmVTdGFydE9mZnNldCA9IDAsIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldCA9IDAsIHNjYW5FcnJvciA9IDAgLyogTm9uZSAqLztcbiAgICBmdW5jdGlvbiBzY2FuSGV4RGlnaXRzKGNvdW50LCBleGFjdCkge1xuICAgICAgICB2YXIgZGlnaXRzID0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcbiAgICAgICAgd2hpbGUgKGRpZ2l0cyA8IGNvdW50IHx8ICFleGFjdCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoY2ggPj0gNDggLyogXzAgKi8gJiYgY2ggPD0gNTcgLyogXzkgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBjaCAtIDQ4IC8qIF8wICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gNjUgLyogQSAqLyAmJiBjaCA8PSA3MCAvKiBGICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA2NSAvKiBBICovICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA+PSA5NyAvKiBhICovICYmIGNoIDw9IDEwMiAvKiBmICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA5NyAvKiBhICovICsgMTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgZGlnaXRzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZ2l0cyA8IGNvdW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0UG9zaXRpb24obmV3UG9zaXRpb24pIHtcbiAgICAgICAgcG9zID0gbmV3UG9zaXRpb247XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIHRva2VuT2Zmc2V0ID0gMDtcbiAgICAgICAgdG9rZW4gPSAxNiAvKiBVbmtub3duICovO1xuICAgICAgICBzY2FuRXJyb3IgPSAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OdW1iZXIoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHBvcztcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MpID09PSA0OCAvKiBfMCAqLykge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDYgLyogZG90ICovKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAzIC8qIFVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZCA9IHBvcztcbiAgICAgICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmICh0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNjkgLyogRSAqLyB8fCB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTAxIC8qIGUgKi8pKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDMgLyogcGx1cyAqLyB8fCB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDUgLyogbWludXMgKi8pIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiBpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMyAvKiBVbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsIHN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMiAvKiBVbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMzQgLyogZG91YmxlUXVvdGUgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IDkyIC8qIGJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAyIC8qIFVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaDIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzQgLyogZG91YmxlUXVvdGUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTIgLyogYmFja3NsYXNoICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3IC8qIHNsYXNoICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk4IC8qIGIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDIgLyogZiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExMCAvKiBuICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE0IC8qIHIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTYgLyogdCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNyAvKiB1ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoMyA9IHNjYW5IZXhEaWdpdHMoNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2gzID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gNCAvKiBJbnZhbGlkVW5pY29kZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gNSAvKiBJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA+PSAwICYmIGNoIDw9IDB4MWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMiAvKiBVbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gNiAvKiBJbnZhbGlkQ2hhcmFjdGVyICovO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIGVycm9yIGJ1dCBjb250aW51ZSB3aXRoIHN0cmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICBzY2FuRXJyb3IgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIHRva2VuT2Zmc2V0ID0gcG9zO1xuICAgICAgICBsaW5lU3RhcnRPZmZzZXQgPSBsaW5lTnVtYmVyO1xuICAgICAgICBwcmV2VG9rZW5MaW5lU3RhcnRPZmZzZXQgPSB0b2tlbkxpbmVTdGFydE9mZnNldDtcbiAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRva2VuT2Zmc2V0ID0gbGVuO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTcgLyogRU9GICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIC8vIHRyaXZpYTogd2hpdGVzcGFjZVxuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNvZGUpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChpc1doaXRlU3BhY2UoY29kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTUgLyogVHJpdmlhICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyaXZpYTogbmV3bGluZXNcbiAgICAgICAgaWYgKGlzTGluZUJyZWFrKGNvZGUpKSB7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMTMgLyogY2FycmlhZ2VSZXR1cm4gKi8gJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwIC8qIGxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lTnVtYmVyKys7XG4gICAgICAgICAgICB0b2tlbkxpbmVTdGFydE9mZnNldCA9IHBvcztcbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDE0IC8qIExpbmVCcmVha1RyaXZpYSAqLztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIC8vIHRva2VuczogW117fTosXG4gICAgICAgICAgICBjYXNlIDEyMyAvKiBvcGVuQnJhY2UgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMSAvKiBPcGVuQnJhY2VUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgMTI1IC8qIGNsb3NlQnJhY2UgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDkxIC8qIG9wZW5CcmFja2V0ICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgOTMgLyogY2xvc2VCcmFja2V0ICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDU4IC8qIGNvbG9uICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDYgLyogQ29sb25Ub2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgNDQgLyogY29tbWEgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gNSAvKiBDb21tYVRva2VuICovO1xuICAgICAgICAgICAgLy8gc3RyaW5nc1xuICAgICAgICAgICAgY2FzZSAzNCAvKiBkb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMCAvKiBTdHJpbmdMaXRlcmFsICovO1xuICAgICAgICAgICAgLy8gY29tbWVudHNcbiAgICAgICAgICAgIGNhc2UgNDcgLyogc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcG9zIC0gMTtcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUtbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDcgLyogc2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBNdWx0aS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0MiAvKiBhc3RlcmlzayAqLykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVMZW5ndGggPSBsZW4gLSAxOyAvLyBGb3IgbG9va2FoZWFkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudENsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgc2FmZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDQyIC8qIGFzdGVyaXNrICovICYmIHRleHQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDcgLyogc2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50Q2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGluZUJyZWFrKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgLyogY2FycmlhZ2VSZXR1cm4gKi8gJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwIC8qIGxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5MaW5lU3RhcnRPZmZzZXQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tZW50Q2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDEgLyogVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGp1c3QgYSBzaW5nbGUgc2xhc2hcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDE2IC8qIFVua25vd24gKi87XG4gICAgICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICAgICBjYXNlIDQ1IC8qIG1pbnVzICovOlxuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gbGVuIHx8ICFpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBVbmtub3duICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvdW5kIGEgbWludXMsIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIHNvXG4gICAgICAgICAgICAvLyB3ZSBmYWxsIHRocm91Z2ggdG8gcHJvY2VlZCB3aXRoIHNjYW5uaW5nXG4gICAgICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICAgICBjYXNlIDQ4IC8qIF8wICovOlxuICAgICAgICAgICAgY2FzZSA0OSAvKiBfMSAqLzpcbiAgICAgICAgICAgIGNhc2UgNTAgLyogXzIgKi86XG4gICAgICAgICAgICBjYXNlIDUxIC8qIF8zICovOlxuICAgICAgICAgICAgY2FzZSA1MiAvKiBfNCAqLzpcbiAgICAgICAgICAgIGNhc2UgNTMgLyogXzUgKi86XG4gICAgICAgICAgICBjYXNlIDU0IC8qIF82ICovOlxuICAgICAgICAgICAgY2FzZSA1NSAvKiBfNyAqLzpcbiAgICAgICAgICAgIGNhc2UgNTYgLyogXzggKi86XG4gICAgICAgICAgICBjYXNlIDU3IC8qIF85ICovOlxuICAgICAgICAgICAgICAgIHZhbHVlICs9IHNjYW5OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMSAvKiBOdW1lcmljTGl0ZXJhbCAqLztcbiAgICAgICAgICAgIC8vIGxpdGVyYWxzIGFuZCB1bmtub3duIHN5bWJvbHNcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gaXMgYSBsaXRlcmFsPyBSZWFkIHRoZSBmdWxsIHdvcmQuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGxlbiAmJiBpc1Vua25vd25Db250ZW50Q2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbk9mZnNldCAhPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGV4dC5zdWJzdHJpbmcodG9rZW5PZmZzZXQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXdvcmRzOiB0cnVlLCBmYWxzZSwgbnVsbFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzogcmV0dXJuIHRva2VuID0gOCAvKiBUcnVlS2V5d29yZCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzogcmV0dXJuIHRva2VuID0gOSAvKiBGYWxzZUtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzogcmV0dXJuIHRva2VuID0gNyAvKiBOdWxsS2V5d29yZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBVbmtub3duICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBVbmtub3duICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkNvbnRlbnRDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGlzTGluZUJyZWFrKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDEyNSAvKiBjbG9zZUJyYWNlICovOlxuICAgICAgICAgICAgY2FzZSA5MyAvKiBjbG9zZUJyYWNrZXQgKi86XG4gICAgICAgICAgICBjYXNlIDEyMyAvKiBvcGVuQnJhY2UgKi86XG4gICAgICAgICAgICBjYXNlIDkxIC8qIG9wZW5CcmFja2V0ICovOlxuICAgICAgICAgICAgY2FzZSAzNCAvKiBkb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgIGNhc2UgNTggLyogY29sb24gKi86XG4gICAgICAgICAgICBjYXNlIDQ0IC8qIGNvbW1hICovOlxuICAgICAgICAgICAgY2FzZSA0NyAvKiBzbGFzaCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0Tm9uVHJpdmlhKCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgPSBzY2FuTmV4dCgpO1xuICAgICAgICB9IHdoaWxlIChyZXN1bHQgPj0gMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi8gJiYgcmVzdWx0IDw9IDE1IC8qIFRyaXZpYSAqLyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldFBvc2l0aW9uOiBzZXRQb3NpdGlvbixcbiAgICAgICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvczsgfSxcbiAgICAgICAgc2NhbjogaWdub3JlVHJpdmlhID8gc2Nhbk5leHROb25Ucml2aWEgOiBzY2FuTmV4dCxcbiAgICAgICAgZ2V0VG9rZW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRva2VuOyB9LFxuICAgICAgICBnZXRUb2tlblZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSxcbiAgICAgICAgZ2V0VG9rZW5PZmZzZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRva2VuT2Zmc2V0OyB9LFxuICAgICAgICBnZXRUb2tlbkxlbmd0aDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9zIC0gdG9rZW5PZmZzZXQ7IH0sXG4gICAgICAgIGdldFRva2VuU3RhcnRMaW5lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lU3RhcnRPZmZzZXQ7IH0sXG4gICAgICAgIGdldFRva2VuU3RhcnRDaGFyYWN0ZXI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRva2VuT2Zmc2V0IC0gcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0OyB9LFxuICAgICAgICBnZXRUb2tlbkVycm9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY2FuRXJyb3I7IH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgIHJldHVybiBjaCA9PT0gMzIgLyogc3BhY2UgKi8gfHwgY2ggPT09IDkgLyogdGFiICovIHx8IGNoID09PSAxMSAvKiB2ZXJ0aWNhbFRhYiAqLyB8fCBjaCA9PT0gMTIgLyogZm9ybUZlZWQgKi8gfHxcbiAgICAgICAgY2ggPT09IDE2MCAvKiBub25CcmVha2luZ1NwYWNlICovIHx8IGNoID09PSA1NzYwIC8qIG9naGFtICovIHx8IGNoID49IDgxOTIgLyogZW5RdWFkICovICYmIGNoIDw9IDgyMDMgLyogemVyb1dpZHRoU3BhY2UgKi8gfHxcbiAgICAgICAgY2ggPT09IDgyMzkgLyogbmFycm93Tm9CcmVha1NwYWNlICovIHx8IGNoID09PSA4Mjg3IC8qIG1hdGhlbWF0aWNhbFNwYWNlICovIHx8IGNoID09PSAxMjI4OCAvKiBpZGVvZ3JhcGhpY1NwYWNlICovIHx8IGNoID09PSA2NTI3OSAvKiBieXRlT3JkZXJNYXJrICovO1xufVxuZnVuY3Rpb24gaXNMaW5lQnJlYWsoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDEwIC8qIGxpbmVGZWVkICovIHx8IGNoID09PSAxMyAvKiBjYXJyaWFnZVJldHVybiAqLyB8fCBjaCA9PT0gODIzMiAvKiBsaW5lU2VwYXJhdG9yICovIHx8IGNoID09PSA4MjMzIC8qIHBhcmFncmFwaFNlcGFyYXRvciAqLztcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY2gpIHtcbiAgICByZXR1cm4gY2ggPj0gNDggLyogXzAgKi8gJiYgY2ggPD0gNTcgLyogXzkgKi87XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGNyZWF0ZVNjYW5uZXIgfSBmcm9tICcuL3NjYW5uZXIuanMnO1xudmFyIFBhcnNlT3B0aW9ucztcbihmdW5jdGlvbiAoUGFyc2VPcHRpb25zKSB7XG4gICAgUGFyc2VPcHRpb25zLkRFRkFVTFQgPSB7XG4gICAgICAgIGFsbG93VHJhaWxpbmdDb21tYTogZmFsc2VcbiAgICB9O1xufSkoUGFyc2VPcHRpb25zIHx8IChQYXJzZU9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBGb3IgYSBnaXZlbiBvZmZzZXQsIGV2YWx1YXRlIHRoZSBsb2NhdGlvbiBpbiB0aGUgSlNPTiBkb2N1bWVudC4gRWFjaCBzZWdtZW50IGluIHRoZSBsb2NhdGlvbiBwYXRoIGlzIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYW4gYXJyYXkgaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbih0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBzZWdtZW50cyA9IFtdOyAvLyBzdHJpbmdzIG9yIG51bWJlcnNcbiAgICB2YXIgZWFybHlSZXR1cm5FeGNlcHRpb24gPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJldmlvdXNOb2RlSW5zdCA9IHtcbiAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHBhcmVudDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB2YXIgaXNBdFByb3BlcnR5S2V5ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc2V0UHJldmlvdXNOb2RlKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCwgdHlwZSkge1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3Qub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC50eXBlID0gdHlwZTtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC5jb2xvbk9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcHJldmlvdXNOb2RlID0gcHJldmlvdXNOb2RlSW5zdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmlzaXQodGV4dCwge1xuICAgICAgICAgICAgb25PYmplY3RCZWdpbjogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlzQXRQcm9wZXJ0eUtleSA9IHBvc2l0aW9uID4gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goJycpOyAvLyBwdXNoIGEgcGxhY2Vob2xkZXIgKHdpbGwgYmUgcmVwbGFjZWQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PYmplY3RQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c05vZGUobmFtZSwgb2Zmc2V0LCBsZW5ndGgsICdwcm9wZXJ0eScpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk9iamVjdEVuZDogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQXJyYXlCZWdpbjogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BcnJheUVuZDogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c05vZGUodmFsdWUsIG9mZnNldCwgbGVuZ3RoLCBnZXROb2RlVHlwZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VwYXJhdG9yOiBmdW5jdGlvbiAoc2VwLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICc6JyAmJiBwcmV2aW91c05vZGUgJiYgcHJldmlvdXNOb2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlLmNvbG9uT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpc0F0UHJvcGVydHlLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXAgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IGxhc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlICE9PSBlYXJseVJldHVybkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBzZWdtZW50cyxcbiAgICAgICAgcHJldmlvdXNOb2RlOiBwcmV2aW91c05vZGUsXG4gICAgICAgIGlzQXRQcm9wZXJ0eUtleTogaXNBdFByb3BlcnR5S2V5LFxuICAgICAgICBtYXRjaGVzOiBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGsgPCBwYXR0ZXJuLmxlbmd0aCAmJiBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybltrXSA9PT0gc2VnbWVudHNbaV0gfHwgcGF0dGVybltrXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybltrXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGsgPT09IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIHRoZSBvYmplY3QgdGhlIEpTT04gY29udGVudCByZXByZXNlbnRzLiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICogVGhlcmVmb3JlIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGVycm9ycywgb3B0aW9ucykge1xuICAgIGlmIChlcnJvcnMgPT09IHZvaWQgMCkgeyBlcnJvcnMgPSBbXTsgfVxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IFBhcnNlT3B0aW9ucy5ERUZBVUxUOyB9XG4gICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBbXTtcbiAgICB2YXIgcHJldmlvdXNQYXJlbnRzID0gW107XG4gICAgZnVuY3Rpb24gb25WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UGFyZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50UHJvcGVydHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRbY3VycmVudFByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB2aXNpdG9yID0ge1xuICAgICAgICBvbk9iamVjdEJlZ2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBvblZhbHVlKG9iamVjdCk7XG4gICAgICAgICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvYmplY3Q7XG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2aW91c1BhcmVudHMucG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICBvblZhbHVlKGFycmF5KTtcbiAgICAgICAgICAgIHByZXZpb3VzUGFyZW50cy5wdXNoKGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGFycmF5O1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25BcnJheUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHByZXZpb3VzUGFyZW50cy5wb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6IG9uVmFsdWUsXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgZXJyb3I6IGVycm9yLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50UGFyZW50WzBdO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgYSB0cmVlIHJlcHJlc2VudGF0aW9uIHRoZSBKU09OIGNvbnRlbnQuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyZWUodGV4dCwgZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gUGFyc2VPcHRpb25zLkRFRkFVTFQ7IH1cbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHsgdHlwZTogJ2FycmF5Jywgb2Zmc2V0OiAtMSwgbGVuZ3RoOiAtMSwgY2hpbGRyZW46IFtdLCBwYXJlbnQ6IHVuZGVmaW5lZCB9OyAvLyBhcnRpZmljaWFsIHJvb3RcbiAgICBmdW5jdGlvbiBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoY3VycmVudFBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IGVuZE9mZnNldCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVmFsdWUodmFsdWVOb2RlKSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICByZXR1cm4gdmFsdWVOb2RlO1xuICAgIH1cbiAgICB2YXIgdmlzaXRvciA9IHtcbiAgICAgICAgb25PYmplY3RCZWdpbjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAnb2JqZWN0Jywgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvblZhbHVlKHsgdHlwZTogJ3Byb3BlcnR5Jywgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBuYW1lLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGgsIHBhcmVudDogY3VycmVudFBhcmVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpOyAvLyBpbiBjYXNlIG9mIGEgbWlzc2luZyB2YWx1ZSBmb3IgYSBwcm9wZXJ0eTogbWFrZSBzdXJlIHByb3BlcnR5IGlzIGNvbXBsZXRlXG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IG9mZnNldCArIGxlbmd0aCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5QmVnaW46IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAnYXJyYXknLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiAtMSwgcGFyZW50OiBjdXJyZW50UGFyZW50LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlFbmQ6IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5sZW5ndGggPSBvZmZzZXQgKyBsZW5ndGggLSBjdXJyZW50UGFyZW50Lm9mZnNldDtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGVuc3VyZVByb3BlcnR5Q29tcGxldGUob2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG9uVmFsdWUoeyB0eXBlOiBnZXROb2RlVHlwZSh2YWx1ZSksIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCwgcGFyZW50OiBjdXJyZW50UGFyZW50LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2VwYXJhdG9yOiBmdW5jdGlvbiAoc2VwLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmNvbG9uT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXAgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7IGVycm9yOiBlcnJvciwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2aXNpdCh0ZXh0LCB2aXNpdG9yLCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gY3VycmVudFBhcmVudC5jaGlsZHJlblswXTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcGF0aCBpbiBhIEpTT04gRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVBdExvY2F0aW9uKHJvb3QsIHBhdGgpIHtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIF9pID0gMCwgcGF0aF8xID0gcGF0aDsgX2kgPCBwYXRoXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gcGF0aF8xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ29iamVjdCcgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gbm9kZS5jaGlsZHJlbjsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOb2RlID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5Tm9kZS5jaGlsZHJlbikgJiYgcHJvcGVydHlOb2RlLmNoaWxkcmVuWzBdLnZhbHVlID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwcm9wZXJ0eU5vZGUuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWdtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2FycmF5JyB8fCBpbmRleCA8IDAgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgfHwgaW5kZXggPj0gbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBKU09OIHBhdGggb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVQYXRoKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUucGFyZW50IHx8ICFub2RlLnBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBwYXRoID0gZ2V0Tm9kZVBhdGgobm9kZS5wYXJlbnQpO1xuICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgIHZhciBrZXkgPSBub2RlLnBhcmVudC5jaGlsZHJlblswXS52YWx1ZTtcbiAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbm9kZS5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBKYXZhU2NyaXB0IG9iamVjdCBvZiB0aGUgZ2l2ZW4gSlNPTiBET00gbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVZhbHVlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZ2V0Tm9kZVZhbHVlKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlTm9kZSA9IHByb3AuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcC5jaGlsZHJlblswXS52YWx1ZV0gPSBnZXROb2RlVmFsdWUodmFsdWVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpIHtcbiAgICBpZiAoaW5jbHVkZVJpZ2h0Qm91bmQgPT09IHZvaWQgMCkgeyBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIChvZmZzZXQgPj0gbm9kZS5vZmZzZXQgJiYgb2Zmc2V0IDwgKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKSB8fCBpbmNsdWRlUmlnaHRCb3VuZCAmJiAob2Zmc2V0ID09PSAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbW9zdCBpbm5lciBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVBdE9mZnNldChub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKSB7XG4gICAgaWYgKGluY2x1ZGVSaWdodEJvdW5kID09PSB2b2lkIDApIHsgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZTsgfVxuICAgIGlmIChjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2ldLm9mZnNldCA8PSBvZmZzZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZmluZE5vZGVBdE9mZnNldChjaGlsZHJlbltpXSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVDsgfVxuICAgIHZhciBfc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIodGV4dCwgZmFsc2UpO1xuICAgIGZ1bmN0aW9uIHRvTm9BcmdWaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpOyB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdmlzaXRGdW5jdGlvbihhcmcsIF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSk7IH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIH1cbiAgICB2YXIgb25PYmplY3RCZWdpbiA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0QmVnaW4pLCBvbk9iamVjdFByb3BlcnR5ID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0UHJvcGVydHkpLCBvbk9iamVjdEVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0RW5kKSwgb25BcnJheUJlZ2luID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25BcnJheUJlZ2luKSwgb25BcnJheUVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uQXJyYXlFbmQpLCBvbkxpdGVyYWxWYWx1ZSA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkxpdGVyYWxWYWx1ZSksIG9uU2VwYXJhdG9yID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uU2VwYXJhdG9yKSwgb25Db21tZW50ID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25Db21tZW50KSwgb25FcnJvciA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkVycm9yKTtcbiAgICB2YXIgZGlzYWxsb3dDb21tZW50cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhbGxvd0NvbW1lbnRzO1xuICAgIHZhciBhbGxvd1RyYWlsaW5nQ29tbWEgPSBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hO1xuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gX3NjYW5uZXIuc2NhbigpO1xuICAgICAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogSW52YWxpZFVuaWNvZGUgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE0IC8qIEludmFsaWRVbmljb2RlICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIEludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE1IC8qIEludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogVW5leHBlY3RlZEVuZE9mTnVtYmVyICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMyAvKiBVbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMSAvKiBVbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMiAvKiBVbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYgLyogSW52YWxpZENoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTYgLyogSW52YWxpZENoYXJhY3RlciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhbGxvd0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMCAvKiBJbnZhbGlkQ29tbWVudFRva2VuICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTYgLyogVW5rbm93biAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMSAvKiBJbnZhbGlkU3ltYm9sICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNSAvKiBUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNCAvKiBMaW5lQnJlYWtUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgc2tpcFVudGlsQWZ0ZXIsIHNraXBVbnRpbCkge1xuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIgPT09IHZvaWQgMCkgeyBza2lwVW50aWxBZnRlciA9IFtdOyB9XG4gICAgICAgIGlmIChza2lwVW50aWwgPT09IHZvaWQgMCkgeyBza2lwVW50aWwgPSBbXTsgfVxuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBfc2Nhbm5lci5nZXRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChza2lwVW50aWwuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoaXNWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgIGlmIChpc1ZhbHVlKSB7XG4gICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbk9iamVjdFByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuTmV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VMaXRlcmFsKCkge1xuICAgICAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMTEgLyogTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuVmFsdWUgPSBfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHRva2VuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMiAvKiBJbnZhbGlkTnVtYmVyRm9ybWF0ICovKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDcgLyogTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDggLyogVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogRmFsc2VLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNjYW5OZXh0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5KCkge1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTAgLyogU3RyaW5nTGl0ZXJhbCAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoMyAvKiBQcm9wZXJ0eU5hbWVFeHBlY3RlZCAqLywgW10sIFsyIC8qIENsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTdHJpbmcoZmFsc2UpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNiAvKiBDb2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBvblNlcGFyYXRvcignOicpO1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb2xvblxuICAgICAgICAgICAgaWYgKCFwYXJzZVZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoNSAvKiBDb2xvbkV4cGVjdGVkICovLCBbXSwgWzIgLyogQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIENvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3QoKSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW4oKTtcbiAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBvcGVuIGJyYWNlXG4gICAgICAgIHZhciBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIENsb3NlQnJhY2VUb2tlbiAqLyAmJiBfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIENvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8gJiYgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig2IC8qIENvbW1hRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlUHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDQgLyogVmFsdWVFeHBlY3RlZCAqLywgW10sIFsyIC8qIENsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvbk9iamVjdEVuZCgpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKDcgLyogQ2xvc2VCcmFjZUV4cGVjdGVkICovLCBbMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi9dLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNsb3NlIGJyYWNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgICAgIG9uQXJyYXlCZWdpbigpO1xuICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIG9wZW4gYnJhY2tldFxuICAgICAgICB2YXIgbmVlZHNDb21tYSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIENvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDYgLyogQ29tbWFFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgWzQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVlZHNDb21tYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb25BcnJheUVuZCgpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoOCAvKiBDbG9zZUJyYWNrZXRFeHBlY3RlZCAqLywgWzQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi9dLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNsb3NlIGJyYWNrZXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSgpIHtcbiAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgICBjYXNlIDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAxIC8qIE9wZW5CcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBTdHJpbmdMaXRlcmFsICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZyh0cnVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTGl0ZXJhbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5OZXh0KCk7XG4gICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0VtcHR5Q29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDQgLyogVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDkgLyogRW5kT2ZGaWxlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBUYWtlcyBKU09OIHdpdGggSmF2YVNjcmlwdC1zdHlsZSBjb21tZW50cyBhbmQgcmVtb3ZlXG4gKiB0aGVtLiBPcHRpb25hbGx5IHJlcGxhY2VzIGV2ZXJ5IG5vbmUtbmV3bGluZSBjaGFyYWN0ZXJcbiAqIG9mIGNvbW1lbnRzIHdpdGggYSByZXBsYWNlQ2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcENvbW1lbnRzKHRleHQsIHJlcGxhY2VDaCkge1xuICAgIHZhciBfc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIodGV4dCksIHBhcnRzID0gW10sIGtpbmQsIG9mZnNldCA9IDAsIHBvcztcbiAgICBkbyB7XG4gICAgICAgIHBvcyA9IF9zY2FubmVyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGtpbmQgPSBfc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAxMiAvKiBMaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTMgLyogQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgY2FzZSAxNyAvKiBFT0YgKi86XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBwb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VDaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpLnJlcGxhY2UoL1teXFxyXFxuXS9nLCByZXBsYWNlQ2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3NjYW5uZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGtpbmQgIT09IDE3IC8qIEVPRiAqLyk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICdudWxsJztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGZvcm1hdCwgaXNFT0wgfSBmcm9tICcuL2Zvcm1hdC5qcyc7XG5pbXBvcnQgeyBwYXJzZVRyZWUsIGZpbmROb2RlQXRMb2NhdGlvbiB9IGZyb20gJy4vcGFyc2VyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0eSh0ZXh0LCBwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHNldFByb3BlcnR5KHRleHQsIHBhdGgsIHZvaWQgMCwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkodGV4dCwgb3JpZ2luYWxQYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcGF0aCA9IG9yaWdpbmFsUGF0aC5zbGljZSgpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgcm9vdCA9IHBhcnNlVHJlZSh0ZXh0LCBlcnJvcnMpO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gdm9pZCAwO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGFzdFNlZ21lbnQgPSBwYXRoLnBvcCgpO1xuICAgICAgICBwYXJlbnQgPSBmaW5kTm9kZUF0TG9jYXRpb24ocm9vdCwgcGF0aCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKF9hID0ge30sIF9hW2xhc3RTZWdtZW50XSA9IHZhbHVlLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAvLyBlbXB0eSBkb2N1bWVudFxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZWxldGUgaW4gZW1wdHkgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgeyBvZmZzZXQ6IHJvb3QgPyByb290Lm9mZnNldCA6IDAsIGxlbmd0aDogcm9vdCA/IHJvb3QubGVuZ3RoIDogMCwgY29udGVudDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gZmluZE5vZGVBdExvY2F0aW9uKHBhcmVudCwgW2xhc3RTZWdtZW50XSk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBBU1QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihleGlzdGluZy5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVCZWdpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlRW5kID0gZXhpc3RpbmcucGFyZW50Lm9mZnNldCArIGV4aXN0aW5nLnBhcmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29tbWEgb2YgdGhlIHByZXZpb3VzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3Byb3BlcnR5SW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQmVnaW4gPSBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVCZWdpbiA9IHBhcmVudC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29tbWEgb2YgdGhlIG5leHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBwYXJlbnQuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFbmQgPSBuZXh0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgeyBvZmZzZXQ6IHJlbW92ZUJlZ2luLCBsZW5ndGg6IHJlbW92ZUVuZCAtIHJlbW92ZUJlZ2luLCBjb250ZW50OiAnJyB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZSBvZiBleGlzdGluZyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogZXhpc3Rpbmcub2Zmc2V0LCBsZW5ndGg6IGV4aXN0aW5nLmxlbmd0aCwgY29udGVudDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCwgbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1Byb3BlcnR5ID0gSlNPTi5zdHJpbmdpZnkobGFzdFNlZ21lbnQpICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gb3B0aW9ucy5nZXRJbnNlcnRpb25JbmRleCA/IG9wdGlvbnMuZ2V0SW5zZXJ0aW9uSW5kZXgocGFyZW50LmNoaWxkcmVuLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jaGlsZHJlblswXS52YWx1ZTsgfSkpIDogcGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBlZGl0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoLCBsZW5ndGg6IDAsIGNvbnRlbnQ6ICcsJyArIG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSArICcsJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudC50eXBlID09PSAnYXJyYXknICYmIHR5cGVvZiBsYXN0U2VnbWVudCA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShwYXJlbnQuY2hpbGRyZW4pKSB7XG4gICAgICAgIHZhciBpbnNlcnRJbmRleCA9IGxhc3RTZWdtZW50O1xuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRcbiAgICAgICAgICAgIHZhciBuZXdQcm9wZXJ0eSA9IFwiXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgZWRpdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmFsXG4gICAgICAgICAgICB2YXIgcmVtb3ZhbEluZGV4ID0gbGFzdFNlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4XTtcbiAgICAgICAgICAgIHZhciBlZGl0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGl0ZW1cbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IHBhcmVudC5sZW5ndGggLSAyLCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEgPT09IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltyZW1vdmFsSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbmRPZmZzZXQgPSBwYXJlbnQub2Zmc2V0ICsgcGFyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBwYXJlbnRFbmRPZmZzZXQgLSAyIC0gb2Zmc2V0LCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiB0b1JlbW92ZS5vZmZzZXQsIGxlbmd0aDogcGFyZW50LmNoaWxkcmVuW3JlbW92YWxJbmRleCArIDFdLm9mZnNldCAtIHRvUmVtb3ZlLm9mZnNldCwgY29udGVudDogJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgZWRpdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBuZXdQcm9wZXJ0eSA9IFwiXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaXNBcnJheUluc2VydGlvbiAmJiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gbGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9Nb2RpZnkgPSBwYXJlbnQuY2hpbGRyZW5bbGFzdFNlZ21lbnRdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogdG9Nb2RpZnkub2Zmc2V0LCBsZW5ndGg6IHRvTW9kaWZ5Lmxlbmd0aCwgY29udGVudDogbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgbGFzdFNlZ21lbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBuZXdQcm9wZXJ0eSA6IG5ld1Byb3BlcnR5ICsgJywnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsYXN0U2VnbWVudCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPyBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIDogbGFzdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGgsIGxlbmd0aDogMCwgY29udGVudDogJywnICsgbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgXCIgKyAodmFsdWUgPT09IHZvaWQgMCA/ICdyZW1vdmUnIDogKG9wdGlvbnMuaXNBcnJheUluc2VydGlvbiA/ICdpbnNlcnQnIDogJ21vZGlmeScpKSArIFwiIEFycmF5IGluZGV4IFwiICsgaW5zZXJ0SW5kZXggKyBcIiBhcyBsZW5ndGggaXMgbm90IHN1ZmZpY2llbnRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWRkIFwiICsgKHR5cGVvZiBsYXN0U2VnbWVudCAhPT0gJ251bWJlcicgPyAnaW5kZXgnIDogJ3Byb3BlcnR5JykgKyBcIiB0byBwYXJlbnQgb2YgdHlwZSBcIiArIHBhcmVudC50eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBbZWRpdF07XG4gICAgfVxuICAgIC8vIGFwcGx5IHRoZSBlZGl0XG4gICAgdmFyIG5ld1RleHQgPSBhcHBseUVkaXQodGV4dCwgZWRpdCk7XG4gICAgLy8gZm9ybWF0IHRoZSBuZXcgdGV4dFxuICAgIHZhciBiZWdpbiA9IGVkaXQub2Zmc2V0O1xuICAgIHZhciBlbmQgPSBlZGl0Lm9mZnNldCArIGVkaXQuY29udGVudC5sZW5ndGg7XG4gICAgaWYgKGVkaXQubGVuZ3RoID09PSAwIHx8IGVkaXQuY29udGVudC5sZW5ndGggPT09IDApIHsgLy8gaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmICFpc0VPTChuZXdUZXh0LCBiZWdpbiAtIDEpKSB7XG4gICAgICAgICAgICBiZWdpbi0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBuZXdUZXh0Lmxlbmd0aCAmJiAhaXNFT0wobmV3VGV4dCwgZW5kKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGVkaXRzID0gZm9ybWF0KG5ld1RleHQsIHsgb2Zmc2V0OiBiZWdpbiwgbGVuZ3RoOiBlbmQgLSBiZWdpbiB9LCBvcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zKTtcbiAgICAvLyBhcHBseSB0aGUgZm9ybWF0dGluZyBlZGl0cyBhbmQgdHJhY2sgdGhlIGJlZ2luIGFuZCBlbmQgb2Zmc2V0cyBvZiB0aGUgY2hhbmdlc1xuICAgIGZvciAodmFyIGkgPSBlZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZWRpdF8xID0gZWRpdHNbaV07XG4gICAgICAgIG5ld1RleHQgPSBhcHBseUVkaXQobmV3VGV4dCwgZWRpdF8xKTtcbiAgICAgICAgYmVnaW4gPSBNYXRoLm1pbihiZWdpbiwgZWRpdF8xLm9mZnNldCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KGVuZCwgZWRpdF8xLm9mZnNldCArIGVkaXRfMS5sZW5ndGgpO1xuICAgICAgICBlbmQgKz0gZWRpdF8xLmNvbnRlbnQubGVuZ3RoIC0gZWRpdF8xLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgc2luZ2xlIGVkaXQgd2l0aCBhbGwgY2hhbmdlc1xuICAgIHZhciBlZGl0TGVuZ3RoID0gdGV4dC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggLSBlbmQpIC0gYmVnaW47XG4gICAgcmV0dXJuIFt7IG9mZnNldDogYmVnaW4sIGxlbmd0aDogZWRpdExlbmd0aCwgY29udGVudDogbmV3VGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCkgfV07XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlFZGl0KHRleHQsIGVkaXQpIHtcbiAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoMCwgZWRpdC5vZmZzZXQpICsgZWRpdC5jb250ZW50ICsgdGV4dC5zdWJzdHJpbmcoZWRpdC5vZmZzZXQgKyBlZGl0Lmxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNXUyh0ZXh0LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gJ1xcclxcbiBcXHQnLmluZGV4T2YodGV4dC5jaGFyQXQob2Zmc2V0KSkgIT09IC0xO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyBmb3JtYXR0ZXIgZnJvbSAnLi9pbXBsL2Zvcm1hdC5qcyc7XG5pbXBvcnQgKiBhcyBlZGl0IGZyb20gJy4vaW1wbC9lZGl0LmpzJztcbmltcG9ydCAqIGFzIHNjYW5uZXIgZnJvbSAnLi9pbXBsL3NjYW5uZXIuanMnO1xuaW1wb3J0ICogYXMgcGFyc2VyIGZyb20gJy4vaW1wbC9wYXJzZXIuanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCB2YXIgY3JlYXRlU2Nhbm5lciA9IHNjYW5uZXIuY3JlYXRlU2Nhbm5lcjtcbi8qKlxuICogRm9yIGEgZ2l2ZW4gb2Zmc2V0LCBldmFsdWF0ZSB0aGUgbG9jYXRpb24gaW4gdGhlIEpTT04gZG9jdW1lbnQuIEVhY2ggc2VnbWVudCBpbiB0aGUgbG9jYXRpb24gcGF0aCBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBuYW1lIG9yIGFuIGFycmF5IGluZGV4LlxuICovXG5leHBvcnQgdmFyIGdldExvY2F0aW9uID0gcGFyc2VyLmdldExvY2F0aW9uO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgdGhlIG9iamVjdCB0aGUgSlNPTiBjb250ZW50IHJlcHJlc2VudHMuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKiBUaGVyZWZvcmUsIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuZXhwb3J0IHZhciBwYXJzZSA9IHBhcnNlci5wYXJzZTtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIGEgdHJlZSByZXByZXNlbnRhdGlvbiB0aGUgSlNPTiBjb250ZW50LiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICovXG5leHBvcnQgdmFyIHBhcnNlVHJlZSA9IHBhcnNlci5wYXJzZVRyZWU7XG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwYXRoIGluIGEgSlNPTiBET00uXG4gKi9cbmV4cG9ydCB2YXIgZmluZE5vZGVBdExvY2F0aW9uID0gcGFyc2VyLmZpbmROb2RlQXRMb2NhdGlvbjtcbi8qKlxuICogRmluZHMgdGhlIGlubmVybW9zdCBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5leHBvcnQgdmFyIGZpbmROb2RlQXRPZmZzZXQgPSBwYXJzZXIuZmluZE5vZGVBdE9mZnNldDtcbi8qKlxuICogR2V0cyB0aGUgSlNPTiBwYXRoIG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmV4cG9ydCB2YXIgZ2V0Tm9kZVBhdGggPSBwYXJzZXIuZ2V0Tm9kZVBhdGg7XG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgSmF2YVNjcmlwdCBvYmplY3Qgb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuZXhwb3J0IHZhciBnZXROb2RlVmFsdWUgPSBwYXJzZXIuZ2V0Tm9kZVZhbHVlO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZXhwb3J0IHZhciB2aXNpdCA9IHBhcnNlci52aXNpdDtcbi8qKlxuICogVGFrZXMgSlNPTiB3aXRoIEphdmFTY3JpcHQtc3R5bGUgY29tbWVudHMgYW5kIHJlbW92ZVxuICogdGhlbS4gT3B0aW9uYWxseSByZXBsYWNlcyBldmVyeSBub25lLW5ld2xpbmUgY2hhcmFjdGVyXG4gKiBvZiBjb21tZW50cyB3aXRoIGEgcmVwbGFjZUNoYXJhY3RlclxuICovXG5leHBvcnQgdmFyIHN0cmlwQ29tbWVudHMgPSBwYXJzZXIuc3RyaXBDb21tZW50cztcbmV4cG9ydCBmdW5jdGlvbiBwcmludFBhcnNlRXJyb3JDb2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIEludmFsaWRTeW1ib2wgKi86IHJldHVybiAnSW52YWxpZFN5bWJvbCc7XG4gICAgICAgIGNhc2UgMiAvKiBJbnZhbGlkTnVtYmVyRm9ybWF0ICovOiByZXR1cm4gJ0ludmFsaWROdW1iZXJGb3JtYXQnO1xuICAgICAgICBjYXNlIDMgLyogUHJvcGVydHlOYW1lRXhwZWN0ZWQgKi86IHJldHVybiAnUHJvcGVydHlOYW1lRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDQgLyogVmFsdWVFeHBlY3RlZCAqLzogcmV0dXJuICdWYWx1ZUV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA1IC8qIENvbG9uRXhwZWN0ZWQgKi86IHJldHVybiAnQ29sb25FeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgNiAvKiBDb21tYUV4cGVjdGVkICovOiByZXR1cm4gJ0NvbW1hRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDcgLyogQ2xvc2VCcmFjZUV4cGVjdGVkICovOiByZXR1cm4gJ0Nsb3NlQnJhY2VFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOCAvKiBDbG9zZUJyYWNrZXRFeHBlY3RlZCAqLzogcmV0dXJuICdDbG9zZUJyYWNrZXRFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOSAvKiBFbmRPZkZpbGVFeHBlY3RlZCAqLzogcmV0dXJuICdFbmRPZkZpbGVFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgMTAgLyogSW52YWxpZENvbW1lbnRUb2tlbiAqLzogcmV0dXJuICdJbnZhbGlkQ29tbWVudFRva2VuJztcbiAgICAgICAgY2FzZSAxMSAvKiBVbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOiByZXR1cm4gJ1VuZXhwZWN0ZWRFbmRPZkNvbW1lbnQnO1xuICAgICAgICBjYXNlIDEyIC8qIFVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZTdHJpbmcnO1xuICAgICAgICBjYXNlIDEzIC8qIFVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZOdW1iZXInO1xuICAgICAgICBjYXNlIDE0IC8qIEludmFsaWRVbmljb2RlICovOiByZXR1cm4gJ0ludmFsaWRVbmljb2RlJztcbiAgICAgICAgY2FzZSAxNSAvKiBJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovOiByZXR1cm4gJ0ludmFsaWRFc2NhcGVDaGFyYWN0ZXInO1xuICAgICAgICBjYXNlIDE2IC8qIEludmFsaWRDaGFyYWN0ZXIgKi86IHJldHVybiAnSW52YWxpZENoYXJhY3Rlcic7XG4gICAgfVxuICAgIHJldHVybiAnPHVua25vd24gUGFyc2VFcnJvckNvZGU+Jztcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXRzIG5lZWRlZCB0byBmb3JtYXQgYSBKU09OIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudFRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gZm9ybWF0IG9yIGB1bmRlZmluZWRgIHRvIGZvcm1hdCB0aGUgZnVsbCBjb250ZW50XG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgZm9ybWF0dGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgZWRpdCBvcGVyYXRpb25zIGRlc2NyaWJpbmcgdGhlIGZvcm1hdHRpbmcgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuIEVkaXRzIGNhbiBiZSBlaXRoZXIgaW5zZXJ0cywgcmVwbGFjZW1lbnRzIG9yXG4gKiByZW1vdmFscyBvZiB0ZXh0IHNlZ21lbnRzLiBBbGwgb2Zmc2V0cyByZWZlciB0byB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50LiBObyB0d28gZWRpdHMgbXVzdCBjaGFuZ2Ugb3IgcmVtb3ZlIHRoZSBzYW1lIHJhbmdlIG9mXG4gKiB0ZXh0IGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudC4gSG93ZXZlciwgbXVsdGlwbGUgZWRpdHMgY2FuIGhhdmVcbiAqIHRoZSBzYW1lIG9mZnNldCwgZm9yIGV4YW1wbGUgbXVsdGlwbGUgaW5zZXJ0cywgb3IgYW4gaW5zZXJ0IGZvbGxvd2VkIGJ5IGEgcmVtb3ZlIG9yIHJlcGxhY2UuIFRoZSBvcmRlciBpbiB0aGUgYXJyYXkgZGVmaW5lcyB3aGljaCBlZGl0IGlzIGFwcGxpZWQgZmlyc3QuXG4gKiBUbyBhcHBseSBlZGl0cyB0byBhbiBpbnB1dCwgeW91IGNhbiB1c2UgYGFwcGx5RWRpdHNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGRvY3VtZW50VGV4dCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChkb2N1bWVudFRleHQsIHJhbmdlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXRzIG5lZWRlZCB0byBtb2RpZnkgYSB2YWx1ZSBpbiB0aGUgSlNPTiBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnRUZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgdmFsdWUgdG8gY2hhbmdlLiBUaGUgcGF0aCByZXByZXNlbnRzIGVpdGhlciB0byB0aGUgZG9jdW1lbnQgcm9vdCwgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBpdGVtLlxuICogSWYgdGhlIHBhdGggcG9pbnRzIHRvIGFuIG5vbi1leGlzdGluZyBwcm9wZXJ0eSBvciBpdGVtLCBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBvciBpdGVtLiBJZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLFxuICogdGhlIHByb3BlcnR5IG9yIGl0ZW0gd2lsbCBiZSByZW1vdmVkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICogQHJldHVybnMgQSBsaXN0IG9mIGVkaXQgb3BlcmF0aW9ucyBkZXNjcmliaW5nIHRoZSBmb3JtYXR0aW5nIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50LiBFZGl0cyBjYW4gYmUgZWl0aGVyIGluc2VydHMsIHJlcGxhY2VtZW50cyBvclxuICogcmVtb3ZhbHMgb2YgdGV4dCBzZWdtZW50cy4gQWxsIG9mZnNldHMgcmVmZXIgdG8gdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudC4gTm8gdHdvIGVkaXRzIG11c3QgY2hhbmdlIG9yIHJlbW92ZSB0aGUgc2FtZSByYW5nZSBvZlxuICogdGV4dCBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuIEhvd2V2ZXIsIG11bHRpcGxlIGVkaXRzIGNhbiBoYXZlXG4gKiB0aGUgc2FtZSBvZmZzZXQsIGZvciBleGFtcGxlIG11bHRpcGxlIGluc2VydHMsIG9yIGFuIGluc2VydCBmb2xsb3dlZCBieSBhIHJlbW92ZSBvciByZXBsYWNlLiBUaGUgb3JkZXIgaW4gdGhlIGFycmF5IGRlZmluZXMgd2hpY2ggZWRpdCBpcyBhcHBsaWVkIGZpcnN0LlxuICogVG8gYXBwbHkgZWRpdHMgdG8gYW4gaW5wdXQsIHlvdSBjYW4gdXNlIGBhcHBseUVkaXRzYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmeSh0ZXh0LCBwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0LnNldFByb3BlcnR5KHRleHQsIHBhdGgsIHZhbHVlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQXBwbGllcyBlZGl0cyB0byBhIGlucHV0IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RWRpdHModGV4dCwgZWRpdHMpIHtcbiAgICBmb3IgKHZhciBpID0gZWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGV4dCA9IGVkaXQuYXBwbHlFZGl0KHRleHQsIGVkaXRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xuICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChBcnJheS5pc0FycmF5KG9uZSkpICE9PSAoQXJyYXkuaXNBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGksIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbmUpKSB7XG4gICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9uZUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb25lKSB7XG4gICAgICAgICAgICBvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvbmVLZXlzLnNvcnQoKTtcbiAgICAgICAgdmFyIG90aGVyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmIChoYXlzdGFjay5sZW5ndGggPCBuZWVkbGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWVkbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhheXN0YWNrW2ldICE9PSBuZWVkbGVbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBoYXlzdGFjayBlbmRzIHdpdGggbmVlZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kc1dpdGgoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIHZhciBkaWZmID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlLmxlbmd0aDtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLmxhc3RJbmRleE9mKG5lZWRsZSkgPT09IGRpZmY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrID09PSBuZWVkbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9bXFwqXS9nLCAnLionKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXQodmFsdWUsIGNvdW50KSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgICAgcyArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgY291bnQgPSBjb3VudCA+Pj4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kZWRSZWdFeHAocGF0dGVybikge1xuICAgIGlmIChzdGFydHNXaXRoKHBhdHRlcm4sICcoP2kpJykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybi5zdWJzdHJpbmcoNCksICdpJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG59XG4iLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4ndXNlIHN0cmljdCc7XG5leHBvcnQgdmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0Nztcbn0pKGludGVnZXIgfHwgKGludGVnZXIgPSB7fSkpO1xuZXhwb3J0IHZhciB1aW50ZWdlcjtcbihmdW5jdGlvbiAodWludGVnZXIpIHtcbiAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgIHVpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbUG9zaXRpb25dKCNQb3NpdGlvbikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3RlcjogY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW1Bvc2l0aW9uXSgjUG9zaXRpb24pIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5jaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBQb3NpdGlvbi5pcyA9IGlzO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW1JhbmdlXSgjUmFuZ2UpIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFJhbmdlO1xuKGZ1bmN0aW9uIChSYW5nZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcbiAgICAgICAgaWYgKElzLnVpbnRlZ2VyKG9uZSkgJiYgSXMudWludGVnZXIodHdvKSAmJiBJcy51aW50ZWdlcih0aHJlZSkgJiYgSXMudWludGVnZXIoZm91cikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBQb3NpdGlvbi5jcmVhdGUob25lLCB0d28pLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSh0aHJlZSwgZm91cikgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQb3NpdGlvbi5pcyhvbmUpICYmIFBvc2l0aW9uLmlzKHR3bykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBvbmUsIGVuZDogdHdvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSNjcmVhdGUgY2FsbGVkIHdpdGggaW52YWxpZCBhcmd1bWVudHNbXCIgKyBvbmUgKyBcIiwgXCIgKyB0d28gKyBcIiwgXCIgKyB0aHJlZSArIFwiLCBcIiArIGZvdXIgKyBcIl1cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbUmFuZ2VdKCNSYW5nZSkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0xvY2F0aW9uXSgjTG9jYXRpb24pIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0xvY2F0aW9uXSgjTG9jYXRpb24pIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUudXJpKSk7XG4gICAgfVxuICAgIExvY2F0aW9uLmlzID0gaXM7XG59KShMb2NhdGlvbiB8fCAoTG9jYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgTG9jYXRpb25MaW5rIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0xvY2F0aW9uTGlua10oI0xvY2F0aW9uTGluaykgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpOiB0YXJnZXRVcmksIHRhcmdldFJhbmdlOiB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2U6IHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZTogb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0xvY2F0aW9uTGlua10oI0xvY2F0aW9uTGluaykgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSkpXG4gICAgICAgICAgICAmJiAoUmFuZ2UuaXMoY2FuZGlkYXRlLm9yaWdpblNlbGVjdGlvblJhbmdlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLm9yaWdpblNlbGVjdGlvblJhbmdlKSk7XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5pcyA9IGlzO1xufSkoTG9jYXRpb25MaW5rIHx8IChMb2NhdGlvbkxpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbQ29sb3JdKCNDb2xvcikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3I7XG4oZnVuY3Rpb24gKENvbG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvciBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVkOiByZWQsXG4gICAgICAgICAgICBncmVlbjogZ3JlZW4sXG4gICAgICAgICAgICBibHVlOiBibHVlLFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtDb2xvcl0oI0NvbG9yKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLnJlZCwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ncmVlbiwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmFscGhhLCAwLCAxKTtcbiAgICB9XG4gICAgQ29sb3IuaXMgPSBpcztcbn0pKENvbG9yIHx8IChDb2xvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2xvckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBDb2xvci5pcyhjYW5kaWRhdGUuY29sb3IpO1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmlzID0gaXM7XG59KShDb2xvckluZm9ybWF0aW9uIHx8IChDb2xvckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0NvbG9yUHJlc2VudGF0aW9uXSgjQ29sb3JQcmVzZW50YXRpb24pIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvbG9yUHJlc2VudGF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIHRleHRFZGl0OiB0ZXh0RWRpdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUZXh0RWRpdHM6IGFkZGl0aW9uYWxUZXh0RWRpdHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRleHRFZGl0KSB8fCBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uaXMgPSBpcztcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEVudW0gb2Yga25vd24gcmFuZ2Uga2luZHNcbiAqL1xuZXhwb3J0IHZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZFtcIkNvbW1lbnRcIl0gPSBcImNvbW1lbnRcIjtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGltcG9ydHMgb3IgaW5jbHVkZXNcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kW1wiSW1wb3J0c1wiXSA9IFwiaW1wb3J0c1wiO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kW1wiUmVnaW9uXCJdID0gXCJyZWdpb25cIjtcbn0pKEZvbGRpbmdSYW5nZUtpbmQgfHwgKEZvbGRpbmdSYW5nZUtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZm9sZGluZyByYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtGb2xkaW5nUmFuZ2VdKCNGb2xkaW5nUmFuZ2UpIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0ZvbGRpbmdSYW5nZV0oI0ZvbGRpbmdSYW5nZSkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0RpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb25dKCNEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbl0oI0RpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24pIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzID0gaXM7XG59KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMncyBzZXZlcml0eS5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXZlcml0eSkge1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yID0gMTtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgd2FybmluZy5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyA9IDI7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb24gPSAzO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSBoaW50LlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5IaW50ID0gNDtcbn0pKERpYWdub3N0aWNTZXZlcml0eSB8fCAoRGlhZ25vc3RpY1NldmVyaXR5ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgdGFncy5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbmV4cG9ydCB2YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgQ29kZURlc2NyaXB0aW9uO1xuKGZ1bmN0aW9uIChDb2RlRGVzY3JpcHRpb24pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0RpYWdub3N0aWNdKCNEaWFnbm9zdGljKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgc291cmNlLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNldmVyaXR5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29kZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHJlbGF0ZWRJbmZvcm1hdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxhdGVkSW5mb3JtYXRpb24gPSByZWxhdGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtEaWFnbm9zdGljXSgjRGlhZ25vc3RpYykgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtDb21tYW5kXSgjQ29tbWFuZCkgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWFuZCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0aXRsZTogdGl0bGUsIGNvbW1hbmQ6IGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbW1hbmRdKCNDb21tYW5kKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG5leHBvcnQgdmFyIFRleHRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaXMgPSBpcztcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XG5leHBvcnQgdmFyIENoYW5nZUFubm90YXRpb247XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIG5lZWRzQ29uZmlybWF0aW9uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKG5lZWRzQ29uZmlybWF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5uZWVkc0NvbmZpcm1hdGlvbiA9IG5lZWRzQ29uZmlybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgJiZcbiAgICAgICAgICAgIChJcy5ib29sZWFuKGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbikgfHwgY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uIHx8IChDaGFuZ2VBbm5vdGF0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSB7fSkpO1xuZXhwb3J0IHZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJywgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmRlbCA9IGRlbDtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LCBlZGl0czogZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG5leHBvcnQgdmFyIENyZWF0ZUZpbGU7XG4oZnVuY3Rpb24gKENyZWF0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBSZW5hbWVGaWxlO1xuKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpOiBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLnJlY3Vyc2l2ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEZWxldGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdkZWxldGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBEZWxldGVGaWxlLmlzID0gaXM7XG59KShEZWxldGVGaWxlIHx8IChEZWxldGVGaWxlID0ge30pKTtcbmV4cG9ydCB2YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG52YXIgVGV4dEVkaXRDaGFuZ2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgY2hhbmdlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZUFubm90YXRpb25zID0gY2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIGVkaXQ7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHQgZWRpdCBjaGFuZ2UgaXMgbm90IGNvbmZpZ3VyZWQgdG8gbWFuYWdlIGNoYW5nZSBhbm5vdGF0aW9ucy5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXh0RWRpdENoYW5nZUltcGw7XG59KCkpO1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG52YXIgQ2hhbmdlQW5ub3RhdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubWFuYWdlID0gZnVuY3Rpb24gKGlkT3JBbm5vdGF0aW9uLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGlkT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklkIFwiICsgaWQgKyBcIiBpcyBhbHJlYWR5IGluIHVzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgXCIgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBXb3Jrc3BhY2VDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XG4gICAgICAgICAgICBpZiAod29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCBfdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSB0ZXh0RWRpdENoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod29ya3NwYWNlRWRpdC5jaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLCBcImVkaXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBbV29ya3NwYWNlRWRpdF0oI1dvcmtzcGFjZUVkaXQpIGxpdGVyYWxcbiAgICAgICAgICogdXNlIHRvIGJlIHJldHVybmVkIGZyb20gYSB3b3Jrc3BhY2UgZWRpdCBvcGVyYXRpb24gbGlrZSByZW5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93b3Jrc3BhY2VFZGl0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5nZXRUZXh0RWRpdENoYW5nZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnQgPSB7IHVyaToga2V5LnVyaSwgdmVyc2lvbjoga2V5LnZlcnNpb24gfTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnRFZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHRleHREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHM6IGVkaXRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKHRleHREb2N1bWVudEVkaXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIHRoaXMuX2NoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3Igbm9ybWFsIHRleHQgZWRpdCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSA9IGVkaXRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5pbml0RG9jdW1lbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgPSBuZXcgQ2hhbmdlQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuaW5pdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmNyZWF0ZUZpbGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBDcmVhdGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBDcmVhdGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUucmVuYW1lRmlsZSA9IGZ1bmN0aW9uIChvbGRVcmksIG5ld1VyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5kZWxldGVGaWxlID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gRGVsZXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gRGVsZXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gV29ya3NwYWNlQ2hhbmdlO1xufSgpKTtcbmV4cG9ydCB7IFdvcmtzcGFjZUNoYW5nZSB9O1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVGV4dERvY3VtZW50SWRlbnRpZmllcikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVGV4dERvY3VtZW50SWRlbnRpZmllcikgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcl0oI1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJdKCNPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbVGV4dERvY3VtZW50SXRlbV0oI1RleHREb2N1bWVudEl0ZW0pIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudEl0ZW07XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudEl0ZW0gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCwgdmVyc2lvbjogdmVyc2lvbiwgdGV4dDogdGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW1RleHREb2N1bWVudEl0ZW1dKCNUZXh0RG9jdW1lbnRJdGVtKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG5leHBvcnQgdmFyIE1hcmt1cEtpbmQ7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0IGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5QbGFpblRleHQgPSAncGxhaW50ZXh0JztcbiAgICAvKipcbiAgICAgKiBNYXJrZG93biBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuTWFya2Rvd24gPSAnbWFya2Rvd24nO1xufSkoTWFya3VwS2luZCB8fCAoTWFya3VwS2luZCA9IHt9KSk7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWx1ZSBvZiB0aGUgW01hcmt1cEtpbmRdKCNNYXJrdXBLaW5kKSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya3VwQ29udGVudDtcbihmdW5jdGlvbiAoTWFya3VwQ29udGVudCkge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUgW01hcmt1cENvbnRlbnRdKCNNYXJrdXBDb250ZW50KSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xuZXhwb3J0IHZhciBJbnNlcnRUZXh0Rm9ybWF0O1xuKGZ1bmN0aW9uIChJbnNlcnRUZXh0Rm9ybWF0KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgcGxhaW4gc3RyaW5nLlxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0ID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBzbmlwcGV0LlxuICAgICAqXG4gICAgICogQSBzbmlwcGV0IGNhbiBkZWZpbmUgdGFiIHN0b3BzIGFuZCBwbGFjZWhvbGRlcnMgd2l0aCBgJDFgLCBgJDJgXG4gICAgICogYW5kIGAkezM6Zm9vfWAuIGAkMGAgZGVmaW5lcyB0aGUgZmluYWwgdGFiIHN0b3AsIGl0IGRlZmF1bHRzIHRvXG4gICAgICogdGhlIGVuZCBvZiB0aGUgc25pcHBldC4gUGxhY2Vob2xkZXJzIHdpdGggZXF1YWwgaWRlbnRpZmllcnMgYXJlIGxpbmtlZCxcbiAgICAgKiB0aGF0IGlzIHR5cGluZyBpbiBvbmUgd2lsbCB1cGRhdGUgb3RoZXJzIHRvby5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvOiBodHRwczovL21pY3Jvc29mdC5naXRodWIuaW8vbGFuZ3VhZ2Utc2VydmVyLXByb3RvY29sL3NwZWNpZmljYXRpb25zL3NwZWNpZmljYXRpb24tY3VycmVudC8jc25pcHBldF9zeW50YXhcbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQgPSAyO1xufSkoSW5zZXJ0VGV4dEZvcm1hdCB8fCAoSW5zZXJ0VGV4dEZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIENvbXBsZXRpb24gaXRlbSB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBjb21wbGV0aW9uXG4gKiBpdGVtLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbSW5zZXJ0UmVwbGFjZUVkaXRdKCNJbnNlcnRSZXBsYWNlRWRpdCkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbDogbGFiZWwgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW0uY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkl0ZW0gfHwgKENvbXBsZXRpb25JdGVtID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25MaXN0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGxpc3RzLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uTGlzdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBjb21wbGV0aW9uIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSBbTWFya2VkU3RyaW5nXSgjTWFya2VkU3RyaW5nKSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcbmV4cG9ydCB2YXIgSG92ZXI7XG4oZnVuY3Rpb24gKEhvdmVyKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSBbSG92ZXJdKCNIb3ZlcikgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbUGFyYW1ldGVySW5mb3JtYXRpb25dKCNQYXJhbWV0ZXJJbmZvcm1hdGlvbikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtTaWduYXR1cmVJbmZvcm1hdGlvbl0oI1NpZ25hdHVyZUluZm9ybWF0aW9uKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU2lnbmF0dXJlSW5mb3JtYXRpb24gfHwgKFNpZ25hdHVyZUluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgdGV4dHVhbCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5UZXh0ID0gMTtcbiAgICAvKipcbiAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlJlYWQgPSAyO1xuICAgIC8qKlxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLldyaXRlID0gMztcbn0pKERvY3VtZW50SGlnaGxpZ2h0S2luZCB8fCAoRG9jdW1lbnRIaWdobGlnaHRLaW5kID0ge30pKTtcbi8qKlxuICogRG9jdW1lbnRIaWdobGlnaHQgbmFtZXNwYWNlIHRvIHByb3ZpZGUgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtEb2N1bWVudEhpZ2hsaWdodF0oI0RvY3VtZW50SGlnaGxpZ2h0KSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEb2N1bWVudEhpZ2hsaWdodCBvYmplY3QuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0aGUgaGlnaGxpZ2h0IGFwcGxpZXMgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICBpZiAoSXMubnVtYmVyKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRIaWdobGlnaHQuY3JlYXRlID0gY3JlYXRlO1xufSkoRG9jdW1lbnRIaWdobGlnaHQgfHwgKERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kO1xuKGZ1bmN0aW9uIChTeW1ib2xLaW5kKSB7XG4gICAgU3ltYm9sS2luZC5GaWxlID0gMTtcbiAgICBTeW1ib2xLaW5kLk1vZHVsZSA9IDI7XG4gICAgU3ltYm9sS2luZC5OYW1lc3BhY2UgPSAzO1xuICAgIFN5bWJvbEtpbmQuUGFja2FnZSA9IDQ7XG4gICAgU3ltYm9sS2luZC5DbGFzcyA9IDU7XG4gICAgU3ltYm9sS2luZC5NZXRob2QgPSA2O1xuICAgIFN5bWJvbEtpbmQuUHJvcGVydHkgPSA3O1xuICAgIFN5bWJvbEtpbmQuRmllbGQgPSA4O1xuICAgIFN5bWJvbEtpbmQuQ29uc3RydWN0b3IgPSA5O1xuICAgIFN5bWJvbEtpbmQuRW51bSA9IDEwO1xuICAgIFN5bWJvbEtpbmQuSW50ZXJmYWNlID0gMTE7XG4gICAgU3ltYm9sS2luZC5GdW5jdGlvbiA9IDEyO1xuICAgIFN5bWJvbEtpbmQuVmFyaWFibGUgPSAxMztcbiAgICBTeW1ib2xLaW5kLkNvbnN0YW50ID0gMTQ7XG4gICAgU3ltYm9sS2luZC5TdHJpbmcgPSAxNTtcbiAgICBTeW1ib2xLaW5kLk51bWJlciA9IDE2O1xuICAgIFN5bWJvbEtpbmQuQm9vbGVhbiA9IDE3O1xuICAgIFN5bWJvbEtpbmQuQXJyYXkgPSAxODtcbiAgICBTeW1ib2xLaW5kLk9iamVjdCA9IDE5O1xuICAgIFN5bWJvbEtpbmQuS2V5ID0gMjA7XG4gICAgU3ltYm9sS2luZC5OdWxsID0gMjE7XG4gICAgU3ltYm9sS2luZC5FbnVtTWVtYmVyID0gMjI7XG4gICAgU3ltYm9sS2luZC5TdHJ1Y3QgPSAyMztcbiAgICBTeW1ib2xLaW5kLkV2ZW50ID0gMjQ7XG4gICAgU3ltYm9sS2luZC5PcGVyYXRvciA9IDI1O1xuICAgIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciA9IDI2O1xufSkoU3ltYm9sS2luZCB8fCAoU3ltYm9sS2luZCA9IHt9KSk7XG4vKipcbiAqIFN5bWJvbCB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBzeW1ib2wuXG4gKiBAc2luY2UgMy4xNlxuICovXG5leHBvcnQgdmFyIFN5bWJvbFRhZztcbihmdW5jdGlvbiAoU3ltYm9sVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc3ltYm9sIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBTeW1ib2xUYWcuRGVwcmVjYXRlZCA9IDE7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG5leHBvcnQgdmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLCBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sIGNvbnRhaW5pbmcgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgcmFuZ2UsIHVyaSwgY29udGFpbmVyTmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICBsb2NhdGlvbjogeyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTeW1ib2xJbmZvcm1hdGlvbiB8fCAoU3ltYm9sSW5mb3JtYXRpb24gPSB7fSkpO1xuZXhwb3J0IHZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRG9jdW1lbnRTeW1ib2xdKCNEb2N1bWVudFN5bWJvbCkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmtpbmQpICYmXG4gICAgICAgICAgICBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5zZWxlY3Rpb25SYW5nZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXByZWNhdGVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuZGVwcmVjYXRlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuY2hpbGRyZW4pKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS50YWdzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUudGFncykpO1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5pcyA9IGlzO1xufSkoRG9jdW1lbnRTeW1ib2wgfHwgKERvY3VtZW50U3ltYm9sID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBjb2RlIGFjdGlvbiBraW5kc1xuICovXG5leHBvcnQgdmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlQWN0aW9uQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtDb2RlQWN0aW9uQ29udGV4dF0oI0NvZGVBY3Rpb25Db250ZXh0KSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlQWN0aW9uQ29udGV4dDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbkNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVBY3Rpb25Db250ZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IGRpYWdub3N0aWNzOiBkaWFnbm9zdGljcyB9O1xuICAgICAgICBpZiAob25seSAhPT0gdW5kZWZpbmVkICYmIG9ubHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vbmx5ID0gb25seTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtDb2RlQWN0aW9uQ29udGV4dF0oI0NvZGVBY3Rpb25Db250ZXh0KSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSAmJiAoY2FuZGlkYXRlLm9ubHkgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5vbmx5LCBJcy5zdHJpbmcpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbkNvbnRleHQuaXMgPSBpcztcbn0pKENvZGVBY3Rpb25Db250ZXh0IHx8IChDb2RlQWN0aW9uQ29udGV4dCA9IHt9KSk7XG5leHBvcnQgdmFyIENvZGVBY3Rpb247XG4oZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGtpbmRPckNvbW1hbmRPckVkaXQsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlIH07XG4gICAgICAgIHZhciBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtDb2RlTGVuc10oI0NvZGVMZW5zKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVMZW5zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvZGVMZW5zXSgjQ29kZUxlbnMpIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIENvZGVMZW5zLmlzID0gaXM7XG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbRm9ybWF0dGluZ09wdGlvbnNdKCNGb3JtYXR0aW5nT3B0aW9ucykgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZTogdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzOiBpbnNlcnRTcGFjZXMgfTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRm9ybWF0dGluZ09wdGlvbnNdKCNGb3JtYXR0aW5nT3B0aW9ucykgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbRG9jdW1lbnRMaW5rXSgjRG9jdW1lbnRMaW5rKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudExpbms7XG4oZnVuY3Rpb24gKERvY3VtZW50TGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRG9jdW1lbnRMaW5rIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0YXJnZXQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0YXJnZXQ6IHRhcmdldCwgZGF0YTogZGF0YSB9O1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRG9jdW1lbnRMaW5rXSgjRG9jdW1lbnRMaW5rKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGFyZ2V0KSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldCkpO1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuaXMgPSBpcztcbn0pKERvY3VtZW50TGluayB8fCAoRG9jdW1lbnRMaW5rID0ge30pKTtcbi8qKlxuICogVGhlIFNlbGVjdGlvblJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gd29yayB3aXRoXG4gKiBTZWxlY3Rpb25SYW5nZSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHBhcmVudDogcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChjYW5kaWRhdGUucGFyZW50ID09PSB1bmRlZmluZWQgfHwgU2VsZWN0aW9uUmFuZ2UuaXMoY2FuZGlkYXRlLnBhcmVudCkpO1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5pcyA9IGlzO1xufSkoU2VsZWN0aW9uUmFuZ2UgfHwgKFNlbGVjdGlvblJhbmdlID0ge30pKTtcbmV4cG9ydCB2YXIgRU9MID0gWydcXG4nLCAnXFxyXFxuJywgJ1xcciddO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCAgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbSVRleHREb2N1bWVudF0oI0lUZXh0RG9jdW1lbnQpIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmxhbmd1YWdlSWQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lQ291bnQpXG4gICAgICAgICAgICAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5nZXRUZXh0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5wb3NpdGlvbkF0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vZmZzZXRBdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIC8vIHNvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB2YXIgbGVmdElkeCA9IDA7XG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgSXM7XG4oZnVuY3Rpb24gKElzKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG4iLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4ndXNlIHN0cmljdCc7XG52YXIgRnVsbFRleHREb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwidXJpXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGFuZ3VhZ2VJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hhbmdlc18xID0gY2hhbmdlczsgX2kgPCBjaGFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc18xW19pXTtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZShjaGFuZ2UucmFuZ2UpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQubGluZSwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZExpbmUgPSBNYXRoLm1heChyYW5nZS5lbmQubGluZSwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5fbGluZU9mZnNldHM7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlLmFwcGx5KGxpbmVPZmZzZXRzLCBbc3RhcnRMaW5lICsgMSwgZW5kTGluZSAtIHN0YXJ0TGluZV0uY29uY2F0KGFkZGVkTGluZU9mZnNldHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYXZvaWQgdG9vIG1hbnkgYXJndW1lbnRzIGZvciBzcGxpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cy5zbGljZSgwLCBzdGFydExpbmUgKyAxKS5jb25jYXQoYWRkZWRMaW5lT2Zmc2V0cywgbGluZU9mZnNldHMuc2xpY2UoZW5kTGluZSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZSArIDEgKyBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCwgbGVuID0gbGluZU9mZnNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzW2ldID0gbGluZU9mZnNldHNbaV0gKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRnVsbFRleHREb2N1bWVudC5pc0Z1bGwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjaGFuZ2UudGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFuZ2UgZXZlbnQgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUucG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogMCwgY2hhcmFjdGVyOiBvZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUub2Zmc2V0QXQgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgdmFyIG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsaW5lQ291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpbmVPZmZzZXRzKCkubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5pc0Z1bGwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bGxUZXh0RG9jdW1lbnQ7XG59KCkpO1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkICBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyBpbml0aWFsIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgVGV4dERvY3VtZW50IGJ5IG1vZGlmaW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0RG9jdW1lbnQuIE5vdGU6IFRoYXQncyB0aGUgc2FtZSBkb2N1bWVudCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKGRvY3VtZW50LCBjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEZ1bGxUZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dERvY3VtZW50LnVwZGF0ZTogZG9jdW1lbnQgbXVzdCBiZSBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQudXBkYXRlID0gdXBkYXRlO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMubWFwKGdldFdlbGxmb3JtZWRFZGl0KSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvcnRlZEVkaXRzXzEgPSBzb3J0ZWRFZGl0czsgX2kgPCBzb3J0ZWRFZGl0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGUgPSBzb3J0ZWRFZGl0c18xW19pXTtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0IDwgbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydE9mZnNldCA+IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHJpbmcobGFzdE1vZGlmaWVkT2Zmc2V0LCBzdGFydE9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHNwYW5zLmpvaW4oJycpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG5mdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIC8vIHNvcnRlZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIHZhciByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgdmFyIGxlZnRJZHggPSAwO1xuICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lT2Zmc2V0cyh0ZXh0LCBpc0F0TGluZVN0YXJ0LCB0ZXh0T2Zmc2V0KSB7XG4gICAgaWYgKHRleHRPZmZzZXQgPT09IHZvaWQgMCkgeyB0ZXh0T2Zmc2V0ID0gMDsgfVxuICAgIHZhciByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDYXJyaWFnZVJldHVybiAqLyB8fCBjaCA9PT0gMTAgLyogTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgLyogQ2FycmlhZ2VSZXR1cm4gKi8gJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCAvKiBMaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRPZmZzZXQgKyBpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRSYW5nZShyYW5nZSkge1xuICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIHZhciByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgaWYgKHJhbmdlICE9PSB0ZXh0RWRpdC5yYW5nZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiB0ZXh0RWRpdC5uZXdUZXh0LCByYW5nZTogcmFuZ2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRFZGl0O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBSYW5nZSwgUG9zaXRpb24sIE1hcmt1cENvbnRlbnQsIE1hcmt1cEtpbmQsIENvbG9yLCBDb2xvckluZm9ybWF0aW9uLCBDb2xvclByZXNlbnRhdGlvbiwgRm9sZGluZ1JhbmdlLCBGb2xkaW5nUmFuZ2VLaW5kLCBTZWxlY3Rpb25SYW5nZSwgRGlhZ25vc3RpYywgRGlhZ25vc3RpY1NldmVyaXR5LCBDb21wbGV0aW9uSXRlbSwgQ29tcGxldGlvbkl0ZW1LaW5kLCBDb21wbGV0aW9uTGlzdCwgQ29tcGxldGlvbkl0ZW1UYWcsIEluc2VydFRleHRGb3JtYXQsIFN5bWJvbEluZm9ybWF0aW9uLCBTeW1ib2xLaW5kLCBEb2N1bWVudFN5bWJvbCwgTG9jYXRpb24sIEhvdmVyLCBNYXJrZWRTdHJpbmcsIENvZGVBY3Rpb25Db250ZXh0LCBDb21tYW5kLCBDb2RlQWN0aW9uLCBEb2N1bWVudEhpZ2hsaWdodCwgRG9jdW1lbnRMaW5rLCBXb3Jrc3BhY2VFZGl0LCBUZXh0RWRpdCwgQ29kZUFjdGlvbktpbmQsIFRleHREb2N1bWVudEVkaXQsIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIsIERvY3VtZW50SGlnaGxpZ2h0S2luZCB9IGZyb20gJy4vLi4vdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL21haW4uanMnO1xuaW1wb3J0IHsgVGV4dERvY3VtZW50IH0gZnJvbSAnLi8uLi92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50L2xpYi9lc20vbWFpbi5qcyc7XG5leHBvcnQgeyBUZXh0RG9jdW1lbnQsIFJhbmdlLCBQb3NpdGlvbiwgTWFya3VwQ29udGVudCwgTWFya3VwS2luZCwgQ29sb3IsIENvbG9ySW5mb3JtYXRpb24sIENvbG9yUHJlc2VudGF0aW9uLCBGb2xkaW5nUmFuZ2UsIEZvbGRpbmdSYW5nZUtpbmQsIFNlbGVjdGlvblJhbmdlLCBEaWFnbm9zdGljLCBEaWFnbm9zdGljU2V2ZXJpdHksIENvbXBsZXRpb25JdGVtLCBDb21wbGV0aW9uSXRlbUtpbmQsIENvbXBsZXRpb25MaXN0LCBDb21wbGV0aW9uSXRlbVRhZywgSW5zZXJ0VGV4dEZvcm1hdCwgU3ltYm9sSW5mb3JtYXRpb24sIFN5bWJvbEtpbmQsIERvY3VtZW50U3ltYm9sLCBMb2NhdGlvbiwgSG92ZXIsIE1hcmtlZFN0cmluZywgQ29kZUFjdGlvbkNvbnRleHQsIENvbW1hbmQsIENvZGVBY3Rpb24sIERvY3VtZW50SGlnaGxpZ2h0LCBEb2N1bWVudExpbmssIFdvcmtzcGFjZUVkaXQsIFRleHRFZGl0LCBDb2RlQWN0aW9uS2luZCwgVGV4dERvY3VtZW50RWRpdCwgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciwgRG9jdW1lbnRIaWdobGlnaHRLaW5kIH07XG4vKipcbiAqIEVycm9yIGNvZGVzIHVzZWQgYnkgZGlhZ25vc3RpY3NcbiAqL1xuZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmRlZmluZWRcIl0gPSAwXSA9IFwiVW5kZWZpbmVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkVudW1WYWx1ZU1pc21hdGNoXCJdID0gMV0gPSBcIkVudW1WYWx1ZU1pc21hdGNoXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkRlcHJlY2F0ZWRcIl0gPSAyXSA9IFwiRGVwcmVjYXRlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMjU3XSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAyNThdID0gXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCJdID0gMjU5XSA9IFwiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRVbmljb2RlXCJdID0gMjYwXSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDI2MV0gPSBcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZENoYXJhY3RlclwiXSA9IDI2Ml0gPSBcIkludmFsaWRDaGFyYWN0ZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUHJvcGVydHlFeHBlY3RlZFwiXSA9IDUxM10gPSBcIlByb3BlcnR5RXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFFeHBlY3RlZFwiXSA9IDUxNF0gPSBcIkNvbW1hRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29sb25FeHBlY3RlZFwiXSA9IDUxNV0gPSBcIkNvbG9uRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVmFsdWVFeHBlY3RlZFwiXSA9IDUxNl0gPSBcIlZhbHVlRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWRcIl0gPSA1MTddID0gXCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkXCJdID0gNTE4XSA9IFwiQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJUcmFpbGluZ0NvbW1hXCJdID0gNTE5XSA9IFwiVHJhaWxpbmdDb21tYVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJEdXBsaWNhdGVLZXlcIl0gPSA1MjBdID0gXCJEdXBsaWNhdGVLZXlcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWVudE5vdFBlcm1pdHRlZFwiXSA9IDUyMV0gPSBcIkNvbW1lbnROb3RQZXJtaXR0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU2NoZW1hUmVzb2x2ZUVycm9yXCJdID0gNzY4XSA9IFwiU2NoZW1hUmVzb2x2ZUVycm9yXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5leHBvcnQgdmFyIENsaWVudENhcGFiaWxpdGllcztcbihmdW5jdGlvbiAoQ2xpZW50Q2FwYWJpbGl0aWVzKSB7XG4gICAgQ2xpZW50Q2FwYWJpbGl0aWVzLkxBVEVTVCA9IHtcbiAgICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uOiB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW01hcmt1cEtpbmQuTWFya2Rvd24sIE1hcmt1cEtpbmQuUGxhaW5UZXh0XSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoQ2xpZW50Q2FwYWJpbGl0aWVzIHx8IChDbGllbnRDYXBhYmlsaXRpZXMgPSB7fSkpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlLCBhcmdzKSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbWVzc2FnZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IG1lc3NhZ2UucmVwbGFjZSgvXFx7KFxcZCspXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgcmVzdCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZXN0WzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3NbaW5kZXhdICE9PSAndW5kZWZpbmVkJyA/IGFyZ3NbaW5kZXhdIDogbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGxvY2FsaXplKGtleSwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXQobWVzc2FnZSwgYXJncyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRNZXNzYWdlQnVuZGxlKGZpbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGl6ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnKG9wdCkge1xyXG4gICAgcmV0dXJuIGxvYWRNZXNzYWdlQnVuZGxlO1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi8uLi8uLi9qc29uYy1wYXJzZXIvbWFpbi5qcyc7XG5pbXBvcnQgeyBpc051bWJlciwgZXF1YWxzLCBpc0Jvb2xlYW4sIGlzU3RyaW5nLCBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlscy9vYmplY3RzLmpzJztcbmltcG9ydCB7IGV4dGVuZGVkUmVnRXhwIH0gZnJvbSAnLi4vdXRpbHMvc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBFcnJvckNvZGUsIERpYWdub3N0aWMsIERpYWdub3N0aWNTZXZlcml0eSwgUmFuZ2UgfSBmcm9tICcuLi9qc29uTGFuZ3VhZ2VUeXBlcy5qcyc7XG5pbXBvcnQgKiBhcyBubHMgZnJvbSAnLi8uLi8uLi8uLi9maWxsZXJzL3ZzY29kZS1ubHMuanMnO1xudmFyIGxvY2FsaXplID0gbmxzLmxvYWRNZXNzYWdlQnVuZGxlKCk7XG52YXIgZm9ybWF0cyA9IHtcbiAgICAnY29sb3ItaGV4JzogeyBlcnJvck1lc3NhZ2U6IGxvY2FsaXplKCdjb2xvckhleEZvcm1hdFdhcm5pbmcnLCAnSW52YWxpZCBjb2xvciBmb3JtYXQuIFVzZSAjUkdCLCAjUkdCQSwgI1JSR0dCQiBvciAjUlJHR0JCQUEuJyksIHBhdHRlcm46IC9eIyhbMC05QS1GYS1mXXszLDR9fChbMC05QS1GYS1mXXsyfSl7Myw0fSkkLyB9LFxuICAgICdkYXRlLXRpbWUnOiB7IGVycm9yTWVzc2FnZTogbG9jYWxpemUoJ2RhdGVUaW1lRm9ybWF0V2FybmluZycsICdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLXRpbWUuJyksIHBhdHRlcm46IC9eKFxcZHs0fSktKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVQoWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pOihbMC01XVswLTldfDYwKShcXC5bMC05XSspPyhafChcXCt8LSkoWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pKSQvaSB9LFxuICAgICdkYXRlJzogeyBlcnJvck1lc3NhZ2U6IGxvY2FsaXplKCdkYXRlRm9ybWF0V2FybmluZycsICdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLicpLCBwYXR0ZXJuOiAvXihcXGR7NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSkkL2kgfSxcbiAgICAndGltZSc6IHsgZXJyb3JNZXNzYWdlOiBsb2NhbGl6ZSgndGltZUZvcm1hdFdhcm5pbmcnLCAnU3RyaW5nIGlzIG5vdCBhIFJGQzMzMzkgdGltZS4nKSwgcGF0dGVybjogL14oWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pOihbMC01XVswLTldfDYwKShcXC5bMC05XSspPyhafChcXCt8LSkoWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pKSQvaSB9LFxuICAgICdlbWFpbCc6IHsgZXJyb3JNZXNzYWdlOiBsb2NhbGl6ZSgnZW1haWxGb3JtYXRXYXJuaW5nJywgJ1N0cmluZyBpcyBub3QgYW4gZS1tYWlsIGFkZHJlc3MuJyksIHBhdHRlcm46IC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvIH1cbn07XG52YXIgQVNUTm9kZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQVNUTm9kZUltcGwocGFyZW50LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gMDsgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQVNUTm9kZUltcGwucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBU1ROb2RlSW1wbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAndHlwZTogJyArIHRoaXMudHlwZSArICcgKCcgKyB0aGlzLm9mZnNldCArICcvJyArIHRoaXMubGVuZ3RoICsgJyknICsgKHRoaXMucGFyZW50ID8gJyBwYXJlbnQ6IHsnICsgdGhpcy5wYXJlbnQudG9TdHJpbmcoKSArICd9JyA6ICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBBU1ROb2RlSW1wbDtcbn0oKSk7XG5leHBvcnQgeyBBU1ROb2RlSW1wbCB9O1xudmFyIE51bGxBU1ROb2RlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVsbEFTVE5vZGVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bGxBU1ROb2RlSW1wbChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIG9mZnNldCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdudWxsJztcbiAgICAgICAgX3RoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOdWxsQVNUTm9kZUltcGw7XG59KEFTVE5vZGVJbXBsKSk7XG5leHBvcnQgeyBOdWxsQVNUTm9kZUltcGwgfTtcbnZhciBCb29sZWFuQVNUTm9kZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJvb2xlYW5BU1ROb2RlSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCBib29sVmFsdWUsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIG9mZnNldCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdib29sZWFuJztcbiAgICAgICAgX3RoaXMudmFsdWUgPSBib29sVmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW5BU1ROb2RlSW1wbDtcbn0oQVNUTm9kZUltcGwpKTtcbmV4cG9ydCB7IEJvb2xlYW5BU1ROb2RlSW1wbCB9O1xudmFyIEFycmF5QVNUTm9kZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5QVNUTm9kZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlBU1ROb2RlSW1wbChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIG9mZnNldCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdhcnJheSc7XG4gICAgICAgIF90aGlzLml0ZW1zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5QVNUTm9kZUltcGwucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBBcnJheUFTVE5vZGVJbXBsO1xufShBU1ROb2RlSW1wbCkpO1xuZXhwb3J0IHsgQXJyYXlBU1ROb2RlSW1wbCB9O1xudmFyIE51bWJlckFTVE5vZGVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdW1iZXJBU1ROb2RlSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJBU1ROb2RlSW1wbChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIG9mZnNldCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdudW1iZXInO1xuICAgICAgICBfdGhpcy5pc0ludGVnZXIgPSB0cnVlO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IE51bWJlci5OYU47XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlckFTVE5vZGVJbXBsO1xufShBU1ROb2RlSW1wbCkpO1xuZXhwb3J0IHsgTnVtYmVyQVNUTm9kZUltcGwgfTtcbnZhciBTdHJpbmdBU1ROb2RlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyaW5nQVNUTm9kZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaW5nQVNUTm9kZUltcGwocGFyZW50LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIG9mZnNldCwgbGVuZ3RoKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ3N0cmluZyc7XG4gICAgICAgIF90aGlzLnZhbHVlID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZ0FTVE5vZGVJbXBsO1xufShBU1ROb2RlSW1wbCkpO1xuZXhwb3J0IHsgU3RyaW5nQVNUTm9kZUltcGwgfTtcbnZhciBQcm9wZXJ0eUFTVE5vZGVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eUFTVE5vZGVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5QVNUTm9kZUltcGwocGFyZW50LCBvZmZzZXQsIGtleU5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCBvZmZzZXQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAncHJvcGVydHknO1xuICAgICAgICBfdGhpcy5jb2xvbk9mZnNldCA9IC0xO1xuICAgICAgICBfdGhpcy5rZXlOb2RlID0ga2V5Tm9kZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlBU1ROb2RlSW1wbC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlTm9kZSA/IFt0aGlzLmtleU5vZGUsIHRoaXMudmFsdWVOb2RlXSA6IFt0aGlzLmtleU5vZGVdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb3BlcnR5QVNUTm9kZUltcGw7XG59KEFTVE5vZGVJbXBsKSk7XG5leHBvcnQgeyBQcm9wZXJ0eUFTVE5vZGVJbXBsIH07XG52YXIgT2JqZWN0QVNUTm9kZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdEFTVE5vZGVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdEFTVE5vZGVJbXBsKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgb2Zmc2V0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ29iamVjdCc7XG4gICAgICAgIF90aGlzLnByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0QVNUTm9kZUltcGwucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdEFTVE5vZGVJbXBsO1xufShBU1ROb2RlSW1wbCkpO1xuZXhwb3J0IHsgT2JqZWN0QVNUTm9kZUltcGwgfTtcbmV4cG9ydCBmdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoaXNCb29sZWFuKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYSA/IHt9IDogeyBcIm5vdFwiOiB7fSB9O1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xufVxuZXhwb3J0IHZhciBFbnVtTWF0Y2g7XG4oZnVuY3Rpb24gKEVudW1NYXRjaCkge1xuICAgIEVudW1NYXRjaFtFbnVtTWF0Y2hbXCJLZXlcIl0gPSAwXSA9IFwiS2V5XCI7XG4gICAgRW51bU1hdGNoW0VudW1NYXRjaFtcIkVudW1cIl0gPSAxXSA9IFwiRW51bVwiO1xufSkoRW51bU1hdGNoIHx8IChFbnVtTWF0Y2ggPSB7fSkpO1xudmFyIFNjaGVtYUNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlbWFDb2xsZWN0b3IoZm9jdXNPZmZzZXQsIGV4Y2x1ZGUpIHtcbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID09PSB2b2lkIDApIHsgZm9jdXNPZmZzZXQgPSAtMTsgfVxuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICAgIHRoaXMuZXhjbHVkZSA9IGV4Y2x1ZGU7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IFtdO1xuICAgIH1cbiAgICBTY2hlbWFDb2xsZWN0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzLnB1c2goc2NoZW1hKTtcbiAgICB9O1xuICAgIFNjaGVtYUNvbGxlY3Rvci5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5zY2hlbWFzLCBvdGhlci5zY2hlbWFzKTtcbiAgICB9O1xuICAgIFNjaGVtYUNvbGxlY3Rvci5wcm90b3R5cGUuaW5jbHVkZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mb2N1c09mZnNldCA9PT0gLTEgfHwgY29udGFpbnMobm9kZSwgdGhpcy5mb2N1c09mZnNldCkpICYmIChub2RlICE9PSB0aGlzLmV4Y2x1ZGUpO1xuICAgIH07XG4gICAgU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5uZXdTdWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hQ29sbGVjdG9yKC0xLCB0aGlzLmV4Y2x1ZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjaGVtYUNvbGxlY3Rvcjtcbn0oKSk7XG52YXIgTm9PcFNjaGVtYUNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb09wU2NoZW1hQ29sbGVjdG9yKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9PcFNjaGVtYUNvbGxlY3Rvci5wcm90b3R5cGUsIFwic2NoZW1hc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOb09wU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoc2NoZW1hKSB7IH07XG4gICAgTm9PcFNjaGVtYUNvbGxlY3Rvci5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHsgfTtcbiAgICBOb09wU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5pbmNsdWRlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgTm9PcFNjaGVtYUNvbGxlY3Rvci5wcm90b3R5cGUubmV3U3ViID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlID0gbmV3IE5vT3BTY2hlbWFDb2xsZWN0b3IoKTtcbiAgICByZXR1cm4gTm9PcFNjaGVtYUNvbGxlY3Rvcjtcbn0oKSk7XG52YXIgVmFsaWRhdGlvblJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uUmVzdWx0KCkge1xuICAgICAgICB0aGlzLnByb2JsZW1zID0gW107XG4gICAgICAgIHRoaXMucHJvcGVydGllc01hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgVmFsaWRhdGlvblJlc3VsdC5wcm90b3R5cGUuaGFzUHJvYmxlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHJvYmxlbXMubGVuZ3RoO1xuICAgIH07XG4gICAgVmFsaWRhdGlvblJlc3VsdC5wcm90b3R5cGUubWVyZ2VBbGwgPSBmdW5jdGlvbiAodmFsaWRhdGlvblJlc3VsdHMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB2YWxpZGF0aW9uUmVzdWx0c18xID0gdmFsaWRhdGlvblJlc3VsdHM7IF9pIDwgdmFsaWRhdGlvblJlc3VsdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uUmVzdWx0ID0gdmFsaWRhdGlvblJlc3VsdHNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLm1lcmdlKHZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWYWxpZGF0aW9uUmVzdWx0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICh2YWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHRoaXMucHJvYmxlbXMgPSB0aGlzLnByb2JsZW1zLmNvbmNhdCh2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zKTtcbiAgICB9O1xuICAgIFZhbGlkYXRpb25SZXN1bHQucHJvdG90eXBlLm1lcmdlRW51bVZhbHVlcyA9IGZ1bmN0aW9uICh2YWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIGlmICghdGhpcy5lbnVtVmFsdWVNYXRjaCAmJiAhdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCAmJiB0aGlzLmVudW1WYWx1ZXMgJiYgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLmVudW1WYWx1ZXMgPSB0aGlzLmVudW1WYWx1ZXMuY29uY2F0KHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5wcm9ibGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IEVycm9yQ29kZS5FbnVtVmFsdWVNaXNtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gbG9jYWxpemUoJ2VudW1XYXJuaW5nJywgJ1ZhbHVlIGlzIG5vdCBhY2NlcHRlZC4gVmFsaWQgdmFsdWVzOiB7MH0uJywgdGhpcy5lbnVtVmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7IH0pLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVmFsaWRhdGlvblJlc3VsdC5wcm90b3R5cGUubWVyZ2VQcm9wZXJ0eU1hdGNoID0gZnVuY3Rpb24gKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICB0aGlzLm1lcmdlKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllc01hdGNoZXMrKztcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCB8fCAhcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkgJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoICYmIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzICYmIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZhbGlkYXRpb25SZXN1bHQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIGhhc1Byb2JsZW1zID0gdGhpcy5oYXNQcm9ibGVtcygpO1xuICAgICAgICBpZiAoaGFzUHJvYmxlbXMgIT09IG90aGVyLmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNQcm9ibGVtcyA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbnVtVmFsdWVNYXRjaCAhPT0gb3RoZXIuZW51bVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5lbnVtVmFsdWVNYXRjaCA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcmltYXJ5VmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5VmFsdWVNYXRjaGVzIC0gb3RoZXIucHJpbWFyeVZhbHVlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICE9PSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzIC0gb3RoZXIucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyAtIG90aGVyLnByb3BlcnRpZXNNYXRjaGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbGlkYXRpb25SZXN1bHQ7XG59KCkpO1xuZXhwb3J0IHsgVmFsaWRhdGlvblJlc3VsdCB9O1xuZXhwb3J0IGZ1bmN0aW9uIG5ld0pTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcykge1xuICAgIGlmIChkaWFnbm9zdGljcyA9PT0gdm9pZCAwKSB7IGRpYWdub3N0aWNzID0gW107IH1cbiAgICByZXR1cm4gbmV3IEpTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcywgW10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVWYWx1ZShub2RlKSB7XG4gICAgcmV0dXJuIEpzb24uZ2V0Tm9kZVZhbHVlKG5vZGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVQYXRoKG5vZGUpIHtcbiAgICByZXR1cm4gSnNvbi5nZXROb2RlUGF0aChub2RlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKSB7XG4gICAgaWYgKGluY2x1ZGVSaWdodEJvdW5kID09PSB2b2lkIDApIHsgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBvZmZzZXQgPj0gbm9kZS5vZmZzZXQgJiYgb2Zmc2V0IDwgKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpIHx8IGluY2x1ZGVSaWdodEJvdW5kICYmIG9mZnNldCA9PT0gKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpO1xufVxudmFyIEpTT05Eb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09ORG9jdW1lbnQocm9vdCwgc3ludGF4RXJyb3JzLCBjb21tZW50cykge1xuICAgICAgICBpZiAoc3ludGF4RXJyb3JzID09PSB2b2lkIDApIHsgc3ludGF4RXJyb3JzID0gW107IH1cbiAgICAgICAgaWYgKGNvbW1lbnRzID09PSB2b2lkIDApIHsgY29tbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLnN5bnRheEVycm9ycyA9IHN5bnRheEVycm9ycztcbiAgICAgICAgdGhpcy5jb21tZW50cyA9IGNvbW1lbnRzO1xuICAgIH1cbiAgICBKU09ORG9jdW1lbnQucHJvdG90eXBlLmdldE5vZGVGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVSaWdodEJvdW5kID09PSB2b2lkIDApIHsgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICByZXR1cm4gSnNvbi5maW5kTm9kZUF0T2Zmc2V0KHRoaXMucm9vdCwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB2YXIgZG9WaXNpdF8xID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3RuID0gdmlzaXRvcihub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjdG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RuID0gZG9WaXNpdF8xKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3RuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvVmlzaXRfMSh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09ORG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHRleHREb2N1bWVudCwgc2NoZW1hLCBzZXZlcml0eSkge1xuICAgICAgICBpZiAoc2V2ZXJpdHkgPT09IHZvaWQgMCkgeyBzZXZlcml0eSA9IERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nOyB9XG4gICAgICAgIGlmICh0aGlzLnJvb3QgJiYgc2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICB2YWxpZGF0ZSh0aGlzLnJvb3QsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHAubG9jYXRpb24ub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQocC5sb2NhdGlvbi5vZmZzZXQgKyBwLmxvY2F0aW9uLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBEaWFnbm9zdGljLmNyZWF0ZShyYW5nZSwgcC5tZXNzYWdlLCAoX2EgPSBwLnNldmVyaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzZXZlcml0eSwgcC5jb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBKU09ORG9jdW1lbnQucHJvdG90eXBlLmdldE1hdGNoaW5nU2NoZW1hcyA9IGZ1bmN0aW9uIChzY2hlbWEsIGZvY3VzT2Zmc2V0LCBleGNsdWRlKSB7XG4gICAgICAgIGlmIChmb2N1c09mZnNldCA9PT0gdm9pZCAwKSB7IGZvY3VzT2Zmc2V0ID0gLTE7IH1cbiAgICAgICAgdmFyIG1hdGNoaW5nU2NoZW1hcyA9IG5ldyBTY2hlbWFDb2xsZWN0b3IoZm9jdXNPZmZzZXQsIGV4Y2x1ZGUpO1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHNjaGVtYSkge1xuICAgICAgICAgICAgdmFsaWRhdGUodGhpcy5yb290LCBzY2hlbWEsIG5ldyBWYWxpZGF0aW9uUmVzdWx0KCksIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nU2NoZW1hcy5zY2hlbWFzO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05Eb2N1bWVudDtcbn0oKSk7XG5leHBvcnQgeyBKU09ORG9jdW1lbnQgfTtcbmZ1bmN0aW9uIHZhbGlkYXRlKG4sIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKSB7XG4gICAgaWYgKCFuIHx8ICFtYXRjaGluZ1NjaGVtYXMuaW5jbHVkZShuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub2RlID0gbjtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgX3ZhbGlkYXRlQXJyYXlOb2RlKG5vZGUsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgX3ZhbGlkYXRlU3RyaW5nTm9kZShub2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Byb3BlcnR5JzpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZShub2RlLnZhbHVlTm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgIH1cbiAgICBfdmFsaWRhdGVOb2RlKCk7XG4gICAgbWF0Y2hpbmdTY2hlbWFzLmFkZCh7IG5vZGU6IG5vZGUsIHNjaGVtYTogc2NoZW1hIH0pO1xuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZU5vZGUoKSB7XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNUeXBlKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IHR5cGUgfHwgKHR5cGUgPT09ICdpbnRlZ2VyJyAmJiBub2RlLnR5cGUgPT09ICdudW1iZXInICYmIG5vZGUuaXNJbnRlZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgIGlmICghc2NoZW1hLnR5cGUuc29tZShtYXRjaGVzVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgbG9jYWxpemUoJ3R5cGVBcnJheU1pc21hdGNoV2FybmluZycsICdJbmNvcnJlY3QgdHlwZS4gRXhwZWN0ZWQgb25lIG9mIHswfS4nLCBzY2hlbWEudHlwZS5qb2luKCcsICcpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXNUeXBlKHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgndHlwZU1pc21hdGNoV2FybmluZycsICdJbmNvcnJlY3QgdHlwZS4gRXhwZWN0ZWQgXCJ7MH1cIi4nLCBzY2hlbWEudHlwZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2NoZW1hLmFsbE9mOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzdWJTY2hlbWFSZWYgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgYXNTY2hlbWEoc3ViU2NoZW1hUmVmKSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbm90U2NoZW1hID0gYXNTY2hlbWEoc2NoZW1hLm5vdCk7XG4gICAgICAgIGlmIChub3RTY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBzdWJWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgIHZhciBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBub3RTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICBpZiAoIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ25vdFNjaGVtYVdhcm5pbmcnLCBcIk1hdGNoZXMgYSBzY2hlbWEgdGhhdCBpcyBub3QgYWxsb3dlZC5cIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBzdWJNYXRjaGluZ1NjaGVtYXMuc2NoZW1hczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXMgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbXMuaW52ZXJ0ZWQgPSAhbXMuaW52ZXJ0ZWQ7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmFkZChtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlc3RBbHRlcm5hdGl2ZXMgPSBmdW5jdGlvbiAoYWx0ZXJuYXRpdmVzLCBtYXhPbmVNYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBiZXN0IG1hdGNoIHRoYXQgaXMgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICAgIHZhciBiZXN0TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFsdGVybmF0aXZlc18xID0gYWx0ZXJuYXRpdmVzOyBfaSA8IGFsdGVybmF0aXZlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzdWJTY2hlbWFSZWYgPSBhbHRlcm5hdGl2ZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHN1YlNjaGVtYSA9IGFzU2NoZW1hKHN1YlNjaGVtYVJlZik7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgc3ViU2NoZW1hLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgIGlmICghc3ViVmFsaWRhdGlvblJlc3VsdC5oYXNQcm9ibGVtcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChzdWJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJlc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSB7IHNjaGVtYTogc3ViU2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0OiBzdWJWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXM6IHN1Yk1hdGNoaW5nU2NoZW1hcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhPbmVNYXRjaCAmJiAhc3ViVmFsaWRhdGlvblJlc3VsdC5oYXNQcm9ibGVtcygpICYmICFiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5oYXNQcm9ibGVtcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBlcnJvcnMsIGJvdGggYXJlIGVxdWFsbHkgZ29vZCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gubWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcyArPSBzdWJWYWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyArPSBzdWJWYWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGFyZVJlc3VsdCA9IHN1YlZhbGlkYXRpb25SZXN1bHQuY29tcGFyZShiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgbm9kZSBpcyB0aGUgYmVzdCBtYXRjaGluZyBzbyBmYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSB7IHNjaGVtYTogc3ViU2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0OiBzdWJWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXM6IHN1Yk1hdGNoaW5nU2NoZW1hcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyZVJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYWxyZWFkeSBhIGJlc3QgbWF0Y2hpbmcgYnV0IHdlIGFyZSBhcyBnb29kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLm1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lm1lcmdlRW51bVZhbHVlcyhzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEgJiYgbWF4T25lTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ29uZU9mV2FybmluZycsIFwiTWF0Y2hlcyBtdWx0aXBsZSBzY2hlbWFzIHdoZW4gb25seSBvbmUgbXVzdCB2YWxpZGF0ZS5cIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlKGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzICs9IGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyArPSBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShiZXN0TWF0Y2gubWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkge1xuICAgICAgICAgICAgdGVzdEFsdGVybmF0aXZlcyhzY2hlbWEuYW55T2YsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgICAgICB0ZXN0QWx0ZXJuYXRpdmVzKHNjaGVtYS5vbmVPZiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlc3RCcmFuY2ggPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICB2YXIgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgYXNTY2hlbWEoc2NoZW1hKSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2Uoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXM7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgKz0gc3ViVmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0ZXN0Q29uZGl0aW9uID0gZnVuY3Rpb24gKGlmU2NoZW1hLCB0aGVuU2NoZW1hLCBlbHNlU2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgc3ViU2NoZW1hID0gYXNTY2hlbWEoaWZTY2hlbWEpO1xuICAgICAgICAgICAgdmFyIHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgdmFyIHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUsIHN1YlNjaGVtYSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhlblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXN0QnJhbmNoKHRoZW5TY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsc2VTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICB0ZXN0QnJhbmNoKGVsc2VTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaWZTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuaWYpO1xuICAgICAgICBpZiAoaWZTY2hlbWEpIHtcbiAgICAgICAgICAgIHRlc3RDb25kaXRpb24oaWZTY2hlbWEsIGFzU2NoZW1hKHNjaGVtYS50aGVuKSwgYXNTY2hlbWEoc2NoZW1hLmVsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBnZXROb2RlVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB2YXIgZW51bVZhbHVlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBzY2hlbWEuZW51bTsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWxzKHZhbCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bVZhbHVlTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgPSBzY2hlbWEuZW51bTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggPSBlbnVtVmFsdWVNYXRjaDtcbiAgICAgICAgICAgIGlmICghZW51bVZhbHVlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEVycm9yQ29kZS5FbnVtVmFsdWVNaXNtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgnZW51bVdhcm5pbmcnLCAnVmFsdWUgaXMgbm90IGFjY2VwdGVkLiBWYWxpZCB2YWx1ZXM6IHswfS4nLCBzY2hlbWEuZW51bS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpOyB9KS5qb2luKCcsICcpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKHZhbCwgc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCdjb25zdFdhcm5pbmcnLCAnVmFsdWUgbXVzdCBiZSB7MH0uJywgSlNPTi5zdHJpbmdpZnkoc2NoZW1hLmNvbnN0KSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyA9IFtzY2hlbWEuY29uc3RdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZGVwcmVjYXRpb25NZXNzYWdlICYmIG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5wYXJlbnQub2Zmc2V0LCBsZW5ndGg6IG5vZGUucGFyZW50Lmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZGVwcmVjYXRpb25NZXNzYWdlLFxuICAgICAgICAgICAgICAgIGNvZGU6IEVycm9yQ29kZS5EZXByZWNhdGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVOdW1iZXJOb2RlKG5vZGUsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKSB7XG4gICAgICAgIHZhciB2YWwgPSBub2RlLnZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVGbG9hdHMoZmxvYXQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9eKC0/XFxkKykoPzpcXC4oXFxkKykpPyg/OmUoWy0rXVxcZCspKT8kLy5leGVjKGZsb2F0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzICYmIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogTnVtYmVyKHBhcnRzWzFdICsgKHBhcnRzWzJdIHx8ICcnKSksXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllcjogKCgoX2EgPSBwYXJ0c1syXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMCkgLSAocGFyc2VJbnQocGFydHNbM10pIHx8IDApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKSkge1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IC0xO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XG4gICAgICAgICAgICAgICAgcmVtYWluZGVyID0gdmFsICUgc2NoZW1hLm11bHRpcGxlT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybU11bHRpcGxlT2YgPSBub3JtYWxpemVGbG9hdHMoc2NoZW1hLm11bHRpcGxlT2YpO1xuICAgICAgICAgICAgICAgIHZhciBub3JtVmFsdWUgPSBub3JtYWxpemVGbG9hdHModmFsKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybU11bHRpcGxlT2YgJiYgbm9ybVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIE1hdGguYWJzKG5vcm1WYWx1ZS5tdWx0aXBsaWVyIC0gbm9ybU11bHRpcGxlT2YubXVsdGlwbGllcikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9ybVZhbHVlLm11bHRpcGxpZXIgPCBub3JtTXVsdGlwbGVPZi5tdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtVmFsdWUudmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1NdWx0aXBsZU9mLnZhbHVlICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyID0gbm9ybVZhbHVlLnZhbHVlICUgbm9ybU11bHRpcGxlT2YudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ211bHRpcGxlT2ZXYXJuaW5nJywgJ1ZhbHVlIGlzIG5vdCBkaXZpc2libGUgYnkgezB9LicsIHNjaGVtYS5tdWx0aXBsZU9mKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEV4Y2x1c2l2ZUxpbWl0KGxpbWl0LCBleGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihleGNsdXNpdmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4oZXhjbHVzaXZlKSAmJiBleGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldExpbWl0KGxpbWl0LCBleGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGV4Y2x1c2l2ZSkgfHwgIWV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4Y2x1c2l2ZU1pbmltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWluaW11bSkgJiYgdmFsIDw9IGV4Y2x1c2l2ZU1pbmltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdleGNsdXNpdmVNaW5pbXVtV2FybmluZycsICdWYWx1ZSBpcyBiZWxvdyB0aGUgZXhjbHVzaXZlIG1pbmltdW0gb2YgezB9LicsIGV4Y2x1c2l2ZU1pbmltdW0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhjbHVzaXZlTWF4aW11bSA9IGdldEV4Y2x1c2l2ZUxpbWl0KHNjaGVtYS5tYXhpbXVtLCBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSk7XG4gICAgICAgIGlmIChpc051bWJlcihleGNsdXNpdmVNYXhpbXVtKSAmJiB2YWwgPj0gZXhjbHVzaXZlTWF4aW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ2V4Y2x1c2l2ZU1heGltdW1XYXJuaW5nJywgJ1ZhbHVlIGlzIGFib3ZlIHRoZSBleGNsdXNpdmUgbWF4aW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWF4aW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5pbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1pbmltdW0sIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG1pbmltdW0pICYmIHZhbCA8IG1pbmltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdtaW5pbXVtV2FybmluZycsICdWYWx1ZSBpcyBiZWxvdyB0aGUgbWluaW11bSBvZiB7MH0uJywgbWluaW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhpbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1heGltdW0sIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG1heGltdW0pICYmIHZhbCA+IG1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdtYXhpbXVtV2FybmluZycsICdWYWx1ZSBpcyBhYm92ZSB0aGUgbWF4aW11bSBvZiB7MH0uJywgbWF4aW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZVN0cmluZ05vZGUobm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5MZW5ndGgpICYmIG5vZGUudmFsdWUubGVuZ3RoIDwgc2NoZW1hLm1pbkxlbmd0aCkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ21pbkxlbmd0aFdhcm5pbmcnLCAnU3RyaW5nIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluaW11bSBsZW5ndGggb2YgezB9LicsIHNjaGVtYS5taW5MZW5ndGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1heExlbmd0aCkgJiYgbm9kZS52YWx1ZS5sZW5ndGggPiBzY2hlbWEubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnbWF4TGVuZ3RoV2FybmluZycsICdTdHJpbmcgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW0gbGVuZ3RoIG9mIHswfS4nLCBzY2hlbWEubWF4TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHNjaGVtYS5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gZXh0ZW5kZWRSZWdFeHAoc2NoZW1hLnBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCdwYXR0ZXJuV2FybmluZycsICdTdHJpbmcgZG9lcyBub3QgbWF0Y2ggdGhlIHBhdHRlcm4gb2YgXCJ7MH1cIi4nLCBzY2hlbWEucGF0dGVybilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgc3dpdGNoIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndXJpJzpcbiAgICAgICAgICAgICAgICBjYXNlICd1cmktcmVmZXJlbmNlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGxvY2FsaXplKCd1cmlFbXB0eScsICdVUkkgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSAvXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/Ly5leGVjKG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gbG9jYWxpemUoJ3VyaU1pc3NpbmcnLCAnVVJJIGlzIGV4cGVjdGVkLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbWF0Y2hbMl0gJiYgc2NoZW1hLmZvcm1hdCA9PT0gJ3VyaScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gbG9jYWxpemUoJ3VyaVNjaGVtZU1pc3NpbmcnLCAnVVJJIHdpdGggYSBzY2hlbWUgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLnBhdHRlcm5FcnJvck1lc3NhZ2UgfHwgc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgndXJpRm9ybWF0V2FybmluZycsICdTdHJpbmcgaXMgbm90IGEgVVJJOiB7MH0nLCBlcnJvck1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29sb3ItaGV4JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlLXRpbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNbc2NoZW1hLmZvcm1hdF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS52YWx1ZSB8fCAhZm9ybWF0LnBhdHRlcm4uZXhlYyhub2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLnBhdHRlcm5FcnJvck1lc3NhZ2UgfHwgc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBmb3JtYXQuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlQXJyYXlOb2RlKG5vZGUsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIHZhciBzdWJTY2hlbWFzID0gc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN1YlNjaGVtYXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlNjaGVtYVJlZiA9IHN1YlNjaGVtYXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBub2RlLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShpdGVtLCBzdWJTY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChpdGVtVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuaXRlbXMubGVuZ3RoID49IHN1YlNjaGVtYXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLml0ZW1zLmxlbmd0aCA+IHN1YlNjaGVtYXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3ViU2NoZW1hcy5sZW5ndGg7IGkgPCBub2RlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUobm9kZS5pdGVtc1tpXSwgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChpdGVtVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdhZGRpdGlvbmFsSXRlbXNXYXJuaW5nJywgJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcyBhY2NvcmRpbmcgdG8gc2NoZW1hLiBFeHBlY3RlZCB7MH0gb3IgZmV3ZXIuJywgc3ViU2NoZW1hcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpdGVtU2NoZW1hID0gYXNTY2hlbWEoc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgIGlmIChpdGVtU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUuaXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShpdGVtLCBpdGVtU2NoZW1hLCBpdGVtVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbnNTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuY29udGFpbnMpO1xuICAgICAgICBpZiAoY29udGFpbnNTY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBkb2VzQ29udGFpbiA9IG5vZGUuaXRlbXMuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgY29udGFpbnNTY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWl0ZW1WYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZG9lc0NvbnRhaW4pIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgbG9jYWxpemUoJ3JlcXVpcmVkSXRlbU1pc3NpbmdXYXJuaW5nJywgJ0FycmF5IGRvZXMgbm90IGNvbnRhaW4gcmVxdWlyZWQgaXRlbS4nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmIG5vZGUuaXRlbXMubGVuZ3RoIDwgc2NoZW1hLm1pbkl0ZW1zKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnbWluSXRlbXNXYXJuaW5nJywgJ0FycmF5IGhhcyB0b28gZmV3IGl0ZW1zLiBFeHBlY3RlZCB7MH0gb3IgbW9yZS4nLCBzY2hlbWEubWluSXRlbXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1heEl0ZW1zKSAmJiBub2RlLml0ZW1zLmxlbmd0aCA+IHNjaGVtYS5tYXhJdGVtcykge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ21heEl0ZW1zV2FybmluZycsICdBcnJheSBoYXMgdG9vIG1hbnkgaXRlbXMuIEV4cGVjdGVkIHswfSBvciBmZXdlci4nLCBzY2hlbWEubWF4SXRlbXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnVuaXF1ZUl0ZW1zID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzXzEgPSBnZXROb2RlVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlcyA9IHZhbHVlc18xLnNvbWUoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCAhPT0gdmFsdWVzXzEubGFzdEluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ3VuaXF1ZUl0ZW1zV2FybmluZycsICdBcnJheSBoYXMgZHVwbGljYXRlIGl0ZW1zLicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcykge1xuICAgICAgICB2YXIgc2VlbktleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBub2RlLnByb3BlcnRpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlOb2RlID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BlcnR5Tm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHByb3BlcnR5Tm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBzY2hlbWEucmVxdWlyZWQ7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZW5LZXlzW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleU5vZGUgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIG5vZGUucGFyZW50LmtleU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGtleU5vZGUgPyB7IG9mZnNldDoga2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDoga2V5Tm9kZS5sZW5ndGggfSA6IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiAxIH07XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnTWlzc2luZ1JlcXVpcmVkUHJvcFdhcm5pbmcnLCAnTWlzc2luZyBwcm9wZXJ0eSBcInswfVwiLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eVByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB1bnByb2Nlc3NlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB1bnByb2Nlc3NlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgcHJvcGVydHlQcm9jZXNzZWQocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ocHJvcGVydHlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5Tm9kZSA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgnRGlzYWxsb3dlZEV4dHJhUHJvcFdhcm5pbmcnLCAnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHByb3BlcnR5U2NoZW1hLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9mID0gMCwgX2cgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpOyBfZiA8IF9nLmxlbmd0aDsgX2YrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVBhdHRlcm4gPSBfZ1tfZl07XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gZXh0ZW5kZWRSZWdFeHAocHJvcGVydHlQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaCA9IDAsIF9qID0gdW5wcm9jZXNzZWRQcm9wZXJ0aWVzLnNsaWNlKDApOyBfaCA8IF9qLmxlbmd0aDsgX2grKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gX2pbX2hdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eVByb2Nlc3NlZChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twcm9wZXJ0eVBhdHRlcm5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ocHJvcGVydHlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgbG9jYWxpemUoJ0Rpc2FsbG93ZWRFeHRyYVByb3BXYXJuaW5nJywgJ1Byb3BlcnR5IHswfSBpcyBub3QgYWxsb3dlZC4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHByb3BlcnR5U2NoZW1hLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2sgPSAwLCB1bnByb2Nlc3NlZFByb3BlcnRpZXNfMSA9IHVucHJvY2Vzc2VkUHJvcGVydGllczsgX2sgPCB1bnByb2Nlc3NlZFByb3BlcnRpZXNfMS5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gdW5wcm9jZXNzZWRQcm9wZXJ0aWVzXzFbX2tdO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh1bnByb2Nlc3NlZFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sID0gMCwgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzXzIgPSB1bnByb2Nlc3NlZFByb3BlcnRpZXM7IF9sIDwgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzXzIubGVuZ3RoOyBfbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSB1bnByb2Nlc3NlZFByb3BlcnRpZXNfMltfbF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5Tm9kZSA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgnRGlzYWxsb3dlZEV4dHJhUHJvcFdhcm5pbmcnLCAnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoID4gc2NoZW1hLm1heFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdNYXhQcm9wV2FybmluZycsICdPYmplY3QgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGxpbWl0IG9mIHswfS4nLCBzY2hlbWEubWF4UHJvcGVydGllcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1pblByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCA8IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnTWluUHJvcFdhcm5pbmcnLCAnT2JqZWN0IGhhcyBmZXdlciBwcm9wZXJ0aWVzIHRoYW4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiB7MH0nLCBzY2hlbWEubWluUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX20gPSAwLCBfbyA9IE9iamVjdC5rZXlzKHNjaGVtYS5kZXBlbmRlbmNpZXMpOyBfbSA8IF9vLmxlbmd0aDsgX20rKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfb1tfbV07XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBzZWVuS2V5c1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eURlcCA9IHNjaGVtYS5kZXBlbmRlbmNpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlEZXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcCA9IDAsIHByb3BlcnR5RGVwXzEgPSBwcm9wZXJ0eURlcDsgX3AgPCBwcm9wZXJ0eURlcF8xLmxlbmd0aDsgX3ArKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZFByb3AgPSBwcm9wZXJ0eURlcF8xW19wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5LZXlzW3JlcXVpcmVkUHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdSZXF1aXJlZERlcGVuZGVudFByb3BXYXJuaW5nJywgJ09iamVjdCBpcyBtaXNzaW5nIHByb3BlcnR5IHswfSByZXF1aXJlZCBieSBwcm9wZXJ0eSB7MX0uJywgcmVxdWlyZWRQcm9wLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5U2NoZW1hID0gYXNTY2hlbWEocHJvcGVydHlEZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVzID0gYXNTY2hlbWEoc2NoZW1hLnByb3BlcnR5TmFtZXMpO1xuICAgICAgICBpZiAocHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX3EgPSAwLCBfciA9IG5vZGUucHJvcGVydGllczsgX3EgPCBfci5sZW5ndGg7IF9xKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IF9yW19xXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZi5rZXlOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoa2V5LCBwcm9wZXJ0eU5hbWVzLCB2YWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2UodGV4dERvY3VtZW50LCBjb25maWcpIHtcbiAgICB2YXIgcHJvYmxlbXMgPSBbXTtcbiAgICB2YXIgbGFzdFByb2JsZW1PZmZzZXQgPSAtMTtcbiAgICB2YXIgdGV4dCA9IHRleHREb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgdmFyIHNjYW5uZXIgPSBKc29uLmNyZWF0ZVNjYW5uZXIodGV4dCwgZmFsc2UpO1xuICAgIHZhciBjb21tZW50UmFuZ2VzID0gY29uZmlnICYmIGNvbmZpZy5jb2xsZWN0Q29tbWVudHMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBfc2Nhbk5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5fMSA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICAgICAgX2NoZWNrU2NhbkVycm9yKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuXzEpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMTMgLyogQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21tZW50UmFuZ2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudFJhbmdlcy5wdXNoKFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNSAvKiBUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNCAvKiBMaW5lQnJlYWtUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbl8xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9hY2NlcHQodG9rZW4pIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gdG9rZW4pIHtcbiAgICAgICAgICAgIF9zY2FuTmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXJyb3JBdFJhbmdlKG1lc3NhZ2UsIGNvZGUsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHNldmVyaXR5KSB7XG4gICAgICAgIGlmIChzZXZlcml0eSA9PT0gdm9pZCAwKSB7IHNldmVyaXR5ID0gRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yOyB9XG4gICAgICAgIGlmIChwcm9ibGVtcy5sZW5ndGggPT09IDAgfHwgc3RhcnRPZmZzZXQgIT09IGxhc3RQcm9ibGVtT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc3RhcnRPZmZzZXQpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChlbmRPZmZzZXQpKTtcbiAgICAgICAgICAgIHByb2JsZW1zLnB1c2goRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCB0ZXh0RG9jdW1lbnQubGFuZ3VhZ2VJZCkpO1xuICAgICAgICAgICAgbGFzdFByb2JsZW1PZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZXJyb3IobWVzc2FnZSwgY29kZSwgbm9kZSwgc2tpcFVudGlsQWZ0ZXIsIHNraXBVbnRpbCkge1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7IG5vZGUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyID09PSB2b2lkIDApIHsgc2tpcFVudGlsQWZ0ZXIgPSBbXTsgfVxuICAgICAgICBpZiAoc2tpcFVudGlsID09PSB2b2lkIDApIHsgc2tpcFVudGlsID0gW107IH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICB2YXIgZW5kID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpO1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCAmJiBzdGFydCA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIC9cXHMvLnRlc3QodGV4dC5jaGFyQXQoc3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgX2Vycm9yQXRSYW5nZShtZXNzYWdlLCBjb2RlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIF9maW5hbGl6ZShub2RlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5fMiA9IHNjYW5uZXIuZ2V0VG9rZW4oKTtcbiAgICAgICAgICAgIHdoaWxlICh0b2tlbl8yICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIuaW5kZXhPZih0b2tlbl8yKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NjYW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChza2lwVW50aWwuaW5kZXhPZih0b2tlbl8yKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuXzIgPSBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NoZWNrU2NhbkVycm9yKCkge1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpKSB7XG4gICAgICAgICAgICBjYXNlIDQgLyogSW52YWxpZFVuaWNvZGUgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdJbnZhbGlkVW5pY29kZScsICdJbnZhbGlkIHVuaWNvZGUgc2VxdWVuY2UgaW4gc3RyaW5nLicpLCBFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSA1IC8qIEludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyJywgJ0ludmFsaWQgZXNjYXBlIGNoYXJhY3RlciBpbiBzdHJpbmcuJyksIEVycm9yQ29kZS5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBVbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdVbmV4cGVjdGVkRW5kT2ZOdW1iZXInLCAnVW5leHBlY3RlZCBlbmQgb2YgbnVtYmVyLicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBVbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnVW5leHBlY3RlZEVuZE9mQ29tbWVudCcsICdVbmV4cGVjdGVkIGVuZCBvZiBjb21tZW50LicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDIgLyogVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnVW5leHBlY3RlZEVuZE9mU3RyaW5nJywgJ1VuZXhwZWN0ZWQgZW5kIG9mIHN0cmluZy4nKSwgRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDYgLyogSW52YWxpZENoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0ludmFsaWRDaGFyYWN0ZXInLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIHN0cmluZy4gQ29udHJvbCBjaGFyYWN0ZXJzIG11c3QgYmUgZXNjYXBlZC4nKSwgRXJyb3JDb2RlLkludmFsaWRDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZpbmFsaXplKG5vZGUsIHNjYW5OZXh0KSB7XG4gICAgICAgIG5vZGUubGVuZ3RoID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpIC0gbm9kZS5vZmZzZXQ7XG4gICAgICAgIGlmIChzY2FuTmV4dCkge1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZUFycmF5KHBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAzIC8qIE9wZW5CcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgQXJyYXlBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIE9wZW5CcmFja2V0VG9rZW5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBzY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBDb21tYVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnVmFsdWVFeHBlY3RlZCcsICdWYWx1ZSBleHBlY3RlZCcpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UobG9jYWxpemUoJ1RyYWlsaW5nQ29tbWEnLCAnVHJhaWxpbmcgY29tbWEnKSwgRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEsIGNvbW1hT2Zmc2V0LCBjb21tYU9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0V4cGVjdGVkQ29tbWEnLCAnRXhwZWN0ZWQgY29tbWEnKSwgRXJyb3JDb2RlLkNvbW1hRXhwZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfcGFyc2VWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnUHJvcGVydHlFeHBlY3RlZCcsICdWYWx1ZSBleHBlY3RlZCcpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCwgdW5kZWZpbmVkLCBbXSwgWzQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVlZHNDb21tYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcihsb2NhbGl6ZSgnRXhwZWN0ZWRDbG9zZUJyYWNrZXQnLCAnRXhwZWN0ZWQgY29tbWEgb3IgY2xvc2luZyBicmFja2V0JyksIEVycm9yQ29kZS5Db21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIGtleVBsYWNlaG9sZGVyID0gbmV3IFN0cmluZ0FTVE5vZGVJbXBsKHVuZGVmaW5lZCwgMCwgMCk7XG4gICAgZnVuY3Rpb24gX3BhcnNlUHJvcGVydHkocGFyZW50LCBrZXlzU2Vlbikge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBQcm9wZXJ0eUFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBrZXlQbGFjZWhvbGRlcik7XG4gICAgICAgIHZhciBrZXkgPSBfcGFyc2VTdHJpbmcobm9kZSk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSAxNiAvKiBVbmtub3duICovKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2l2ZSBhIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdEb3VibGVRdW90ZXNFeHBlY3RlZCcsICdQcm9wZXJ0eSBrZXlzIG11c3QgYmUgZG91YmxlcXVvdGVkJyksIEVycm9yQ29kZS5VbmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHZhciBrZXlOb2RlID0gbmV3IFN0cmluZ0FTVE5vZGVJbXBsKG5vZGUsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICBrZXlOb2RlLnZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5Tm9kZTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBVbmtub3duXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUua2V5Tm9kZSA9IGtleTtcbiAgICAgICAgdmFyIHNlZW4gPSBrZXlzU2VlbltrZXkudmFsdWVdO1xuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgX2Vycm9yQXRSYW5nZShsb2NhbGl6ZSgnRHVwbGljYXRlS2V5V2FybmluZycsIFwiRHVwbGljYXRlIG9iamVjdCBrZXlcIiksIEVycm9yQ29kZS5EdXBsaWNhdGVLZXksIG5vZGUua2V5Tm9kZS5vZmZzZXQsIG5vZGUua2V5Tm9kZS5vZmZzZXQgKyBub2RlLmtleU5vZGUubGVuZ3RoLCBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlZW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yQXRSYW5nZShsb2NhbGl6ZSgnRHVwbGljYXRlS2V5V2FybmluZycsIFwiRHVwbGljYXRlIG9iamVjdCBrZXlcIiksIEVycm9yQ29kZS5EdXBsaWNhdGVLZXksIHNlZW4ua2V5Tm9kZS5vZmZzZXQsIHNlZW4ua2V5Tm9kZS5vZmZzZXQgKyBzZWVuLmtleU5vZGUubGVuZ3RoLCBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlzU2VlbltrZXkudmFsdWVdID0gdHJ1ZTsgLy8gaWYgdGhlIHNhbWUga2V5IGlzIGR1cGxpY2F0ZSBhZ2FpbiwgYXZvaWQgZHVwbGljYXRlIGVycm9yIHJlcG9ydGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1NlZW5ba2V5LnZhbHVlXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNiAvKiBDb2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBub2RlLmNvbG9uT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgQ29sb25Ub2tlblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdDb2xvbkV4cGVjdGVkJywgJ0NvbG9uIGV4cGVjdGVkJyksIEVycm9yQ29kZS5Db2xvbkV4cGVjdGVkKTtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDEwIC8qIFN0cmluZ0xpdGVyYWwgKi8gJiYgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoa2V5Lm9mZnNldCArIGtleS5sZW5ndGgpLmxpbmUgPCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxlbmd0aCA9IGtleS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gX3BhcnNlVmFsdWUobm9kZSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXJyb3IobG9jYWxpemUoJ1ZhbHVlRXhwZWN0ZWQnLCAnVmFsdWUgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIG5vZGUsIFtdLCBbMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudmFsdWVOb2RlID0gdmFsdWU7XG4gICAgICAgIG5vZGUubGVuZ3RoID0gdmFsdWUub2Zmc2V0ICsgdmFsdWUubGVuZ3RoIC0gbm9kZS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VPYmplY3QocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDEgLyogT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgT2JqZWN0QVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICB2YXIga2V5c1NlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBPcGVuQnJhY2VUb2tlblxuICAgICAgICB2YXIgbmVlZHNDb21tYSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIENsb3NlQnJhY2VUb2tlbiAqLyAmJiBzY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBDb21tYVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnUHJvcGVydHlFeHBlY3RlZCcsICdQcm9wZXJ0eSBleHBlY3RlZCcpLCBFcnJvckNvZGUuUHJvcGVydHlFeHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDIgLyogQ2xvc2VCcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3JBdFJhbmdlKGxvY2FsaXplKCdUcmFpbGluZ0NvbW1hJywgJ1RyYWlsaW5nIGNvbW1hJyksIEVycm9yQ29kZS5UcmFpbGluZ0NvbW1hLCBjb21tYU9mZnNldCwgY29tbWFPZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdFeHBlY3RlZENvbW1hJywgJ0V4cGVjdGVkIGNvbW1hJyksIEVycm9yQ29kZS5Db21tYUV4cGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IF9wYXJzZVByb3BlcnR5KG5vZGUsIGtleXNTZWVuKTtcbiAgICAgICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ1Byb3BlcnR5RXhwZWN0ZWQnLCAnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQsIHVuZGVmaW5lZCwgW10sIFsyIC8qIENsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIENsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcihsb2NhbGl6ZSgnRXhwZWN0ZWRDbG9zZUJyYWNlJywgJ0V4cGVjdGVkIGNvbW1hIG9yIGNsb3NpbmcgYnJhY2UnKSwgRXJyb3JDb2RlLkNvbW1hT3JDbG9zZUJyYWNlRXhwZWN0ZWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZVN0cmluZyhwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTAgLyogU3RyaW5nTGl0ZXJhbCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBTdHJpbmdBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIG5vZGUudmFsdWUgPSBzY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlTnVtYmVyKHBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxMSAvKiBOdW1lcmljTGl0ZXJhbCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOdW1iZXJBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuRXJyb3IoKSA9PT0gMCAvKiBOb25lICovKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5WYWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyVmFsdWUgPSBKU09OLnBhcnNlKHRva2VuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIobnVtYmVyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXJyb3IobG9jYWxpemUoJ0ludmFsaWROdW1iZXJGb3JtYXQnLCAnSW52YWxpZCBudW1iZXIgZm9ybWF0LicpLCBFcnJvckNvZGUuVW5kZWZpbmVkLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG51bWJlclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Vycm9yKGxvY2FsaXplKCdJbnZhbGlkTnVtYmVyRm9ybWF0JywgJ0ludmFsaWQgbnVtYmVyIGZvcm1hdC4nKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmlzSW50ZWdlciA9IHRva2VuVmFsdWUuaW5kZXhPZignLicpID09PSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VMaXRlcmFsKHBhcmVudCkge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgc3dpdGNoIChzY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgNyAvKiBOdWxsS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBOdWxsQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgOCAvKiBUcnVlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCB0cnVlLCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgOSAvKiBGYWxzZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShuZXcgQm9vbGVhbkFTVE5vZGVJbXBsKHBhcmVudCwgZmFsc2UsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSksIHRydWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZVZhbHVlKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gX3BhcnNlQXJyYXkocGFyZW50KSB8fCBfcGFyc2VPYmplY3QocGFyZW50KSB8fCBfcGFyc2VTdHJpbmcocGFyZW50KSB8fCBfcGFyc2VOdW1iZXIocGFyZW50KSB8fCBfcGFyc2VMaXRlcmFsKHBhcmVudCk7XG4gICAgfVxuICAgIHZhciBfcm9vdCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdG9rZW4gPSBfc2Nhbk5leHQoKTtcbiAgICBpZiAodG9rZW4gIT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICBfcm9vdCA9IF9wYXJzZVZhbHVlKF9yb290KTtcbiAgICAgICAgaWYgKCFfcm9vdCkge1xuICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdJbnZhbGlkIHN5bWJvbCcsICdFeHBlY3RlZCBhIEpTT04gb2JqZWN0LCBhcnJheSBvciBsaXRlcmFsLicpLCBFcnJvckNvZGUuVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdFbmQgb2YgZmlsZSBleHBlY3RlZCcsICdFbmQgb2YgZmlsZSBleHBlY3RlZC4nKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBKU09ORG9jdW1lbnQoX3Jvb3QsIHByb2JsZW1zLCBjb21tZW50UmFuZ2VzKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIGluZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCkge1xuICAgIGlmIChvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIG5ld0luZGVudCA9IGluZGVudCArICdcXHQnO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICdbXFxuJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIHN0cmluZ2lmeU9iamVjdChvYmpbaV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBvYmoubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50ICsgJ10nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICd7XFxuJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBuZXdJbmRlbnQgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJzogJyArIHN0cmluZ2lmeU9iamVjdChvYmpba2V5XSwgbmV3SW5kZW50LCBzdHJpbmdpZnlMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50ICsgJ30nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5TGl0ZXJhbChvYmopO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyL2pzb25QYXJzZXIuanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuLy4uLy4uL2pzb25jLXBhcnNlci9tYWluLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeU9iamVjdCB9IGZyb20gJy4uL3V0aWxzL2pzb24uanMnO1xuaW1wb3J0IHsgZW5kc1dpdGgsIGV4dGVuZGVkUmVnRXhwIH0gZnJvbSAnLi4vdXRpbHMvc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlscy9vYmplY3RzLmpzJztcbmltcG9ydCB7IENvbXBsZXRpb25JdGVtLCBDb21wbGV0aW9uSXRlbUtpbmQsIFJhbmdlLCBUZXh0RWRpdCwgSW5zZXJ0VGV4dEZvcm1hdCwgTWFya3VwS2luZCB9IGZyb20gJy4uL2pzb25MYW5ndWFnZVR5cGVzLmpzJztcbmltcG9ydCAqIGFzIG5scyBmcm9tICcuLy4uLy4uLy4uL2ZpbGxlcnMvdnNjb2RlLW5scy5qcyc7XG52YXIgbG9jYWxpemUgPSBubHMubG9hZE1lc3NhZ2VCdW5kbGUoKTtcbnZhciB2YWx1ZUNvbW1pdENoYXJhY3RlcnMgPSBbJywnLCAnfScsICddJ107XG52YXIgcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzID0gWyc6J107XG52YXIgSlNPTkNvbXBsZXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTkNvbXBsZXRpb24oc2NoZW1hU2VydmljZSwgY29udHJpYnV0aW9ucywgcHJvbWlzZUNvbnN0cnVjdG9yLCBjbGllbnRDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgaWYgKGNvbnRyaWJ1dGlvbnMgPT09IHZvaWQgMCkgeyBjb250cmlidXRpb25zID0gW107IH1cbiAgICAgICAgaWYgKHByb21pc2VDb25zdHJ1Y3RvciA9PT0gdm9pZCAwKSB7IHByb21pc2VDb25zdHJ1Y3RvciA9IFByb21pc2U7IH1cbiAgICAgICAgaWYgKGNsaWVudENhcGFiaWxpdGllcyA9PT0gdm9pZCAwKSB7IGNsaWVudENhcGFiaWxpdGllcyA9IHt9OyB9XG4gICAgICAgIHRoaXMuc2NoZW1hU2VydmljZSA9IHNjaGVtYVNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9ucyA9IGNvbnRyaWJ1dGlvbnM7XG4gICAgICAgIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZUNvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLmNsaWVudENhcGFiaWxpdGllcyA9IGNsaWVudENhcGFiaWxpdGllcztcbiAgICB9XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmRvUmVzb2x2ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlQ29tcGxldGlvbiA9IHRoaXMuY29udHJpYnV0aW9uc1tpXS5yZXNvbHZlQ29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHJlc29sdmVDb21wbGV0aW9uKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VDb25zdHJ1Y3Rvci5yZXNvbHZlKGl0ZW0pO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmRvQ29tcGxldGUgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHBvc2l0aW9uLCBkb2MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgIGlzSW5jb21wbGV0ZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChwb3NpdGlvbik7XG4gICAgICAgIHZhciBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5Db21tZW50KGRvY3VtZW50LCBub2RlID8gbm9kZS5vZmZzZXQgOiAwLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgJiYgKG9mZnNldCA9PT0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkgJiYgb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGV4dFtvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnICYmIGNoID09PSAnfScgfHwgbm9kZS50eXBlID09PSAnYXJyYXknICYmIGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAvLyBhZnRlciBdIG9yIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRXb3JkID0gdGhpcy5nZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KTtcbiAgICAgICAgdmFyIG92ZXJ3cml0ZVJhbmdlO1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb3ZlcndyaXRlUmFuZ2UgPSBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG92ZXJ3cml0ZVN0YXJ0ID0gb2Zmc2V0IC0gY3VycmVudFdvcmQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZVN0YXJ0ID4gMCAmJiB0ZXh0W292ZXJ3cml0ZVN0YXJ0IC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGVTdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcndyaXRlUmFuZ2UgPSBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChvdmVyd3JpdGVTdGFydCksIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzID0gZmFsc2U7IC8vdGhpcy5kb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKCk7IGRpc2FibGVkIGZvciBub3csIHdhaXRpbmcgZm9yIG5ldyBBUEk6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvdnNjb2RlL2lzc3Vlcy80MjU0NFxuICAgICAgICB2YXIgcHJvcG9zZWQgPSB7fTtcbiAgICAgICAgdmFyIGNvbGxlY3RvciA9IHtcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKHN1Z2dlc3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBzdWdnZXN0aW9uLmxhYmVsO1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHByb3Bvc2VkW2xhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwucmVwbGFjZSgvW1xcbl0vZywgJ+KGtScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwubGVuZ3RoID4gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG9ydGVuZGVkTGFiZWwgPSBsYWJlbC5zdWJzdHIoMCwgNTcpLnRyaW0oKSArICcuLi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wb3NlZFtzaG9ydGVuZGVkTGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBzaG9ydGVuZGVkTGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZVJhbmdlICYmIHN1Z2dlc3Rpb24uaW5zZXJ0VGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLnRleHRFZGl0ID0gVGV4dEVkaXQucmVwbGFjZShvdmVyd3JpdGVSYW5nZSwgc3VnZ2VzdGlvbi5pbnNlcnRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLmNvbW1pdENoYXJhY3RlcnMgPSBzdWdnZXN0aW9uLmtpbmQgPT09IENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA/IHByb3BlcnR5Q29tbWl0Q2hhcmFjdGVycyA6IHZhbHVlQ29tbWl0Q2hhcmFjdGVycztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHByb3Bvc2VkW2xhYmVsXSA9IHN1Z2dlc3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pdGVtcy5wdXNoKHN1Z2dlc3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZy5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5kb2N1bWVudGF0aW9uID0gc3VnZ2VzdGlvbi5kb2N1bWVudGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcuZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5kZXRhaWwgPSBzdWdnZXN0aW9uLmRldGFpbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBc0luY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaXNJbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROdW1iZXJPZlByb3Bvc2FsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFTZXJ2aWNlLmdldFNjaGVtYUZvclJlc291cmNlKGRvY3VtZW50LnVyaSwgZG9jKS50aGVuKGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhZGRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY3VycmVudEtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZSA9ICFwYXJlbnQudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEtleSA9IHRleHQuc3Vic3RyKG5vZGUub2Zmc2V0ICsgMSwgbm9kZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3Qga2V5cyB3aGVuIHRoZSBjdXJzb3IgaXMganVzdCBiZWZvcmUgdGhlIG9wZW5pbmcgY3VybHkgYnJhY2VcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdWdnZXN0IHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBub2RlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5IHx8IGN1cnJlbnRQcm9wZXJ0eSAhPT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWRbcC5rZXlOb2RlLnZhbHVlXSA9IENvbXBsZXRpb25JdGVtLmNyZWF0ZSgnX18nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JBZnRlcl8xID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGFkZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvckFmdGVyXzEgPSBfdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBkb2N1bWVudC5vZmZzZXRBdChvdmVyd3JpdGVSYW5nZS5lbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBwcm9wb3NhbHMgd2l0aCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0UHJvcGVydHlDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyXzEsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBwcm9wb3NhbHMgd2l0aG91dCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0U2NoZW1hTGVzc1Byb3BlcnR5Q29tcGxldGlvbnMoZG9jLCBub2RlLCBjdXJyZW50S2V5LCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25fMSA9IFBhcnNlci5nZXROb2RlUGF0aChub2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250cmlidXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyaWJ1dGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdFByb3BlcnR5Q29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBsb2NhdGlvbl8xLCBjdXJyZW50V29yZCwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyXzEgPT09ICcnLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICgoIXNjaGVtYSAmJiBjdXJyZW50V29yZC5sZW5ndGggPiAwICYmIHRleHQuY2hhckF0KG9mZnNldCAtIGN1cnJlbnRXb3JkLmxlbmd0aCAtIDEpICE9PSAnXCInKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5nZXRMYWJlbEZvclZhbHVlKGN1cnJlbnRXb3JkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IF90aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShjdXJyZW50V29yZCwgdW5kZWZpbmVkLCBmYWxzZSwgc2VwYXJhdG9yQWZ0ZXJfMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLnNldEFzSW5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgdmFsdWVzXG4gICAgICAgICAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBwcm9wb3NhbHMgd2l0aCBzY2hlbWFcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHByb3Bvc2FscyB3aXRob3V0IHNjaGVtYVxuICAgICAgICAgICAgICAgIF90aGlzLmdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5jb250cmlidXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nZXRDb250cmlidXRlZFZhbHVlQ29tcGxldGlvbnMoZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIGNvbGxlY3Rpb25Qcm9taXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvbWlzZUNvbnN0cnVjdG9yLmFsbChjb2xsZWN0aW9uUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0b3IuZ2V0TnVtYmVyT2ZQcm9wb3NhbHMoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yQWZ0ZXIgPSBfdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBvZmZzZXRGb3JTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRGaWxsZXJWYWx1ZUNvbXBsZXRpb25zKHR5cGVzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRQcm9wZXJ0eUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKHNjaGVtYSwgZG9jLCBub2RlLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XG4gICAgICAgIG1hdGNoaW5nU2NoZW1hcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYVByb3BlcnRpZXNfMSA9IHMuc2NoZW1hLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnRpZXNfMSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWFQcm9wZXJ0aWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5U2NoZW1hID0gc2NoZW1hUHJvcGVydGllc18xW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5U2NoZW1hID09PSAnb2JqZWN0JyAmJiAhcHJvcGVydHlTY2hlbWEuZGVwcmVjYXRpb25NZXNzYWdlICYmICFwcm9wZXJ0eVNjaGVtYS5kb05vdFN1Z2dlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KGtleSwgcHJvcGVydHlTY2hlbWEsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogX3RoaXMuZ2V0RmlsdGVyVGV4dEZvclZhbHVlKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IF90aGlzLmZyb21NYXJrdXAocHJvcGVydHlTY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgcHJvcGVydHlTY2hlbWEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEuc3VnZ2VzdFNvcnRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwuc29ydFRleHQgPSBwcm9wZXJ0eVNjaGVtYS5zdWdnZXN0U29ydFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wb3NhbC5pbnNlcnRUZXh0ICYmIGVuZHNXaXRoKHByb3Bvc2FsLmluc2VydFRleHQsIFwiJDFcIiArIHNlcGFyYXRvckFmdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5jb21tYW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdTdWdnZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHByb3Bvc2FsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzY2hlbWFQcm9wZXJ0eU5hbWVzXzEgPSBzLnNjaGVtYS5wcm9wZXJ0eU5hbWVzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hUHJvcGVydHlOYW1lc18xID09PSAnb2JqZWN0JyAmJiAhc2NoZW1hUHJvcGVydHlOYW1lc18xLmRlcHJlY2F0aW9uTWVzc2FnZSAmJiAhc2NoZW1hUHJvcGVydHlOYW1lc18xLmRvTm90U3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0gPSBmdW5jdGlvbiAobmFtZSwgZW51bURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW51bURlc2NyaXB0aW9uID09PSB2b2lkIDApIHsgZW51bURlc2NyaXB0aW9uID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcG9zYWwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IF90aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShuYW1lLCB1bmRlZmluZWQsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IF90aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBlbnVtRGVzY3JpcHRpb24gfHwgX3RoaXMuZnJvbU1hcmt1cChzY2hlbWFQcm9wZXJ0eU5hbWVzXzEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hUHJvcGVydHlOYW1lc18xLmRlc2NyaXB0aW9uIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuc3VnZ2VzdFNvcnRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5zb3J0VGV4dCA9IHNjaGVtYVByb3BlcnR5TmFtZXNfMS5zdWdnZXN0U29ydFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcG9zYWwuaW5zZXJ0VGV4dCAmJiBlbmRzV2l0aChwcm9wb3NhbC5pbnNlcnRUZXh0LCBcIiQxXCIgKyBzZXBhcmF0b3JBZnRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5jb21tYW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1N1Z2dlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnZWRpdG9yLmFjdGlvbi50cmlnZ2VyU3VnZ2VzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZChwcm9wb3NhbCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZW51bS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnVtRGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMgJiYgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXNfMS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1EZXNjcmlwdGlvbiA9IF90aGlzLmZyb21NYXJrdXAoc2NoZW1hUHJvcGVydHlOYW1lc18xLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5lbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bURlc2NyaXB0aW9uID0gc2NoZW1hUHJvcGVydHlOYW1lc18xLmVudW1EZXNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZUNvbXBsZXRpb25JdGVtKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5lbnVtW2ldLCBlbnVtRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuY29uc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZUNvbXBsZXRpb25JdGVtKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5jb25zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldFNjaGVtYUxlc3NQcm9wZXJ0eUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKGRvYywgbm9kZSwgY3VycmVudEtleSwgY29sbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0Q29tcGxldGlvbnNGb3JTaW1pbGFyT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgb2JqLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwLmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGtleSwgJycpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IF90aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgcHJvcGVydHkgdmFsdWUsIGNoZWNrIHRoZSB0cmVlIGZvciBvdGhlciBvYmplY3RzIHRoYXQgaGFuZyB1bmRlciBhIHByb3BlcnR5IG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50S2V5XzEgPSBub2RlLnBhcmVudC5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvYy52aXNpdChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSAncHJvcGVydHknICYmIG4gIT09IG5vZGUucGFyZW50ICYmIG4ua2V5Tm9kZS52YWx1ZSA9PT0gcGFyZW50S2V5XzEgJiYgbi52YWx1ZU5vZGUgJiYgbi52YWx1ZU5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3Qobi52YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgaW4gYW4gYXJyYXksIHVzZSBhbGwgb3RoZXIgYXJyYXkgZWxlbWVudHMgYXMgc2ltaWxhciBvYmplY3RzXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSAnb2JqZWN0JyAmJiBuICE9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0Q29tcGxldGlvbnNGb3JTaW1pbGFyT2JqZWN0KG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnJHNjaGVtYScsXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoJyRzY2hlbWEnLCB1bmRlZmluZWQsIHRydWUsICcnKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnLFxuICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IHRoaXMuZ2V0RmlsdGVyVGV4dEZvclZhbHVlKFwiJHNjaGVtYVwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRTY2hlbWFMZXNzVmFsdWVDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ29iamVjdCcpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRW1wdHkgb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh7fSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdhcnJheScpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRW1wdHkgYXJyYXknLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKFtdLCAnJyksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XG4gICAgICAgIHZhciBjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5wYXJlbnQgJiYgIVBhcnNlci5jb250YWlucyh2YWx1ZS5wYXJlbnQsIG9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogX3RoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodmFsdWUudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5nZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUodmFsdWUsIGRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvck1hdGNoaW5nTm9kZSh2YWx1ZSwgZG9jdW1lbnQsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LCBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24oIXZhbHVlLnZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IChub2RlLmNvbG9uT2Zmc2V0IHx8IDApKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUgJiYgKG9mZnNldCA+ICh2YWx1ZU5vZGUub2Zmc2V0ICsgdmFsdWVOb2RlLmxlbmd0aCkgfHwgdmFsdWVOb2RlLnR5cGUgPT09ICdvYmplY3QnIHx8IHZhbHVlTm9kZS50eXBlID09PSAnYXJyYXknKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3QgdmFsdWVzIGF0IHRoZSBzYW1lIGtleVxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRLZXlfMiA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2MudmlzaXQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleV8yICYmIG4udmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMobi52YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRLZXlfMiA9PT0gJyRzY2hlbWEnICYmIG5vZGUucGFyZW50ICYmICFub2RlLnBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyhzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0IGl0ZW1zIG9mIGFuIGFycmF5IGF0IHRoZSBzYW1lIGtleVxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRLZXlfMyA9IG5vZGUucGFyZW50LmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZG9jLnZpc2l0KGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgbi5rZXlOb2RlLnZhbHVlID09PSBwYXJlbnRLZXlfMyAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnZhbHVlTm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0IGl0ZW1zIGluIHRoZSBzYW1lIGFycmF5XG4gICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRWYWx1ZUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKHNjaGVtYSwgZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIHR5cGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXRGb3JTZXBhcmF0b3IgPSBvZmZzZXQ7XG4gICAgICAgIHZhciBwYXJlbnRLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB2YWx1ZU5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpKSB7XG4gICAgICAgICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzY2hlbWEuc2NoZW1hLCAnJywgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChub2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpICYmIG9mZnNldCA+IChub2RlLmNvbG9uT2Zmc2V0IHx8IDApKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVOb2RlXzEgPSBub2RlLnZhbHVlTm9kZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZU5vZGVfMSAmJiBvZmZzZXQgPiAodmFsdWVOb2RlXzEub2Zmc2V0ICsgdmFsdWVOb2RlXzEubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gd2UgYXJlIHBhc3QgdGhlIHZhbHVlIG5vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudEtleSA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAmJiAocGFyZW50S2V5ICE9PSB1bmRlZmluZWQgfHwgbm9kZS50eXBlID09PSAnYXJyYXknKSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckFmdGVyID0gdGhpcy5ldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBvZmZzZXRGb3JTZXBhcmF0b3IpO1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nU2NoZW1hcyA9IGRvYy5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSwgbm9kZS5vZmZzZXQsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hdGNoaW5nU2NoZW1hc18xID0gbWF0Y2hpbmdTY2hlbWFzOyBfaSA8IG1hdGNoaW5nU2NoZW1hc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gbWF0Y2hpbmdTY2hlbWFzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChzLm5vZGUgPT09IG5vZGUgJiYgIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5JyAmJiBzLnNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocy5zY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSXRlbUF0T2Zmc2V0KG5vZGUsIGRvY3VtZW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHMuc2NoZW1hLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocy5zY2hlbWEuaXRlbXNbaW5kZXhdLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMuc2NoZW1hLml0ZW1zLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLnByb3BlcnRpZXNbcGFyZW50S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICYmICFwcm9wZXJ0eU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gT2JqZWN0LmtleXMocy5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMpOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gZXh0ZW5kZWRSZWdFeHAocGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlTY2hlbWEgPSBzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhwcm9wZXJ0eVNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmICFwcm9wZXJ0eU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlTY2hlbWEgPSBzLnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocHJvcGVydHlTY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRLZXkgPT09ICckc2NoZW1hJyAmJiAhbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVzWydib29sZWFuJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24odHJ1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uKGZhbHNlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlc1snbnVsbCddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGROdWxsVmFsdWVDb21wbGV0aW9uKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0Q29udHJpYnV0ZWRWYWx1ZUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCBjb2xsZWN0aW9uUHJvbWlzZXMpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3RQcm9taXNlID0gY29udHJpYnV0aW9uLmNvbGxlY3REZWZhdWx0Q29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uUHJvbWlzZXMucHVzaChjb2xsZWN0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5JykgJiYgb2Zmc2V0ID4gKG5vZGUuY29sb25PZmZzZXQgfHwgMCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50S2V5XzQgPSBub2RlLmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICgoIXZhbHVlTm9kZSB8fCBvZmZzZXQgPD0gKHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoKSkgJiYgbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uXzIgPSBQYXJzZXIuZ2V0Tm9kZVBhdGgobm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdFZhbHVlQ29tcGxldGlvbnMoZG9jdW1lbnQudXJpLCBsb2NhdGlvbl8yLCBwYXJlbnRLZXlfNCwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5hZGRFbnVtVmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5hZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyhzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0VHlwZXMoc2NoZW1hLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLmFsbE9mLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF90aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuYW55T2YuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gX3RoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5vbmVPZi5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBfdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5hZGREZWZhdWx0VmFsdWVDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIGFycmF5RGVwdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFycmF5RGVwdGggPT09IHZvaWQgMCkgeyBhcnJheURlcHRoID0gMDsgfVxuICAgICAgICB2YXIgaGFzUHJvcG9zYWxzID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NoZW1hLmRlZmF1bHQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiBsb2NhbGl6ZSgnanNvbi5zdWdnZXN0LmRlZmF1bHQnLCAnRGVmYXVsdCB2YWx1ZScpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmV4YW1wbGVzKSkge1xuICAgICAgICAgICAgc2NoZW1hLmV4YW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKGV4YW1wbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4YW1wbGU7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5RGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IF90aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogX3RoaXMuZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IF90aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmRlZmF1bHRTbmlwcGV0cykpIHtcbiAgICAgICAgICAgIHNjaGVtYS5kZWZhdWx0U25pcHBldHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcy5ib2R5O1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHMubGFiZWw7XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydFRleHQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlclRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVfMSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZV8xID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0ID0gX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gX3RoaXMuZ2V0RmlsdGVyVGV4dEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwgfHwgX3RoaXMuZ2V0TGFiZWxGb3JTbmlwcGV0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcy5ib2R5VGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9ICcnLCBzdWZmaXggPSAnJywgaW5kZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggKyBpbmRlbnQgKyAnW1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXggKyAnXFxuJyArIGluZGVudCArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQgPSBwcmVmaXggKyBpbmRlbnQgKyBzLmJvZHlUZXh0LnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgaW5kZW50KSArIHN1ZmZpeCArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IGluc2VydFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gaW5zZXJ0VGV4dC5yZXBsYWNlKC9bXFxuXS9nLCAnJyk7IC8vIHJlbW92ZSBuZXcgbGluZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IF90aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IF90aGlzLmZyb21NYXJrdXAocy5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBzLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiBpbnNlcnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQ6IGZpbHRlclRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNQcm9wb3NhbHMgJiYgdHlwZW9mIHNjaGVtYS5pdGVtcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSAmJiBhcnJheURlcHRoIDwgNSAvKiBiZXdhcmUgb2YgcmVjdXJzaW9uICovKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlZmF1bHRWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYS5pdGVtcywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgYXJyYXlEZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuYWRkRW51bVZhbHVlQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQoc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZChzY2hlbWEudHlwZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWEuY29uc3QpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHNjaGVtYS5jb25zdCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmZyb21NYXJrdXAoc2NoZW1hLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHNjaGVtYS5kZXNjcmlwdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2NoZW1hLmVudW0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5tID0gc2NoZW1hLmVudW1baV07XG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50YXRpb24gPSB0aGlzLmZyb21NYXJrdXAoc2NoZW1hLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHNjaGVtYS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucyAmJiBpIDwgc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucy5sZW5ndGggJiYgdGhpcy5kb2VzU3VwcG9ydE1hcmtkb3duKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmVudW1EZXNjcmlwdGlvbnMgJiYgaSA8IHNjaGVtYS5lbnVtRGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uID0gc2NoZW1hLmVudW1EZXNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHNjaGVtYS50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShlbm0pLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShlbm0sIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBkb2N1bWVudGF0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5jb2xsZWN0VHlwZXMgPSBmdW5jdGlvbiAoc2NoZW1hLCB0eXBlcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkgfHwgaXNEZWZpbmVkKHNjaGVtYS5jb25zdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgdHlwZS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0eXBlc1t0XSA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmFkZEZpbGxlclZhbHVlQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAodHlwZXMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVzWydvYmplY3QnXSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICd7fScsXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHt9LCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRldGFpbDogbG9jYWxpemUoJ2RlZmF1bHRzLm9iamVjdCcsICdOZXcgb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc1snYXJyYXknXSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnYXJyYXknKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1tdJyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUoW10sIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiBsb2NhbGl6ZSgnZGVmYXVsdHMuYXJyYXknLCAnTmV3IGFycmF5JyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ2Jvb2xlYW4nKSxcbiAgICAgICAgICAgIGxhYmVsOiB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuYWRkTnVsbFZhbHVlQ29tcGxldGlvbiA9IGZ1bmN0aW9uIChzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnbnVsbCcpLFxuICAgICAgICAgICAgbGFiZWw6ICdudWxsJyxcbiAgICAgICAgICAgIGluc2VydFRleHQ6ICdudWxsJyArIHNlcGFyYXRvckFmdGVyLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuYWRkRG9sbGFyU2NoZW1hQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2NoZW1hSWRzID0gdGhpcy5zY2hlbWFTZXJ2aWNlLmdldFJlZ2lzdGVyZWRTY2hlbWFJZHMoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hID09PSAnaHR0cCcgfHwgc2NoZW1hID09PSAnaHR0cHMnOyB9KTtcbiAgICAgICAgc2NoZW1hSWRzLmZvckVhY2goZnVuY3Rpb24gKHNjaGVtYUlkKSB7IHJldHVybiBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgIGtpbmQ6IENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUsXG4gICAgICAgICAgICBsYWJlbDogX3RoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICBmaWx0ZXJUZXh0OiBfdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoc2NoZW1hSWQpLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHNjaGVtYUlkLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0RmlsdGVyVGV4dEZvclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0RmlsdGVyVGV4dEZvclNuaXBwZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL1xcJFxce1xcZCs6KFtefV0rKVxcfXxcXCRcXGQrL2csICckMScpO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldExhYmVsRm9yU25pcHBldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsLnJlcGxhY2UoL1xcJFxce1xcZCs6KFtefV0rKVxcfXxcXCRcXGQrL2csICckMScpO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldEluc2VydFRleHRGb3JQbGFpblRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFxcXFxcJFxcfV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgJCwgXFwgYW5kIH0gXG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICB2YXIgdGV4dCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgIGlmICh0ZXh0ID09PSAne30nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3skMX0nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PT0gJ1tdJykge1xuICAgICAgICAgICAgcmV0dXJuICdbJDFdJyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JQbGFpblRleHQodGV4dCArIHNlcGFyYXRvckFmdGVyKTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICB2YXIgcmVwbGFjZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSAnXicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlLCAnJywgcmVwbGFjZXIpICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJHsxOm51bGx9JyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgdmFyIHNuaXBwZXRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBzbmlwcGV0VmFsdWUgPSBzbmlwcGV0VmFsdWUuc3Vic3RyKDEsIHNuaXBwZXRWYWx1ZS5sZW5ndGggLSAyKTsgLy8gcmVtb3ZlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHNuaXBwZXRWYWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChzbmlwcGV0VmFsdWUpOyAvLyBlc2NhcGUgXFwgYW5kIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJHsxOicgKyBzbmlwcGV0VmFsdWUgKyAnfVwiJyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJHsxOicgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRTdWdnZXN0aW9uS2luZCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSB0eXBlO1xuICAgICAgICAgICAgdHlwZSA9IGFycmF5Lmxlbmd0aCA+IDAgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogcmV0dXJuIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6IHJldHVybiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0TGFiZWxUZXh0Rm9yTWF0Y2hpbmdOb2RlID0gZnVuY3Rpb24gKG5vZGUsIGRvY3VtZW50KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmdldFRleHQoKS5zdWJzdHIobm9kZS5vZmZzZXQsIG5vZGUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldEluc2VydFRleHRGb3JNYXRjaGluZ05vZGUgPSBmdW5jdGlvbiAobm9kZSwgZG9jdW1lbnQsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKFtdLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh7fSwgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmdldFRleHQoKS5zdWJzdHIobm9kZS5vZmZzZXQsIG5vZGUubGVuZ3RoKSArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JQbGFpblRleHQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkgPSBmdW5jdGlvbiAoa2V5LCBwcm9wZXJ0eVNjaGVtYSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eVRleHQgPSB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShrZXksICcnKTtcbiAgICAgICAgaWYgKCFhZGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5VGV4dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0VGV4dCA9IHByb3BlcnR5VGV4dCArICc6ICc7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIG5WYWx1ZVByb3Bvc2FscyA9IDA7XG4gICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzWzBdLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQoYm9keSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKGJvZHksICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMgKz0gcHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiBwcm9wZXJ0eVNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShwcm9wZXJ0eVNjaGVtYS5lbnVtWzBdLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5lbnVtLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydHlTY2hlbWEuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmRlZmF1bHQsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblZhbHVlUHJvcG9zYWxzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcykgJiYgcHJvcGVydHlTY2hlbWEuZXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShwcm9wZXJ0eVNjaGVtYS5leGFtcGxlc1swXSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMgKz0gcHJvcGVydHlTY2hlbWEuZXhhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5WYWx1ZVByb3Bvc2FscyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS50eXBlKSA/IHByb3BlcnR5U2NoZW1hLnR5cGVbMF0gOiBwcm9wZXJ0eVNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5U2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICckMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ1wiJDFcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ3skMX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ1skMV0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJHsxOjB9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyR7MTpudWxsfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgblZhbHVlUHJvcG9zYWxzID4gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJDEnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRUZXh0ICsgdmFsdWUgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRDdXJyZW50V29yZCA9IGZ1bmN0aW9uIChkb2N1bWVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpID0gb2Zmc2V0IC0gMTtcbiAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgJyBcXHRcXG5cXHJcXHZcIjp7WyxdfScuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGkgKyAxLCBvZmZzZXQpO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgc2Nhbm5lciA9IEpzb24uY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xuICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKG9mZnNldCk7XG4gICAgICAgIHZhciB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIDUgLyogQ29tbWFUb2tlbiAqLzpcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDE3IC8qIEVPRiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnLCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5maW5kSXRlbUF0T2Zmc2V0ID0gZnVuY3Rpb24gKG5vZGUsIGRvY3VtZW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHNjYW5uZXIgPSBKc29uLmNyZWF0ZVNjYW5uZXIoZG9jdW1lbnQuZ2V0VGV4dCgpLCB0cnVlKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5pdGVtcztcbiAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjaGlsZC5vZmZzZXQgKyBjaGlsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKGNoaWxkLm9mZnNldCArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSA1IC8qIENvbW1hVG9rZW4gKi8gJiYgb2Zmc2V0ID49IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID49IGNoaWxkLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmlzSW5Db21tZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50LCBzdGFydCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBzY2FubmVyID0gSnNvbi5jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgZmFsc2UpO1xuICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAhPT0gMTcgLyogRU9GICovICYmIChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgPCBvZmZzZXQpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodG9rZW4gPT09IDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovIHx8IHRva2VuID09PSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi8pICYmIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSA8PSBvZmZzZXQ7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZnJvbU1hcmt1cCA9IGZ1bmN0aW9uIChtYXJrdXBTdHJpbmcpIHtcbiAgICAgICAgaWYgKG1hcmt1cFN0cmluZyAmJiB0aGlzLmRvZXNTdXBwb3J0TWFya2Rvd24oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBraW5kOiBNYXJrdXBLaW5kLk1hcmtkb3duLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXJrdXBTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5kb2VzU3VwcG9ydE1hcmtkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzTWFya2Rvd24pKSB7XG4gICAgICAgICAgICB2YXIgY29tcGxldGlvbiA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudCAmJiB0aGlzLmNsaWVudENhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnQuY29tcGxldGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNNYXJrZG93biA9IGNvbXBsZXRpb24gJiYgY29tcGxldGlvbi5jb21wbGV0aW9uSXRlbSAmJiBBcnJheS5pc0FycmF5KGNvbXBsZXRpb24uY29tcGxldGlvbkl0ZW0uZG9jdW1lbnRhdGlvbkZvcm1hdCkgJiYgY29tcGxldGlvbi5jb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uRm9ybWF0LmluZGV4T2YoTWFya3VwS2luZC5NYXJrZG93bikgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzTWFya2Rvd247XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZG9lc1N1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGhpcy5zdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMpKSB7XG4gICAgICAgICAgICB2YXIgY29tcGxldGlvbiA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudCAmJiB0aGlzLmNsaWVudENhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnQuY29tcGxldGlvbjtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzID0gY29tcGxldGlvbiAmJiBjb21wbGV0aW9uLmNvbXBsZXRpb25JdGVtICYmICEhY29tcGxldGlvbi5jb21wbGV0aW9uSXRlbS5jb21taXRDaGFyYWN0ZXJzU3VwcG9ydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c0NvbW1pdENoYXJhY3RlcnM7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkNvbXBsZXRpb247XG59KCkpO1xuZXhwb3J0IHsgSlNPTkNvbXBsZXRpb24gfTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgUGFyc2VyIGZyb20gJy4uL3BhcnNlci9qc29uUGFyc2VyLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xudmFyIEpTT05Ib3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OSG92ZXIoc2NoZW1hU2VydmljZSwgY29udHJpYnV0aW9ucywgcHJvbWlzZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmIChjb250cmlidXRpb25zID09PSB2b2lkIDApIHsgY29udHJpYnV0aW9ucyA9IFtdOyB9XG4gICAgICAgIHRoaXMuc2NoZW1hU2VydmljZSA9IHNjaGVtYVNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9ucyA9IGNvbnRyaWJ1dGlvbnM7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgIH1cbiAgICBKU09OSG92ZXIucHJvdG90eXBlLmRvSG92ZXIgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHBvc2l0aW9uLCBkb2MpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKCFub2RlIHx8IChub2RlLnR5cGUgPT09ICdvYmplY3QnIHx8IG5vZGUudHlwZSA9PT0gJ2FycmF5JykgJiYgb2Zmc2V0ID4gbm9kZS5vZmZzZXQgKyAxICYmIG9mZnNldCA8IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvdmVyUmFuZ2VOb2RlID0gbm9kZTtcbiAgICAgICAgLy8gdXNlIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdGlvbiB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IGtleVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBwYXJlbnQua2V5Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBob3ZlclJhbmdlID0gUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQoaG92ZXJSYW5nZU5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChob3ZlclJhbmdlTm9kZS5vZmZzZXQgKyBob3ZlclJhbmdlTm9kZS5sZW5ndGgpKTtcbiAgICAgICAgdmFyIGNyZWF0ZUhvdmVyID0gZnVuY3Rpb24gKGNvbnRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzOiBjb250ZW50cyxcbiAgICAgICAgICAgICAgICByYW5nZTogaG92ZXJSYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IFBhcnNlci5nZXROb2RlUGF0aChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY29udHJpYnV0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGNvbnRyaWJ1dGlvbiA9IHRoaXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gY29udHJpYnV0aW9uLmdldEluZm9Db250cmlidXRpb24oZG9jdW1lbnQudXJpLCBsb2NhdGlvbik7XG4gICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGh0bWxDb250ZW50KSB7IHJldHVybiBjcmVhdGVIb3ZlcihodG1sQ29udGVudCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nU2NoZW1hcyA9IGRvYy5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSwgbm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZV8xID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZG93bkRlc2NyaXB0aW9uXzEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb25fMSA9IHVuZGVmaW5lZCwgZW51bVZhbHVlXzEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm5vZGUgPT09IG5vZGUgJiYgIXMuaW52ZXJ0ZWQgJiYgcy5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlXzEgPSB0aXRsZV8xIHx8IHMuc2NoZW1hLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25EZXNjcmlwdGlvbl8xID0gbWFya2Rvd25EZXNjcmlwdGlvbl8xIHx8IHMuc2NoZW1hLm1hcmtkb3duRGVzY3JpcHRpb24gfHwgdG9NYXJrZG93bihzLnNjaGVtYS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEuZW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBzLnNjaGVtYS5lbnVtLmluZGV4T2YoUGFyc2VyLmdldE5vZGVWYWx1ZShub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uXzEgPSBzLnNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocy5zY2hlbWEuZW51bURlc2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uXzEgPSB0b01hcmtkb3duKHMuc2NoZW1hLmVudW1EZXNjcmlwdGlvbnNbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bVZhbHVlXzEgPSBzLnNjaGVtYS5lbnVtW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW51bVZhbHVlXzEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWVfMSA9IEpTT04uc3RyaW5naWZ5KGVudW1WYWx1ZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9NYXJrZG93bih0aXRsZV8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtkb3duRGVzY3JpcHRpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtYXJrZG93bkRlc2NyaXB0aW9uXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJgXCIgKyB0b01hcmtkb3duQ29kZUJsb2NrKGVudW1WYWx1ZV8xKSArIFwiYDogXCIgKyBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVIb3ZlcihbcmVzdWx0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkhvdmVyO1xufSgpKTtcbmV4cG9ydCB7IEpTT05Ib3ZlciB9O1xuZnVuY3Rpb24gdG9NYXJrZG93bihwbGFpbikge1xuICAgIGlmIChwbGFpbikge1xuICAgICAgICB2YXIgcmVzID0gcGxhaW4ucmVwbGFjZSgvKFteXFxuXFxyXSkoXFxyP1xcbikoW15cXG5cXHJdKS9nbSwgJyQxXFxuXFxuJDMnKTsgLy8gc2luZ2xlIG5ldyBsaW5lcyB0byBcXG5cXG4gKE1hcmtkb3duIHBhcmFncmFwaClcbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgXCJcXFxcJCZcIik7IC8vIGVzY2FwZSBtYXJrZG93biBzeW50YXggdG9rZW5zOiBodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheCNiYWNrc2xhc2hcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRvTWFya2Rvd25Db2RlQmxvY2soY29udGVudCkge1xuICAgIC8vIHNlZSBodHRwczovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjcHJlY29kZVxuICAgIGlmIChjb250ZW50LmluZGV4T2YoJ2AnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICdgYCAnICsgY29udGVudCArICcgYGAnO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cbiIsInZhciBMSUI7TElCPSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXs0NzA6dD0+e2Z1bmN0aW9uIGUodCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkodCkpfWZ1bmN0aW9uIHIodCxlKXtmb3IodmFyIHIsbj1cIlwiLG89MCxpPS0xLGE9MCxoPTA7aDw9dC5sZW5ndGg7KytoKXtpZihoPHQubGVuZ3RoKXI9dC5jaGFyQ29kZUF0KGgpO2Vsc2V7aWYoNDc9PT1yKWJyZWFrO3I9NDd9aWYoNDc9PT1yKXtpZihpPT09aC0xfHwxPT09YSk7ZWxzZSBpZihpIT09aC0xJiYyPT09YSl7aWYobi5sZW5ndGg8Mnx8MiE9PW98fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTEpfHw0NiE9PW4uY2hhckNvZGVBdChuLmxlbmd0aC0yKSlpZihuLmxlbmd0aD4yKXt2YXIgcz1uLmxhc3RJbmRleE9mKFwiL1wiKTtpZihzIT09bi5sZW5ndGgtMSl7LTE9PT1zPyhuPVwiXCIsbz0wKTpvPShuPW4uc2xpY2UoMCxzKSkubGVuZ3RoLTEtbi5sYXN0SW5kZXhPZihcIi9cIiksaT1oLGE9MDtjb250aW51ZX19ZWxzZSBpZigyPT09bi5sZW5ndGh8fDE9PT1uLmxlbmd0aCl7bj1cIlwiLG89MCxpPWgsYT0wO2NvbnRpbnVlfWUmJihuLmxlbmd0aD4wP24rPVwiLy4uXCI6bj1cIi4uXCIsbz0yKX1lbHNlIG4ubGVuZ3RoPjA/bis9XCIvXCIrdC5zbGljZShpKzEsaCk6bj10LnNsaWNlKGkrMSxoKSxvPWgtaS0xO2k9aCxhPTB9ZWxzZSA0Nj09PXImJi0xIT09YT8rK2E6YT0tMX1yZXR1cm4gbn12YXIgbj17cmVzb2x2ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCxuPVwiXCIsbz0hMSxpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIW87aS0tKXt2YXIgYTtpPj0wP2E9YXJndW1lbnRzW2ldOih2b2lkIDA9PT10JiYodD1wcm9jZXNzLmN3ZCgpKSxhPXQpLGUoYSksMCE9PWEubGVuZ3RoJiYobj1hK1wiL1wiK24sbz00Nz09PWEuY2hhckNvZGVBdCgwKSl9cmV0dXJuIG49cihuLCFvKSxvP24ubGVuZ3RoPjA/XCIvXCIrbjpcIi9cIjpuLmxlbmd0aD4wP246XCIuXCJ9LG5vcm1hbGl6ZTpmdW5jdGlvbih0KXtpZihlKHQpLDA9PT10Lmxlbmd0aClyZXR1cm5cIi5cIjt2YXIgbj00Nz09PXQuY2hhckNvZGVBdCgwKSxvPTQ3PT09dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTEpO3JldHVybiAwIT09KHQ9cih0LCFuKSkubGVuZ3RofHxufHwodD1cIi5cIiksdC5sZW5ndGg+MCYmbyYmKHQrPVwiL1wiKSxuP1wiL1wiK3Q6dH0saXNBYnNvbHV0ZTpmdW5jdGlvbih0KXtyZXR1cm4gZSh0KSx0Lmxlbmd0aD4wJiY0Nz09PXQuY2hhckNvZGVBdCgwKX0sam9pbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVyblwiLlwiO2Zvcih2YXIgdCxyPTA7cjxhcmd1bWVudHMubGVuZ3RoOysrcil7dmFyIG89YXJndW1lbnRzW3JdO2Uobyksby5sZW5ndGg+MCYmKHZvaWQgMD09PXQ/dD1vOnQrPVwiL1wiK28pfXJldHVybiB2b2lkIDA9PT10P1wiLlwiOm4ubm9ybWFsaXplKHQpfSxyZWxhdGl2ZTpmdW5jdGlvbih0LHIpe2lmKGUodCksZShyKSx0PT09cilyZXR1cm5cIlwiO2lmKCh0PW4ucmVzb2x2ZSh0KSk9PT0ocj1uLnJlc29sdmUocikpKXJldHVyblwiXCI7Zm9yKHZhciBvPTE7bzx0Lmxlbmd0aCYmNDc9PT10LmNoYXJDb2RlQXQobyk7KytvKTtmb3IodmFyIGk9dC5sZW5ndGgsYT1pLW8saD0xO2g8ci5sZW5ndGgmJjQ3PT09ci5jaGFyQ29kZUF0KGgpOysraCk7Zm9yKHZhciBzPXIubGVuZ3RoLWgsZj1hPHM/YTpzLHU9LTEsYz0wO2M8PWY7KytjKXtpZihjPT09Zil7aWYocz5mKXtpZig0Nz09PXIuY2hhckNvZGVBdChoK2MpKXJldHVybiByLnNsaWNlKGgrYysxKTtpZigwPT09YylyZXR1cm4gci5zbGljZShoK2MpfWVsc2UgYT5mJiYoNDc9PT10LmNoYXJDb2RlQXQobytjKT91PWM6MD09PWMmJih1PTApKTticmVha312YXIgbD10LmNoYXJDb2RlQXQobytjKTtpZihsIT09ci5jaGFyQ29kZUF0KGgrYykpYnJlYWs7NDc9PT1sJiYodT1jKX12YXIgcD1cIlwiO2ZvcihjPW8rdSsxO2M8PWk7KytjKWMhPT1pJiY0NyE9PXQuY2hhckNvZGVBdChjKXx8KDA9PT1wLmxlbmd0aD9wKz1cIi4uXCI6cCs9XCIvLi5cIik7cmV0dXJuIHAubGVuZ3RoPjA/cCtyLnNsaWNlKGgrdSk6KGgrPXUsNDc9PT1yLmNoYXJDb2RlQXQoaCkmJisraCxyLnNsaWNlKGgpKX0sX21ha2VMb25nOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxkaXJuYW1lOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO2Zvcih2YXIgcj10LmNoYXJDb2RlQXQoMCksbj00Nz09PXIsbz0tMSxpPSEwLGE9dC5sZW5ndGgtMTthPj0xOy0tYSlpZig0Nz09PShyPXQuY2hhckNvZGVBdChhKSkpe2lmKCFpKXtvPWE7YnJlYWt9fWVsc2UgaT0hMTtyZXR1cm4tMT09PW8/bj9cIi9cIjpcIi5cIjpuJiYxPT09bz9cIi8vXCI6dC5zbGljZSgwLG8pfSxiYXNlbmFtZTpmdW5jdGlvbih0LHIpe2lmKHZvaWQgMCE9PXImJlwic3RyaW5nXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2UodCk7dmFyIG4sbz0wLGk9LTEsYT0hMDtpZih2b2lkIDAhPT1yJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9dC5sZW5ndGgpe2lmKHIubGVuZ3RoPT09dC5sZW5ndGgmJnI9PT10KXJldHVyblwiXCI7dmFyIGg9ci5sZW5ndGgtMSxzPS0xO2ZvcihuPXQubGVuZ3RoLTE7bj49MDstLW4pe3ZhciBmPXQuY2hhckNvZGVBdChuKTtpZig0Nz09PWYpe2lmKCFhKXtvPW4rMTticmVha319ZWxzZS0xPT09cyYmKGE9ITEscz1uKzEpLGg+PTAmJihmPT09ci5jaGFyQ29kZUF0KGgpPy0xPT0tLWgmJihpPW4pOihoPS0xLGk9cykpfXJldHVybiBvPT09aT9pPXM6LTE9PT1pJiYoaT10Lmxlbmd0aCksdC5zbGljZShvLGkpfWZvcihuPXQubGVuZ3RoLTE7bj49MDstLW4paWYoNDc9PT10LmNoYXJDb2RlQXQobikpe2lmKCFhKXtvPW4rMTticmVha319ZWxzZS0xPT09aSYmKGE9ITEsaT1uKzEpO3JldHVybi0xPT09aT9cIlwiOnQuc2xpY2UobyxpKX0sZXh0bmFtZTpmdW5jdGlvbih0KXtlKHQpO2Zvcih2YXIgcj0tMSxuPTAsbz0tMSxpPSEwLGE9MCxoPXQubGVuZ3RoLTE7aD49MDstLWgpe3ZhciBzPXQuY2hhckNvZGVBdChoKTtpZig0NyE9PXMpLTE9PT1vJiYoaT0hMSxvPWgrMSksNDY9PT1zPy0xPT09cj9yPWg6MSE9PWEmJihhPTEpOi0xIT09ciYmKGE9LTEpO2Vsc2UgaWYoIWkpe249aCsxO2JyZWFrfX1yZXR1cm4tMT09PXJ8fC0xPT09b3x8MD09PWF8fDE9PT1hJiZyPT09by0xJiZyPT09bisxP1wiXCI6dC5zbGljZShyLG8pfSxmb3JtYXQ6ZnVuY3Rpb24odCl7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpO3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciByPWUuZGlyfHxlLnJvb3Qsbj1lLmJhc2V8fChlLm5hbWV8fFwiXCIpKyhlLmV4dHx8XCJcIik7cmV0dXJuIHI/cj09PWUucm9vdD9yK246citcIi9cIituOm59KDAsdCl9LHBhcnNlOmZ1bmN0aW9uKHQpe2UodCk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIHI7dmFyIG4sbz10LmNoYXJDb2RlQXQoMCksaT00Nz09PW87aT8oci5yb290PVwiL1wiLG49MSk6bj0wO2Zvcih2YXIgYT0tMSxoPTAscz0tMSxmPSEwLHU9dC5sZW5ndGgtMSxjPTA7dT49bjstLXUpaWYoNDchPT0obz10LmNoYXJDb2RlQXQodSkpKS0xPT09cyYmKGY9ITEscz11KzEpLDQ2PT09bz8tMT09PWE/YT11OjEhPT1jJiYoYz0xKTotMSE9PWEmJihjPS0xKTtlbHNlIGlmKCFmKXtoPXUrMTticmVha31yZXR1cm4tMT09PWF8fC0xPT09c3x8MD09PWN8fDE9PT1jJiZhPT09cy0xJiZhPT09aCsxPy0xIT09cyYmKHIuYmFzZT1yLm5hbWU9MD09PWgmJmk/dC5zbGljZSgxLHMpOnQuc2xpY2UoaCxzKSk6KDA9PT1oJiZpPyhyLm5hbWU9dC5zbGljZSgxLGEpLHIuYmFzZT10LnNsaWNlKDEscykpOihyLm5hbWU9dC5zbGljZShoLGEpLHIuYmFzZT10LnNsaWNlKGgscykpLHIuZXh0PXQuc2xpY2UoYSxzKSksaD4wP3IuZGlyPXQuc2xpY2UoMCxoLTEpOmkmJihyLmRpcj1cIi9cIikscn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O24ucG9zaXg9bix0LmV4cG9ydHM9bn0sNDQ3Oih0LGUscik9Pnt2YXIgbjtpZihyLnIoZSksci5kKGUse1VSSTooKT0+ZyxVdGlsczooKT0+T30pLFwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzKW49XCJ3aW4zMlwiPT09cHJvY2Vzcy5wbGF0Zm9ybTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3Ipe3ZhciBvPW5hdmlnYXRvci51c2VyQWdlbnQ7bj1vLmluZGV4T2YoXCJXaW5kb3dzXCIpPj0wfXZhciBpLGEsaD0oaT1mdW5jdGlvbih0LGUpe3JldHVybihpPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX0pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9dH1pKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKTooci5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IHIpfSkscz0vXlxcd1tcXHdcXGQrLi1dKiQvLGY9L15cXC8vLHU9L15cXC9cXC8vLGM9XCJcIixsPVwiL1wiLHA9L14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy8sZz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsbixvLGkpe3ZvaWQgMD09PWkmJihpPSExKSxcIm9iamVjdFwiPT10eXBlb2YgdD8odGhpcy5zY2hlbWU9dC5zY2hlbWV8fGMsdGhpcy5hdXRob3JpdHk9dC5hdXRob3JpdHl8fGMsdGhpcy5wYXRoPXQucGF0aHx8Yyx0aGlzLnF1ZXJ5PXQucXVlcnl8fGMsdGhpcy5mcmFnbWVudD10LmZyYWdtZW50fHxjKToodGhpcy5zY2hlbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZT90OlwiZmlsZVwifSh0LGkpLHRoaXMuYXV0aG9yaXR5PWV8fGMsdGhpcy5wYXRoPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcImh0dHBzXCI6Y2FzZVwiaHR0cFwiOmNhc2VcImZpbGVcIjplP2VbMF0hPT1sJiYoZT1sK2UpOmU9bH1yZXR1cm4gZX0odGhpcy5zY2hlbWUscnx8YyksdGhpcy5xdWVyeT1ufHxjLHRoaXMuZnJhZ21lbnQ9b3x8YyxmdW5jdGlvbih0LGUpe2lmKCF0LnNjaGVtZSYmZSl0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IFNjaGVtZSBpcyBtaXNzaW5nOiB7c2NoZW1lOiBcIlwiLCBhdXRob3JpdHk6IFwiJyt0LmF1dGhvcml0eSsnXCIsIHBhdGg6IFwiJyt0LnBhdGgrJ1wiLCBxdWVyeTogXCInK3QucXVlcnkrJ1wiLCBmcmFnbWVudDogXCInK3QuZnJhZ21lbnQrJ1wifScpO2lmKHQuc2NoZW1lJiYhcy50ZXN0KHQuc2NoZW1lKSl0aHJvdyBuZXcgRXJyb3IoXCJbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLlwiKTtpZih0LnBhdGgpaWYodC5hdXRob3JpdHkpe2lmKCFmLnRlc3QodC5wYXRoKSl0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGNvbnRhaW5zIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY29tcG9uZW50IG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSBzbGFzaCAoXCIvXCIpIGNoYXJhY3RlcicpfWVsc2UgaWYodS50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBkb2VzIG5vdCBjb250YWluIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY2Fubm90IGJlZ2luIHdpdGggdHdvIHNsYXNoIGNoYXJhY3RlcnMgKFwiLy9cIiknKX0odGhpcyxpKSl9cmV0dXJuIHQuaXNVcmk9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0fHwhIWUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLmF1dGhvcml0eSYmXCJzdHJpbmdcIj09dHlwZW9mIGUuZnJhZ21lbnQmJlwic3RyaW5nXCI9PXR5cGVvZiBlLnBhdGgmJlwic3RyaW5nXCI9PXR5cGVvZiBlLnF1ZXJ5JiZcInN0cmluZ1wiPT10eXBlb2YgZS5zY2hlbWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZnNQYXRoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLndpdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUudG9TdHJpbmd9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImZzUGF0aFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQyh0aGlzLCExKX0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS53aXRoPWZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiB0aGlzO3ZhciBlPXQuc2NoZW1lLHI9dC5hdXRob3JpdHksbj10LnBhdGgsbz10LnF1ZXJ5LGk9dC5mcmFnbWVudDtyZXR1cm4gdm9pZCAwPT09ZT9lPXRoaXMuc2NoZW1lOm51bGw9PT1lJiYoZT1jKSx2b2lkIDA9PT1yP3I9dGhpcy5hdXRob3JpdHk6bnVsbD09PXImJihyPWMpLHZvaWQgMD09PW4/bj10aGlzLnBhdGg6bnVsbD09PW4mJihuPWMpLHZvaWQgMD09PW8/bz10aGlzLnF1ZXJ5Om51bGw9PT1vJiYobz1jKSx2b2lkIDA9PT1pP2k9dGhpcy5mcmFnbWVudDpudWxsPT09aSYmKGk9YyksZT09PXRoaXMuc2NoZW1lJiZyPT09dGhpcy5hdXRob3JpdHkmJm49PT10aGlzLnBhdGgmJm89PT10aGlzLnF1ZXJ5JiZpPT09dGhpcy5mcmFnbWVudD90aGlzOm5ldyB2KGUscixuLG8saSl9LHQucGFyc2U9ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9cC5leGVjKHQpO3JldHVybiByP25ldyB2KHJbMl18fGMseChyWzRdfHxjKSx4KHJbNV18fGMpLHgocls3XXx8YykseChyWzldfHxjKSxlKTpuZXcgdihjLGMsYyxjLGMpfSx0LmZpbGU9ZnVuY3Rpb24odCl7dmFyIGU9YztpZihuJiYodD10LnJlcGxhY2UoL1xcXFwvZyxsKSksdFswXT09PWwmJnRbMV09PT1sKXt2YXIgcj10LmluZGV4T2YobCwyKTstMT09PXI/KGU9dC5zdWJzdHJpbmcoMiksdD1sKTooZT10LnN1YnN0cmluZygyLHIpLHQ9dC5zdWJzdHJpbmcocil8fGwpfXJldHVybiBuZXcgdihcImZpbGVcIixlLHQsYyxjKX0sdC5mcm9tPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdih0LnNjaGVtZSx0LmF1dGhvcml0eSx0LnBhdGgsdC5xdWVyeSx0LmZyYWdtZW50KX0sdC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxBKHRoaXMsdCl9LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx0LnJldml2ZT1mdW5jdGlvbihlKXtpZihlKXtpZihlIGluc3RhbmNlb2YgdClyZXR1cm4gZTt2YXIgcj1uZXcgdihlKTtyZXR1cm4gci5fZm9ybWF0dGVkPWUuZXh0ZXJuYWwsci5fZnNQYXRoPWUuX3NlcD09PWQ/ZS5mc1BhdGg6bnVsbCxyfXJldHVybiBlfSx0fSgpLGQ9bj8xOnZvaWQgMCx2PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuX2Zvcm1hdHRlZD1udWxsLGUuX2ZzUGF0aD1udWxsLGV9cmV0dXJuIGgoZSx0KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJmc1BhdGhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZzUGF0aHx8KHRoaXMuX2ZzUGF0aD1DKHRoaXMsITEpKSx0aGlzLl9mc1BhdGh9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0P0EodGhpcywhMCk6KHRoaXMuX2Zvcm1hdHRlZHx8KHRoaXMuX2Zvcm1hdHRlZD1BKHRoaXMsITEpKSx0aGlzLl9mb3JtYXR0ZWQpfSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXt2YXIgdD17JG1pZDoxfTtyZXR1cm4gdGhpcy5fZnNQYXRoJiYodC5mc1BhdGg9dGhpcy5fZnNQYXRoLHQuX3NlcD1kKSx0aGlzLl9mb3JtYXR0ZWQmJih0LmV4dGVybmFsPXRoaXMuX2Zvcm1hdHRlZCksdGhpcy5wYXRoJiYodC5wYXRoPXRoaXMucGF0aCksdGhpcy5zY2hlbWUmJih0LnNjaGVtZT10aGlzLnNjaGVtZSksdGhpcy5hdXRob3JpdHkmJih0LmF1dGhvcml0eT10aGlzLmF1dGhvcml0eSksdGhpcy5xdWVyeSYmKHQucXVlcnk9dGhpcy5xdWVyeSksdGhpcy5mcmFnbWVudCYmKHQuZnJhZ21lbnQ9dGhpcy5mcmFnbWVudCksdH0sZX0oZyksbT0oKGE9e30pWzU4XT1cIiUzQVwiLGFbNDddPVwiJTJGXCIsYVs2M109XCIlM0ZcIixhWzM1XT1cIiUyM1wiLGFbOTFdPVwiJTVCXCIsYVs5M109XCIlNURcIixhWzY0XT1cIiU0MFwiLGFbMzNdPVwiJTIxXCIsYVszNl09XCIlMjRcIixhWzM4XT1cIiUyNlwiLGFbMzldPVwiJTI3XCIsYVs0MF09XCIlMjhcIixhWzQxXT1cIiUyOVwiLGFbNDJdPVwiJTJBXCIsYVs0M109XCIlMkJcIixhWzQ0XT1cIiUyQ1wiLGFbNTldPVwiJTNCXCIsYVs2MV09XCIlM0RcIixhWzMyXT1cIiUyMFwiLGEpO2Z1bmN0aW9uIHkodCxlKXtmb3IodmFyIHI9dm9pZCAwLG49LTEsbz0wO288dC5sZW5ndGg7bysrKXt2YXIgaT10LmNoYXJDb2RlQXQobyk7aWYoaT49OTcmJmk8PTEyMnx8aT49NjUmJmk8PTkwfHxpPj00OCYmaTw9NTd8fDQ1PT09aXx8NDY9PT1pfHw5NT09PWl8fDEyNj09PWl8fGUmJjQ3PT09aSktMSE9PW4mJihyKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcobixvKSksbj0tMSksdm9pZCAwIT09ciYmKHIrPXQuY2hhckF0KG8pKTtlbHNle3ZvaWQgMD09PXImJihyPXQuc3Vic3RyKDAsbykpO3ZhciBhPW1baV07dm9pZCAwIT09YT8oLTEhPT1uJiYocis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKG4sbykpLG49LTEpLHIrPWEpOi0xPT09biYmKG49byl9fXJldHVybi0xIT09biYmKHIrPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhuKSkpLHZvaWQgMCE9PXI/cjp0fWZ1bmN0aW9uIGIodCl7Zm9yKHZhciBlPXZvaWQgMCxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXQuY2hhckNvZGVBdChyKTszNT09PW58fDYzPT09bj8odm9pZCAwPT09ZSYmKGU9dC5zdWJzdHIoMCxyKSksZSs9bVtuXSk6dm9pZCAwIT09ZSYmKGUrPXRbcl0pfXJldHVybiB2b2lkIDAhPT1lP2U6dH1mdW5jdGlvbiBDKHQsZSl7dmFyIHI7cmV0dXJuIHI9dC5hdXRob3JpdHkmJnQucGF0aC5sZW5ndGg+MSYmXCJmaWxlXCI9PT10LnNjaGVtZT9cIi8vXCIrdC5hdXRob3JpdHkrdC5wYXRoOjQ3PT09dC5wYXRoLmNoYXJDb2RlQXQoMCkmJih0LnBhdGguY2hhckNvZGVBdCgxKT49NjUmJnQucGF0aC5jaGFyQ29kZUF0KDEpPD05MHx8dC5wYXRoLmNoYXJDb2RlQXQoMSk+PTk3JiZ0LnBhdGguY2hhckNvZGVBdCgxKTw9MTIyKSYmNTg9PT10LnBhdGguY2hhckNvZGVBdCgyKT9lP3QucGF0aC5zdWJzdHIoMSk6dC5wYXRoWzFdLnRvTG93ZXJDYXNlKCkrdC5wYXRoLnN1YnN0cigyKTp0LnBhdGgsbiYmKHI9ci5yZXBsYWNlKC9cXC8vZyxcIlxcXFxcIikpLHJ9ZnVuY3Rpb24gQSh0LGUpe3ZhciByPWU/Yjp5LG49XCJcIixvPXQuc2NoZW1lLGk9dC5hdXRob3JpdHksYT10LnBhdGgsaD10LnF1ZXJ5LHM9dC5mcmFnbWVudDtpZihvJiYobis9byxuKz1cIjpcIiksKGl8fFwiZmlsZVwiPT09bykmJihuKz1sLG4rPWwpLGkpe3ZhciBmPWkuaW5kZXhPZihcIkBcIik7aWYoLTEhPT1mKXt2YXIgdT1pLnN1YnN0cigwLGYpO2k9aS5zdWJzdHIoZisxKSwtMT09PShmPXUuaW5kZXhPZihcIjpcIikpP24rPXIodSwhMSk6KG4rPXIodS5zdWJzdHIoMCxmKSwhMSksbis9XCI6XCIsbis9cih1LnN1YnN0cihmKzEpLCExKSksbis9XCJAXCJ9LTE9PT0oZj0oaT1pLnRvTG93ZXJDYXNlKCkpLmluZGV4T2YoXCI6XCIpKT9uKz1yKGksITEpOihuKz1yKGkuc3Vic3RyKDAsZiksITEpLG4rPWkuc3Vic3RyKGYpKX1pZihhKXtpZihhLmxlbmd0aD49MyYmNDc9PT1hLmNoYXJDb2RlQXQoMCkmJjU4PT09YS5jaGFyQ29kZUF0KDIpKShjPWEuY2hhckNvZGVBdCgxKSk+PTY1JiZjPD05MCYmKGE9XCIvXCIrU3RyaW5nLmZyb21DaGFyQ29kZShjKzMyKStcIjpcIithLnN1YnN0cigzKSk7ZWxzZSBpZihhLmxlbmd0aD49MiYmNTg9PT1hLmNoYXJDb2RlQXQoMSkpe3ZhciBjOyhjPWEuY2hhckNvZGVBdCgwKSk+PTY1JiZjPD05MCYmKGE9U3RyaW5nLmZyb21DaGFyQ29kZShjKzMyKStcIjpcIithLnN1YnN0cigyKSl9bis9cihhLCEwKX1yZXR1cm4gaCYmKG4rPVwiP1wiLG4rPXIoaCwhMSkpLHMmJihuKz1cIiNcIixuKz1lP3M6eShzLCExKSksbn1mdW5jdGlvbiB3KHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpfWNhdGNoKGUpe3JldHVybiB0Lmxlbmd0aD4zP3Quc3Vic3RyKDAsMykrdyh0LnN1YnN0cigzKSk6dH19dmFyIF89LyglWzAtOUEtWmEtel1bMC05QS1aYS16XSkrL2c7ZnVuY3Rpb24geCh0KXtyZXR1cm4gdC5tYXRjaChfKT90LnJlcGxhY2UoXywoZnVuY3Rpb24odCl7cmV0dXJuIHcodCl9KSk6dH12YXIgTyxQPXIoNDcwKSxqPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wLHI9YXJndW1lbnRzLmxlbmd0aDtlPHI7ZSsrKXQrPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG49QXJyYXkodCksbz0wO2ZvcihlPTA7ZTxyO2UrKylmb3IodmFyIGk9YXJndW1lbnRzW2VdLGE9MCxoPWkubGVuZ3RoO2E8aDthKyssbysrKW5bb109aVthXTtyZXR1cm4gbn0sVT1QLnBvc2l4fHxQOyFmdW5jdGlvbih0KXt0LmpvaW5QYXRoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO3JldHVybiB0LndpdGgoe3BhdGg6VS5qb2luLmFwcGx5KFUsaihbdC5wYXRoXSxlKSl9KX0sdC5yZXNvbHZlUGF0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTt2YXIgbj10LnBhdGh8fFwiL1wiO3JldHVybiB0LndpdGgoe3BhdGg6VS5yZXNvbHZlLmFwcGx5KFUsaihbbl0sZSkpfSl9LHQuZGlybmFtZT1mdW5jdGlvbih0KXt2YXIgZT1VLmRpcm5hbWUodC5wYXRoKTtyZXR1cm4gMT09PWUubGVuZ3RoJiY0Nj09PWUuY2hhckNvZGVBdCgwKT90OnQud2l0aCh7cGF0aDplfSl9LHQuYmFzZW5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIFUuYmFzZW5hbWUodC5wYXRoKX0sdC5leHRuYW1lPWZ1bmN0aW9uKHQpe3JldHVybiBVLmV4dG5hbWUodC5wYXRoKX19KE98fChPPXt9KSl9fSxlPXt9O2Z1bmN0aW9uIHIobil7aWYoZVtuXSlyZXR1cm4gZVtuXS5leHBvcnRzO3ZhciBvPWVbbl09e2V4cG9ydHM6e319O3JldHVybiB0W25dKG8sby5leHBvcnRzLHIpLG8uZXhwb3J0c31yZXR1cm4gci5kPSh0LGUpPT57Zm9yKHZhciBuIGluIGUpci5vKGUsbikmJiFyLm8odCxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxnZXQ6ZVtuXX0pfSxyLm89KHQsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpLHIucj10PT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0scig0NDcpfSkoKTtleHBvcnQgY29uc3R7VVJJLFV0aWxzfT1MSUI7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIENvcHlyaWdodCAoYykgMjAxMywgTmljayBGaXR6Z2VyYWxkXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5DRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVnZXgoZ2xvYiwgb3B0cykge1xuICAgIGlmICh0eXBlb2YgZ2xvYiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgdmFyIHN0ciA9IFN0cmluZyhnbG9iKTtcbiAgICAvLyBUaGUgcmVnZXhwIHdlIGFyZSBidWlsZGluZywgYXMgYSBzdHJpbmcuXG4gICAgdmFyIHJlU3RyID0gXCJcIjtcbiAgICAvLyBXaGV0aGVyIHdlIGFyZSBtYXRjaGluZyBzbyBjYWxsZWQgXCJleHRlbmRlZFwiIGdsb2JzIChsaWtlIGJhc2gpIGFuZCBzaG91bGRcbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hpbmcsIG1hdGNoaW5nIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLCBncm91cFxuICAgIC8vIG1hdGNoaW5nLCBldGMuXG4gICAgdmFyIGV4dGVuZGVkID0gb3B0cyA/ICEhb3B0cy5leHRlbmRlZCA6IGZhbHNlO1xuICAgIC8vIFdoZW4gZ2xvYnN0YXIgaXMgX2ZhbHNlXyAoZGVmYXVsdCksICcvZm9vLyonIGlzIHRyYW5zbGF0ZWQgYSByZWdleHAgbGlrZVxuICAgIC8vICdeXFwvZm9vXFwvLiokJyB3aGljaCB3aWxsIG1hdGNoIGFueSBzdHJpbmcgYmVnaW5uaW5nIHdpdGggJy9mb28vJ1xuICAgIC8vIFdoZW4gZ2xvYnN0YXIgaXMgX3RydWVfLCAnL2Zvby8qJyBpcyB0cmFuc2xhdGVkIHRvIHJlZ2V4cCBsaWtlXG4gICAgLy8gJ15cXC9mb29cXC9bXi9dKiQnIHdoaWNoIHdpbGwgbWF0Y2ggYW55IHN0cmluZyBiZWdpbm5pbmcgd2l0aCAnL2Zvby8nIEJVVFxuICAgIC8vIHdoaWNoIGRvZXMgbm90IGhhdmUgYSAnLycgdG8gdGhlIHJpZ2h0IG9mIGl0LlxuICAgIC8vIEUuZy4gd2l0aCAnL2Zvby8qJyB0aGVzZSB3aWxsIG1hdGNoOiAnL2Zvby9iYXInLCAnL2Zvby9iYXIudHh0JyBidXRcbiAgICAvLyB0aGVzZSB3aWxsIG5vdCAnL2Zvby9iYXIvYmF6JywgJy9mb28vYmFyL2Jhei50eHQnXG4gICAgLy8gTGFzdGVseSwgd2hlbiBnbG9ic3RhciBpcyBfdHJ1ZV8sICcvZm9vLyoqJyBpcyBlcXVpdmVsYW50IHRvICcvZm9vLyonIHdoZW5cbiAgICAvLyBnbG9ic3RhciBpcyBfZmFsc2VfXG4gICAgdmFyIGdsb2JzdGFyID0gb3B0cyA/ICEhb3B0cy5nbG9ic3RhciA6IGZhbHNlO1xuICAgIC8vIElmIHdlIGFyZSBkb2luZyBleHRlbmRlZCBtYXRjaGluZywgdGhpcyBib29sZWFuIGlzIHRydWUgd2hlbiB3ZSBhcmUgaW5zaWRlXG4gICAgLy8gYSBncm91cCAoZWcgeyouaHRtbCwqLmpzfSksIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgdmFyIGluR3JvdXAgPSBmYWxzZTtcbiAgICAvLyBSZWdFeHAgZmxhZ3MgKGVnIFwiaVwiICkgdG8gcGFzcyBpbiB0byBSZWdFeHAgY29uc3RydWN0b3IuXG4gICAgdmFyIGZsYWdzID0gb3B0cyAmJiB0eXBlb2YgKG9wdHMuZmxhZ3MpID09PSBcInN0cmluZ1wiID8gb3B0cy5mbGFncyA6IFwiXCI7XG4gICAgdmFyIGM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjID0gc3RyW2ldO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJcXFxcXCIgKyBjO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIuXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgICAgICAgICAgaWYgKGluR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJ8XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZVN0ciArPSBcIlxcXFxcIiArIGM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgb3ZlciBhbGwgY29uc2VjdXRpdmUgXCIqXCIncy5cbiAgICAgICAgICAgICAgICAvLyBBbHNvIHN0b3JlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgdmFyIHByZXZDaGFyID0gc3RyW2kgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhckNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyW2kgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gc3RyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIWdsb2JzdGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdsb2JzdGFyIGlzIGRpc2FibGVkLCBzbyB0cmVhdCBhbnkgbnVtYmVyIG9mIFwiKlwiIGFzIG9uZVxuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcIi4qXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnbG9ic3RhciBpcyBlbmFibGVkLCBzbyBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhIGdsb2JzdGFyIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzR2xvYnN0YXIgPSBzdGFyQ291bnQgPiAxIC8vIG11bHRpcGxlIFwiKlwiJ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChwcmV2Q2hhciA9PT0gXCIvXCIgfHwgcHJldkNoYXIgPT09IHVuZGVmaW5lZCB8fCBwcmV2Q2hhciA9PT0gJ3snIHx8IHByZXZDaGFyID09PSAnLCcpIC8vIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAobmV4dENoYXIgPT09IFwiL1wiIHx8IG5leHRDaGFyID09PSB1bmRlZmluZWQgfHwgbmV4dENoYXIgPT09ICcsJyB8fCBuZXh0Q2hhciA9PT0gJ30nKTsgLy8gdG8gdGhlIGVuZCBvZiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNHbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gbW92ZSBvdmVyIHRoZSBcIi9cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldkNoYXIgPT09ICcvJyAmJiByZVN0ci5lbmRzV2l0aCgnXFxcXC8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlU3RyID0gcmVTdHIuc3Vic3RyKDAsIHJlU3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhIGdsb2JzdGFyLCBzbyBtYXRjaCB6ZXJvIG9yIG1vcmUgcGF0aCBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoKD86W14vXSooPzpcXC98JCkpKilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IGEgZ2xvYnN0YXIsIHNvIG9ubHkgbWF0Y2ggb25lIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gXCIoW14vXSopXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlU3RyICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiByZWdleHAgJ2cnIGZsYWcgaXMgc3BlY2lmaWVkIGRvbid0XG4gICAgLy8gY29uc3RyYWluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gd2l0aCBeICYgJFxuICAgIGlmICghZmxhZ3MgfHwgIX5mbGFncy5pbmRleE9mKCdnJykpIHtcbiAgICAgICAgcmVTdHIgPSBcIl5cIiArIHJlU3RyICsgXCIkXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJlU3RyLCBmbGFncyk7XG59XG47XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi8uLi8uLi9qc29uYy1wYXJzZXIvbWFpbi5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLy4uLy4uL3ZzY29kZS11cmkvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgU3RyaW5ncyBmcm9tICcuLi91dGlscy9zdHJpbmdzLmpzJztcbmltcG9ydCAqIGFzIFBhcnNlciBmcm9tICcuLi9wYXJzZXIvanNvblBhcnNlci5qcyc7XG5pbXBvcnQgKiBhcyBubHMgZnJvbSAnLi8uLi8uLi8uLi9maWxsZXJzL3ZzY29kZS1ubHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVnZXggfSBmcm9tICcuLi91dGlscy9nbG9iLmpzJztcbnZhciBsb2NhbGl6ZSA9IG5scy5sb2FkTWVzc2FnZUJ1bmRsZSgpO1xudmFyIEJBTkcgPSAnISc7XG52YXIgUEFUSF9TRVAgPSAnLyc7XG52YXIgRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWxlUGF0dGVybkFzc29jaWF0aW9uKHBhdHRlcm4sIHVyaXMpIHtcbiAgICAgICAgdGhpcy5nbG9iV3JhcHBlcnMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGF0dGVybl8xID0gcGF0dGVybjsgX2kgPCBwYXR0ZXJuXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm5TdHJpbmcgPSBwYXR0ZXJuXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBpbmNsdWRlID0gcGF0dGVyblN0cmluZ1swXSAhPT0gQkFORztcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5TdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0dGVyblN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuU3RyaW5nWzBdID09PSBQQVRIX1NFUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5TdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYldyYXBwZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhwOiBjcmVhdGVSZWdleCgnKiovJyArIHBhdHRlcm5TdHJpbmcsIHsgZXh0ZW5kZWQ6IHRydWUsIGdsb2JzdGFyOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZTogaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy51cmlzID0gdXJpcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5nbG9iV3JhcHBlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMudXJpcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ucHJvdG90eXBlLm1hdGNoZXNQYXR0ZXJuID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5nbG9iV3JhcHBlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIHJlZ2V4cCA9IF9iLnJlZ2V4cCwgaW5jbHVkZSA9IF9iLmluY2x1ZGU7XG4gICAgICAgICAgICBpZiAocmVnZXhwLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBpbmNsdWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuICAgIEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ucHJvdG90eXBlLmdldFVSSXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVyaXM7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbjtcbn0oKSk7XG52YXIgU2NoZW1hSGFuZGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjaGVtYUhhbmRsZShzZXJ2aWNlLCB1cmwsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IHt9O1xuICAgICAgICBpZiAodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEodW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2hlbWFIYW5kbGUucHJvdG90eXBlLmdldFVucmVzb2x2ZWRTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVzb2x2ZWRTY2hlbWEgPSB0aGlzLnNlcnZpY2UubG9hZFNjaGVtYSh0aGlzLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudW5yZXNvbHZlZFNjaGVtYTtcbiAgICB9O1xuICAgIFNjaGVtYUhhbmRsZS5wcm90b3R5cGUuZ2V0UmVzb2x2ZWRTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuZ2V0VW5yZXNvbHZlZFNjaGVtYSgpLnRoZW4oZnVuY3Rpb24gKHVucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VydmljZS5yZXNvbHZlU2NoZW1hQ29udGVudCh1bnJlc29sdmVkLCBfdGhpcy51cmwsIF90aGlzLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFNjaGVtYTtcbiAgICB9O1xuICAgIFNjaGVtYUhhbmRsZS5wcm90b3R5cGUuY2xlYXJTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSB7fTtcbiAgICB9O1xuICAgIHJldHVybiBTY2hlbWFIYW5kbGU7XG59KCkpO1xudmFyIFVucmVzb2x2ZWRTY2hlbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5yZXNvbHZlZFNjaGVtYShzY2hlbWEsIGVycm9ycykge1xuICAgICAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHsgZXJyb3JzID0gW107IH1cbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVW5yZXNvbHZlZFNjaGVtYTtcbn0oKSk7XG5leHBvcnQgeyBVbnJlc29sdmVkU2NoZW1hIH07XG52YXIgUmVzb2x2ZWRTY2hlbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb2x2ZWRTY2hlbWEoc2NoZW1hLCBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgUmVzb2x2ZWRTY2hlbWEucHJvdG90eXBlLmdldFNlY3Rpb24gPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgc2NoZW1hUmVmID0gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgaWYgKHNjaGVtYVJlZikge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlci5hc1NjaGVtYShzY2hlbWFSZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBSZXNvbHZlZFNjaGVtYS5wcm90b3R5cGUuZ2V0U2VjdGlvblJlY3Vyc2l2ZSA9IGZ1bmN0aW9uIChwYXRoLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ2Jvb2xlYW4nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMgJiYgdHlwZW9mIHNjaGVtYS5wcm9wZXJ0aWVzW25leHRdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5wcm9wZXJ0aWVzW25leHRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciByZWdleCA9IFN0cmluZ3MuZXh0ZW5kZWRSZWdFeHAocGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5leHQubWF0Y2goJ1swLTldKycpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQobmV4dCwgMTApO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaW5kZXgpICYmIHNjaGVtYS5pdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEuaXRlbXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvbHZlZFNjaGVtYTtcbn0oKSk7XG5leHBvcnQgeyBSZXNvbHZlZFNjaGVtYSB9O1xudmFyIEpTT05TY2hlbWFTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05TY2hlbWFTZXJ2aWNlKHJlcXVlc3RTZXJ2aWNlLCBjb250ZXh0U2VydmljZSwgcHJvbWlzZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFNlcnZpY2UgPSBjb250ZXh0U2VydmljZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2VydmljZSA9IHJlcXVlc3RTZXJ2aWNlO1xuICAgICAgICB0aGlzLnByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgICAgICB0aGlzLmNhbGxPbkRpc3Bvc2UgPSBbXTtcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25TY2hlbWFzID0ge307XG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2NoZW1hc0J5SWQgPSB7fTtcbiAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzID0ge307XG4gICAgfVxuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5nZXRSZWdpc3RlcmVkU2NoZW1hSWRzID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkcykuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IFVSSS5wYXJzZShpZCkuc2NoZW1lO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtZSAhPT0gJ3NjaGVtYXNlcnZpY2UnICYmICghZmlsdGVyIHx8IGZpbHRlcihzY2hlbWUpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLCBcInByb21pc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jYWxsT25EaXNwb3NlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbE9uRGlzcG9zZS5wb3AoKSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUub25SZXNvdXJjZUNoYW5nZSA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdXJpID0gbm9ybWFsaXplSWQodXJpKTtcbiAgICAgICAgdmFyIHRvV2FsayA9IFt1cmldO1xuICAgICAgICB2YXIgYWxsID0gT2JqZWN0LmtleXModGhpcy5zY2hlbWFzQnlJZCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLnNjaGVtYXNCeUlkW2tleV07IH0pO1xuICAgICAgICB3aGlsZSAodG9XYWxrLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGN1cnIgPSB0b1dhbGsucG9wKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhbGxbaV07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoaGFuZGxlLnVybCA9PT0gY3VyciB8fCBoYW5kbGUuZGVwZW5kZW5jaWVzW2N1cnJdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLnVybCAhPT0gY3Vycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goaGFuZGxlLnVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNsZWFyU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIGFsbFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNDaGFuZ2VzO1xuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLnNldFNjaGVtYUNvbnRyaWJ1dGlvbnMgPSBmdW5jdGlvbiAoc2NoZW1hQ29udHJpYnV0aW9ucykge1xuICAgICAgICBpZiAoc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hcyA9IHNjaGVtYUNvbnRyaWJ1dGlvbnMuc2NoZW1hcztcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZElkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hc1tub3JtYWxpemVkSWRdID0gdGhpcy5hZGRTY2hlbWFIYW5kbGUobm9ybWFsaXplZElkLCBzY2hlbWFzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFBc3NvY2lhdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hQXNzb2NpYXRpb25zID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFBc3NvY2lhdGlvbnM7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNjaGVtYUFzc29jaWF0aW9uc18xID0gc2NoZW1hQXNzb2NpYXRpb25zOyBfaSA8IHNjaGVtYUFzc29jaWF0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWFBc3NvY2lhdGlvbiA9IHNjaGVtYUFzc29jaWF0aW9uc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgdXJpcyA9IHNjaGVtYUFzc29jaWF0aW9uLnVyaXMubWFwKG5vcm1hbGl6ZUlkKTtcbiAgICAgICAgICAgICAgICB2YXIgYXNzb2NpYXRpb24gPSB0aGlzLmFkZEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24oc2NoZW1hQXNzb2NpYXRpb24ucGF0dGVybiwgdXJpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cmlidXRpb25Bc3NvY2lhdGlvbnMucHVzaChhc3NvY2lhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5hZGRTY2hlbWFIYW5kbGUgPSBmdW5jdGlvbiAoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHZhciBzY2hlbWFIYW5kbGUgPSBuZXcgU2NoZW1hSGFuZGxlKHRoaXMsIGlkLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCk7XG4gICAgICAgIHRoaXMuc2NoZW1hc0J5SWRbaWRdID0gc2NoZW1hSGFuZGxlO1xuICAgICAgICByZXR1cm4gc2NoZW1hSGFuZGxlO1xuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmdldE9yQWRkU2NoZW1hSGFuZGxlID0gZnVuY3Rpb24gKGlkLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFzQnlJZFtpZF0gfHwgdGhpcy5hZGRTY2hlbWFIYW5kbGUoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KTtcbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5hZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uID0gZnVuY3Rpb24gKHBhdHRlcm4sIHVyaXMpIHtcbiAgICAgICAgdmFyIGZwYSA9IG5ldyBGaWxlUGF0dGVybkFzc29jaWF0aW9uKHBhdHRlcm4sIHVyaXMpO1xuICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zLnB1c2goZnBhKTtcbiAgICAgICAgcmV0dXJuIGZwYTtcbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlckV4dGVybmFsU2NoZW1hID0gZnVuY3Rpb24gKHVyaSwgZmlsZVBhdHRlcm5zLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xuICAgICAgICB2YXIgaWQgPSBub3JtYWxpemVJZCh1cmkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzW2lkXSA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChmaWxlUGF0dGVybnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihmaWxlUGF0dGVybnMsIFt1cmldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQgPyB0aGlzLmFkZFNjaGVtYUhhbmRsZShpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIDogdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShpZCk7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUuY2xlYXJFeHRlcm5hbFNjaGVtYXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hc0J5SWQgPSB7fTtcbiAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzID0ge307XG4gICAgICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hcykge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNvbnRyaWJ1dGlvbkFzc29jaWF0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb250cmlidXRpb25Bc3NvY2lhdGlvbiA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMucHVzaChjb250cmlidXRpb25Bc3NvY2lhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5nZXRSZXNvbHZlZFNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWFJZCkge1xuICAgICAgICB2YXIgaWQgPSBub3JtYWxpemVJZChzY2hlbWFJZCk7XG4gICAgICAgIHZhciBzY2hlbWFIYW5kbGUgPSB0aGlzLnNjaGVtYXNCeUlkW2lkXTtcbiAgICAgICAgaWYgKHNjaGVtYUhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYUhhbmRsZS5nZXRSZXNvbHZlZFNjaGVtYSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmxvYWRTY2hlbWEgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0U2VydmljZSkge1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGxvY2FsaXplKCdqc29uLnNjaGVtYS5ub3JlcXVlc3RzZXJ2aWNlJywgJ1VuYWJsZSB0byBsb2FkIHNjaGVtYSBmcm9tIFxcJ3swfVxcJy4gTm8gc2NoZW1hIHJlcXVlc3Qgc2VydmljZSBhdmFpbGFibGUnLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlLnJlc29sdmUobmV3IFVucmVzb2x2ZWRTY2hlbWEoe30sIFtlcnJvck1lc3NhZ2VdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFNlcnZpY2UodXJsKS50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gbG9jYWxpemUoJ2pzb24uc2NoZW1hLm5vY29udGVudCcsICdVbmFibGUgdG8gbG9hZCBzY2hlbWEgZnJvbSBcXCd7MH1cXCc6IE5vIGNvbnRlbnQuJywgdG9EaXNwbGF5U3RyaW5nKHVybCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5yZXNvbHZlZFNjaGVtYSh7fSwgW2Vycm9yTWVzc2FnZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjaGVtYUNvbnRlbnQgPSB7fTtcbiAgICAgICAgICAgIHZhciBqc29uRXJyb3JzID0gW107XG4gICAgICAgICAgICBzY2hlbWFDb250ZW50ID0gSnNvbi5wYXJzZShjb250ZW50LCBqc29uRXJyb3JzKTtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBqc29uRXJyb3JzLmxlbmd0aCA/IFtsb2NhbGl6ZSgnanNvbi5zY2hlbWEuaW52YWxpZEZvcm1hdCcsICdVbmFibGUgdG8gcGFyc2UgY29udGVudCBmcm9tIFxcJ3swfVxcJzogUGFyc2UgZXJyb3IgYXQgb2Zmc2V0IHsxfS4nLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSwganNvbkVycm9yc1swXS5vZmZzZXQpXSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHNjaGVtYUNvbnRlbnQsIGVycm9ycyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgZXJyb3JTcGxpdCA9IGVycm9yLnRvU3RyaW5nKCkuc3BsaXQoJ0Vycm9yOiAnKTtcbiAgICAgICAgICAgIGlmIChlcnJvclNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3JlIGNvbmNpc2UgZXJyb3IgbWVzc2FnZSwgVVJMIGFuZCBjb250ZXh0IGFyZSBhdHRhY2hlZCBieSBjYWxsZXIgYW55d2F5c1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yU3BsaXRbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoU3RyaW5ncy5lbmRzV2l0aChlcnJvck1lc3NhZ2UsICcuJykpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2Uuc3Vic3RyKDAsIGVycm9yTWVzc2FnZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5yZXNvbHZlZFNjaGVtYSh7fSwgW2xvY2FsaXplKCdqc29uLnNjaGVtYS5ub2NvbnRlbnQnLCAnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnOiB7MX0uJywgdG9EaXNwbGF5U3RyaW5nKHVybCksIGVycm9yTWVzc2FnZSldKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUucmVzb2x2ZVNjaGVtYUNvbnRlbnQgPSBmdW5jdGlvbiAoc2NoZW1hVG9SZXNvbHZlLCBzY2hlbWFVUkwsIGRlcGVuZGVuY2llcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzb2x2ZUVycm9ycyA9IHNjaGVtYVRvUmVzb2x2ZS5lcnJvcnMuc2xpY2UoMCk7XG4gICAgICAgIHZhciBzY2hlbWEgPSBzY2hlbWFUb1Jlc29sdmUuc2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hLiRzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDMvc2NoZW1hJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShuZXcgUmVzb2x2ZWRTY2hlbWEoe30sIFtsb2NhbGl6ZSgnanNvbi5zY2hlbWEuZHJhZnQwMy5ub3RzdXBwb3J0ZWQnLCBcIkRyYWZ0LTAzIHNjaGVtYXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaWQgPT09ICdodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L3NjaGVtYScpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRXJyb3JzLnB1c2gobG9jYWxpemUoJ2pzb24uc2NoZW1hLmRyYWZ0MjAxOTA5Lm5vdHN1cHBvcnRlZCcsIFwiRHJhZnQgMjAxOS0wOSBzY2hlbWFzIGFyZSBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZXh0U2VydmljZSA9IHRoaXMuY29udGV4dFNlcnZpY2U7XG4gICAgICAgIHZhciBmaW5kU2VjdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHNjaGVtYTtcbiAgICAgICAgICAgIGlmIChwYXRoWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuc29tZShmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2VSb290LCBzb3VyY2VVUkksIHJlZlNlZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcmVmU2VnbWVudCA/IGRlY29kZVVSSUNvbXBvbmVudChyZWZTZWdtZW50KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gZmluZFNlY3Rpb24oc291cmNlUm9vdCwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNlY3Rpb25ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaChsb2NhbGl6ZSgnanNvbi5zY2hlbWEuaW52YWxpZHJlZicsICckcmVmIFxcJ3swfVxcJyBpbiBcXCd7MX1cXCcgY2FuIG5vdCBiZSByZXNvbHZlZC4nLCBwYXRoLCBzb3VyY2VVUkkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc29sdmVFeHRlcm5hbExpbmsgPSBmdW5jdGlvbiAobm9kZSwgdXJpLCByZWZTZWdtZW50LCBwYXJlbnRTY2hlbWFVUkwsIHBhcmVudFNjaGVtYURlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRTZXJ2aWNlICYmICEvXltBLVphLXpdW0EtWmEtejAtOStcXC0uK10qOlxcL1xcLy4qLy50ZXN0KHVyaSkpIHtcbiAgICAgICAgICAgICAgICB1cmkgPSBjb250ZXh0U2VydmljZS5yZXNvbHZlUmVsYXRpdmVQYXRoKHVyaSwgcGFyZW50U2NoZW1hVVJMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVyaSA9IG5vcm1hbGl6ZUlkKHVyaSk7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlZEhhbmRsZSA9IF90aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKHVyaSk7XG4gICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlZEhhbmRsZS5nZXRVbnJlc29sdmVkU2NoZW1hKCkudGhlbihmdW5jdGlvbiAodW5yZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHBhcmVudFNjaGVtYURlcGVuZGVuY2llc1t1cmldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodW5yZXNvbHZlZFNjaGVtYS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2MgPSByZWZTZWdtZW50ID8gdXJpICsgJyMnICsgcmVmU2VnbWVudCA6IHVyaTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUVycm9ycy5wdXNoKGxvY2FsaXplKCdqc29uLnNjaGVtYS5wcm9ibGVtbG9hZGluZ3JlZicsICdQcm9ibGVtcyBsb2FkaW5nIHJlZmVyZW5jZSBcXCd7MH1cXCc6IHsxfScsIGxvYywgdW5yZXNvbHZlZFNjaGVtYS5lcnJvcnNbMF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2Uobm9kZSwgdW5yZXNvbHZlZFNjaGVtYS5zY2hlbWEsIHVyaSwgcmVmU2VnbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVSZWZzKG5vZGUsIHVucmVzb2x2ZWRTY2hlbWEuc2NoZW1hLCB1cmksIHJlZmVyZW5jZWRIYW5kbGUuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzb2x2ZVJlZnMgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50U2NoZW1hLCBwYXJlbnRTY2hlbWFVUkwsIHBhcmVudFNjaGVtYURlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG9XYWxrID0gW25vZGVdO1xuICAgICAgICAgICAgdmFyIHNlZW4gPSBbXTtcbiAgICAgICAgICAgIHZhciBvcGVuUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0RW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfYSA8IGVudHJpZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc18xW19hXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29sbGVjdE1hcEVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBtYXBzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgbWFwc18xID0gbWFwczsgX2EgPCBtYXBzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBtYXBzXzFbX2FdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gbWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29sbGVjdEFycmF5RW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgYXJyYXlzXzEgPSBhcnJheXM7IF9hIDwgYXJyYXlzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IGFycmF5c18xW19hXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIGFycmF5XzEgPSBhcnJheTsgX2IgPCBhcnJheV8xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGFycmF5XzFbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhhbmRsZVJlZiA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZW5SZWZzID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQuJHJlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gbmV4dC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudHMgPSByZWYuc3BsaXQoJyMnLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5leHQuJHJlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9taXNlcy5wdXNoKHJlc29sdmVFeHRlcm5hbExpbmsobmV4dCwgc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdLCBwYXJlbnRTY2hlbWFVUkwsIHBhcmVudFNjaGVtYURlcGVuZGVuY2llcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5SZWZzLmluZGV4T2YocmVmKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZShuZXh0LCBwYXJlbnRTY2hlbWEsIHBhcmVudFNjaGVtYVVSTCwgc2VnbWVudHNbMV0pOyAvLyBjYW4gc2V0IG5leHQuJHJlZiBhZ2FpbiwgdXNlIHNlZW5SZWZzIHRvIGF2b2lkIGNpcmNsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5SZWZzLnB1c2gocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0RW50cmllcyhuZXh0Lml0ZW1zLCBuZXh0LmFkZGl0aW9uYWxJdGVtcywgbmV4dC5hZGRpdGlvbmFsUHJvcGVydGllcywgbmV4dC5ub3QsIG5leHQuY29udGFpbnMsIG5leHQucHJvcGVydHlOYW1lcywgbmV4dC5pZiwgbmV4dC50aGVuLCBuZXh0LmVsc2UpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RNYXBFbnRyaWVzKG5leHQuZGVmaW5pdGlvbnMsIG5leHQucHJvcGVydGllcywgbmV4dC5wYXR0ZXJuUHJvcGVydGllcywgbmV4dC5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RBcnJheUVudHJpZXMobmV4dC5hbnlPZiwgbmV4dC5hbGxPZiwgbmV4dC5vbmVPZiwgbmV4dC5pdGVtcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHRvV2Fsay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRvV2Fsay5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5leHQpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVSZWYobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvbWlzZS5hbGwob3BlblByb21pc2VzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVSZWZzKHNjaGVtYSwgc2NoZW1hLCBzY2hlbWFVUkwsIGRlcGVuZGVuY2llcykudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gbmV3IFJlc29sdmVkU2NoZW1hKHNjaGVtYSwgcmVzb2x2ZUVycm9ycyk7IH0pO1xuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmdldFNjaGVtYUZvclJlc291cmNlID0gZnVuY3Rpb24gKHJlc291cmNlLCBkb2N1bWVudCkge1xuICAgICAgICAvLyBmaXJzdCB1c2UgJHNjaGVtYSBpZiBwcmVzZW50XG4gICAgICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5yb290ICYmIGRvY3VtZW50LnJvb3QudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFQcm9wZXJ0aWVzID0gZG9jdW1lbnQucm9vdC5wcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gKHAua2V5Tm9kZS52YWx1ZSA9PT0gJyRzY2hlbWEnKSAmJiBwLnZhbHVlTm9kZSAmJiBwLnZhbHVlTm9kZS50eXBlID09PSAnc3RyaW5nJzsgfSk7XG4gICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlTm9kZSA9IHNjaGVtYVByb3BlcnRpZXNbMF0udmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUgJiYgdmFsdWVOb2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2hlbWVJZCA9IFBhcnNlci5nZXROb2RlVmFsdWUodmFsdWVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZUlkICYmIFN0cmluZ3Muc3RhcnRzV2l0aChzY2hlbWVJZCwgJy4nKSAmJiB0aGlzLmNvbnRleHRTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWVJZCA9IHRoaXMuY29udGV4dFNlcnZpY2UucmVzb2x2ZVJlbGF0aXZlUGF0aChzY2hlbWVJZCwgcmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gbm9ybWFsaXplSWQoc2NoZW1lSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JBZGRTY2hlbWFIYW5kbGUoaWQpLmdldFJlc29sdmVkU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgJiYgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZS5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlLnJlc29sdmVkU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIHNjaGVtYXMgPSBbXTtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRSZXNvdXJjZSA9IG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcocmVzb3VyY2UpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5tYXRjaGVzUGF0dGVybihub3JtYWxpemVkUmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGVudHJ5LmdldFVSSXMoKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjaGVtYUlkID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW5bc2NoZW1hSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFzLnB1c2goc2NoZW1hSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltzY2hlbWFJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvbHZlZFNjaGVtYSA9IHNjaGVtYXMubGVuZ3RoID4gMCA/IHRoaXMuY3JlYXRlQ29tYmluZWRTY2hlbWEocmVzb3VyY2UsIHNjaGVtYXMpLmdldFJlc29sdmVkU2NoZW1hKCkgOiB0aGlzLnByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0geyByZXNvdXJjZTogcmVzb3VyY2UsIHJlc29sdmVkU2NoZW1hOiByZXNvbHZlZFNjaGVtYSB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRTY2hlbWE7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUuY3JlYXRlQ29tYmluZWRTY2hlbWEgPSBmdW5jdGlvbiAocmVzb3VyY2UsIHNjaGVtYUlkcykge1xuICAgICAgICBpZiAoc2NoZW1hSWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JBZGRTY2hlbWFIYW5kbGUoc2NoZW1hSWRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZFNjaGVtYUlkID0gJ3NjaGVtYXNlcnZpY2U6Ly9jb21iaW5lZFNjaGVtYS8nICsgZW5jb2RlVVJJQ29tcG9uZW50KHJlc291cmNlKTtcbiAgICAgICAgICAgIHZhciBjb21iaW5lZFNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBhbGxPZjogc2NoZW1hSWRzLm1hcChmdW5jdGlvbiAoc2NoZW1hSWQpIHsgcmV0dXJuICh7ICRyZWY6IHNjaGVtYUlkIH0pOyB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNjaGVtYUhhbmRsZShjb21iaW5lZFNjaGVtYUlkLCBjb21iaW5lZFNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5nZXRNYXRjaGluZ1NjaGVtYXMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIGpzb25Eb2N1bWVudCwgc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHNjaGVtYS5pZCB8fCAoJ3NjaGVtYXNlcnZpY2U6Ly91bnRpdGxlZC9tYXRjaGluZ1NjaGVtYXMvJyArIGlkQ291bnRlcisrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVTY2hlbWFDb250ZW50KG5ldyBVbnJlc29sdmVkU2NoZW1hKHNjaGVtYSksIGlkLCB7fSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbkRvY3VtZW50LmdldE1hdGNoaW5nU2NoZW1hcyhyZXNvbHZlZFNjaGVtYS5zY2hlbWEpLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gIXMuaW52ZXJ0ZWQ7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uRG9jdW1lbnQuZ2V0TWF0Y2hpbmdTY2hlbWFzKHNjaGVtYS5zY2hlbWEpLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gIXMuaW52ZXJ0ZWQ7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBKU09OU2NoZW1hU2VydmljZTtcbn0oKSk7XG5leHBvcnQgeyBKU09OU2NoZW1hU2VydmljZSB9O1xudmFyIGlkQ291bnRlciA9IDA7XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyAnIycsIG5vcm1hbGl6ZSBkcml2ZSBjYXBpdGFsaXphdGlvblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBVUkkucGFyc2UoaWQpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZXNvdXJjZUZvck1hdGNoaW5nKHJlc291cmNlKSB7XG4gICAgLy8gcmVtb3ZlIHF1ZXJpZXMgYW5kIGZyYWdtZW50cywgbm9ybWFsaXplIGRyaXZlIGNhcGl0YWxpemF0aW9uXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFVSSS5wYXJzZShyZXNvdXJjZSkud2l0aCh7IGZyYWdtZW50OiBudWxsLCBxdWVyeTogbnVsbCB9KS50b1N0cmluZygpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9EaXNwbGF5U3RyaW5nKHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB1cmkgPSBVUkkucGFyc2UodXJsKTtcbiAgICAgICAgaWYgKHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgcmV0dXJuIHVyaS5mc1BhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFVucmVzb2x2ZWRTY2hlbWEgfSBmcm9tICcuL2pzb25TY2hlbWFTZXJ2aWNlLmpzJztcbmltcG9ydCB7IEVycm9yQ29kZSwgRGlhZ25vc3RpYywgRGlhZ25vc3RpY1NldmVyaXR5LCBSYW5nZSB9IGZyb20gJy4uL2pzb25MYW5ndWFnZVR5cGVzLmpzJztcbmltcG9ydCAqIGFzIG5scyBmcm9tICcuLy4uLy4uLy4uL2ZpbGxlcnMvdnNjb2RlLW5scy5qcyc7XG5pbXBvcnQgeyBpc0Jvb2xlYW4gfSBmcm9tICcuLi91dGlscy9vYmplY3RzLmpzJztcbnZhciBsb2NhbGl6ZSA9IG5scy5sb2FkTWVzc2FnZUJ1bmRsZSgpO1xudmFyIEpTT05WYWxpZGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05WYWxpZGF0aW9uKGpzb25TY2hlbWFTZXJ2aWNlLCBwcm9taXNlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5qc29uU2NoZW1hU2VydmljZSA9IGpzb25TY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBKU09OVmFsaWRhdGlvbi5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHJhdykge1xuICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRpb25FbmFibGVkID0gcmF3LnZhbGlkYXRlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudFNldmVyaXR5ID0gcmF3LmFsbG93Q29tbWVudHMgPyB1bmRlZmluZWQgOiBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05WYWxpZGF0aW9uLnByb3RvdHlwZS5kb1ZhbGlkYXRpb24gPSBmdW5jdGlvbiAodGV4dERvY3VtZW50LCBqc29uRG9jdW1lbnQsIGRvY3VtZW50U2V0dGluZ3MsIHNjaGVtYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpYWdub3N0aWNzID0gW107XG4gICAgICAgIHZhciBhZGRlZCA9IHt9O1xuICAgICAgICB2YXIgYWRkUHJvYmxlbSA9IGZ1bmN0aW9uIChwcm9ibGVtKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlZCBtZXNzYWdlc1xuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHByb2JsZW0ucmFuZ2Uuc3RhcnQubGluZSArICcgJyArIHByb2JsZW0ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyICsgJyAnICsgcHJvYmxlbS5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFhZGRlZFtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRbc2lnbmF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MucHVzaChwcm9ibGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldERpYWdub3N0aWNzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWFTZXZlcml0eSA9IChkb2N1bWVudFNldHRpbmdzID09PSBudWxsIHx8IGRvY3VtZW50U2V0dGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50U2V0dGluZ3MudHJhaWxpbmdDb21tYXMpID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy50cmFpbGluZ0NvbW1hcykgOiBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XG4gICAgICAgICAgICB2YXIgY29tbWVudFNldmVyaXR5ID0gKGRvY3VtZW50U2V0dGluZ3MgPT09IG51bGwgfHwgZG9jdW1lbnRTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnRTZXR0aW5ncy5jb21tZW50cykgPyB0b0RpYWdub3N0aWNTZXZlcml0eShkb2N1bWVudFNldHRpbmdzLmNvbW1lbnRzKSA6IF90aGlzLmNvbW1lbnRTZXZlcml0eTtcbiAgICAgICAgICAgIHZhciBzY2hlbWFWYWxpZGF0aW9uID0gKGRvY3VtZW50U2V0dGluZ3MgPT09IG51bGwgfHwgZG9jdW1lbnRTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnRTZXR0aW5ncy5zY2hlbWFWYWxpZGF0aW9uKSA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hVmFsaWRhdGlvbikgOiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgICAgIHZhciBzY2hlbWFSZXF1ZXN0ID0gKGRvY3VtZW50U2V0dGluZ3MgPT09IG51bGwgfHwgZG9jdW1lbnRTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnRTZXR0aW5ncy5zY2hlbWFSZXF1ZXN0KSA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hUmVxdWVzdCkgOiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9ycy5sZW5ndGggJiYganNvbkRvY3VtZW50LnJvb3QgJiYgc2NoZW1hUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXN0Um9vdCA9IGpzb25Eb2N1bWVudC5yb290O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBhc3RSb290LnR5cGUgPT09ICdvYmplY3QnID8gYXN0Um9vdC5wcm9wZXJ0aWVzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gJyRzY2hlbWEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHByb3BlcnR5LnZhbHVlTm9kZSB8fCBwcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFByb2JsZW0oRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIHNjaGVtYS5lcnJvcnNbMF0sIHNjaGVtYVJlcXVlc3QsIEVycm9yQ29kZS5TY2hlbWFSZXNvbHZlRXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChhc3RSb290Lm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGFzdFJvb3Qub2Zmc2V0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUHJvYmxlbShEaWFnbm9zdGljLmNyZWF0ZShyYW5nZSwgc2NoZW1hLmVycm9yc1swXSwgc2NoZW1hUmVxdWVzdCwgRXJyb3JDb2RlLlNjaGVtYVJlc29sdmVFcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbWFudGljRXJyb3JzID0ganNvbkRvY3VtZW50LnZhbGlkYXRlKHRleHREb2N1bWVudCwgc2NoZW1hLnNjaGVtYSwgc2NoZW1hVmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZW1hbnRpY0Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VtYW50aWNFcnJvcnMuZm9yRWFjaChhZGRQcm9ibGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudFNldmVyaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hQWxsb3dzVHJhaWxpbmdDb21tYXMoc2NoZW1hLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tYVNldmVyaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBqc29uRG9jdW1lbnQuc3ludGF4RXJyb3JzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChwLmNvZGUgPT09IEVycm9yQ29kZS5UcmFpbGluZ0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhaWxpbmdDb21tYVNldmVyaXR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcC5zZXZlcml0eSA9IHRyYWlsaW5nQ29tbWFTZXZlcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkUHJvYmxlbShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudFNldmVyaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlXzEgPSBsb2NhbGl6ZSgnSW52YWxpZENvbW1lbnRUb2tlbicsICdDb21tZW50cyBhcmUgbm90IHBlcm1pdHRlZCBpbiBKU09OLicpO1xuICAgICAgICAgICAgICAgIGpzb25Eb2N1bWVudC5jb21tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFByb2JsZW0oRGlhZ25vc3RpYy5jcmVhdGUoYywgbWVzc2FnZV8xLCBjb21tZW50U2V2ZXJpdHksIEVycm9yQ29kZS5Db21tZW50Tm90UGVybWl0dGVkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3M7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHNjaGVtYS5pZCB8fCAoJ3NjaGVtYXNlcnZpY2U6Ly91bnRpdGxlZC8nICsgaWRDb3VudGVyKyspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuanNvblNjaGVtYVNlcnZpY2UucmVzb2x2ZVNjaGVtYUNvbnRlbnQobmV3IFVucmVzb2x2ZWRTY2hlbWEoc2NoZW1hKSwgaWQsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXREaWFnbm9zdGljcyhyZXNvbHZlZFNjaGVtYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5qc29uU2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZSh0ZXh0RG9jdW1lbnQudXJpLCBqc29uRG9jdW1lbnQpLnRoZW4oZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldERpYWdub3N0aWNzKHNjaGVtYSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05WYWxpZGF0aW9uO1xufSgpKTtcbmV4cG9ydCB7IEpTT05WYWxpZGF0aW9uIH07XG52YXIgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYVJlZikge1xuICAgIGlmIChzY2hlbWFSZWYgJiYgdHlwZW9mIHNjaGVtYVJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihzY2hlbWFSZWYuYWxsb3dDb21tZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWFSZWYuYWxsb3dDb21tZW50cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hUmVmLmFsbE9mKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2NoZW1hUmVmLmFsbE9mOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGFsbG93ID0gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCb29sZWFuKGFsbG93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzY2hlbWFBbGxvd3NUcmFpbGluZ0NvbW1hcyhzY2hlbWFSZWYpIHtcbiAgICBpZiAoc2NoZW1hUmVmICYmIHR5cGVvZiBzY2hlbWFSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oc2NoZW1hUmVmLmFsbG93VHJhaWxpbmdDb21tYXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hUmVmLmFsbG93VHJhaWxpbmdDb21tYXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHJTY2hlbWFSZWYgPSBzY2hlbWFSZWY7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oZGVwclNjaGVtYVJlZlsnYWxsb3dzVHJhaWxpbmdDb21tYXMnXSkpIHsgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgcmV0dXJuIGRlcHJTY2hlbWFSZWZbJ2FsbG93c1RyYWlsaW5nQ29tbWFzJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVJlZi5hbGxPZikge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNjaGVtYVJlZi5hbGxPZjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBhbGxvdyA9IHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihhbGxvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9EaWFnbm9zdGljU2V2ZXJpdHkoc2V2ZXJpdHlMZXZlbCkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHlMZXZlbCkge1xuICAgICAgICBjYXNlICdlcnJvcic6IHJldHVybiBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7XG4gICAgICAgIGNhc2UgJ3dhcm5pbmcnOiByZXR1cm4gRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc7XG4gICAgICAgIGNhc2UgJ2lnbm9yZSc6IHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBEaWdpdDAgPSA0ODtcbnZhciBEaWdpdDkgPSA1NztcbnZhciBBID0gNjU7XG52YXIgYSA9IDk3O1xudmFyIGYgPSAxMDI7XG5leHBvcnQgZnVuY3Rpb24gaGV4RGlnaXQoY2hhckNvZGUpIHtcbiAgICBpZiAoY2hhckNvZGUgPCBEaWdpdDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZSA8PSBEaWdpdDkpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlIC0gRGlnaXQwO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPCBhKSB7XG4gICAgICAgIGNoYXJDb2RlICs9IChhIC0gQSk7XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZSA+PSBhICYmIGNoYXJDb2RlIDw9IGYpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlIC0gYSArIDEwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2xvckZyb21IZXgodGV4dCkge1xuICAgIGlmICh0ZXh0WzBdICE9PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDcpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoOCkpKSAvIDI1NS4wXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yRnJvbTI1NlJHQihyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMS4wOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiByZWQgLyAyNTUuMCxcbiAgICAgICAgZ3JlZW46IGdyZWVuIC8gMjU1LjAsXG4gICAgICAgIGJsdWU6IGJsdWUgLyAyNTUuMCxcbiAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgfTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgUGFyc2VyIGZyb20gJy4uL3BhcnNlci9qc29uUGFyc2VyLmpzJztcbmltcG9ydCAqIGFzIFN0cmluZ3MgZnJvbSAnLi4vdXRpbHMvc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBjb2xvckZyb21IZXggfSBmcm9tICcuLi91dGlscy9jb2xvcnMuanMnO1xuaW1wb3J0IHsgUmFuZ2UsIFRleHRFZGl0LCBTeW1ib2xLaW5kLCBMb2NhdGlvbiB9IGZyb20gXCIuLi9qc29uTGFuZ3VhZ2VUeXBlcy5qc1wiO1xudmFyIEpTT05Eb2N1bWVudFN5bWJvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTkRvY3VtZW50U3ltYm9scyhzY2hlbWFTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hU2VydmljZSA9IHNjaGVtYVNlcnZpY2U7XG4gICAgfVxuICAgIEpTT05Eb2N1bWVudFN5bWJvbHMucHJvdG90eXBlLmZpbmREb2N1bWVudFN5bWJvbHMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIGRvYywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7IHJlc3VsdExpbWl0OiBOdW1iZXIuTUFYX1ZBTFVFIH07IH1cbiAgICAgICAgdmFyIHJvb3QgPSBkb2Mucm9vdDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbWl0ID0gY29udGV4dC5yZXN1bHRMaW1pdCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBrZXkgYmluZGluZ3NcbiAgICAgICAgdmFyIHJlc291cmNlU3RyaW5nID0gZG9jdW1lbnQudXJpO1xuICAgICAgICBpZiAoKHJlc291cmNlU3RyaW5nID09PSAndnNjb2RlOi8vZGVmYXVsdHNldHRpbmdzL2tleWJpbmRpbmdzLmpzb24nKSB8fCBTdHJpbmdzLmVuZHNXaXRoKHJlc291cmNlU3RyaW5nLnRvTG93ZXJDYXNlKCksICcvdXNlci9rZXliaW5kaW5ncy5qc29uJykpIHtcbiAgICAgICAgICAgIGlmIChyb290LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcm9vdC5pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gaXRlbS5wcm9wZXJ0aWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gJ2tleScgJiYgcHJvcGVydHkudmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IExvY2F0aW9uLmNyZWF0ZShkb2N1bWVudC51cmksIGdldFJhbmdlKGRvY3VtZW50LCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xLnB1c2goeyBuYW1lOiBQYXJzZXIuZ2V0Tm9kZVZhbHVlKHByb3BlcnR5LnZhbHVlTm9kZSksIGtpbmQ6IFN5bWJvbEtpbmQuRnVuY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9WaXNpdCA9IFtcbiAgICAgICAgICAgIHsgbm9kZTogcm9vdCwgY29udGFpbmVyTmFtZTogJycgfVxuICAgICAgICBdO1xuICAgICAgICB2YXIgbmV4dFRvVmlzaXQgPSAwO1xuICAgICAgICB2YXIgbGltaXRFeGNlZWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBjb2xsZWN0T3V0bGluZUVudHJpZXMgPSBmdW5jdGlvbiAobm9kZSwgY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgbm9kZTogbm9kZSwgY29udGFpbmVyTmFtZTogY29udGFpbmVyTmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBMb2NhdGlvbi5jcmVhdGUoZG9jdW1lbnQudXJpLCBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRDb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZSA/IGNvbnRhaW5lck5hbWUgKyAnLicgKyBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlIDogcHJvcGVydHkua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IF90aGlzLmdldEtleUxhYmVsKHByb3BlcnR5KSwga2luZDogX3RoaXMuZ2V0U3ltYm9sS2luZCh2YWx1ZU5vZGUudHlwZSksIGxvY2F0aW9uOiBsb2NhdGlvbiwgY29udGFpbmVyTmFtZTogY29udGFpbmVyTmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyBub2RlOiB2YWx1ZU5vZGUsIGNvbnRhaW5lck5hbWU6IGNoaWxkQ29udGFpbmVyTmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGJyZWF0aCBmaXJzdCB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5leHRUb1Zpc2l0IDwgdG9WaXNpdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcbiAgICAgICAgICAgIGNvbGxlY3RPdXRsaW5lRW50cmllcyhuZXh0Lm5vZGUsIG5leHQuY29udGFpbmVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0RXhjZWVkZWQgJiYgY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBKU09ORG9jdW1lbnRTeW1ib2xzLnByb3RvdHlwZS5maW5kRG9jdW1lbnRTeW1ib2xzMiA9IGZ1bmN0aW9uIChkb2N1bWVudCwgZG9jLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IHsgcmVzdWx0TGltaXQ6IE51bWJlci5NQVhfVkFMVUUgfTsgfVxuICAgICAgICB2YXIgcm9vdCA9IGRvYy5yb290O1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGltaXQgPSBjb250ZXh0LnJlc3VsdExpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGtleSBiaW5kaW5nc1xuICAgICAgICB2YXIgcmVzb3VyY2VTdHJpbmcgPSBkb2N1bWVudC51cmk7XG4gICAgICAgIGlmICgocmVzb3VyY2VTdHJpbmcgPT09ICd2c2NvZGU6Ly9kZWZhdWx0c2V0dGluZ3Mva2V5YmluZGluZ3MuanNvbicpIHx8IFN0cmluZ3MuZW5kc1dpdGgocmVzb3VyY2VTdHJpbmcudG9Mb3dlckNhc2UoKSwgJy91c2VyL2tleWJpbmRpbmdzLmpzb24nKSkge1xuICAgICAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSByb290Lml0ZW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBpdGVtLnByb3BlcnRpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSAna2V5JyAmJiBwcm9wZXJ0eS52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkua2V5Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2goeyBuYW1lOiBQYXJzZXIuZ2V0Tm9kZVZhbHVlKHByb3BlcnR5LnZhbHVlTm9kZSksIGtpbmQ6IFN5bWJvbEtpbmQuRnVuY3Rpb24sIHJhbmdlOiByYW5nZSwgc2VsZWN0aW9uUmFuZ2U6IHNlbGVjdGlvblJhbmdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHRvVmlzaXQgPSBbXG4gICAgICAgICAgICB7IG5vZGU6IHJvb3QsIHJlc3VsdDogcmVzdWx0IH1cbiAgICAgICAgXTtcbiAgICAgICAgdmFyIG5leHRUb1Zpc2l0ID0gMDtcbiAgICAgICAgdmFyIGxpbWl0RXhjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvbGxlY3RPdXRsaW5lRW50cmllcyA9IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBub2RlLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSB7IG5hbWU6IG5hbWUsIGtpbmQ6IF90aGlzLmdldFN5bWJvbEtpbmQobm9kZS50eXBlKSwgcmFuZ2U6IHJhbmdlLCBzZWxlY3Rpb25SYW5nZTogc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgcmVzdWx0OiBzeW1ib2wuY2hpbGRyZW4sIG5vZGU6IG5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVOb2RlID0gcHJvcGVydHkudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eS5rZXlOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0geyBuYW1lOiBfdGhpcy5nZXRLZXlMYWJlbChwcm9wZXJ0eSksIGtpbmQ6IF90aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCByYW5nZTogcmFuZ2UsIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZSwgY2hpbGRyZW46IGNoaWxkcmVuLCBkZXRhaWw6IF90aGlzLmdldERldGFpbCh2YWx1ZU5vZGUpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyByZXN1bHQ6IGNoaWxkcmVuLCBub2RlOiB2YWx1ZU5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBicmVhdGggZmlyc3QgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChuZXh0VG9WaXNpdCA8IHRvVmlzaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRvVmlzaXRbbmV4dFRvVmlzaXQrK107XG4gICAgICAgICAgICBjb2xsZWN0T3V0bGluZUVudHJpZXMobmV4dC5ub2RlLCBuZXh0LnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0RXhjZWVkZWQgJiYgY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBKU09ORG9jdW1lbnRTeW1ib2xzLnByb3RvdHlwZS5nZXRTeW1ib2xLaW5kID0gZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuTW9kdWxlO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5TdHJpbmc7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2xLaW5kLk51bWJlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5BcnJheTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2xLaW5kLkJvb2xlYW47XG4gICAgICAgICAgICBkZWZhdWx0OiAvLyAnbnVsbCdcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5WYXJpYWJsZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkRvY3VtZW50U3ltYm9scy5wcm90b3R5cGUuZ2V0S2V5TGFiZWwgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcbl0vZywgJ+KGtScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCI7XG4gICAgfTtcbiAgICBKU09ORG9jdW1lbnRTeW1ib2xzLnByb3RvdHlwZS5nZXREZXRhaWwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcgfHwgbm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5sZW5ndGggPyB1bmRlZmluZWQgOiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IHVuZGVmaW5lZCA6ICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudFN5bWJvbHMucHJvdG90eXBlLmZpbmREb2N1bWVudENvbG9ycyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgZG9jLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQucmVzdWx0TGltaXQgPT09ICdudW1iZXInID8gY29udGV4dC5yZXN1bHRMaW1pdCA6IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nU2NoZW1hcyA9IGRvYy5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWROb2RlID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYXRjaGluZ1NjaGVtYXNfMSA9IG1hdGNoaW5nU2NoZW1hczsgX2kgPCBtYXRjaGluZ1NjaGVtYXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBtYXRjaGluZ1NjaGVtYXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcy5pbnZlcnRlZCAmJiBzLnNjaGVtYSAmJiAocy5zY2hlbWEuZm9ybWF0ID09PSAnY29sb3InIHx8IHMuc2NoZW1hLmZvcm1hdCA9PT0gJ2NvbG9yLWhleCcpICYmIHMubm9kZSAmJiBzLm5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSWQgPSBTdHJpbmcocy5ub2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWROb2RlW25vZGVJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvckZyb21IZXgoUGFyc2VyLmdldE5vZGVWYWx1ZShzLm5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHMubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgY29sb3I6IGNvbG9yLCByYW5nZTogcmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWROb2RlW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudFN5bWJvbHMucHJvdG90eXBlLmdldENvbG9yUHJlc2VudGF0aW9ucyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgZG9jLCBjb2xvciwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgcmVkMjU2ID0gTWF0aC5yb3VuZChjb2xvci5yZWQgKiAyNTUpLCBncmVlbjI1NiA9IE1hdGgucm91bmQoY29sb3IuZ3JlZW4gKiAyNTUpLCBibHVlMjU2ID0gTWF0aC5yb3VuZChjb2xvci5ibHVlICogMjU1KTtcbiAgICAgICAgZnVuY3Rpb24gdG9Ud29EaWdpdEhleChuKSB7XG4gICAgICAgICAgICB2YXIgciA9IG4udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIHIubGVuZ3RoICE9PSAyID8gJzAnICsgciA6IHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhYmVsO1xuICAgICAgICBpZiAoY29sb3IuYWxwaGEgPT09IDEpIHtcbiAgICAgICAgICAgIGxhYmVsID0gXCIjXCIgKyB0b1R3b0RpZ2l0SGV4KHJlZDI1NikgKyB0b1R3b0RpZ2l0SGV4KGdyZWVuMjU2KSArIHRvVHdvRGlnaXRIZXgoYmx1ZTI1Nik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCA9IFwiI1wiICsgdG9Ud29EaWdpdEhleChyZWQyNTYpICsgdG9Ud29EaWdpdEhleChncmVlbjI1NikgKyB0b1R3b0RpZ2l0SGV4KGJsdWUyNTYpICsgdG9Ud29EaWdpdEhleChNYXRoLnJvdW5kKGNvbG9yLmFscGhhICogMjU1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goeyBsYWJlbDogbGFiZWwsIHRleHRFZGl0OiBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBKU09OLnN0cmluZ2lmeShsYWJlbCkpIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05Eb2N1bWVudFN5bWJvbHM7XG59KCkpO1xuZXhwb3J0IHsgSlNPTkRvY3VtZW50U3ltYm9scyB9O1xuZnVuY3Rpb24gZ2V0UmFuZ2UoZG9jdW1lbnQsIG5vZGUpIHtcbiAgICByZXR1cm4gUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgbmxzIGZyb20gJy4vLi4vLi4vLi4vZmlsbGVycy92c2NvZGUtbmxzLmpzJztcbnZhciBsb2NhbGl6ZSA9IG5scy5sb2FkTWVzc2FnZUJ1bmRsZSgpO1xuZXhwb3J0IHZhciBzY2hlbWFDb250cmlidXRpb25zID0ge1xuICAgIHNjaGVtYUFzc29jaWF0aW9uczogW10sXG4gICAgc2NoZW1hczoge1xuICAgICAgICAvLyByZWZlciB0byB0aGUgbGF0ZXN0IHNjaGVtYVxuICAgICAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWEjJzoge1xuICAgICAgICAgICAgJHJlZjogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIydcbiAgICAgICAgfSxcbiAgICAgICAgLy8gYnVuZGxlIHRoZSBzY2hlbWEtc2NoZW1hIHRvIGluY2x1ZGUgKGxvY2FsaXplZCkgZGVzY3JpcHRpb25zXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAndGl0bGUnOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24nLCAnRGVzY3JpYmVzIGEgSlNPTiBmaWxlIHVzaW5nIGEgc2NoZW1hLiBTZWUganNvbi1zY2hlbWEub3JnIGZvciBtb3JlIGluZm8uJyksXG4gICAgICAgICAgICAnJHNjaGVtYSc6ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnLFxuICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICdzY2hlbWFBcnJheSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncG9zaXRpdmVJbnRlZ2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW0nOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDAnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzaW1wbGVUeXBlcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2VudW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ251bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzdHJpbmdBcnJheSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICdpZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHNjaGVtYSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndGl0bGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fSxcbiAgICAgICAgICAgICAgICAnbXVsdGlwbGVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhpbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWF4aW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhMZW5ndGgnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pbkxlbmd0aCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDAnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYXR0ZXJuJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3JlZ2V4J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxJdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhJdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4UHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDAnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYXR0ZXJuUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlcGVuZGVuY2llcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbnVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0eXBlJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlcydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlcydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZm9ybWF0Jzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZW51bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGUtdGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1cmknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZW1haWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaG9zdG5hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXB2NCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcHY2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2V4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWxsT2YnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYW55T2YnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnb25lT2YnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbm90Jzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVwZW5kZW5jaWVzJzoge1xuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNYXhpbXVtJzogW1xuICAgICAgICAgICAgICAgICAgICAnbWF4aW11bSdcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzogW1xuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICB9LFxuICAgICAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJzoge1xuICAgICAgICAgICAgJ3RpdGxlJzogbG9jYWxpemUoJ3NjaGVtYS5qc29uJywgJ0Rlc2NyaWJlcyBhIEpTT04gZmlsZSB1c2luZyBhIHNjaGVtYS4gU2VlIGpzb24tc2NoZW1hLm9yZyBmb3IgbW9yZSBpbmZvLicpLFxuICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICdzY2hlbWFBcnJheSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7ICckcmVmJzogJyMnIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdub25OZWdhdGl2ZUludGVnZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlcicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgJ2RlZmF1bHQnOiAwIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3NpbXBsZVR5cGVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnZW51bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3N0cmluZ0FycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHsgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IFtdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0eXBlJzogWydvYmplY3QnLCAnYm9vbGVhbiddLFxuICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgJyRpZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmktcmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyRzY2hlbWEnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAndXJpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyRyZWYnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAndXJpLXJlZmVyZW5jZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3RpdGxlJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZWZhdWx0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAncmVhZE9ubHknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhhbXBsZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ211bHRpcGxlT2YnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNYXhpbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluaW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhMZW5ndGgnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5MZW5ndGgnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDAnIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm4nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAncmVnZXgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbEl0ZW1zJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5JyB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heEl0ZW1zJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlcicgfSxcbiAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDAnIH0sXG4gICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdtYXhQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlcicgfSxcbiAgICAgICAgICAgICAgICAnbWluUHJvcGVydGllcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAncmVxdWlyZWQnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXknIH0sXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncGF0dGVyblByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5TmFtZXMnOiB7ICdmb3JtYXQnOiAncmVnZXgnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZXBlbmRlbmNpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5JyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0eU5hbWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdjb25zdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2VudW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZm9ybWF0JzogeyAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnRNZWRpYVR5cGUnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnY29udGVudEVuY29kaW5nJzogeyAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgJ2lmJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICd0aGVuJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdlbHNlJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICdhbGxPZic6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnYW55T2YnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH0sXG4gICAgICAgICAgICAgICAgJ29uZU9mJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5JyB9LFxuICAgICAgICAgICAgICAgICdub3QnOiB7ICckcmVmJzogJyMnIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVmYXVsdCc6IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgZGVzY3JpcHRpb25zID0ge1xuICAgIGlkOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uaWQnLCBcIkEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzY2hlbWEuXCIpLFxuICAgICRzY2hlbWE6IGxvY2FsaXplKCdzY2hlbWEuanNvbi4kc2NoZW1hJywgXCJUaGUgc2NoZW1hIHRvIHZlcmlmeSB0aGlzIGRvY3VtZW50IGFnYWluc3QuXCIpLFxuICAgIHRpdGxlOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24udGl0bGUnLCBcIkEgZGVzY3JpcHRpdmUgdGl0bGUgb2YgdGhlIGVsZW1lbnQuXCIpLFxuICAgIGRlc2NyaXB0aW9uOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uZGVzY3JpcHRpb24nLCBcIkEgbG9uZyBkZXNjcmlwdGlvbiBvZiB0aGUgZWxlbWVudC4gVXNlZCBpbiBob3ZlciBtZW51cyBhbmQgc3VnZ2VzdGlvbnMuXCIpLFxuICAgIGRlZmF1bHQ6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5kZWZhdWx0JywgXCJBIGRlZmF1bHQgdmFsdWUuIFVzZWQgYnkgc3VnZ2VzdGlvbnMuXCIpLFxuICAgIG11bHRpcGxlT2Y6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5tdWx0aXBsZU9mJywgXCJBIG51bWJlciB0aGF0IHNob3VsZCBjbGVhbmx5IGRpdmlkZSB0aGUgY3VycmVudCB2YWx1ZSAoaS5lLiBoYXZlIG5vIHJlbWFpbmRlcikuXCIpLFxuICAgIG1heGltdW06IGxvY2FsaXplKCdzY2hlbWEuanNvbi5tYXhpbXVtJywgXCJUaGUgbWF4aW11bSBudW1lcmljYWwgdmFsdWUsIGluY2x1c2l2ZSBieSBkZWZhdWx0LlwiKSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uZXhjbHVzaXZlTWF4aW11bScsIFwiTWFrZXMgdGhlIG1heGltdW0gcHJvcGVydHkgZXhjbHVzaXZlLlwiKSxcbiAgICBtaW5pbXVtOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ubWluaW11bScsIFwiVGhlIG1pbmltdW0gbnVtZXJpY2FsIHZhbHVlLCBpbmNsdXNpdmUgYnkgZGVmYXVsdC5cIiksXG4gICAgZXhjbHVzaXZlTWluaW11bTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmV4Y2x1c2l2ZU1pbmludW0nLCBcIk1ha2VzIHRoZSBtaW5pbXVtIHByb3BlcnR5IGV4Y2x1c2l2ZS5cIiksXG4gICAgbWF4TGVuZ3RoOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ubWF4TGVuZ3RoJywgXCJUaGUgbWF4aW11bSBsZW5ndGggb2YgYSBzdHJpbmcuXCIpLFxuICAgIG1pbkxlbmd0aDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm1pbkxlbmd0aCcsIFwiVGhlIG1pbmltdW0gbGVuZ3RoIG9mIGEgc3RyaW5nLlwiKSxcbiAgICBwYXR0ZXJuOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ucGF0dGVybicsIFwiQSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggdGhlIHN0cmluZyBhZ2FpbnN0LiBJdCBpcyBub3QgaW1wbGljaXRseSBhbmNob3JlZC5cIiksXG4gICAgYWRkaXRpb25hbEl0ZW1zOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uYWRkaXRpb25hbEl0ZW1zJywgXCJGb3IgYXJyYXlzLCBvbmx5IHdoZW4gaXRlbXMgaXMgc2V0IGFzIGFuIGFycmF5LiBJZiBpdCBpcyBhIHNjaGVtYSwgdGhlbiB0aGlzIHNjaGVtYSB2YWxpZGF0ZXMgaXRlbXMgYWZ0ZXIgdGhlIG9uZXMgc3BlY2lmaWVkIGJ5IHRoZSBpdGVtcyBhcnJheS4gSWYgaXQgaXMgZmFsc2UsIHRoZW4gYWRkaXRpb25hbCBpdGVtcyB3aWxsIGNhdXNlIHZhbGlkYXRpb24gdG8gZmFpbC5cIiksXG4gICAgaXRlbXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5pdGVtcycsIFwiRm9yIGFycmF5cy4gQ2FuIGVpdGhlciBiZSBhIHNjaGVtYSB0byB2YWxpZGF0ZSBldmVyeSBlbGVtZW50IGFnYWluc3Qgb3IgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB2YWxpZGF0ZSBlYWNoIGl0ZW0gYWdhaW5zdCBpbiBvcmRlciAodGhlIGZpcnN0IHNjaGVtYSB3aWxsIHZhbGlkYXRlIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgc2Vjb25kIHNjaGVtYSB3aWxsIHZhbGlkYXRlIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlwiKSxcbiAgICBtYXhJdGVtczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm1heEl0ZW1zJywgXCJUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgaW5zaWRlIGFuIGFycmF5LiBJbmNsdXNpdmUuXCIpLFxuICAgIG1pbkl0ZW1zOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ubWluSXRlbXMnLCBcIlRoZSBtaW5pbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbnNpZGUgYW4gYXJyYXkuIEluY2x1c2l2ZS5cIiksXG4gICAgdW5pcXVlSXRlbXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi51bmlxdWVJdGVtcycsIFwiSWYgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYXJyYXkgbXVzdCBiZSB1bmlxdWUuIERlZmF1bHRzIHRvIGZhbHNlLlwiKSxcbiAgICBtYXhQcm9wZXJ0aWVzOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ubWF4UHJvcGVydGllcycsIFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIHByb3BlcnRpZXMgYW4gb2JqZWN0IGNhbiBoYXZlLiBJbmNsdXNpdmUuXCIpLFxuICAgIG1pblByb3BlcnRpZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5taW5Qcm9wZXJ0aWVzJywgXCJUaGUgbWluaW11bSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgY2FuIGhhdmUuIEluY2x1c2l2ZS5cIiksXG4gICAgcmVxdWlyZWQ6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5yZXF1aXJlZCcsIFwiQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGxpc3RzIHRoZSBuYW1lcyBvZiBhbGwgcHJvcGVydGllcyByZXF1aXJlZCBvbiB0aGlzIG9iamVjdC5cIiksXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5hZGRpdGlvbmFsUHJvcGVydGllcycsIFwiRWl0aGVyIGEgc2NoZW1hIG9yIGEgYm9vbGVhbi4gSWYgYSBzY2hlbWEsIHRoZW4gdXNlZCB0byB2YWxpZGF0ZSBhbGwgcHJvcGVydGllcyBub3QgbWF0Y2hlZCBieSAncHJvcGVydGllcycgb3IgJ3BhdHRlcm5Qcm9wZXJ0aWVzJy4gSWYgZmFsc2UsIHRoZW4gYW55IHByb3BlcnRpZXMgbm90IG1hdGNoZWQgYnkgZWl0aGVyIHdpbGwgY2F1c2UgdGhpcyBzY2hlbWEgdG8gZmFpbC5cIiksXG4gICAgZGVmaW5pdGlvbnM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5kZWZpbml0aW9ucycsIFwiTm90IHVzZWQgZm9yIHZhbGlkYXRpb24uIFBsYWNlIHN1YnNjaGVtYXMgaGVyZSB0aGF0IHlvdSB3aXNoIHRvIHJlZmVyZW5jZSBpbmxpbmUgd2l0aCAkcmVmLlwiKSxcbiAgICBwcm9wZXJ0aWVzOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ucHJvcGVydGllcycsIFwiQSBtYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gc2NoZW1hcyBmb3IgZWFjaCBwcm9wZXJ0eS5cIiksXG4gICAgcGF0dGVyblByb3BlcnRpZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5wYXR0ZXJuUHJvcGVydGllcycsIFwiQSBtYXAgb2YgcmVndWxhciBleHByZXNzaW9ucyBvbiBwcm9wZXJ0eSBuYW1lcyB0byBzY2hlbWFzIGZvciBtYXRjaGluZyBwcm9wZXJ0aWVzLlwiKSxcbiAgICBkZXBlbmRlbmNpZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5kZXBlbmRlbmNpZXMnLCBcIkEgbWFwIG9mIHByb3BlcnR5IG5hbWVzIHRvIGVpdGhlciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciBhIHNjaGVtYS4gQW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgbWVhbnMgdGhlIHByb3BlcnR5IG5hbWVkIGluIHRoZSBrZXkgZGVwZW5kcyBvbiB0aGUgcHJvcGVydGllcyBpbiB0aGUgYXJyYXkgYmVpbmcgcHJlc2VudCBpbiB0aGUgb2JqZWN0IGluIG9yZGVyIHRvIGJlIHZhbGlkLiBJZiB0aGUgdmFsdWUgaXMgYSBzY2hlbWEsIHRoZW4gdGhlIHNjaGVtYSBpcyBvbmx5IGFwcGxpZWQgdG8gdGhlIG9iamVjdCBpZiB0aGUgcHJvcGVydHkgaW4gdGhlIGtleSBleGlzdHMgb24gdGhlIG9iamVjdC5cIiksXG4gICAgZW51bTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmVudW0nLCBcIlRoZSBzZXQgb2YgbGl0ZXJhbCB2YWx1ZXMgdGhhdCBhcmUgdmFsaWQuXCIpLFxuICAgIHR5cGU6IGxvY2FsaXplKCdzY2hlbWEuanNvbi50eXBlJywgXCJFaXRoZXIgYSBzdHJpbmcgb2Ygb25lIG9mIHRoZSBiYXNpYyBzY2hlbWEgdHlwZXMgKG51bWJlciwgaW50ZWdlciwgbnVsbCwgYXJyYXksIG9iamVjdCwgYm9vbGVhbiwgc3RyaW5nKSBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHNwZWNpZnlpbmcgYSBzdWJzZXQgb2YgdGhvc2UgdHlwZXMuXCIpLFxuICAgIGZvcm1hdDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmZvcm1hdCcsIFwiRGVzY3JpYmVzIHRoZSBmb3JtYXQgZXhwZWN0ZWQgZm9yIHRoZSB2YWx1ZS5cIiksXG4gICAgYWxsT2Y6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5hbGxPZicsIFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgYWxsIG9mIHdoaWNoIG11c3QgbWF0Y2guXCIpLFxuICAgIGFueU9mOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uYW55T2YnLCBcIkFuIGFycmF5IG9mIHNjaGVtYXMsIHdoZXJlIGF0IGxlYXN0IG9uZSBtdXN0IG1hdGNoLlwiKSxcbiAgICBvbmVPZjogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm9uZU9mJywgXCJBbiBhcnJheSBvZiBzY2hlbWFzLCBleGFjdGx5IG9uZSBvZiB3aGljaCBtdXN0IG1hdGNoLlwiKSxcbiAgICBub3Q6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5ub3QnLCBcIkEgc2NoZW1hIHdoaWNoIG11c3Qgbm90IG1hdGNoLlwiKSxcbiAgICAkaWQ6IGxvY2FsaXplKCdzY2hlbWEuanNvbi4kaWQnLCBcIkEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzY2hlbWEuXCIpLFxuICAgICRyZWY6IGxvY2FsaXplKCdzY2hlbWEuanNvbi4kcmVmJywgXCJSZWZlcmVuY2UgYSBkZWZpbml0aW9uIGhvc3RlZCBvbiBhbnkgbG9jYXRpb24uXCIpLFxuICAgICRjb21tZW50OiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uJGNvbW1lbnQnLCBcIkNvbW1lbnRzIGZyb20gc2NoZW1hIGF1dGhvcnMgdG8gcmVhZGVycyBvciBtYWludGFpbmVycyBvZiB0aGUgc2NoZW1hLlwiKSxcbiAgICByZWFkT25seTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLnJlYWRPbmx5JywgXCJJbmRpY2F0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGluc3RhbmNlIGlzIG1hbmFnZWQgZXhjbHVzaXZlbHkgYnkgdGhlIG93bmluZyBhdXRob3JpdHkuXCIpLFxuICAgIGV4YW1wbGVzOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uZXhhbXBsZXMnLCBcIlNhbXBsZSBKU09OIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHNjaGVtYSwgZm9yIHRoZSBwdXJwb3NlIG9mIGlsbHVzdHJhdGluZyB1c2FnZS5cIiksXG4gICAgY29udGFpbnM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5jb250YWlucycsIFwiQW4gYXJyYXkgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCBcXFwiY29udGFpbnNcXFwiIGlmIGF0IGxlYXN0IG9uZSBvZiBpdHMgZWxlbWVudHMgaXMgdmFsaWQgYWdhaW5zdCB0aGUgZ2l2ZW4gc2NoZW1hLlwiKSxcbiAgICBwcm9wZXJ0eU5hbWVzOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ucHJvcGVydHlOYW1lcycsIFwiSWYgdGhlIGluc3RhbmNlIGlzIGFuIG9iamVjdCwgdGhpcyBrZXl3b3JkIHZhbGlkYXRlcyBpZiBldmVyeSBwcm9wZXJ0eSBuYW1lIGluIHRoZSBpbnN0YW5jZSB2YWxpZGF0ZXMgYWdhaW5zdCB0aGUgcHJvdmlkZWQgc2NoZW1hLlwiKSxcbiAgICBjb25zdDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmNvbnN0JywgXCJBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgdGhlIGtleXdvcmQuXCIpLFxuICAgIGNvbnRlbnRNZWRpYVR5cGU6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5jb250ZW50TWVkaWFUeXBlJywgXCJEZXNjcmliZXMgdGhlIG1lZGlhIHR5cGUgb2YgYSBzdHJpbmcgcHJvcGVydHkuXCIpLFxuICAgIGNvbnRlbnRFbmNvZGluZzogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmNvbnRlbnRFbmNvZGluZycsIFwiRGVzY3JpYmVzIHRoZSBjb250ZW50IGVuY29kaW5nIG9mIGEgc3RyaW5nIHByb3BlcnR5LlwiKSxcbiAgICBpZjogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmlmJywgXCJUaGUgdmFsaWRhdGlvbiBvdXRjb21lIG9mIHRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBjb250cm9scyB3aGljaCBvZiB0aGUgXFxcInRoZW5cXFwiIG9yIFxcXCJlbHNlXFxcIiBrZXl3b3JkcyBhcmUgZXZhbHVhdGVkLlwiKSxcbiAgICB0aGVuOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24udGhlbicsIFwiVGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIGlzIHVzZWQgZm9yIHZhbGlkYXRpb24gd2hlbiB0aGUgXFxcImlmXFxcIiBzdWJzY2hlbWEgc3VjY2VlZHMuXCIpLFxuICAgIGVsc2U6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5lbHNlJywgXCJUaGUgXFxcImVsc2VcXFwiIHN1YnNjaGVtYSBpcyB1c2VkIGZvciB2YWxpZGF0aW9uIHdoZW4gdGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIGZhaWxzLlwiKVxufTtcbmZvciAodmFyIHNjaGVtYU5hbWUgaW4gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzKSB7XG4gICAgdmFyIHNjaGVtYSA9IHNjaGVtYUNvbnRyaWJ1dGlvbnMuc2NoZW1hc1tzY2hlbWFOYW1lXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICB2YXIgcHJvcGVydHlPYmplY3QgPSBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlPYmplY3QgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcHJvcGVydHlPYmplY3QgPSBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbnNbcHJvcGVydHldO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHByb3BlcnR5T2JqZWN0WydkZXNjcmlwdGlvbiddID0gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwcm9wZXJ0eSArIFwiOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uXCIgKyBwcm9wZXJ0eSArIFwiJywgXFxcIlxcXCIpXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBjcmVhdGVTY2FubmVyIH0gZnJvbSAnLi8uLi8uLi9qc29uYy1wYXJzZXIvbWFpbi5qcyc7XG5pbXBvcnQgeyBGb2xkaW5nUmFuZ2VLaW5kLCBQb3NpdGlvbiB9IGZyb20gJy4uL2pzb25MYW5ndWFnZVR5cGVzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRGb2xkaW5nUmFuZ2VzKGRvY3VtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgIHZhciBuZXN0aW5nTGV2ZWxzID0gW107XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHByZXZTdGFydCA9IC0xO1xuICAgIHZhciBzY2FubmVyID0gY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIGZhbHNlKTtcbiAgICB2YXIgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIG5lc3RpbmdMZXZlbHMucHVzaChzdGFjay5sZW5ndGgpO1xuICAgIH1cbiAgICB3aGlsZSAodG9rZW4gIT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7IHN0YXJ0TGluZTogc3RhcnRMaW5lLCBlbmRMaW5lOiBzdGFydExpbmUsIGtpbmQ6IHRva2VuID09PSAxIC8qIE9wZW5CcmFjZVRva2VuICovID8gJ29iamVjdCcgOiAnYXJyYXknIH07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDIgLyogQ2xvc2VCcmFjZVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSA0IC8qIENsb3NlQnJhY2tldFRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSB0b2tlbiA9PT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8gPyAnb2JqZWN0JyA6ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ua2luZCA9PT0ga2luZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIGxpbmUgPiByYW5nZS5zdGFydExpbmUgKyAxICYmIHByZXZTdGFydCAhPT0gcmFuZ2Uuc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRMaW5lID0gbGluZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSByYW5nZS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEzIC8qIEJsb2NrQ29tbWVudFRyaXZpYSAqLzoge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kTGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuRXJyb3IoKSA9PT0gMSAvKiBVbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovICYmIHN0YXJ0TGluZSArIDEgPCBkb2N1bWVudC5saW5lQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihkb2N1bWVudC5vZmZzZXRBdChQb3NpdGlvbi5jcmVhdGUoc3RhcnRMaW5lICsgMSwgMCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydExpbmUgPCBlbmRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZSh7IHN0YXJ0TGluZTogc3RhcnRMaW5lLCBlbmRMaW5lOiBlbmRMaW5lLCBraW5kOiBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovOiB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCkuc3Vic3RyKHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSwgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRleHQubWF0Y2goL15cXC9cXC9cXHMqIyhyZWdpb25cXGIpfChlbmRyZWdpb25cXGIpLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1bMV0pIHsgLy8gc3RhcnQgcGF0dGVybiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0geyBzdGFydExpbmU6IGxpbmUsIGVuZExpbmU6IGxpbmUsIGtpbmQ6IEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgc3RhY2tbaV0ua2luZCAhPT0gRm9sZGluZ1JhbmdlS2luZC5SZWdpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA+IHJhbmdlLnN0YXJ0TGluZSAmJiBwcmV2U3RhcnQgIT09IHJhbmdlLnN0YXJ0TGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRMaW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSByYW5nZS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgfVxuICAgIHZhciByYW5nZUxpbWl0ID0gY29udGV4dCAmJiBjb250ZXh0LnJhbmdlTGltaXQ7XG4gICAgaWYgKHR5cGVvZiByYW5nZUxpbWl0ICE9PSAnbnVtYmVyJyB8fCByYW5nZXMubGVuZ3RoIDw9IHJhbmdlTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJhbmdlTGltaXRFeGNlZWRlZCkge1xuICAgICAgICBjb250ZXh0Lm9uUmFuZ2VMaW1pdEV4Y2VlZGVkKGRvY3VtZW50LnVyaSk7XG4gICAgfVxuICAgIHZhciBjb3VudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG5lc3RpbmdMZXZlbHNfMSA9IG5lc3RpbmdMZXZlbHM7IF9pIDwgbmVzdGluZ0xldmVsc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbGV2ZWwgPSBuZXN0aW5nTGV2ZWxzXzFbX2ldO1xuICAgICAgICBpZiAobGV2ZWwgPCAzMCkge1xuICAgICAgICAgICAgY291bnRzW2xldmVsXSA9IChjb3VudHNbbGV2ZWxdIHx8IDApICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZW50cmllcyA9IDA7XG4gICAgdmFyIG1heExldmVsID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGNvdW50c1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGlmIChuICsgZW50cmllcyA+IHJhbmdlTGltaXQpIHtcbiAgICAgICAgICAgICAgICBtYXhMZXZlbCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyaWVzICs9IG47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IG5lc3RpbmdMZXZlbHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCBtYXhMZXZlbCB8fCAobGV2ZWwgPT09IG1heExldmVsICYmIGVudHJpZXMrKyA8IHJhbmdlTGltaXQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBSYW5nZSwgU2VsZWN0aW9uUmFuZ2UgfSBmcm9tICcuLi9qc29uTGFuZ3VhZ2VUeXBlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTY2FubmVyIH0gZnJvbSAnLi8uLi8uLi9qc29uYy1wYXJzZXIvbWFpbi5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2VzKGRvY3VtZW50LCBwb3NpdGlvbnMsIGRvYykge1xuICAgIGZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChwb3NpdGlvbik7XG4gICAgICAgIHZhciBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gcmFuZ2Ugd2l0aG91dCBcIiwgWyBvciB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjU3RhcnQgPSBub2RlLm9mZnNldCArIDEsIGNFbmQgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNTdGFydCA8IGNFbmQgJiYgb2Zmc2V0ID49IGNTdGFydCAmJiBvZmZzZXQgPD0gY0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2UoY1N0YXJ0LCBjRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1JhbmdlKG5vZGUub2Zmc2V0LCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5JyB8fCBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyQ29tbWFPZmZzZXQgPSBnZXRPZmZzZXRBZnRlck5leHRUb2tlbihub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoLCA1IC8qIENvbW1hVG9rZW4gKi8pO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlckNvbW1hT2Zmc2V0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShub2RlLm9mZnNldCwgYWZ0ZXJDb21tYU9mZnNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSByZXN1bHQubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgY3VycmVudCA9IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShyZXN1bHRbaW5kZXhdLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoUmFuZ2UuY3JlYXRlKHBvc2l0aW9uLCBwb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXdSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChzdGFydCksIGRvY3VtZW50LnBvc2l0aW9uQXQoZW5kKSk7XG4gICAgfVxuICAgIHZhciBzY2FubmVyID0gY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xuICAgIGZ1bmN0aW9uIGdldE9mZnNldEFmdGVyTmV4dFRva2VuKG9mZnNldCwgZXhwZWN0ZWRUb2tlbikge1xuICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKG9mZnNldCk7XG4gICAgICAgIHZhciB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICBpZiAodG9rZW4gPT09IGV4cGVjdGVkVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25zLm1hcChnZXRTZWxlY3Rpb25SYW5nZSk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMaW5rcyhkb2N1bWVudCwgZG9jKSB7XG4gICAgdmFyIGxpbmtzID0gW107XG4gICAgZG9jLnZpc2l0KGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJwcm9wZXJ0eVwiICYmIG5vZGUua2V5Tm9kZS52YWx1ZSA9PT0gXCIkcmVmXCIgJiYgKChfYSA9IG5vZGUudmFsdWVOb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IG5vZGUudmFsdWVOb2RlLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBmaW5kVGFyZ2V0Tm9kZShkb2MsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UG9zID0gZG9jdW1lbnQucG9zaXRpb25BdCh0YXJnZXROb2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZG9jdW1lbnQudXJpICsgXCIjXCIgKyAodGFyZ2V0UG9zLmxpbmUgKyAxKSArIFwiLFwiICsgKHRhcmdldFBvcy5jaGFyYWN0ZXIgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGNyZWF0ZVJhbmdlKGRvY3VtZW50LCBub2RlLnZhbHVlTm9kZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxpbmtzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGRvY3VtZW50LCBub2RlKSB7XG4gICAgcmV0dXJuIFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgMSksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCAtIDEpKTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXROb2RlKGRvYywgcGF0aCkge1xuICAgIHZhciB0b2tlbnMgPSBwYXJzZUpTT05Qb2ludGVyKHBhdGgpO1xuICAgIGlmICghdG9rZW5zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmluZE5vZGUodG9rZW5zLCBkb2Mucm9vdCk7XG59XG5mdW5jdGlvbiBmaW5kTm9kZShwb2ludGVyLCBub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocG9pbnRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHZhciB0b2tlbiA9IHBvaW50ZXIuc2hpZnQoKTtcbiAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5vZGUgPSBub2RlLnByb3BlcnRpZXMuZmluZChmdW5jdGlvbiAocHJvcGVydHlOb2RlKSB7IHJldHVybiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS52YWx1ZSA9PT0gdG9rZW47IH0pO1xuICAgICAgICBpZiAoIXByb3BlcnR5Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmROb2RlKHBvaW50ZXIsIHByb3BlcnR5Tm9kZS52YWx1ZU5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAodG9rZW4ubWF0Y2goL14oMHxbMS05XVswLTldKikkLykpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE51bWJlci5wYXJzZUludCh0b2tlbik7XG4gICAgICAgICAgICB2YXIgYXJyYXlJdGVtID0gbm9kZS5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWFycmF5SXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbmROb2RlKHBvaW50ZXIsIGFycmF5SXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUpTT05Qb2ludGVyKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gXCIjXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAocGF0aFswXSAhPT0gJyMnIHx8IHBhdGhbMV0gIT09ICcvJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKDIpLnNwbGl0KC9cXC8vKS5tYXAodW5lc2NhcGUpO1xufVxuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEpTT05Db21wbGV0aW9uIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uQ29tcGxldGlvbi5qcyc7XG5pbXBvcnQgeyBKU09OSG92ZXIgfSBmcm9tICcuL3NlcnZpY2VzL2pzb25Ib3Zlci5qcyc7XG5pbXBvcnQgeyBKU09OVmFsaWRhdGlvbiB9IGZyb20gJy4vc2VydmljZXMvanNvblZhbGlkYXRpb24uanMnO1xuaW1wb3J0IHsgSlNPTkRvY3VtZW50U3ltYm9scyB9IGZyb20gJy4vc2VydmljZXMvanNvbkRvY3VtZW50U3ltYm9scy5qcyc7XG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZUpTT04sIG5ld0pTT05Eb2N1bWVudCB9IGZyb20gJy4vcGFyc2VyL2pzb25QYXJzZXIuanMnO1xuaW1wb3J0IHsgc2NoZW1hQ29udHJpYnV0aW9ucyB9IGZyb20gJy4vc2VydmljZXMvY29uZmlndXJhdGlvbi5qcyc7XG5pbXBvcnQgeyBKU09OU2NoZW1hU2VydmljZSB9IGZyb20gJy4vc2VydmljZXMvanNvblNjaGVtYVNlcnZpY2UuanMnO1xuaW1wb3J0IHsgZ2V0Rm9sZGluZ1JhbmdlcyB9IGZyb20gJy4vc2VydmljZXMvanNvbkZvbGRpbmcuanMnO1xuaW1wb3J0IHsgZ2V0U2VsZWN0aW9uUmFuZ2VzIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uU2VsZWN0aW9uUmFuZ2VzLmpzJztcbmltcG9ydCB7IGZvcm1hdCBhcyBmb3JtYXRKU09OIH0gZnJvbSAnLi8uLi9qc29uYy1wYXJzZXIvbWFpbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSwgVGV4dEVkaXQgfSBmcm9tICcuL2pzb25MYW5ndWFnZVR5cGVzLmpzJztcbmltcG9ydCB7IGZpbmRMaW5rcyB9IGZyb20gJy4vc2VydmljZXMvanNvbkxpbmtzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmd1YWdlU2VydmljZShwYXJhbXMpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHBhcmFtcy5wcm9taXNlQ29uc3RydWN0b3IgfHwgUHJvbWlzZTtcbiAgICB2YXIganNvblNjaGVtYVNlcnZpY2UgPSBuZXcgSlNPTlNjaGVtYVNlcnZpY2UocGFyYW1zLnNjaGVtYVJlcXVlc3RTZXJ2aWNlLCBwYXJhbXMud29ya3NwYWNlQ29udGV4dCwgcHJvbWlzZSk7XG4gICAganNvblNjaGVtYVNlcnZpY2Uuc2V0U2NoZW1hQ29udHJpYnV0aW9ucyhzY2hlbWFDb250cmlidXRpb25zKTtcbiAgICB2YXIganNvbkNvbXBsZXRpb24gPSBuZXcgSlNPTkNvbXBsZXRpb24oanNvblNjaGVtYVNlcnZpY2UsIHBhcmFtcy5jb250cmlidXRpb25zLCBwcm9taXNlLCBwYXJhbXMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcbiAgICB2YXIganNvbkhvdmVyID0gbmV3IEpTT05Ib3Zlcihqc29uU2NoZW1hU2VydmljZSwgcGFyYW1zLmNvbnRyaWJ1dGlvbnMsIHByb21pc2UpO1xuICAgIHZhciBqc29uRG9jdW1lbnRTeW1ib2xzID0gbmV3IEpTT05Eb2N1bWVudFN5bWJvbHMoanNvblNjaGVtYVNlcnZpY2UpO1xuICAgIHZhciBqc29uVmFsaWRhdGlvbiA9IG5ldyBKU09OVmFsaWRhdGlvbihqc29uU2NoZW1hU2VydmljZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJlOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGpzb25TY2hlbWFTZXJ2aWNlLmNsZWFyRXh0ZXJuYWxTY2hlbWFzKCk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NoZW1hcykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjaGVtYXMuZm9yRWFjaChmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAganNvblNjaGVtYVNlcnZpY2UucmVnaXN0ZXJFeHRlcm5hbFNjaGVtYShzZXR0aW5ncy51cmksIHNldHRpbmdzLmZpbGVNYXRjaCwgc2V0dGluZ3Muc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpzb25WYWxpZGF0aW9uLmNvbmZpZ3VyZShzZXR0aW5ncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0U2NoZW1hOiBmdW5jdGlvbiAodXJpKSB7IHJldHVybiBqc29uU2NoZW1hU2VydmljZS5vblJlc291cmNlQ2hhbmdlKHVyaSk7IH0sXG4gICAgICAgIGRvVmFsaWRhdGlvbjoganNvblZhbGlkYXRpb24uZG9WYWxpZGF0aW9uLmJpbmQoanNvblZhbGlkYXRpb24pLFxuICAgICAgICBwYXJzZUpTT05Eb2N1bWVudDogZnVuY3Rpb24gKGRvY3VtZW50KSB7IHJldHVybiBwYXJzZUpTT04oZG9jdW1lbnQsIHsgY29sbGVjdENvbW1lbnRzOiB0cnVlIH0pOyB9LFxuICAgICAgICBuZXdKU09ORG9jdW1lbnQ6IGZ1bmN0aW9uIChyb290LCBkaWFnbm9zdGljcykgeyByZXR1cm4gbmV3SlNPTkRvY3VtZW50KHJvb3QsIGRpYWdub3N0aWNzKTsgfSxcbiAgICAgICAgZ2V0TWF0Y2hpbmdTY2hlbWFzOiBqc29uU2NoZW1hU2VydmljZS5nZXRNYXRjaGluZ1NjaGVtYXMuYmluZChqc29uU2NoZW1hU2VydmljZSksXG4gICAgICAgIGRvUmVzb2x2ZToganNvbkNvbXBsZXRpb24uZG9SZXNvbHZlLmJpbmQoanNvbkNvbXBsZXRpb24pLFxuICAgICAgICBkb0NvbXBsZXRlOiBqc29uQ29tcGxldGlvbi5kb0NvbXBsZXRlLmJpbmQoanNvbkNvbXBsZXRpb24pLFxuICAgICAgICBmaW5kRG9jdW1lbnRTeW1ib2xzOiBqc29uRG9jdW1lbnRTeW1ib2xzLmZpbmREb2N1bWVudFN5bWJvbHMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcbiAgICAgICAgZmluZERvY3VtZW50U3ltYm9sczI6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9sczIuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcbiAgICAgICAgZmluZERvY3VtZW50Q29sb3JzOiBqc29uRG9jdW1lbnRTeW1ib2xzLmZpbmREb2N1bWVudENvbG9ycy5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBnZXRDb2xvclByZXNlbnRhdGlvbnM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZ2V0Q29sb3JQcmVzZW50YXRpb25zLmJpbmQoanNvbkRvY3VtZW50U3ltYm9scyksXG4gICAgICAgIGRvSG92ZXI6IGpzb25Ib3Zlci5kb0hvdmVyLmJpbmQoanNvbkhvdmVyKSxcbiAgICAgICAgZ2V0Rm9sZGluZ1JhbmdlczogZ2V0Rm9sZGluZ1JhbmdlcyxcbiAgICAgICAgZ2V0U2VsZWN0aW9uUmFuZ2VzOiBnZXRTZWxlY3Rpb25SYW5nZXMsXG4gICAgICAgIGZpbmREZWZpbml0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pOyB9LFxuICAgICAgICBmaW5kTGlua3M6IGZpbmRMaW5rcyxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbiAoZCwgciwgbykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZC5vZmZzZXRBdChyLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gZC5vZmZzZXRBdChyLmVuZCkgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7IG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7IHRhYlNpemU6IG8gPyBvLnRhYlNpemUgOiA0LCBpbnNlcnRTcGFjZXM6IChvID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8uaW5zZXJ0U3BhY2VzKSA9PT0gdHJ1ZSwgaW5zZXJ0RmluYWxOZXdsaW5lOiAobyA9PT0gbnVsbCB8fCBvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvLmluc2VydEZpbmFsTmV3bGluZSkgPT09IHRydWUsIGVvbDogJ1xcbicgfTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRKU09OKGQuZ2V0VGV4dCgpLCByYW5nZSwgb3B0aW9ucykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRleHRFZGl0LnJlcGxhY2UoUmFuZ2UuY3JlYXRlKGQucG9zaXRpb25BdChlLm9mZnNldCksIGQucG9zaXRpb25BdChlLm9mZnNldCArIGUubGVuZ3RoKSksIGUuY29udGVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgVXJpLCBSYW5nZSwgZWRpdG9yLCBsYW5ndWFnZXMsIE1hcmtlclNldmVyaXR5IH0gZnJvbSAnLi9maWxsZXJzL21vbmFjby1lZGl0b3ItY29yZS5qcyc7XHJcbmltcG9ydCAqIGFzIGpzb25TZXJ2aWNlIGZyb20gJy4vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2pzb25MYW5ndWFnZVNlcnZpY2UuanMnO1xyXG4vLyAtLS0gZGlhZ25vc3RpY3MgLS0tIC0tLVxyXG52YXIgRGlhZ25vc3RpY3NBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGlhZ25vc3RpY3NBZGFwdGVyKF9sYW5ndWFnZUlkLCBfd29ya2VyLCBkZWZhdWx0cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IF9sYW5ndWFnZUlkO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IF93b3JrZXI7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgdmFyIG9uTW9kZWxBZGQgPSBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgdmFyIG1vZGVJZCA9IG1vZGVsLmdldE1vZGVJZCgpO1xyXG4gICAgICAgICAgICBpZiAobW9kZUlkICE9PSBfdGhpcy5fbGFuZ3VhZ2VJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGU7XHJcbiAgICAgICAgICAgIF90aGlzLl9saXN0ZW5lclttb2RlbC51cmkudG9TdHJpbmcoKV0gPSBtb2RlbC5vbkRpZENoYW5nZUNvbnRlbnQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kb1ZhbGlkYXRlKG1vZGVsLnVyaSwgbW9kZUlkKTsgfSwgNTAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9kb1ZhbGlkYXRlKG1vZGVsLnVyaSwgbW9kZUlkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBvbk1vZGVsUmVtb3ZlZCA9IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICBlZGl0b3Iuc2V0TW9kZWxNYXJrZXJzKG1vZGVsLCBfdGhpcy5fbGFuZ3VhZ2VJZCwgW10pO1xyXG4gICAgICAgICAgICB2YXIgdXJpU3RyID0gbW9kZWwudXJpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF90aGlzLl9saXN0ZW5lclt1cmlTdHJdO1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fbGlzdGVuZXJbdXJpU3RyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChlZGl0b3Iub25EaWRDcmVhdGVNb2RlbChvbk1vZGVsQWRkKSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChlZGl0b3Iub25XaWxsRGlzcG9zZU1vZGVsKGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICBvbk1vZGVsUmVtb3ZlZChtb2RlbCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXNldFNjaGVtYShtb2RlbC51cmkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKGVkaXRvci5vbkRpZENoYW5nZU1vZGVsTGFuZ3VhZ2UoZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIG9uTW9kZWxSZW1vdmVkKGV2ZW50Lm1vZGVsKTtcclxuICAgICAgICAgICAgb25Nb2RlbEFkZChldmVudC5tb2RlbCk7XHJcbiAgICAgICAgICAgIF90aGlzLl9yZXNldFNjaGVtYShldmVudC5tb2RlbC51cmkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKGRlZmF1bHRzLm9uRGlkQ2hhbmdlKGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIGVkaXRvci5nZXRNb2RlbHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLmdldE1vZGVJZCgpID09PSBfdGhpcy5fbGFuZ3VhZ2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uTW9kZWxSZW1vdmVkKG1vZGVsKTtcclxuICAgICAgICAgICAgICAgICAgICBvbk1vZGVsQWRkKG1vZGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlZGl0b3IuZ2V0TW9kZWxzKCkuZm9yRWFjaChvbk1vZGVsUmVtb3ZlZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX3RoaXMuX2xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xpc3RlbmVyW2tleV0uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWRpdG9yLmdldE1vZGVscygpLmZvckVhY2gob25Nb2RlbEFkZCk7XHJcbiAgICB9XHJcbiAgICBEaWFnbm9zdGljc0FkYXB0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCAmJiBkLmRpc3Bvc2UoKTsgfSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBbXTtcclxuICAgIH07XHJcbiAgICBEaWFnbm9zdGljc0FkYXB0ZXIucHJvdG90eXBlLl9yZXNldFNjaGVtYSA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlcigpLnRoZW4oZnVuY3Rpb24gKHdvcmtlcikge1xyXG4gICAgICAgICAgICB3b3JrZXIucmVzZXRTY2hlbWEocmVzb3VyY2UudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGlhZ25vc3RpY3NBZGFwdGVyLnByb3RvdHlwZS5fZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgbGFuZ3VhZ2VJZCkge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlcihyZXNvdXJjZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdvcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gd29ya2VyLmRvVmFsaWRhdGlvbihyZXNvdXJjZS50b1N0cmluZygpKS50aGVuKGZ1bmN0aW9uIChkaWFnbm9zdGljcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBkaWFnbm9zdGljcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHRvRGlhZ25vc3RpY3MocmVzb3VyY2UsIGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGVkaXRvci5nZXRNb2RlbChyZXNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwgJiYgbW9kZWwuZ2V0TW9kZUlkKCkgPT09IGxhbmd1YWdlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0TW9kZWxNYXJrZXJzKG1vZGVsLCBsYW5ndWFnZUlkLCBtYXJrZXJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlhZ25vc3RpY3NBZGFwdGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEaWFnbm9zdGljc0FkYXB0ZXIgfTtcclxuZnVuY3Rpb24gdG9TZXZlcml0eShsc1NldmVyaXR5KSB7XHJcbiAgICBzd2l0Y2ggKGxzU2V2ZXJpdHkpIHtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkRpYWdub3N0aWNTZXZlcml0eS5FcnJvcjpcclxuICAgICAgICAgICAgcmV0dXJuIE1hcmtlclNldmVyaXR5LkVycm9yO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc6XHJcbiAgICAgICAgICAgIHJldHVybiBNYXJrZXJTZXZlcml0eS5XYXJuaW5nO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uOlxyXG4gICAgICAgICAgICByZXR1cm4gTWFya2VyU2V2ZXJpdHkuSW5mbztcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkRpYWdub3N0aWNTZXZlcml0eS5IaW50OlxyXG4gICAgICAgICAgICByZXR1cm4gTWFya2VyU2V2ZXJpdHkuSGludDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gTWFya2VyU2V2ZXJpdHkuSW5mbztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b0RpYWdub3N0aWNzKHJlc291cmNlLCBkaWFnKSB7XHJcbiAgICB2YXIgY29kZSA9IHR5cGVvZiBkaWFnLmNvZGUgPT09ICdudW1iZXInID8gU3RyaW5nKGRpYWcuY29kZSkgOiBkaWFnLmNvZGU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNldmVyaXR5OiB0b1NldmVyaXR5KGRpYWcuc2V2ZXJpdHkpLFxyXG4gICAgICAgIHN0YXJ0TGluZU51bWJlcjogZGlhZy5yYW5nZS5zdGFydC5saW5lICsgMSxcclxuICAgICAgICBzdGFydENvbHVtbjogZGlhZy5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgKyAxLFxyXG4gICAgICAgIGVuZExpbmVOdW1iZXI6IGRpYWcucmFuZ2UuZW5kLmxpbmUgKyAxLFxyXG4gICAgICAgIGVuZENvbHVtbjogZGlhZy5yYW5nZS5lbmQuY2hhcmFjdGVyICsgMSxcclxuICAgICAgICBtZXNzYWdlOiBkaWFnLm1lc3NhZ2UsXHJcbiAgICAgICAgY29kZTogY29kZSxcclxuICAgICAgICBzb3VyY2U6IGRpYWcuc291cmNlXHJcbiAgICB9O1xyXG59XHJcbi8vIC0tLSBjb21wbGV0aW9uIC0tLS0tLVxyXG5mdW5jdGlvbiBmcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIGlmICghcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgY2hhcmFjdGVyOiBwb3NpdGlvbi5jb2x1bW4gLSAxLCBsaW5lOiBwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21SYW5nZShyYW5nZSkge1xyXG4gICAgaWYgKCFyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0OiB7XHJcbiAgICAgICAgICAgIGxpbmU6IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDEsXHJcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmQ6IHsgbGluZTogcmFuZ2UuZW5kTGluZU51bWJlciAtIDEsIGNoYXJhY3RlcjogcmFuZ2UuZW5kQ29sdW1uIC0gMSB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRvUmFuZ2UocmFuZ2UpIHtcclxuICAgIGlmICghcmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydC5saW5lICsgMSwgcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyICsgMSwgcmFuZ2UuZW5kLmxpbmUgKyAxLCByYW5nZS5lbmQuY2hhcmFjdGVyICsgMSk7XHJcbn1cclxuZnVuY3Rpb24gaXNJbnNlcnRSZXBsYWNlRWRpdChlZGl0KSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBlZGl0Lmluc2VydCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB0eXBlb2YgZWRpdC5yZXBsYWNlICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuZnVuY3Rpb24gdG9Db21wbGV0aW9uSXRlbUtpbmQoa2luZCkge1xyXG4gICAgdmFyIG1JdGVtS2luZCA9IGxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQ7XHJcbiAgICBzd2l0Y2ggKGtpbmQpIHtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5UZXh0OlxyXG4gICAgICAgICAgICByZXR1cm4gbUl0ZW1LaW5kLlRleHQ7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kOlxyXG4gICAgICAgICAgICByZXR1cm4gbUl0ZW1LaW5kLk1ldGhvZDtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5GdW5jdGlvbjpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5GdW5jdGlvbjtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvcjpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5Db25zdHJ1Y3RvcjtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5GaWVsZDpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5GaWVsZDtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5WYXJpYWJsZTpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5WYXJpYWJsZTtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5DbGFzczpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5DbGFzcztcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2U6XHJcbiAgICAgICAgICAgIHJldHVybiBtSXRlbUtpbmQuSW50ZXJmYWNlO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZTpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5Nb2R1bGU7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk6XHJcbiAgICAgICAgICAgIHJldHVybiBtSXRlbUtpbmQuUHJvcGVydHk7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuVW5pdDpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5Vbml0O1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlOlxyXG4gICAgICAgICAgICByZXR1cm4gbUl0ZW1LaW5kLlZhbHVlO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLkVudW06XHJcbiAgICAgICAgICAgIHJldHVybiBtSXRlbUtpbmQuRW51bTtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkOlxyXG4gICAgICAgICAgICByZXR1cm4gbUl0ZW1LaW5kLktleXdvcmQ7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuU25pcHBldDpcclxuICAgICAgICAgICAgcmV0dXJuIG1JdGVtS2luZC5TbmlwcGV0O1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yOlxyXG4gICAgICAgICAgICByZXR1cm4gbUl0ZW1LaW5kLkNvbG9yO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU6XHJcbiAgICAgICAgICAgIHJldHVybiBtSXRlbUtpbmQuRmlsZTtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2U6XHJcbiAgICAgICAgICAgIHJldHVybiBtSXRlbUtpbmQuUmVmZXJlbmNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1JdGVtS2luZC5Qcm9wZXJ0eTtcclxufVxyXG5mdW5jdGlvbiBmcm9tQ29tcGxldGlvbkl0ZW1LaW5kKGtpbmQpIHtcclxuICAgIHZhciBtSXRlbUtpbmQgPSBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kO1xyXG4gICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuVGV4dDpcclxuICAgICAgICAgICAgcmV0dXJuIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5UZXh0O1xyXG4gICAgICAgIGNhc2UgbUl0ZW1LaW5kLk1ldGhvZDpcclxuICAgICAgICAgICAgcmV0dXJuIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5NZXRob2Q7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb247XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuQ29uc3RydWN0b3I6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3I7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuRmllbGQ6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuRmllbGQ7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuVmFyaWFibGU6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGU7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuQ2xhc3M6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuQ2xhc3M7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuSW50ZXJmYWNlOlxyXG4gICAgICAgICAgICByZXR1cm4ganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZTtcclxuICAgICAgICBjYXNlIG1JdGVtS2luZC5Nb2R1bGU6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlO1xyXG4gICAgICAgIGNhc2UgbUl0ZW1LaW5kLlByb3BlcnR5OlxyXG4gICAgICAgICAgICByZXR1cm4ganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5O1xyXG4gICAgICAgIGNhc2UgbUl0ZW1LaW5kLlVuaXQ6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuVW5pdDtcclxuICAgICAgICBjYXNlIG1JdGVtS2luZC5WYWx1ZTpcclxuICAgICAgICAgICAgcmV0dXJuIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcclxuICAgICAgICBjYXNlIG1JdGVtS2luZC5FbnVtOlxyXG4gICAgICAgICAgICByZXR1cm4ganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLkVudW07XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuS2V5d29yZDpcclxuICAgICAgICAgICAgcmV0dXJuIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkO1xyXG4gICAgICAgIGNhc2UgbUl0ZW1LaW5kLlNuaXBwZXQ6XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuU25pcHBldDtcclxuICAgICAgICBjYXNlIG1JdGVtS2luZC5Db2xvcjpcclxuICAgICAgICAgICAgcmV0dXJuIGpzb25TZXJ2aWNlLkNvbXBsZXRpb25JdGVtS2luZC5Db2xvcjtcclxuICAgICAgICBjYXNlIG1JdGVtS2luZC5GaWxlOlxyXG4gICAgICAgICAgICByZXR1cm4ganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU7XHJcbiAgICAgICAgY2FzZSBtSXRlbUtpbmQuUmVmZXJlbmNlOlxyXG4gICAgICAgICAgICByZXR1cm4ganNvblNlcnZpY2UuQ29tcGxldGlvbkl0ZW1LaW5kLlJlZmVyZW5jZTtcclxuICAgIH1cclxuICAgIHJldHVybiBqc29uU2VydmljZS5Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XHJcbn1cclxuZnVuY3Rpb24gdG9UZXh0RWRpdCh0ZXh0RWRpdCkge1xyXG4gICAgaWYgKCF0ZXh0RWRpdCkge1xyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJhbmdlOiB0b1JhbmdlKHRleHRFZGl0LnJhbmdlKSxcclxuICAgICAgICB0ZXh0OiB0ZXh0RWRpdC5uZXdUZXh0XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRvQ29tbWFuZChjKSB7XHJcbiAgICByZXR1cm4gYyAmJiBjLmNvbW1hbmQgPT09ICdlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0JyA/IHsgaWQ6IGMuY29tbWFuZCwgdGl0bGU6IGMudGl0bGUsIGFyZ3VtZW50czogYy5hcmd1bWVudHMgfSA6IHVuZGVmaW5lZDtcclxufVxyXG52YXIgQ29tcGxldGlvbkFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb21wbGV0aW9uQWRhcHRlcihfd29ya2VyKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gX3dvcmtlcjtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wbGV0aW9uQWRhcHRlci5wcm90b3R5cGUsIFwidHJpZ2dlckNoYXJhY3RlcnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gWycgJywgJzonLCAnXCInXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDb21wbGV0aW9uQWRhcHRlci5wcm90b3R5cGUucHJvdmlkZUNvbXBsZXRpb25JdGVtcyA9IGZ1bmN0aW9uIChtb2RlbCwgcG9zaXRpb24sIGNvbnRleHQsIHRva2VuKSB7XHJcbiAgICAgICAgdmFyIHJlc291cmNlID0gbW9kZWwudXJpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JrZXIocmVzb3VyY2UpXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3b3JrZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdvcmtlci5kb0NvbXBsZXRlKHJlc291cmNlLnRvU3RyaW5nKCksIGZyb21Qb3NpdGlvbihwb3NpdGlvbikpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5mbykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB3b3JkSW5mbyA9IG1vZGVsLmdldFdvcmRVbnRpbFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHdvcmRSYW5nZSA9IG5ldyBSYW5nZShwb3NpdGlvbi5saW5lTnVtYmVyLCB3b3JkSW5mby5zdGFydENvbHVtbiwgcG9zaXRpb24ubGluZU51bWJlciwgd29yZEluZm8uZW5kQ29sdW1uKTtcclxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gaW5mby5pdGVtcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZW50cnkubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogZW50cnkuaW5zZXJ0VGV4dCB8fCBlbnRyeS5sYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICBzb3J0VGV4dDogZW50cnkuc29ydFRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogZW50cnkuZmlsdGVyVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiBlbnRyeS5kb2N1bWVudGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogZW50cnkuZGV0YWlsLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IHRvQ29tbWFuZChlbnRyeS5jb21tYW5kKSxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogd29yZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IHRvQ29tcGxldGlvbkl0ZW1LaW5kKGVudHJ5LmtpbmQpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnRleHRFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5zZXJ0UmVwbGFjZUVkaXQoZW50cnkudGV4dEVkaXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQ6IHRvUmFuZ2UoZW50cnkudGV4dEVkaXQuaW5zZXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IHRvUmFuZ2UoZW50cnkudGV4dEVkaXQucmVwbGFjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucmFuZ2UgPSB0b1JhbmdlKGVudHJ5LnRleHRFZGl0LnJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5pbnNlcnRUZXh0ID0gZW50cnkudGV4dEVkaXQubmV3VGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5hZGRpdGlvbmFsVGV4dEVkaXRzID0gZW50cnkuYWRkaXRpb25hbFRleHRFZGl0cy5tYXAodG9UZXh0RWRpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaW5zZXJ0VGV4dEZvcm1hdCA9PT0ganNvblNlcnZpY2UuSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5pbnNlcnRUZXh0UnVsZXMgPSBsYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZS5JbnNlcnRBc1NuaXBwZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBpc0luY29tcGxldGU6IGluZm8uaXNJbmNvbXBsZXRlLFxyXG4gICAgICAgICAgICAgICAgc3VnZ2VzdGlvbnM6IGl0ZW1zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBsZXRpb25BZGFwdGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBDb21wbGV0aW9uQWRhcHRlciB9O1xyXG5mdW5jdGlvbiBpc01hcmt1cENvbnRlbnQodGhpbmcpIHtcclxuICAgIHJldHVybiAodGhpbmcgJiZcclxuICAgICAgICB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgdHlwZW9mIHRoaW5nLmtpbmQgPT09ICdzdHJpbmcnKTtcclxufVxyXG5mdW5jdGlvbiB0b01hcmtkb3duU3RyaW5nKGVudHJ5KSB7XHJcbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBlbnRyeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaXNNYXJrdXBDb250ZW50KGVudHJ5KSkge1xyXG4gICAgICAgIGlmIChlbnRyeS5raW5kID09PSAncGxhaW50ZXh0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlLnJlcGxhY2UoL1tcXFxcYCpfe31bXFxdKCkjK1xcLS4hXS9nLCAnXFxcXCQmJylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHZhbHVlOiAnYGBgJyArIGVudHJ5Lmxhbmd1YWdlICsgJ1xcbicgKyBlbnRyeS52YWx1ZSArICdcXG5gYGBcXG4nIH07XHJcbn1cclxuZnVuY3Rpb24gdG9NYXJrZWRTdHJpbmdBcnJheShjb250ZW50cykge1xyXG4gICAgaWYgKCFjb250ZW50cykge1xyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50cykpIHtcclxuICAgICAgICByZXR1cm4gY29udGVudHMubWFwKHRvTWFya2Rvd25TdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFt0b01hcmtkb3duU3RyaW5nKGNvbnRlbnRzKV07XHJcbn1cclxuLy8gLS0tIGhvdmVyIC0tLS0tLVxyXG52YXIgSG92ZXJBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSG92ZXJBZGFwdGVyKF93b3JrZXIpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xyXG4gICAgfVxyXG4gICAgSG92ZXJBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlSG92ZXIgPSBmdW5jdGlvbiAobW9kZWwsIHBvc2l0aW9uLCB0b2tlbikge1xyXG4gICAgICAgIHZhciByZXNvdXJjZSA9IG1vZGVsLnVyaTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyKHJlc291cmNlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod29ya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXIuZG9Ib3ZlcihyZXNvdXJjZS50b1N0cmluZygpLCBmcm9tUG9zaXRpb24ocG9zaXRpb24pKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICBpZiAoIWluZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRvUmFuZ2UoaW5mby5yYW5nZSksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50czogdG9NYXJrZWRTdHJpbmdBcnJheShpbmZvLmNvbnRlbnRzKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIb3ZlckFkYXB0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IEhvdmVyQWRhcHRlciB9O1xyXG4vLyAtLS0gZGVmaW5pdGlvbiAtLS0tLS1cclxuZnVuY3Rpb24gdG9Mb2NhdGlvbihsb2NhdGlvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1cmk6IFVyaS5wYXJzZShsb2NhdGlvbi51cmkpLFxyXG4gICAgICAgIHJhbmdlOiB0b1JhbmdlKGxvY2F0aW9uLnJhbmdlKVxyXG4gICAgfTtcclxufVxyXG4vLyAtLS0gZG9jdW1lbnQgc3ltYm9scyAtLS0tLS1cclxuZnVuY3Rpb24gdG9TeW1ib2xLaW5kKGtpbmQpIHtcclxuICAgIHZhciBtS2luZCA9IGxhbmd1YWdlcy5TeW1ib2xLaW5kO1xyXG4gICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLkZpbGU6XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5BcnJheTtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLlN5bWJvbEtpbmQuTW9kdWxlOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuTW9kdWxlO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuU3ltYm9sS2luZC5OYW1lc3BhY2U6XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5OYW1lc3BhY2U7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLlBhY2thZ2U6XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5QYWNrYWdlO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuU3ltYm9sS2luZC5DbGFzczpcclxuICAgICAgICAgICAgcmV0dXJuIG1LaW5kLkNsYXNzO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuU3ltYm9sS2luZC5NZXRob2Q6XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5NZXRob2Q7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLlByb3BlcnR5OlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuUHJvcGVydHk7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLkZpZWxkOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuRmllbGQ7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuQ29uc3RydWN0b3I7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLkVudW06XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5FbnVtO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuU3ltYm9sS2luZC5JbnRlcmZhY2U6XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5JbnRlcmZhY2U7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLkZ1bmN0aW9uOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuRnVuY3Rpb247XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLlZhcmlhYmxlOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuVmFyaWFibGU7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLkNvbnN0YW50OlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuQ29uc3RhbnQ7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5TeW1ib2xLaW5kLlN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIG1LaW5kLlN0cmluZztcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLlN5bWJvbEtpbmQuTnVtYmVyOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuTnVtYmVyO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuU3ltYm9sS2luZC5Cb29sZWFuOlxyXG4gICAgICAgICAgICByZXR1cm4gbUtpbmQuQm9vbGVhbjtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLlN5bWJvbEtpbmQuQXJyYXk6XHJcbiAgICAgICAgICAgIHJldHVybiBtS2luZC5BcnJheTtcclxuICAgIH1cclxuICAgIHJldHVybiBtS2luZC5GdW5jdGlvbjtcclxufVxyXG52YXIgRG9jdW1lbnRTeW1ib2xBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRTeW1ib2xBZGFwdGVyKF93b3JrZXIpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xyXG4gICAgfVxyXG4gICAgRG9jdW1lbnRTeW1ib2xBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlRG9jdW1lbnRTeW1ib2xzID0gZnVuY3Rpb24gKG1vZGVsLCB0b2tlbikge1xyXG4gICAgICAgIHZhciByZXNvdXJjZSA9IG1vZGVsLnVyaTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyKHJlc291cmNlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod29ya2VyKSB7IHJldHVybiB3b3JrZXIuZmluZERvY3VtZW50U3ltYm9scyhyZXNvdXJjZS50b1N0cmluZygpKTsgfSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmICghaXRlbXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsOiAnJyxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lck5hbWU6IGl0ZW0uY29udGFpbmVyTmFtZSxcclxuICAgICAgICAgICAgICAgIGtpbmQ6IHRvU3ltYm9sS2luZChpdGVtLmtpbmQpLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRvUmFuZ2UoaXRlbS5sb2NhdGlvbi5yYW5nZSksXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZTogdG9SYW5nZShpdGVtLmxvY2F0aW9uLnJhbmdlKSxcclxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdXHJcbiAgICAgICAgICAgIH0pOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRG9jdW1lbnRTeW1ib2xBZGFwdGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEb2N1bWVudFN5bWJvbEFkYXB0ZXIgfTtcclxuZnVuY3Rpb24gZnJvbUZvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFiU2l6ZTogb3B0aW9ucy50YWJTaXplLFxyXG4gICAgICAgIGluc2VydFNwYWNlczogb3B0aW9ucy5pbnNlcnRTcGFjZXNcclxuICAgIH07XHJcbn1cclxudmFyIERvY3VtZW50Rm9ybWF0dGluZ0VkaXRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERvY3VtZW50Rm9ybWF0dGluZ0VkaXRQcm92aWRlcihfd29ya2VyKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gX3dvcmtlcjtcclxuICAgIH1cclxuICAgIERvY3VtZW50Rm9ybWF0dGluZ0VkaXRQcm92aWRlci5wcm90b3R5cGUucHJvdmlkZURvY3VtZW50Rm9ybWF0dGluZ0VkaXRzID0gZnVuY3Rpb24gKG1vZGVsLCBvcHRpb25zLCB0b2tlbikge1xyXG4gICAgICAgIHZhciByZXNvdXJjZSA9IG1vZGVsLnVyaTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyKHJlc291cmNlKS50aGVuKGZ1bmN0aW9uICh3b3JrZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdvcmtlclxyXG4gICAgICAgICAgICAgICAgLmZvcm1hdChyZXNvdXJjZS50b1N0cmluZygpLCBudWxsLCBmcm9tRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucykpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZWRpdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZWRpdHMgfHwgZWRpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRzLm1hcCh0b1RleHRFZGl0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERvY3VtZW50Rm9ybWF0dGluZ0VkaXRQcm92aWRlcjtcclxufSgpKTtcclxuZXhwb3J0IHsgRG9jdW1lbnRGb3JtYXR0aW5nRWRpdFByb3ZpZGVyIH07XHJcbnZhciBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdFByb3ZpZGVyKF93b3JrZXIpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xyXG4gICAgfVxyXG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0UHJvdmlkZXIucHJvdG90eXBlLnByb3ZpZGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRzID0gZnVuY3Rpb24gKG1vZGVsLCByYW5nZSwgb3B0aW9ucywgdG9rZW4pIHtcclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBtb2RlbC51cmk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlcihyZXNvdXJjZSkudGhlbihmdW5jdGlvbiAod29ya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJcclxuICAgICAgICAgICAgICAgIC5mb3JtYXQocmVzb3VyY2UudG9TdHJpbmcoKSwgZnJvbVJhbmdlKHJhbmdlKSwgZnJvbUZvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGVkaXRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRzIHx8IGVkaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0cy5tYXAodG9UZXh0RWRpdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRQcm92aWRlcjtcclxufSgpKTtcclxuZXhwb3J0IHsgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0UHJvdmlkZXIgfTtcclxudmFyIERvY3VtZW50Q29sb3JBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRG9jdW1lbnRDb2xvckFkYXB0ZXIoX3dvcmtlcikge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IF93b3JrZXI7XHJcbiAgICB9XHJcbiAgICBEb2N1bWVudENvbG9yQWRhcHRlci5wcm90b3R5cGUucHJvdmlkZURvY3VtZW50Q29sb3JzID0gZnVuY3Rpb24gKG1vZGVsLCB0b2tlbikge1xyXG4gICAgICAgIHZhciByZXNvdXJjZSA9IG1vZGVsLnVyaTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyKHJlc291cmNlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod29ya2VyKSB7IHJldHVybiB3b3JrZXIuZmluZERvY3VtZW50Q29sb3JzKHJlc291cmNlLnRvU3RyaW5nKCkpOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5mb3MpIHtcclxuICAgICAgICAgICAgaWYgKCFpbmZvcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogaXRlbS5jb2xvcixcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB0b1JhbmdlKGl0ZW0ucmFuZ2UpXHJcbiAgICAgICAgICAgIH0pOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEb2N1bWVudENvbG9yQWRhcHRlci5wcm90b3R5cGUucHJvdmlkZUNvbG9yUHJlc2VudGF0aW9ucyA9IGZ1bmN0aW9uIChtb2RlbCwgaW5mbywgdG9rZW4pIHtcclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBtb2RlbC51cmk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlcihyZXNvdXJjZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdvcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gd29ya2VyLmdldENvbG9yUHJlc2VudGF0aW9ucyhyZXNvdXJjZS50b1N0cmluZygpLCBpbmZvLmNvbG9yLCBmcm9tUmFuZ2UoaW5mby5yYW5nZSkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcmVzZW50YXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghcHJlc2VudGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVzZW50YXRpb25zLm1hcChmdW5jdGlvbiAocHJlc2VudGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogcHJlc2VudGF0aW9uLmxhYmVsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlbnRhdGlvbi50ZXh0RWRpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGV4dEVkaXQgPSB0b1RleHRFZGl0KHByZXNlbnRhdGlvbi50ZXh0RWRpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJlc2VudGF0aW9uLmFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmFkZGl0aW9uYWxUZXh0RWRpdHMgPSBwcmVzZW50YXRpb24uYWRkaXRpb25hbFRleHRFZGl0cy5tYXAodG9UZXh0RWRpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERvY3VtZW50Q29sb3JBZGFwdGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBEb2N1bWVudENvbG9yQWRhcHRlciB9O1xyXG52YXIgRm9sZGluZ1JhbmdlQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvbGRpbmdSYW5nZUFkYXB0ZXIoX3dvcmtlcikge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IF93b3JrZXI7XHJcbiAgICB9XHJcbiAgICBGb2xkaW5nUmFuZ2VBZGFwdGVyLnByb3RvdHlwZS5wcm92aWRlRm9sZGluZ1JhbmdlcyA9IGZ1bmN0aW9uIChtb2RlbCwgY29udGV4dCwgdG9rZW4pIHtcclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBtb2RlbC51cmk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlcihyZXNvdXJjZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdvcmtlcikgeyByZXR1cm4gd29ya2VyLmdldEZvbGRpbmdSYW5nZXMocmVzb3VyY2UudG9TdHJpbmcoKSwgY29udGV4dCk7IH0pXHJcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyYW5nZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFyYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VzLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHJhbmdlLnN0YXJ0TGluZSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiByYW5nZS5lbmRMaW5lICsgMVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmFuZ2Uua2luZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQua2luZCA9IHRvRm9sZGluZ1JhbmdlS2luZChyYW5nZS5raW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGb2xkaW5nUmFuZ2VBZGFwdGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBGb2xkaW5nUmFuZ2VBZGFwdGVyIH07XHJcbmZ1bmN0aW9uIHRvRm9sZGluZ1JhbmdlS2luZChraW5kKSB7XHJcbiAgICBzd2l0Y2ggKGtpbmQpIHtcclxuICAgICAgICBjYXNlIGpzb25TZXJ2aWNlLkZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudDpcclxuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlcy5Gb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQ7XHJcbiAgICAgICAgY2FzZSBqc29uU2VydmljZS5Gb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHM6XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXMuRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzO1xyXG4gICAgICAgIGNhc2UganNvblNlcnZpY2UuRm9sZGluZ1JhbmdlS2luZC5SZWdpb246XHJcbiAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZXMuRm9sZGluZ1JhbmdlS2luZC5SZWdpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm9pZCAwO1xyXG59XHJcbnZhciBTZWxlY3Rpb25SYW5nZUFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25SYW5nZUFkYXB0ZXIoX3dvcmtlcikge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IF93b3JrZXI7XHJcbiAgICB9XHJcbiAgICBTZWxlY3Rpb25SYW5nZUFkYXB0ZXIucHJvdG90eXBlLnByb3ZpZGVTZWxlY3Rpb25SYW5nZXMgPSBmdW5jdGlvbiAobW9kZWwsIHBvc2l0aW9ucywgdG9rZW4pIHtcclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBtb2RlbC51cmk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlcihyZXNvdXJjZSlcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdvcmtlcikgeyByZXR1cm4gd29ya2VyLmdldFNlbGVjdGlvblJhbmdlcyhyZXNvdXJjZS50b1N0cmluZygpLCBwb3NpdGlvbnMubWFwKGZyb21Qb3NpdGlvbikpOyB9KVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VsZWN0aW9uUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblJhbmdlcy5tYXAoZnVuY3Rpb24gKHNlbGVjdGlvblJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VsZWN0aW9uUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHJhbmdlOiB0b1JhbmdlKHNlbGVjdGlvblJhbmdlLnJhbmdlKSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvblJhbmdlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZUFkYXB0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IFNlbGVjdGlvblJhbmdlQWRhcHRlciB9O1xyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL19kZXBzL2pzb25jLXBhcnNlci9tYWluLmpzJztcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRva2VuaXphdGlvblN1cHBvcnQoc3VwcG9ydENvbW1lbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEpTT05TdGF0ZShudWxsLCBudWxsLCBmYWxzZSwgbnVsbCk7IH0sXHJcbiAgICAgICAgdG9rZW5pemU6IGZ1bmN0aW9uIChsaW5lLCBzdGF0ZSwgb2Zmc2V0RGVsdGEsIHN0b3BBdE9mZnNldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5pemUoc3VwcG9ydENvbW1lbnRzLCBsaW5lLCBzdGF0ZSwgb2Zmc2V0RGVsdGEsIHN0b3BBdE9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnQgdmFyIFRPS0VOX0RFTElNX09CSkVDVCA9ICdkZWxpbWl0ZXIuYnJhY2tldC5qc29uJztcclxuZXhwb3J0IHZhciBUT0tFTl9ERUxJTV9BUlJBWSA9ICdkZWxpbWl0ZXIuYXJyYXkuanNvbic7XHJcbmV4cG9ydCB2YXIgVE9LRU5fREVMSU1fQ09MT04gPSAnZGVsaW1pdGVyLmNvbG9uLmpzb24nO1xyXG5leHBvcnQgdmFyIFRPS0VOX0RFTElNX0NPTU1BID0gJ2RlbGltaXRlci5jb21tYS5qc29uJztcclxuZXhwb3J0IHZhciBUT0tFTl9WQUxVRV9CT09MRUFOID0gJ2tleXdvcmQuanNvbic7XHJcbmV4cG9ydCB2YXIgVE9LRU5fVkFMVUVfTlVMTCA9ICdrZXl3b3JkLmpzb24nO1xyXG5leHBvcnQgdmFyIFRPS0VOX1ZBTFVFX1NUUklORyA9ICdzdHJpbmcudmFsdWUuanNvbic7XHJcbmV4cG9ydCB2YXIgVE9LRU5fVkFMVUVfTlVNQkVSID0gJ251bWJlci5qc29uJztcclxuZXhwb3J0IHZhciBUT0tFTl9QUk9QRVJUWV9OQU1FID0gJ3N0cmluZy5rZXkuanNvbic7XHJcbmV4cG9ydCB2YXIgVE9LRU5fQ09NTUVOVF9CTE9DSyA9ICdjb21tZW50LmJsb2NrLmpzb24nO1xyXG5leHBvcnQgdmFyIFRPS0VOX0NPTU1FTlRfTElORSA9ICdjb21tZW50LmxpbmUuanNvbic7XHJcbnZhciBQYXJlbnRzU3RhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXJlbnRzU3RhY2socGFyZW50LCB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIH1cclxuICAgIFBhcmVudHNTdGFjay5wb3AgPSBmdW5jdGlvbiAocGFyZW50cykge1xyXG4gICAgICAgIGlmIChwYXJlbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRzLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgUGFyZW50c1N0YWNrLnB1c2ggPSBmdW5jdGlvbiAocGFyZW50cywgdHlwZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyZW50c1N0YWNrKHBhcmVudHMsIHR5cGUpO1xyXG4gICAgfTtcclxuICAgIFBhcmVudHNTdGFjay5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhIHx8ICFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGEgJiYgYikge1xyXG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYSA9IGEucGFyZW50O1xyXG4gICAgICAgICAgICBiID0gYi5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYXJlbnRzU3RhY2s7XHJcbn0oKSk7XHJcbnZhciBKU09OU3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKU09OU3RhdGUoc3RhdGUsIHNjYW5FcnJvciwgbGFzdFdhc0NvbG9uLCBwYXJlbnRzKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLnNjYW5FcnJvciA9IHNjYW5FcnJvcjtcclxuICAgICAgICB0aGlzLmxhc3RXYXNDb2xvbiA9IGxhc3RXYXNDb2xvbjtcclxuICAgICAgICB0aGlzLnBhcmVudHMgPSBwYXJlbnRzO1xyXG4gICAgfVxyXG4gICAgSlNPTlN0YXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpTT05TdGF0ZSh0aGlzLl9zdGF0ZSwgdGhpcy5zY2FuRXJyb3IsIHRoaXMubGFzdFdhc0NvbG9uLCB0aGlzLnBhcmVudHMpO1xyXG4gICAgfTtcclxuICAgIEpTT05TdGF0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW90aGVyIHx8ICEob3RoZXIgaW5zdGFuY2VvZiBKU09OU3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjYW5FcnJvciA9PT0gb3RoZXIuc2NhbkVycm9yICYmXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFdhc0NvbG9uID09PSBvdGhlci5sYXN0V2FzQ29sb24gJiZcclxuICAgICAgICAgICAgUGFyZW50c1N0YWNrLmVxdWFscyh0aGlzLnBhcmVudHMsIG90aGVyLnBhcmVudHMpKTtcclxuICAgIH07XHJcbiAgICBKU09OU3RhdGUucHJvdG90eXBlLmdldFN0YXRlRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgICB9O1xyXG4gICAgSlNPTlN0YXRlLnByb3RvdHlwZS5zZXRTdGF0ZURhdGEgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBKU09OU3RhdGU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIHRva2VuaXplKGNvbW1lbnRzLCBsaW5lLCBzdGF0ZSwgb2Zmc2V0RGVsdGEsIHN0b3BBdE9mZnNldCkge1xyXG4gICAgaWYgKG9mZnNldERlbHRhID09PSB2b2lkIDApIHsgb2Zmc2V0RGVsdGEgPSAwOyB9XHJcbiAgICAvLyBoYW5kbGUgbXVsdGlsaW5lIHN0cmluZ3MgYW5kIGJsb2NrIGNvbW1lbnRzXHJcbiAgICB2YXIgbnVtYmVyT2ZJbnNlcnRlZENoYXJhY3RlcnMgPSAwO1xyXG4gICAgdmFyIGFkanVzdE9mZnNldCA9IGZhbHNlO1xyXG4gICAgc3dpdGNoIChzdGF0ZS5zY2FuRXJyb3IpIHtcclxuICAgICAgICBjYXNlIDIgLyogVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxyXG4gICAgICAgICAgICBsaW5lID0gJ1wiJyArIGxpbmU7XHJcbiAgICAgICAgICAgIG51bWJlck9mSW5zZXJ0ZWRDaGFyYWN0ZXJzID0gMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxIC8qIFVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi86XHJcbiAgICAgICAgICAgIGxpbmUgPSAnLyonICsgbGluZTtcclxuICAgICAgICAgICAgbnVtYmVyT2ZJbnNlcnRlZENoYXJhY3RlcnMgPSAyO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHZhciBzY2FubmVyID0ganNvbi5jcmVhdGVTY2FubmVyKGxpbmUpO1xyXG4gICAgdmFyIGxhc3RXYXNDb2xvbiA9IHN0YXRlLmxhc3RXYXNDb2xvbjtcclxuICAgIHZhciBwYXJlbnRzID0gc3RhdGUucGFyZW50cztcclxuICAgIHZhciByZXQgPSB7XHJcbiAgICAgICAgdG9rZW5zOiBbXSxcclxuICAgICAgICBlbmRTdGF0ZTogc3RhdGUuY2xvbmUoKVxyXG4gICAgfTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldERlbHRhICsgc2Nhbm5lci5nZXRQb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciB0eXBlID0gJyc7XHJcbiAgICAgICAgdmFyIGtpbmQgPSBzY2FubmVyLnNjYW4oKTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gMTcgLyogRU9GICovKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzY2FubmVyIGhhcyBhZHZhbmNlZFxyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IG9mZnNldERlbHRhICsgc2Nhbm5lci5nZXRQb3NpdGlvbigpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2Nhbm5lciBkaWQgbm90IGFkdmFuY2UsIG5leHQgMyBjaGFyYWN0ZXJzIGFyZTogJyArIGxpbmUuc3Vic3RyKHNjYW5uZXIuZ2V0UG9zaXRpb24oKSwgMykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbiBjYXNlIHdlIGluc2VydGVkIC8qIG9yIFwiIGNoYXJhY3Rlciwgd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vIGFkanVzdCB0aGUgb2Zmc2V0IG9mIGFsbCB0b2tlbnMgKGV4Y2VwdCB0aGUgZmlyc3QpXHJcbiAgICAgICAgaWYgKGFkanVzdE9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgLT0gbnVtYmVyT2ZJbnNlcnRlZENoYXJhY3RlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFkanVzdE9mZnNldCA9IG51bWJlck9mSW5zZXJ0ZWRDaGFyYWN0ZXJzID4gMDtcclxuICAgICAgICAvLyBicmFja2V0cyBhbmQgdHlwZVxyXG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogT3BlbkJyYWNlVG9rZW4gKi86XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRzID0gUGFyZW50c1N0YWNrLnB1c2gocGFyZW50cywgMCAvKiBPYmplY3QgKi8pO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0RFTElNX09CSkVDVDtcclxuICAgICAgICAgICAgICAgIGxhc3RXYXNDb2xvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi86XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRzID0gUGFyZW50c1N0YWNrLnBvcChwYXJlbnRzKTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9ERUxJTV9PQkpFQ1Q7XHJcbiAgICAgICAgICAgICAgICBsYXN0V2FzQ29sb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLzpcclxuICAgICAgICAgICAgICAgIHBhcmVudHMgPSBQYXJlbnRzU3RhY2sucHVzaChwYXJlbnRzLCAxIC8qIEFycmF5ICovKTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9ERUxJTV9BUlJBWTtcclxuICAgICAgICAgICAgICAgIGxhc3RXYXNDb2xvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLzpcclxuICAgICAgICAgICAgICAgIHBhcmVudHMgPSBQYXJlbnRzU3RhY2sucG9wKHBhcmVudHMpO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0RFTElNX0FSUkFZO1xyXG4gICAgICAgICAgICAgICAgbGFzdFdhc0NvbG9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2IC8qIENvbG9uVG9rZW4gKi86XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gVE9LRU5fREVMSU1fQ09MT047XHJcbiAgICAgICAgICAgICAgICBsYXN0V2FzQ29sb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNSAvKiBDb21tYVRva2VuICovOlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0RFTElNX0NPTU1BO1xyXG4gICAgICAgICAgICAgICAgbGFzdFdhc0NvbG9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA4IC8qIFRydWVLZXl3b3JkICovOlxyXG4gICAgICAgICAgICBjYXNlIDkgLyogRmFsc2VLZXl3b3JkICovOlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1ZBTFVFX0JPT0xFQU47XHJcbiAgICAgICAgICAgICAgICBsYXN0V2FzQ29sb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDcgLyogTnVsbEtleXdvcmQgKi86XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gVE9LRU5fVkFMVUVfTlVMTDtcclxuICAgICAgICAgICAgICAgIGxhc3RXYXNDb2xvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTAgLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50cyA/IHBhcmVudHMudHlwZSA6IDAgLyogT2JqZWN0ICovO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluQXJyYXkgPSBjdXJyZW50UGFyZW50ID09PSAxIC8qIEFycmF5ICovO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdFdhc0NvbG9uIHx8IGluQXJyYXkgPyBUT0tFTl9WQUxVRV9TVFJJTkcgOiBUT0tFTl9QUk9QRVJUWV9OQU1FO1xyXG4gICAgICAgICAgICAgICAgbGFzdFdhc0NvbG9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMSAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9WQUxVRV9OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICBsYXN0V2FzQ29sb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21tZW50cywgaWZmIGVuYWJsZWRcclxuICAgICAgICBpZiAoY29tbWVudHMpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovOlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9DT01NRU5UX0xJTkU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIEJsb2NrQ29tbWVudFRyaXZpYSAqLzpcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gVE9LRU5fQ09NTUVOVF9CTE9DSztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXQuZW5kU3RhdGUgPSBuZXcgSlNPTlN0YXRlKHN0YXRlLmdldFN0YXRlRGF0YSgpLCBzY2FubmVyLmdldFRva2VuRXJyb3IoKSwgbGFzdFdhc0NvbG9uLCBwYXJlbnRzKTtcclxuICAgICAgICByZXQudG9rZW5zLnB1c2goe1xyXG4gICAgICAgICAgICBzdGFydEluZGV4OiBvZmZzZXQsXHJcbiAgICAgICAgICAgIHNjb3BlczogdHlwZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgV29ya2VyTWFuYWdlciB9IGZyb20gJy4vd29ya2VyTWFuYWdlci5qcyc7XHJcbmltcG9ydCAqIGFzIGxhbmd1YWdlRmVhdHVyZXMgZnJvbSAnLi9sYW5ndWFnZUZlYXR1cmVzLmpzJztcclxuaW1wb3J0IHsgY3JlYXRlVG9rZW5pemF0aW9uU3VwcG9ydCB9IGZyb20gJy4vdG9rZW5pemF0aW9uLmpzJztcclxuaW1wb3J0IHsgbGFuZ3VhZ2VzIH0gZnJvbSAnLi9maWxsZXJzL21vbmFjby1lZGl0b3ItY29yZS5qcyc7XHJcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cE1vZGUoZGVmYXVsdHMpIHtcclxuICAgIHZhciBkaXNwb3NhYmxlcyA9IFtdO1xyXG4gICAgdmFyIHByb3ZpZGVycyA9IFtdO1xyXG4gICAgdmFyIGNsaWVudCA9IG5ldyBXb3JrZXJNYW5hZ2VyKGRlZmF1bHRzKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2goY2xpZW50KTtcclxuICAgIHZhciB3b3JrZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVyaXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB1cmlzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGllbnQuZ2V0TGFuZ3VhZ2VTZXJ2aWNlV29ya2VyLmFwcGx5KGNsaWVudCwgdXJpcyk7XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgdmFyIGxhbmd1YWdlSWQgPSBkZWZhdWx0cy5sYW5ndWFnZUlkLCBtb2RlQ29uZmlndXJhdGlvbiA9IGRlZmF1bHRzLm1vZGVDb25maWd1cmF0aW9uO1xyXG4gICAgICAgIGRpc3Bvc2VBbGwocHJvdmlkZXJzKTtcclxuICAgICAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24uZG9jdW1lbnRGb3JtYXR0aW5nRWRpdHMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRGb3JtYXR0aW5nRWRpdFByb3ZpZGVyKGxhbmd1YWdlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLkRvY3VtZW50Rm9ybWF0dGluZ0VkaXRQcm92aWRlcih3b3JrZXIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKGxhbmd1YWdlcy5yZWdpc3RlckRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdFByb3ZpZGVyKGxhbmd1YWdlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdFByb3ZpZGVyKHdvcmtlcikpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLmNvbXBsZXRpb25JdGVtcykge1xyXG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChsYW5ndWFnZXMucmVnaXN0ZXJDb21wbGV0aW9uSXRlbVByb3ZpZGVyKGxhbmd1YWdlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLkNvbXBsZXRpb25BZGFwdGVyKHdvcmtlcikpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLmhvdmVycykge1xyXG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChsYW5ndWFnZXMucmVnaXN0ZXJIb3ZlclByb3ZpZGVyKGxhbmd1YWdlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLkhvdmVyQWRhcHRlcih3b3JrZXIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5kb2N1bWVudFN5bWJvbHMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRTeW1ib2xQcm92aWRlcihsYW5ndWFnZUlkLCBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5Eb2N1bWVudFN5bWJvbEFkYXB0ZXIod29ya2VyKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24udG9rZW5zKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKGxhbmd1YWdlcy5zZXRUb2tlbnNQcm92aWRlcihsYW5ndWFnZUlkLCBjcmVhdGVUb2tlbml6YXRpb25TdXBwb3J0KHRydWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5jb2xvcnMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobGFuZ3VhZ2VzLnJlZ2lzdGVyQ29sb3JQcm92aWRlcihsYW5ndWFnZUlkLCBuZXcgbGFuZ3VhZ2VGZWF0dXJlcy5Eb2N1bWVudENvbG9yQWRhcHRlcih3b3JrZXIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5mb2xkaW5nUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKGxhbmd1YWdlcy5yZWdpc3RlckZvbGRpbmdSYW5nZVByb3ZpZGVyKGxhbmd1YWdlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLkZvbGRpbmdSYW5nZUFkYXB0ZXIod29ya2VyKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24uZGlhZ25vc3RpY3MpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IGxhbmd1YWdlRmVhdHVyZXMuRGlhZ25vc3RpY3NBZGFwdGVyKGxhbmd1YWdlSWQsIHdvcmtlciwgZGVmYXVsdHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLnNlbGVjdGlvblJhbmdlcykge1xyXG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChsYW5ndWFnZXMucmVnaXN0ZXJTZWxlY3Rpb25SYW5nZVByb3ZpZGVyKGxhbmd1YWdlSWQsIG5ldyBsYW5ndWFnZUZlYXR1cmVzLlNlbGVjdGlvblJhbmdlQWRhcHRlcih3b3JrZXIpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJQcm92aWRlcnMoKTtcclxuICAgIGRpc3Bvc2FibGVzLnB1c2gobGFuZ3VhZ2VzLnNldExhbmd1YWdlQ29uZmlndXJhdGlvbihkZWZhdWx0cy5sYW5ndWFnZUlkLCByaWNoRWRpdENvbmZpZ3VyYXRpb24pKTtcclxuICAgIHZhciBtb2RlQ29uZmlndXJhdGlvbiA9IGRlZmF1bHRzLm1vZGVDb25maWd1cmF0aW9uO1xyXG4gICAgZGVmYXVsdHMub25EaWRDaGFuZ2UoZnVuY3Rpb24gKG5ld0RlZmF1bHRzKSB7XHJcbiAgICAgICAgaWYgKG5ld0RlZmF1bHRzLm1vZGVDb25maWd1cmF0aW9uICE9PSBtb2RlQ29uZmlndXJhdGlvbikge1xyXG4gICAgICAgICAgICBtb2RlQ29uZmlndXJhdGlvbiA9IG5ld0RlZmF1bHRzLm1vZGVDb25maWd1cmF0aW9uO1xyXG4gICAgICAgICAgICByZWdpc3RlclByb3ZpZGVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZGlzcG9zYWJsZXMucHVzaChhc0Rpc3Bvc2FibGUocHJvdmlkZXJzKSk7XHJcbiAgICByZXR1cm4gYXNEaXNwb3NhYmxlKGRpc3Bvc2FibGVzKTtcclxufVxyXG5mdW5jdGlvbiBhc0Rpc3Bvc2FibGUoZGlzcG9zYWJsZXMpIHtcclxuICAgIHJldHVybiB7IGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3Bvc2VBbGwoZGlzcG9zYWJsZXMpOyB9IH07XHJcbn1cclxuZnVuY3Rpb24gZGlzcG9zZUFsbChkaXNwb3NhYmxlcykge1xyXG4gICAgd2hpbGUgKGRpc3Bvc2FibGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGRpc3Bvc2FibGVzLnBvcCgpLmRpc3Bvc2UoKTtcclxuICAgIH1cclxufVxyXG52YXIgcmljaEVkaXRDb25maWd1cmF0aW9uID0ge1xyXG4gICAgd29yZFBhdHRlcm46IC8oLT9cXGQqXFwuXFxkXFx3Kil8KFteXFxbXFx7XFxdXFx9XFw6XFxcIlxcLFxcc10rKS9nLFxyXG4gICAgY29tbWVudHM6IHtcclxuICAgICAgICBsaW5lQ29tbWVudDogJy8vJyxcclxuICAgICAgICBibG9ja0NvbW1lbnQ6IFsnLyonLCAnKi8nXVxyXG4gICAgfSxcclxuICAgIGJyYWNrZXRzOiBbXHJcbiAgICAgICAgWyd7JywgJ30nXSxcclxuICAgICAgICBbJ1snLCAnXSddXHJcbiAgICBdLFxyXG4gICAgYXV0b0Nsb3NpbmdQYWlyczogW1xyXG4gICAgICAgIHsgb3BlbjogJ3snLCBjbG9zZTogJ30nLCBub3RJbjogWydzdHJpbmcnXSB9LFxyXG4gICAgICAgIHsgb3BlbjogJ1snLCBjbG9zZTogJ10nLCBub3RJbjogWydzdHJpbmcnXSB9LFxyXG4gICAgICAgIHsgb3BlbjogJ1wiJywgY2xvc2U6ICdcIicsIG5vdEluOiBbJ3N0cmluZyddIH1cclxuICAgIF1cclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51099\n")}}]);