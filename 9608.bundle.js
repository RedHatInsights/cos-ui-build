(self.webpackChunk_cos_ui_apps_cos_ui=self.webpackChunk_cos_ui_apps_cos_ui||[]).push([[9608,1126],{91126:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "asEffect": () => (/* reexport */ asEffect),\n  "asLayoutEffect": () => (/* reexport */ asLayoutEffect),\n  "useActor": () => (/* reexport */ useActor),\n  "useInterpret": () => (/* reexport */ useInterpret),\n  "useMachine": () => (/* reexport */ useMachine),\n  "useSelector": () => (/* reexport */ useSelector),\n  "useService": () => (/* reexport */ useService)\n});\n\n// EXTERNAL MODULE: consume shared module (default) react@^16.13.1 (singleton) (fallback: ../../node_modules/react/index.js) (eager)\nvar index_js_eager_ = __webpack_require__(28596);\n// EXTERNAL MODULE: consume shared module (default) xstate@^4.19.1 (strict) (fallback: ../../node_modules/xstate/es/index.js)\nvar index_js_ = __webpack_require__(77616);\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/types.js\nvar ReactEffectType;\n(function (ReactEffectType) {\n    ReactEffectType[ReactEffectType["Effect"] = 1] = "Effect";\n    ReactEffectType[ReactEffectType["LayoutEffect"] = 2] = "LayoutEffect";\n})(ReactEffectType || (ReactEffectType = {}));\n\n;// CONCATENATED MODULE: ../../node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js\n\n\nvar index =  index_js_eager_.useLayoutEffect ;\n\n/* harmony default export */ const use_isomorphic_layout_effect_browser_esm = (index);\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useConstant.js\n\nfunction useConstant(fn) {\n    var ref = index_js_eager_.useRef();\n    if (!ref.current) {\n        ref.current = { v: fn() };\n    }\n    return ref.current.v;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/utils.js\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === "number") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n};\nfunction partition(items, predicate) {\n    var e_1, _a;\n    var _b = __read([[], []], 2), truthy = _b[0], falsy = _b[1];\n    try {\n        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n            var item = items_1_1.value;\n            if (predicate(item)) {\n                truthy.push(item);\n            }\n            else {\n                falsy.push(item);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return [truthy, falsy];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useReactEffectActions.js\nvar useReactEffectActions_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (undefined && undefined.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(useReactEffectActions_read(arguments[i]));\n    return ar;\n};\n\n\n\n\nfunction executeEffect(action, state) {\n    var exec = action.exec;\n    var originalExec = exec(state.context, state._event.data, {\n        action: action,\n        state: state,\n        _event: state._event\n    });\n    originalExec();\n}\nfunction useReactEffectActions(service) {\n    var effectActionsRef = (0,index_js_eager_.useRef)([]);\n    var layoutEffectActionsRef = (0,index_js_eager_.useRef)([]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        var sub = service.subscribe(function (currentState) {\n            var _a, _b;\n            if (currentState.actions.length) {\n                var reactEffectActions = currentState.actions.filter(function (action) {\n                    return (typeof action.exec === \'function\' &&\n                        \'__effect\' in action.exec);\n                });\n                var _c = useReactEffectActions_read(partition(reactEffectActions, function (action) {\n                    return action.exec.__effect === ReactEffectType.Effect;\n                }), 2), effectActions = _c[0], layoutEffectActions = _c[1];\n                (_a = effectActionsRef.current).push.apply(_a, __spread(effectActions.map(function (effectAction) { return [effectAction, currentState]; })));\n                (_b = layoutEffectActionsRef.current).push.apply(_b, __spread(layoutEffectActions.map(function (layoutEffectAction) { return [layoutEffectAction, currentState]; })));\n            }\n        });\n        return function () {\n            sub.unsubscribe();\n        };\n    }, []);\n    // this is somewhat weird - this should always be flushed within useLayoutEffect\n    // but we don\'t want to receive warnings about useLayoutEffect being used on the server\n    // so we have to use `useIsomorphicLayoutEffect` to silence those warnings\n    use_isomorphic_layout_effect_browser_esm(function () {\n        while (layoutEffectActionsRef.current.length) {\n            var _a = useReactEffectActions_read(layoutEffectActionsRef.current.shift(), 2), layoutEffectAction = _a[0], effectState = _a[1];\n            executeEffect(layoutEffectAction, effectState);\n        }\n    }); // https://github.com/davidkpiano/xstate/pull/1202#discussion_r429677773\n    (0,index_js_eager_.useEffect)(function () {\n        while (effectActionsRef.current.length) {\n            var _a = useReactEffectActions_read(effectActionsRef.current.shift(), 2), effectAction = _a[0], effectState = _a[1];\n            executeEffect(effectAction, effectState);\n        }\n    });\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useInterpret.js\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar useInterpret_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\n\n\n// copied from core/src/utils.ts\n// it avoids a breaking change between this package and XState which is its peer dep\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    if (typeof nextHandler === \'object\') {\n        return nextHandler;\n    }\n    var noop = function () { return void 0; };\n    return {\n        next: nextHandler,\n        error: errorHandler || noop,\n        complete: completionHandler || noop\n    };\n}\nfunction useInterpret(getMachine, options, observerOrListener) {\n    if (options === void 0) { options = {}; }\n    var machine = useConstant(function () {\n        return typeof getMachine === \'function\' ? getMachine() : getMachine;\n    });\n    if (false) { var _a, initialMachine; }\n    var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);\n    var service = useConstant(function () {\n        var machineConfig = {\n            context: context,\n            guards: guards,\n            actions: actions,\n            activities: activities,\n            services: services,\n            delays: delays\n        };\n        var machineWithConfig = machine.withConfig(machineConfig, __assign(__assign({}, machine.context), context));\n        return (0,index_js_.interpret)(machineWithConfig, __assign({ deferEvents: true }, interpreterOptions));\n    });\n    use_isomorphic_layout_effect_browser_esm(function () {\n        var sub;\n        if (observerOrListener) {\n            sub = service.subscribe(toObserver(observerOrListener));\n        }\n        return function () {\n            sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n        };\n    }, [observerOrListener]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        service.start(rehydratedState ? index_js_.State.create(rehydratedState) : undefined);\n        return function () {\n            service.stop();\n        };\n    }, []);\n    // Make sure actions and services are kept updated when they change.\n    // This mutation assignment is safe because the service instance is only used\n    // in one place -- this hook\'s caller.\n    use_isomorphic_layout_effect_browser_esm(function () {\n        Object.assign(service.machine.options.actions, actions);\n    }, [actions]);\n    use_isomorphic_layout_effect_browser_esm(function () {\n        Object.assign(service.machine.options.services, services);\n    }, [services]);\n    useReactEffectActions(service);\n    return service;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useMachine.js\nvar useMachine_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar useMachine_spread = (undefined && undefined.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(useMachine_read(arguments[i]));\n    return ar;\n};\n\n\n\n\nfunction createReactActionFunction(exec, tag) {\n    var effectExec = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // don\'t execute; just return\n        return function () {\n            return exec.apply(void 0, useMachine_spread(args));\n        };\n    };\n    Object.defineProperties(effectExec, {\n        name: { value: "effect:" + exec.name },\n        __effect: { value: tag }\n    });\n    return effectExec;\n}\nfunction asEffect(exec) {\n    return createReactActionFunction(exec, ReactEffectType.Effect);\n}\nfunction asLayoutEffect(exec) {\n    return createReactActionFunction(exec, ReactEffectType.LayoutEffect);\n}\nfunction useMachine(getMachine, options) {\n    if (options === void 0) { options = {}; }\n    var listener = (0,index_js_eager_.useCallback)(function (nextState) {\n        // Only change the current state if:\n        // - the incoming state is the "live" initial state (since it might have new actors)\n        // - OR the incoming state actually changed.\n        //\n        // The "live" initial state will have .changed === undefined.\n        var initialStateChanged = nextState.changed === undefined &&\n            Object.keys(nextState.children).length;\n        if (nextState.changed || initialStateChanged) {\n            setState(nextState);\n        }\n    }, []);\n    var service = useInterpret(getMachine, options, listener);\n    var _a = useMachine_read((0,index_js_eager_.useState)(function () {\n        var initialState = service.machine.initialState;\n        return (options.state\n            ? index_js_.State.create(options.state)\n            : initialState);\n    }), 2), state = _a[0], setState = _a[1];\n    return [state, service.send, service];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useActor.js\nvar useActor_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction isActorWithState(actorRef) {\n    return \'state\' in actorRef;\n}\nfunction isDeferredActor(actorRef) {\n    return \'deferred\' in actorRef;\n}\nvar noop = function () {\n    /* ... */\n};\nfunction useActor(actorRef, getSnapshot) {\n    if (getSnapshot === void 0) { getSnapshot = function (a) {\n        return isActorWithState(a) ? a.state : undefined;\n    }; }\n    var actorRefRef = (0,index_js_eager_.useRef)(actorRef);\n    var deferredEventsRef = (0,index_js_eager_.useRef)([]);\n    var _a = useActor_read((0,index_js_eager_.useState)(function () { return getSnapshot(actorRef); }), 2), current = _a[0], setCurrent = _a[1];\n    var send = useConstant(function () { return function (event) {\n        var currentActorRef = actorRefRef.current;\n        // If the previous actor is a deferred actor,\n        // queue the events so that they can be replayed\n        // on the non-deferred actor.\n        if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {\n            deferredEventsRef.current.push(event);\n        }\n        else {\n            currentActorRef.send(event);\n        }\n    }; });\n    use_isomorphic_layout_effect_browser_esm(function () {\n        actorRefRef.current = actorRef;\n        setCurrent(getSnapshot(actorRef));\n        var subscription = actorRef.subscribe({\n            next: function (emitted) { return setCurrent(emitted); },\n            error: noop,\n            complete: noop\n        });\n        // Dequeue deferred events from the previous deferred actorRef\n        while (deferredEventsRef.current.length > 0) {\n            var deferredEvent = deferredEventsRef.current.shift();\n            actorRef.send(deferredEvent);\n        }\n        return function () {\n            subscription.unsubscribe();\n        };\n    }, [actorRef]);\n    return [current, send];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useService.js\nvar useService_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\nfunction getServiceSnapshot(service) {\n    // TODO: remove compat lines in a new major, replace literal number with InterpreterStatus then as well\n    return (\'status\' in service ? service.status : service._status) !== 0\n        ? service.state\n        : service.machine.initialState;\n}\nfunction useService(service) {\n    if (false) {}\n    var _a = useService_read(useActor(service, getServiceSnapshot), 1), state = _a[0];\n    return [state, service.send];\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/useSelector.js\nvar useSelector_read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\nfunction isService(actor) {\n    return \'state\' in actor && \'machine\' in actor;\n}\nvar defaultCompare = function (a, b) { return a === b; };\nvar defaultGetSnapshot = function (a) {\n    return isService(a)\n        ? getServiceSnapshot(a)\n        : isActorWithState(a)\n            ? a.state\n            : undefined;\n};\nfunction useSelector(actor, selector, compare, getSnapshot) {\n    if (compare === void 0) { compare = defaultCompare; }\n    if (getSnapshot === void 0) { getSnapshot = defaultGetSnapshot; }\n    var _a = useSelector_read((0,index_js_eager_.useState)(function () { return selector(getSnapshot(actor)); }), 2), selected = _a[0], setSelected = _a[1];\n    var selectedRef = (0,index_js_eager_.useRef)(selected);\n    (0,index_js_eager_.useEffect)(function () {\n        var updateSelectedIfChanged = function (nextSelected) {\n            if (!compare(selectedRef.current, nextSelected)) {\n                setSelected(nextSelected);\n                selectedRef.current = nextSelected;\n            }\n        };\n        var initialSelected = selector(getSnapshot(actor));\n        updateSelectedIfChanged(initialSelected);\n        var sub = actor.subscribe(function (emitted) {\n            var nextSelected = selector(emitted);\n            updateSelectedIfChanged(nextSelected);\n        });\n        return function () { return sub.unsubscribe(); };\n    }, [selector, compare]);\n    return selected;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/@xstate/react/es/index.js\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3R5cGVzLmpzP2JhZTciLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvdXNlLWlzb21vcnBoaWMtbGF5b3V0LWVmZmVjdC9kaXN0L3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QuYnJvd3Nlci5lc20uanM/OTA3ZiIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZUNvbnN0YW50LmpzP2MxNzAiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91dGlscy5qcz81MzI0Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvdXNlUmVhY3RFZmZlY3RBY3Rpb25zLmpzPzMwNmMiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VJbnRlcnByZXQuanM/ODNmNCIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZU1hY2hpbmUuanM/MTNmOSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL25vZGVfbW9kdWxlcy9AeHN0YXRlL3JlYWN0L2VzL3VzZUFjdG9yLmpzP2I1YzAiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VTZXJ2aWNlLmpzP2YxNzkiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi9ub2RlX21vZHVsZXMvQHhzdGF0ZS9yZWFjdC9lcy91c2VTZWxlY3Rvci5qcz8zYjRkIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vbm9kZV9tb2R1bGVzL0B4c3RhdGUvcmVhY3QvZXMvaW5kZXguanM/MTFkZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQzs7O0FDSkg7O0FBRXhDLGFBQWEsK0JBQWU7O0FBRTVCLCtFQUFlLEtBQUssRUFBQzs7O0FDSlU7QUFDaEI7QUFDZixjQUFjLHNCQUFZO0FBQzFCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7O0FDUEEsY0FBYyxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFJLElBQUksU0FBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsaUJBQWlCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBOzs7QUNqREEsSUFBSSwwQkFBTSxJQUFJLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCLDRCQUE0QixzQkFBc0IscUJBQXFCLDBCQUFNO0FBQzdFO0FBQ0E7QUFDMEM7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QTtBQUNzQztBQUMvQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsS0FBZ0UsRUFBRSxFQUVyRTtBQUNMLGFBQWEsZUFBTSxDQUFDLFFBQVE7QUFDNUI7QUFDQTs7O0FDN0JBLElBQUksZ0JBQU0sSUFBSSxTQUFJLElBQUksU0FBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNvRDtBQUNOO0FBQ0k7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUIsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsMEJBQTBCO0FBQ3ZELGlDQUFpQyxrQ0FBa0M7QUFDbkUsYUFBYSxnQkFBTSxDQUFDLDRCQUFRLGNBQWMscUNBQXFDLEVBQUU7QUFDakYsc0JBQXNCLDBCQUFNO0FBQzVCLElBQUksNkJBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QiwwQkFBMEI7QUFDdEQsS0FBSztBQUNMO0FBQ0E7OztBQ25Eb0U7QUFDMUI7QUFDSjtBQUNRO0FBQ0YiLCJmaWxlIjoiOTExMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIFJlYWN0RWZmZWN0VHlwZTtcbihmdW5jdGlvbiAoUmVhY3RFZmZlY3RUeXBlKSB7XG4gICAgUmVhY3RFZmZlY3RUeXBlW1JlYWN0RWZmZWN0VHlwZVtcIkVmZmVjdFwiXSA9IDFdID0gXCJFZmZlY3RcIjtcbiAgICBSZWFjdEVmZmVjdFR5cGVbUmVhY3RFZmZlY3RUeXBlW1wiTGF5b3V0RWZmZWN0XCJdID0gMl0gPSBcIkxheW91dEVmZmVjdFwiO1xufSkoUmVhY3RFZmZlY3RUeXBlIHx8IChSZWFjdEVmZmVjdFR5cGUgPSB7fSkpO1xuIiwiaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG52YXIgaW5kZXggPSAgdXNlTGF5b3V0RWZmZWN0IDtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDb25zdGFudChmbikge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0geyB2OiBmbigpIH07XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudC52O1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpdGlvbihpdGVtcywgcHJlZGljYXRlKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIF9iID0gX19yZWFkKFtbXSwgW11dLCAyKSwgdHJ1dGh5ID0gX2JbMF0sIGZhbHN5ID0gX2JbMV07XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaXRlbXNfMSA9IF9fdmFsdWVzKGl0ZW1zKSwgaXRlbXNfMV8xID0gaXRlbXNfMS5uZXh0KCk7ICFpdGVtc18xXzEuZG9uZTsgaXRlbXNfMV8xID0gaXRlbXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHRydXRoeS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFsc3kucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGl0ZW1zXzFfMSAmJiAhaXRlbXNfMV8xLmRvbmUgJiYgKF9hID0gaXRlbXNfMS5yZXR1cm4pKSBfYS5jYWxsKGl0ZW1zXzEpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbn1cbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWQpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJ3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgUmVhY3RFZmZlY3RUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBwYXJ0aXRpb24gfSBmcm9tICcuL3V0aWxzJztcbmZ1bmN0aW9uIGV4ZWN1dGVFZmZlY3QoYWN0aW9uLCBzdGF0ZSkge1xuICAgIHZhciBleGVjID0gYWN0aW9uLmV4ZWM7XG4gICAgdmFyIG9yaWdpbmFsRXhlYyA9IGV4ZWMoc3RhdGUuY29udGV4dCwgc3RhdGUuX2V2ZW50LmRhdGEsIHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgX2V2ZW50OiBzdGF0ZS5fZXZlbnRcbiAgICB9KTtcbiAgICBvcmlnaW5hbEV4ZWMoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFjdEVmZmVjdEFjdGlvbnMoc2VydmljZSkge1xuICAgIHZhciBlZmZlY3RBY3Rpb25zUmVmID0gdXNlUmVmKFtdKTtcbiAgICB2YXIgbGF5b3V0RWZmZWN0QWN0aW9uc1JlZiA9IHVzZVJlZihbXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWIgPSBzZXJ2aWNlLnN1YnNjcmliZShmdW5jdGlvbiAoY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZWFjdEVmZmVjdEFjdGlvbnMgPSBjdXJyZW50U3RhdGUuYWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBhY3Rpb24uZXhlYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJ19fZWZmZWN0JyBpbiBhY3Rpb24uZXhlYyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gX19yZWFkKHBhcnRpdGlvbihyZWFjdEVmZmVjdEFjdGlvbnMsIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5leGVjLl9fZWZmZWN0ID09PSBSZWFjdEVmZmVjdFR5cGUuRWZmZWN0O1xuICAgICAgICAgICAgICAgIH0pLCAyKSwgZWZmZWN0QWN0aW9ucyA9IF9jWzBdLCBsYXlvdXRFZmZlY3RBY3Rpb25zID0gX2NbMV07XG4gICAgICAgICAgICAgICAgKF9hID0gZWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50KS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChlZmZlY3RBY3Rpb25zLm1hcChmdW5jdGlvbiAoZWZmZWN0QWN0aW9uKSB7IHJldHVybiBbZWZmZWN0QWN0aW9uLCBjdXJyZW50U3RhdGVdOyB9KSkpO1xuICAgICAgICAgICAgICAgIChfYiA9IGxheW91dEVmZmVjdEFjdGlvbnNSZWYuY3VycmVudCkucHVzaC5hcHBseShfYiwgX19zcHJlYWQobGF5b3V0RWZmZWN0QWN0aW9ucy5tYXAoZnVuY3Rpb24gKGxheW91dEVmZmVjdEFjdGlvbikgeyByZXR1cm4gW2xheW91dEVmZmVjdEFjdGlvbiwgY3VycmVudFN0YXRlXTsgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gdGhpcyBpcyBzb21ld2hhdCB3ZWlyZCAtIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSBmbHVzaGVkIHdpdGhpbiB1c2VMYXlvdXRFZmZlY3RcbiAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0byByZWNlaXZlIHdhcm5pbmdzIGFib3V0IHVzZUxheW91dEVmZmVjdCBiZWluZyB1c2VkIG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHVzZSBgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdGAgdG8gc2lsZW5jZSB0aG9zZSB3YXJuaW5nc1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAobGF5b3V0RWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKGxheW91dEVmZmVjdEFjdGlvbnNSZWYuY3VycmVudC5zaGlmdCgpLCAyKSwgbGF5b3V0RWZmZWN0QWN0aW9uID0gX2FbMF0sIGVmZmVjdFN0YXRlID0gX2FbMV07XG4gICAgICAgICAgICBleGVjdXRlRWZmZWN0KGxheW91dEVmZmVjdEFjdGlvbiwgZWZmZWN0U3RhdGUpO1xuICAgICAgICB9XG4gICAgfSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGtwaWFuby94c3RhdGUvcHVsbC8xMjAyI2Rpc2N1c3Npb25fcjQyOTY3Nzc3M1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlIChlZmZlY3RBY3Rpb25zUmVmLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZWZmZWN0QWN0aW9uc1JlZi5jdXJyZW50LnNoaWZ0KCksIDIpLCBlZmZlY3RBY3Rpb24gPSBfYVswXSwgZWZmZWN0U3RhdGUgPSBfYVsxXTtcbiAgICAgICAgICAgIGV4ZWN1dGVFZmZlY3QoZWZmZWN0QWN0aW9uLCBlZmZlY3RTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJ3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHsgaW50ZXJwcmV0LCBTdGF0ZSB9IGZyb20gJ3hzdGF0ZSc7XG5pbXBvcnQgdXNlQ29uc3RhbnQgZnJvbSAnLi91c2VDb25zdGFudCc7XG5pbXBvcnQgeyB1c2VSZWFjdEVmZmVjdEFjdGlvbnMgfSBmcm9tICcuL3VzZVJlYWN0RWZmZWN0QWN0aW9ucyc7XG4vLyBjb3BpZWQgZnJvbSBjb3JlL3NyYy91dGlscy50c1xuLy8gaXQgYXZvaWRzIGEgYnJlYWtpbmcgY2hhbmdlIGJldHdlZW4gdGhpcyBwYWNrYWdlIGFuZCBYU3RhdGUgd2hpY2ggaXMgaXRzIHBlZXIgZGVwXG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0SGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5leHRIYW5kbGVyO1xuICAgIH1cbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvaWQgMDsgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBuZXh0SGFuZGxlcixcbiAgICAgICAgZXJyb3I6IGVycm9ySGFuZGxlciB8fCBub29wLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGlvbkhhbmRsZXIgfHwgbm9vcFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJwcmV0KGdldE1hY2hpbmUsIG9wdGlvbnMsIG9ic2VydmVyT3JMaXN0ZW5lcikge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG1hY2hpbmUgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZ2V0TWFjaGluZSA9PT0gJ2Z1bmN0aW9uJyA/IGdldE1hY2hpbmUoKSA6IGdldE1hY2hpbmU7XG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIGdldE1hY2hpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKG1hY2hpbmUpLCAxKSwgaW5pdGlhbE1hY2hpbmUgPSBfYVswXTtcbiAgICAgICAgaWYgKG1hY2hpbmUgIT09IGluaXRpYWxNYWNoaW5lKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01hY2hpbmUgZ2l2ZW4gdG8gYHVzZU1hY2hpbmVgIGhhcyBjaGFuZ2VkIGJldHdlZW4gcmVuZGVycy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cy5cXG4nICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdSBwYXNzIHRoZSBzYW1lIE1hY2hpbmUgYXMgYXJndW1lbnQgZWFjaCB0aW1lLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBndWFyZHMgPSBvcHRpb25zLmd1YXJkcywgYWN0aW9ucyA9IG9wdGlvbnMuYWN0aW9ucywgYWN0aXZpdGllcyA9IG9wdGlvbnMuYWN0aXZpdGllcywgc2VydmljZXMgPSBvcHRpb25zLnNlcnZpY2VzLCBkZWxheXMgPSBvcHRpb25zLmRlbGF5cywgcmVoeWRyYXRlZFN0YXRlID0gb3B0aW9ucy5zdGF0ZSwgaW50ZXJwcmV0ZXJPcHRpb25zID0gX19yZXN0KG9wdGlvbnMsIFtcImNvbnRleHRcIiwgXCJndWFyZHNcIiwgXCJhY3Rpb25zXCIsIFwiYWN0aXZpdGllc1wiLCBcInNlcnZpY2VzXCIsIFwiZGVsYXlzXCIsIFwic3RhdGVcIl0pO1xuICAgIHZhciBzZXJ2aWNlID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFjaGluZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBndWFyZHM6IGd1YXJkcyxcbiAgICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMsXG4gICAgICAgICAgICBhY3Rpdml0aWVzOiBhY3Rpdml0aWVzLFxuICAgICAgICAgICAgc2VydmljZXM6IHNlcnZpY2VzLFxuICAgICAgICAgICAgZGVsYXlzOiBkZWxheXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1hY2hpbmVXaXRoQ29uZmlnID0gbWFjaGluZS53aXRoQ29uZmlnKG1hY2hpbmVDb25maWcsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBtYWNoaW5lLmNvbnRleHQpLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiBpbnRlcnByZXQobWFjaGluZVdpdGhDb25maWcsIF9fYXNzaWduKHsgZGVmZXJFdmVudHM6IHRydWUgfSwgaW50ZXJwcmV0ZXJPcHRpb25zKSk7XG4gICAgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWI7XG4gICAgICAgIGlmIChvYnNlcnZlck9yTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHN1YiA9IHNlcnZpY2Uuc3Vic2NyaWJlKHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YiA9PT0gbnVsbCB8fCBzdWIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtvYnNlcnZlck9yTGlzdGVuZXJdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VydmljZS5zdGFydChyZWh5ZHJhdGVkU3RhdGUgPyBTdGF0ZS5jcmVhdGUocmVoeWRyYXRlZFN0YXRlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXJ2aWNlLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgLy8gTWFrZSBzdXJlIGFjdGlvbnMgYW5kIHNlcnZpY2VzIGFyZSBrZXB0IHVwZGF0ZWQgd2hlbiB0aGV5IGNoYW5nZS5cbiAgICAvLyBUaGlzIG11dGF0aW9uIGFzc2lnbm1lbnQgaXMgc2FmZSBiZWNhdXNlIHRoZSBzZXJ2aWNlIGluc3RhbmNlIGlzIG9ubHkgdXNlZFxuICAgIC8vIGluIG9uZSBwbGFjZSAtLSB0aGlzIGhvb2sncyBjYWxsZXIuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2VydmljZS5tYWNoaW5lLm9wdGlvbnMuYWN0aW9ucywgYWN0aW9ucyk7XG4gICAgfSwgW2FjdGlvbnNdKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2aWNlLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlcywgc2VydmljZXMpO1xuICAgIH0sIFtzZXJ2aWNlc10pO1xuICAgIHVzZVJlYWN0RWZmZWN0QWN0aW9ucyhzZXJ2aWNlKTtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWQpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIHJldHVybiBhcjtcbn07XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTdGF0ZSB9IGZyb20gJ3hzdGF0ZSc7XG5pbXBvcnQgeyBSZWFjdEVmZmVjdFR5cGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHVzZUludGVycHJldCB9IGZyb20gJy4vdXNlSW50ZXJwcmV0JztcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0QWN0aW9uRnVuY3Rpb24oZXhlYywgdGFnKSB7XG4gICAgdmFyIGVmZmVjdEV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgZXhlY3V0ZTsganVzdCByZXR1cm5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBleGVjLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZWZmZWN0RXhlYywge1xuICAgICAgICBuYW1lOiB7IHZhbHVlOiBcImVmZmVjdDpcIiArIGV4ZWMubmFtZSB9LFxuICAgICAgICBfX2VmZmVjdDogeyB2YWx1ZTogdGFnIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZWZmZWN0RXhlYztcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc0VmZmVjdChleGVjKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0QWN0aW9uRnVuY3Rpb24oZXhlYywgUmVhY3RFZmZlY3RUeXBlLkVmZmVjdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNMYXlvdXRFZmZlY3QoZXhlYykge1xuICAgIHJldHVybiBjcmVhdGVSZWFjdEFjdGlvbkZ1bmN0aW9uKGV4ZWMsIFJlYWN0RWZmZWN0VHlwZS5MYXlvdXRFZmZlY3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hY2hpbmUoZ2V0TWFjaGluZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGxpc3RlbmVyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAvLyBPbmx5IGNoYW5nZSB0aGUgY3VycmVudCBzdGF0ZSBpZjpcbiAgICAgICAgLy8gLSB0aGUgaW5jb21pbmcgc3RhdGUgaXMgdGhlIFwibGl2ZVwiIGluaXRpYWwgc3RhdGUgKHNpbmNlIGl0IG1pZ2h0IGhhdmUgbmV3IGFjdG9ycylcbiAgICAgICAgLy8gLSBPUiB0aGUgaW5jb21pbmcgc3RhdGUgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIFwibGl2ZVwiIGluaXRpYWwgc3RhdGUgd2lsbCBoYXZlIC5jaGFuZ2VkID09PSB1bmRlZmluZWQuXG4gICAgICAgIHZhciBpbml0aWFsU3RhdGVDaGFuZ2VkID0gbmV4dFN0YXRlLmNoYW5nZWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV4dFN0YXRlLmNoaWxkcmVuKS5sZW5ndGg7XG4gICAgICAgIGlmIChuZXh0U3RhdGUuY2hhbmdlZCB8fCBpbml0aWFsU3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZShuZXh0U3RhdGUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBzZXJ2aWNlID0gdXNlSW50ZXJwcmV0KGdldE1hY2hpbmUsIG9wdGlvbnMsIGxpc3RlbmVyKTtcbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gc2VydmljZS5tYWNoaW5lLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLnN0YXRlXG4gICAgICAgICAgICA/IFN0YXRlLmNyZWF0ZShvcHRpb25zLnN0YXRlKVxuICAgICAgICAgICAgOiBpbml0aWFsU3RhdGUpO1xuICAgIH0pLCAyKSwgc3RhdGUgPSBfYVswXSwgc2V0U3RhdGUgPSBfYVsxXTtcbiAgICByZXR1cm4gW3N0YXRlLCBzZXJ2aWNlLnNlbmQsIHNlcnZpY2VdO1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGZyb20gJ3VzZS1pc29tb3JwaGljLWxheW91dC1lZmZlY3QnO1xuaW1wb3J0IHVzZUNvbnN0YW50IGZyb20gJy4vdXNlQ29uc3RhbnQnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWN0b3JXaXRoU3RhdGUoYWN0b3JSZWYpIHtcbiAgICByZXR1cm4gJ3N0YXRlJyBpbiBhY3RvclJlZjtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWRBY3RvcihhY3RvclJlZikge1xuICAgIHJldHVybiAnZGVmZXJyZWQnIGluIGFjdG9yUmVmO1xufVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogLi4uICovXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdG9yKGFjdG9yUmVmLCBnZXRTbmFwc2hvdCkge1xuICAgIGlmIChnZXRTbmFwc2hvdCA9PT0gdm9pZCAwKSB7IGdldFNuYXBzaG90ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGlzQWN0b3JXaXRoU3RhdGUoYSkgPyBhLnN0YXRlIDogdW5kZWZpbmVkO1xuICAgIH07IH1cbiAgICB2YXIgYWN0b3JSZWZSZWYgPSB1c2VSZWYoYWN0b3JSZWYpO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50c1JlZiA9IHVzZVJlZihbXSk7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldFNuYXBzaG90KGFjdG9yUmVmKTsgfSksIDIpLCBjdXJyZW50ID0gX2FbMF0sIHNldEN1cnJlbnQgPSBfYVsxXTtcbiAgICB2YXIgc2VuZCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY3VycmVudEFjdG9yUmVmID0gYWN0b3JSZWZSZWYuY3VycmVudDtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGFjdG9yIGlzIGEgZGVmZXJyZWQgYWN0b3IsXG4gICAgICAgIC8vIHF1ZXVlIHRoZSBldmVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXBsYXllZFxuICAgICAgICAvLyBvbiB0aGUgbm9uLWRlZmVycmVkIGFjdG9yLlxuICAgICAgICBpZiAoaXNEZWZlcnJlZEFjdG9yKGN1cnJlbnRBY3RvclJlZikgJiYgY3VycmVudEFjdG9yUmVmLmRlZmVycmVkKSB7XG4gICAgICAgICAgICBkZWZlcnJlZEV2ZW50c1JlZi5jdXJyZW50LnB1c2goZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEFjdG9yUmVmLnNlbmQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTsgfSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFjdG9yUmVmUmVmLmN1cnJlbnQgPSBhY3RvclJlZjtcbiAgICAgICAgc2V0Q3VycmVudChnZXRTbmFwc2hvdChhY3RvclJlZikpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gYWN0b3JSZWYuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChlbWl0dGVkKSB7IHJldHVybiBzZXRDdXJyZW50KGVtaXR0ZWQpOyB9LFxuICAgICAgICAgICAgZXJyb3I6IG5vb3AsXG4gICAgICAgICAgICBjb21wbGV0ZTogbm9vcFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRGVxdWV1ZSBkZWZlcnJlZCBldmVudHMgZnJvbSB0aGUgcHJldmlvdXMgZGVmZXJyZWQgYWN0b3JSZWZcbiAgICAgICAgd2hpbGUgKGRlZmVycmVkRXZlbnRzUmVmLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkRXZlbnQgPSBkZWZlcnJlZEV2ZW50c1JlZi5jdXJyZW50LnNoaWZ0KCk7XG4gICAgICAgICAgICBhY3RvclJlZi5zZW5kKGRlZmVycmVkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWN0b3JSZWZdKTtcbiAgICByZXR1cm4gW2N1cnJlbnQsIHNlbmRdO1xufVxuIiwidmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuaW1wb3J0IHsgdXNlQWN0b3IgfSBmcm9tICcuL3VzZUFjdG9yJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXJ2aWNlU25hcHNob3Qoc2VydmljZSkge1xuICAgIC8vIFRPRE86IHJlbW92ZSBjb21wYXQgbGluZXMgaW4gYSBuZXcgbWFqb3IsIHJlcGxhY2UgbGl0ZXJhbCBudW1iZXIgd2l0aCBJbnRlcnByZXRlclN0YXR1cyB0aGVuIGFzIHdlbGxcbiAgICByZXR1cm4gKCdzdGF0dXMnIGluIHNlcnZpY2UgPyBzZXJ2aWNlLnN0YXR1cyA6IHNlcnZpY2UuX3N0YXR1cykgIT09IDBcbiAgICAgICAgPyBzZXJ2aWNlLnN0YXRlXG4gICAgICAgIDogc2VydmljZS5tYWNoaW5lLmluaXRpYWxTdGF0ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKCdtYWNoaW5lJyBpbiBzZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdXNlIGFuIGFjdG9yLWxpa2Ugb2JqZWN0IGluc3RlYWQgb2YgYSBzZXJ2aWNlIGluIHRoZSB1c2VTZXJ2aWNlKCkgaG9vay4gUGxlYXNlIHVzZSB0aGUgdXNlQWN0b3IoKSBob29rIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlQWN0b3Ioc2VydmljZSwgZ2V0U2VydmljZVNuYXBzaG90KSwgMSksIHN0YXRlID0gX2FbMF07XG4gICAgcmV0dXJuIFtzdGF0ZSwgc2VydmljZS5zZW5kXTtcbn1cbiIsInZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzQWN0b3JXaXRoU3RhdGUgfSBmcm9tICcuL3VzZUFjdG9yJztcbmltcG9ydCB7IGdldFNlcnZpY2VTbmFwc2hvdCB9IGZyb20gJy4vdXNlU2VydmljZSc7XG5mdW5jdGlvbiBpc1NlcnZpY2UoYWN0b3IpIHtcbiAgICByZXR1cm4gJ3N0YXRlJyBpbiBhY3RvciAmJiAnbWFjaGluZScgaW4gYWN0b3I7XG59XG52YXIgZGVmYXVsdENvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbnZhciBkZWZhdWx0R2V0U25hcHNob3QgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBpc1NlcnZpY2UoYSlcbiAgICAgICAgPyBnZXRTZXJ2aWNlU25hcHNob3QoYSlcbiAgICAgICAgOiBpc0FjdG9yV2l0aFN0YXRlKGEpXG4gICAgICAgICAgICA/IGEuc3RhdGVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3RvcihhY3Rvciwgc2VsZWN0b3IsIGNvbXBhcmUsIGdldFNuYXBzaG90KSB7XG4gICAgaWYgKGNvbXBhcmUgPT09IHZvaWQgMCkgeyBjb21wYXJlID0gZGVmYXVsdENvbXBhcmU7IH1cbiAgICBpZiAoZ2V0U25hcHNob3QgPT09IHZvaWQgMCkgeyBnZXRTbmFwc2hvdCA9IGRlZmF1bHRHZXRTbmFwc2hvdDsgfVxuICAgIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3RvcihnZXRTbmFwc2hvdChhY3RvcikpOyB9KSwgMiksIHNlbGVjdGVkID0gX2FbMF0sIHNldFNlbGVjdGVkID0gX2FbMV07XG4gICAgdmFyIHNlbGVjdGVkUmVmID0gdXNlUmVmKHNlbGVjdGVkKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXBkYXRlU2VsZWN0ZWRJZkNoYW5nZWQgPSBmdW5jdGlvbiAobmV4dFNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmUoc2VsZWN0ZWRSZWYuY3VycmVudCwgbmV4dFNlbGVjdGVkKSkge1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkKG5leHRTZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRSZWYuY3VycmVudCA9IG5leHRTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGluaXRpYWxTZWxlY3RlZCA9IHNlbGVjdG9yKGdldFNuYXBzaG90KGFjdG9yKSk7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkSWZDaGFuZ2VkKGluaXRpYWxTZWxlY3RlZCk7XG4gICAgICAgIHZhciBzdWIgPSBhY3Rvci5zdWJzY3JpYmUoZnVuY3Rpb24gKGVtaXR0ZWQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0U2VsZWN0ZWQgPSBzZWxlY3RvcihlbWl0dGVkKTtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGVkSWZDaGFuZ2VkKG5leHRTZWxlY3RlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgfSwgW3NlbGVjdG9yLCBjb21wYXJlXSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkO1xufVxuIiwiZXhwb3J0IHsgdXNlTWFjaGluZSwgYXNFZmZlY3QsIGFzTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi91c2VNYWNoaW5lJztcbmV4cG9ydCB7IHVzZVNlcnZpY2UgfSBmcm9tICcuL3VzZVNlcnZpY2UnO1xuZXhwb3J0IHsgdXNlQWN0b3IgfSBmcm9tICcuL3VzZUFjdG9yJztcbmV4cG9ydCB7IHVzZUludGVycHJldCB9IGZyb20gJy4vdXNlSW50ZXJwcmV0JztcbmV4cG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAnLi91c2VTZWxlY3Rvcic7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///91126\n')}}]);