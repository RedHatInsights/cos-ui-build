(()=>{"use strict";var __webpack_modules__={412:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/errors.js\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\r\nclass ErrorHandler {\r\n    constructor() {\r\n        this.listeners = [];\r\n        this.unexpectedErrorHandler = function (e) {\r\n            setTimeout(() => {\r\n                if (e.stack) {\r\n                    throw new Error(e.message + '\\n\\n' + e.stack);\r\n                }\r\n                throw e;\r\n            }, 0);\r\n        };\r\n    }\r\n    emit(e) {\r\n        this.listeners.forEach((listener) => {\r\n            listener(e);\r\n        });\r\n    }\r\n    onUnexpectedError(e) {\r\n        this.unexpectedErrorHandler(e);\r\n        this.emit(e);\r\n    }\r\n    // For external errors, we don't want the listeners to be called\r\n    onUnexpectedExternalError(e) {\r\n        this.unexpectedErrorHandler(e);\r\n    }\r\n}\r\nconst errorHandler = new ErrorHandler();\r\nfunction onUnexpectedError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isPromiseCanceledError(e)) {\r\n        errorHandler.onUnexpectedError(e);\r\n    }\r\n    return undefined;\r\n}\r\nfunction onUnexpectedExternalError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isPromiseCanceledError(e)) {\r\n        errorHandler.onUnexpectedExternalError(e);\r\n    }\r\n    return undefined;\r\n}\r\nfunction transformErrorForSerialization(error) {\r\n    if (error instanceof Error) {\r\n        let { name, message } = error;\r\n        const stack = error.stacktrace || error.stack;\r\n        return {\r\n            $isError: true,\r\n            name,\r\n            message,\r\n            stack\r\n        };\r\n    }\r\n    // return as is\r\n    return error;\r\n}\r\nconst canceledName = 'Canceled';\r\n/**\r\n * Checks if the given error is a promise in canceled state\r\n */\r\nfunction isPromiseCanceledError(error) {\r\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\r\n}\r\n/**\r\n * Returns an error that signals cancellation.\r\n */\r\nfunction canceled() {\r\n    const error = new Error(canceledName);\r\n    error.name = error.message;\r\n    return error;\r\n}\r\nfunction errors_illegalArgument(name) {\r\n    if (name) {\r\n        return new Error(`Illegal argument: ${name}`);\r\n    }\r\n    else {\r\n        return new Error('Illegal argument');\r\n    }\r\n}\r\nfunction illegalState(name) {\r\n    if (name) {\r\n        return new Error(`Illegal state: ${name}`);\r\n    }\r\n    else {\r\n        return new Error('Illegal state');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/functional.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction once(fn) {\r\n    const _this = this;\r\n    let didCall = false;\r\n    let result;\r\n    return function () {\r\n        if (didCall) {\r\n            return result;\r\n        }\r\n        didCall = true;\r\n        result = fn.apply(_this, arguments);\r\n        return result;\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/iterator.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar Iterable;\r\n(function (Iterable) {\r\n    function is(thing) {\r\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\r\n    }\r\n    Iterable.is = is;\r\n    const _empty = Object.freeze([]);\r\n    function empty() {\r\n        return _empty;\r\n    }\r\n    Iterable.empty = empty;\r\n    function* single(element) {\r\n        yield element;\r\n    }\r\n    Iterable.single = single;\r\n    function from(iterable) {\r\n        return iterable || _empty;\r\n    }\r\n    Iterable.from = from;\r\n    function isEmpty(iterable) {\r\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\r\n    }\r\n    Iterable.isEmpty = isEmpty;\r\n    function first(iterable) {\r\n        return iterable[Symbol.iterator]().next().value;\r\n    }\r\n    Iterable.first = first;\r\n    function some(iterable, predicate) {\r\n        for (const element of iterable) {\r\n            if (predicate(element)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    Iterable.some = some;\r\n    function find(iterable, predicate) {\r\n        for (const element of iterable) {\r\n            if (predicate(element)) {\r\n                return element;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    Iterable.find = find;\r\n    function* filter(iterable, predicate) {\r\n        for (const element of iterable) {\r\n            if (predicate(element)) {\r\n                yield element;\r\n            }\r\n        }\r\n    }\r\n    Iterable.filter = filter;\r\n    function* map(iterable, fn) {\r\n        let index = 0;\r\n        for (const element of iterable) {\r\n            yield fn(element, index++);\r\n        }\r\n    }\r\n    Iterable.map = map;\r\n    function* concat(...iterables) {\r\n        for (const iterable of iterables) {\r\n            for (const element of iterable) {\r\n                yield element;\r\n            }\r\n        }\r\n    }\r\n    Iterable.concat = concat;\r\n    function* concatNested(iterables) {\r\n        for (const iterable of iterables) {\r\n            for (const element of iterable) {\r\n                yield element;\r\n            }\r\n        }\r\n    }\r\n    Iterable.concatNested = concatNested;\r\n    function reduce(iterable, reducer, initialValue) {\r\n        let value = initialValue;\r\n        for (const element of iterable) {\r\n            value = reducer(value, element);\r\n        }\r\n        return value;\r\n    }\r\n    Iterable.reduce = reduce;\r\n    /**\r\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\r\n     */\r\n    function* slice(arr, from, to = arr.length) {\r\n        if (from < 0) {\r\n            from += arr.length;\r\n        }\r\n        if (to < 0) {\r\n            to += arr.length;\r\n        }\r\n        else if (to > arr.length) {\r\n            to = arr.length;\r\n        }\r\n        for (; from < to; from++) {\r\n            yield arr[from];\r\n        }\r\n    }\r\n    Iterable.slice = slice;\r\n    /**\r\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\r\n     * and an iterable for the rest of the elements.\r\n     */\r\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\r\n        const consumed = [];\r\n        if (atMost === 0) {\r\n            return [consumed, iterable];\r\n        }\r\n        const iterator = iterable[Symbol.iterator]();\r\n        for (let i = 0; i < atMost; i++) {\r\n            const next = iterator.next();\r\n            if (next.done) {\r\n                return [consumed, Iterable.empty()];\r\n            }\r\n            consumed.push(next.value);\r\n        }\r\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\r\n    }\r\n    Iterable.consume = consume;\r\n    /**\r\n     * Returns whether the iterables are the same length and all items are\r\n     * equal using the comparator function.\r\n     */\r\n    function equals(a, b, comparator = (at, bt) => at === bt) {\r\n        const ai = a[Symbol.iterator]();\r\n        const bi = b[Symbol.iterator]();\r\n        while (true) {\r\n            const an = ai.next();\r\n            const bn = bi.next();\r\n            if (an.done !== bn.done) {\r\n                return false;\r\n            }\r\n            else if (an.done) {\r\n                return true;\r\n            }\r\n            else if (!comparator(an.value, bn.value)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    Iterable.equals = equals;\r\n})(Iterable || (Iterable = {}));\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\r\nconst TRACK_DISPOSABLES = false;\r\nlet disposableTracker = null;\r\nfunction setDisposableTracker(tracker) {\r\n    disposableTracker = tracker;\r\n}\r\nif (TRACK_DISPOSABLES) {\r\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\r\n    setDisposableTracker(new class {\r\n        trackDisposable(x) {\r\n            const stack = new Error('Potentially leaked disposable').stack;\r\n            setTimeout(() => {\r\n                if (!x[__is_disposable_tracked__]) {\r\n                    console.log(stack);\r\n                }\r\n            }, 3000);\r\n        }\r\n        setParent(child, parent) {\r\n            if (child && child !== lifecycle_Disposable.None) {\r\n                try {\r\n                    child[__is_disposable_tracked__] = true;\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n            }\r\n        }\r\n        markAsDisposed(disposable) {\r\n            if (disposable && disposable !== lifecycle_Disposable.None) {\r\n                try {\r\n                    disposable[__is_disposable_tracked__] = true;\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n            }\r\n        }\r\n        markAsSingleton(disposable) { }\r\n    });\r\n}\r\nfunction trackDisposable(x) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\r\n    return x;\r\n}\r\nfunction markAsDisposed(disposable) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\r\n}\r\nfunction setParentOfDisposable(child, parent) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\r\n}\r\nfunction setParentOfDisposables(children, parent) {\r\n    if (!disposableTracker) {\r\n        return;\r\n    }\r\n    for (const child of children) {\r\n        disposableTracker.setParent(child, parent);\r\n    }\r\n}\r\n/**\r\n * Indicates that the given object is a singleton which does not need to be disposed.\r\n*/\r\nfunction markAsSingleton(singleton) {\r\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\r\n    return singleton;\r\n}\r\nclass MultiDisposeError extends Error {\r\n    constructor(errors) {\r\n        super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\r\n        this.errors = errors;\r\n    }\r\n}\r\nfunction isDisposable(thing) {\r\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\r\n}\r\nfunction dispose(arg) {\r\n    if (Iterable.is(arg)) {\r\n        let errors = [];\r\n        for (const d of arg) {\r\n            if (d) {\r\n                try {\r\n                    d.dispose();\r\n                }\r\n                catch (e) {\r\n                    errors.push(e);\r\n                }\r\n            }\r\n        }\r\n        if (errors.length === 1) {\r\n            throw errors[0];\r\n        }\r\n        else if (errors.length > 1) {\r\n            throw new MultiDisposeError(errors);\r\n        }\r\n        return Array.isArray(arg) ? [] : arg;\r\n    }\r\n    else if (arg) {\r\n        arg.dispose();\r\n        return arg;\r\n    }\r\n}\r\nfunction combinedDisposable(...disposables) {\r\n    const parent = toDisposable(() => dispose(disposables));\r\n    setParentOfDisposables(disposables, parent);\r\n    return parent;\r\n}\r\nfunction toDisposable(fn) {\r\n    const self = trackDisposable({\r\n        dispose: once(() => {\r\n            markAsDisposed(self);\r\n            fn();\r\n        })\r\n    });\r\n    return self;\r\n}\r\nclass DisposableStore {\r\n    constructor() {\r\n        this._toDispose = new Set();\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables and mark this object as disposed.\r\n     *\r\n     * Any future disposables added to this object will be disposed of on `add`.\r\n     */\r\n    dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        markAsDisposed(this);\r\n        this._isDisposed = true;\r\n        this.clear();\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\r\n    clear() {\r\n        try {\r\n            dispose(this._toDispose.values());\r\n        }\r\n        finally {\r\n            this._toDispose.clear();\r\n        }\r\n    }\r\n    add(o) {\r\n        if (!o) {\r\n            return o;\r\n        }\r\n        if (o === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        setParentOfDisposable(o, this);\r\n        if (this._isDisposed) {\r\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\r\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\r\n            }\r\n        }\r\n        else {\r\n            this._toDispose.add(o);\r\n        }\r\n        return o;\r\n    }\r\n}\r\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\r\nclass lifecycle_Disposable {\r\n    constructor() {\r\n        this._store = new DisposableStore();\r\n        trackDisposable(this);\r\n        setParentOfDisposable(this._store, this);\r\n    }\r\n    dispose() {\r\n        markAsDisposed(this);\r\n        this._store.dispose();\r\n    }\r\n    _register(o) {\r\n        if (o === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        return this._store.add(o);\r\n    }\r\n}\r\nlifecycle_Disposable.None = Object.freeze({ dispose() { } });\r\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\r\nclass MutableDisposable {\r\n    constructor() {\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    get value() {\r\n        return this._isDisposed ? undefined : this._value;\r\n    }\r\n    set value(value) {\r\n        var _a;\r\n        if (this._isDisposed || value === this._value) {\r\n            return;\r\n        }\r\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        if (value) {\r\n            setParentOfDisposable(value, this);\r\n        }\r\n        this._value = value;\r\n    }\r\n    clear() {\r\n        this.value = undefined;\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        this._isDisposed = true;\r\n        markAsDisposed(this);\r\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._value = undefined;\r\n    }\r\n    /**\r\n     * Clears the value, but does not dispose it.\r\n     * The old value is returned.\r\n    */\r\n    clearAndLeak() {\r\n        const oldValue = this._value;\r\n        this._value = undefined;\r\n        if (oldValue) {\r\n            setParentOfDisposable(oldValue, null);\r\n        }\r\n        return oldValue;\r\n    }\r\n}\r\nclass ImmortalReference {\r\n    constructor(object) {\r\n        this.object = object;\r\n    }\r\n    dispose() { }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/platform.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar _a;\r\nconst LANGUAGE_DEFAULT = 'en';\r\nlet _isWindows = false;\r\nlet _isMacintosh = false;\r\nlet _isLinux = false;\r\nlet _isLinuxSnap = false;\r\nlet _isNative = false;\r\nlet _isWeb = false;\r\nlet _isIOS = false;\r\nlet _locale = undefined;\r\nlet _language = (/* unused pure expression or super */ null && (LANGUAGE_DEFAULT));\r\nlet _translationsConfigFile = undefined;\r\nlet _userAgent = undefined;\r\nconst globals = (typeof self === 'object' ? self : typeof __webpack_require__.g === 'object' ? __webpack_require__.g : {});\r\nlet nodeProcess = undefined;\r\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\r\n    // Native environment (sandboxed)\r\n    nodeProcess = globals.vscode.process;\r\n}\r\nelse if (typeof process !== 'undefined') {\r\n    // Native environment (non-sandboxed)\r\n    nodeProcess = process;\r\n}\r\nconst isElectronRenderer = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === 'string' && nodeProcess.type === 'renderer';\r\nconst isElectronSandboxed = isElectronRenderer && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.sandboxed);\r\nconst browserCodeLoadingCacheStrategy = (() => {\r\n    // Always enabled when sandbox is enabled\r\n    if (isElectronSandboxed) {\r\n        return 'bypassHeatCheck';\r\n    }\r\n    // Otherwise, only enabled conditionally\r\n    const env = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.env['VSCODE_BROWSER_CODE_LOADING'];\r\n    if (typeof env === 'string') {\r\n        if (env === 'none' || env === 'code' || env === 'bypassHeatCheck' || env === 'bypassHeatCheckAndEagerCompile') {\r\n            return env;\r\n        }\r\n        return 'bypassHeatCheck';\r\n    }\r\n    return undefined;\r\n})();\r\nconst isPreferringBrowserCodeLoad = typeof browserCodeLoadingCacheStrategy === 'string';\r\n// Web environment\r\nif (typeof navigator === 'object' && !isElectronRenderer) {\r\n    _userAgent = navigator.userAgent;\r\n    _isWindows = _userAgent.indexOf('Windows') >= 0;\r\n    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\r\n    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\r\n    _isLinux = _userAgent.indexOf('Linux') >= 0;\r\n    _isWeb = true;\r\n    _locale = navigator.language;\r\n    _language = _locale;\r\n}\r\n// Native environment\r\nelse if (typeof nodeProcess === 'object') {\r\n    _isWindows = (nodeProcess.platform === 'win32');\r\n    _isMacintosh = (nodeProcess.platform === 'darwin');\r\n    _isLinux = (nodeProcess.platform === 'linux');\r\n    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\r\n    _locale = LANGUAGE_DEFAULT;\r\n    _language = LANGUAGE_DEFAULT;\r\n    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\r\n    if (rawNlsConfig) {\r\n        try {\r\n            const nlsConfig = JSON.parse(rawNlsConfig);\r\n            const resolved = nlsConfig.availableLanguages['*'];\r\n            _locale = nlsConfig.locale;\r\n            // VSCode's default language is 'en'\r\n            _language = resolved ? resolved : LANGUAGE_DEFAULT;\r\n            _translationsConfigFile = nlsConfig._translationsConfigFile;\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    _isNative = true;\r\n}\r\n// Unknown environment\r\nelse {\r\n    console.error('Unable to resolve platform.');\r\n}\r\nlet _platform = 0 /* Web */;\r\nif (_isMacintosh) {\r\n    _platform = 1 /* Mac */;\r\n}\r\nelse if (_isWindows) {\r\n    _platform = 3 /* Windows */;\r\n}\r\nelse if (_isLinux) {\r\n    _platform = 2 /* Linux */;\r\n}\r\nconst isWindows = _isWindows;\r\nconst isMacintosh = _isMacintosh;\r\nconst isLinux = (/* unused pure expression or super */ null && (_isLinux));\r\nconst isNative = (/* unused pure expression or super */ null && (_isNative));\r\nconst platform_isWeb = (/* unused pure expression or super */ null && (_isWeb));\r\nconst isIOS = (/* unused pure expression or super */ null && (_isIOS));\r\nconst userAgent = (/* unused pure expression or super */ null && (_userAgent));\r\nconst setImmediate = (function defineSetImmediate() {\r\n    if (globals.setImmediate) {\r\n        return globals.setImmediate.bind(globals);\r\n    }\r\n    if (typeof globals.postMessage === 'function' && !globals.importScripts) {\r\n        let pending = [];\r\n        globals.addEventListener('message', (e) => {\r\n            if (e.data && e.data.vscodeSetImmediateId) {\r\n                for (let i = 0, len = pending.length; i < len; i++) {\r\n                    const candidate = pending[i];\r\n                    if (candidate.id === e.data.vscodeSetImmediateId) {\r\n                        pending.splice(i, 1);\r\n                        candidate.callback();\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        let lastId = 0;\r\n        return (callback) => {\r\n            const myId = ++lastId;\r\n            pending.push({\r\n                id: myId,\r\n                callback: callback\r\n            });\r\n            globals.postMessage({ vscodeSetImmediateId: myId }, '*');\r\n        };\r\n    }\r\n    if (typeof (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.nextTick) === 'function') {\r\n        return nodeProcess.nextTick.bind(nodeProcess);\r\n    }\r\n    const _promise = Promise.resolve();\r\n    return (callback) => _promise.then(callback);\r\n})();\r\nconst OS = (_isMacintosh || _isIOS ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));\r\nlet _isLittleEndian = true;\r\nlet _isLittleEndianComputed = false;\r\nfunction isLittleEndian() {\r\n    if (!_isLittleEndianComputed) {\r\n        _isLittleEndianComputed = true;\r\n        const test = new Uint8Array(2);\r\n        test[0] = 1;\r\n        test[1] = 2;\r\n        const view = new Uint16Array(test.buffer);\r\n        _isLittleEndian = (view[0] === (2 << 8) + 1);\r\n    }\r\n    return _isLittleEndian;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/types.js\n/**\r\n * @returns whether the provided parameter is a JavaScript Array or not.\r\n */\r\nfunction isArray(array) {\r\n    return Array.isArray(array);\r\n}\r\n/**\r\n * @returns whether the provided parameter is a JavaScript String or not.\r\n */\r\nfunction isString(str) {\r\n    return (typeof str === 'string');\r\n}\r\n/**\r\n *\r\n * @returns whether the provided parameter is of type `object` but **not**\r\n *\t`null`, an `array`, a `regexp`, nor a `date`.\r\n */\r\nfunction isObject(obj) {\r\n    // The method can't do a type cast since there are type (like strings) which\r\n    // are subclasses of any put not positvely matched by the function. Hence type\r\n    // narrowing results in wrong results.\r\n    return typeof obj === 'object'\r\n        && obj !== null\r\n        && !Array.isArray(obj)\r\n        && !(obj instanceof RegExp)\r\n        && !(obj instanceof Date);\r\n}\r\n/**\r\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\r\n * @returns whether the provided parameter is a JavaScript Number or not.\r\n */\r\nfunction isNumber(obj) {\r\n    return (typeof obj === 'number' && !isNaN(obj));\r\n}\r\n/**\r\n * @returns whether the provided parameter is a JavaScript Boolean or not.\r\n */\r\nfunction isBoolean(obj) {\r\n    return (obj === true || obj === false);\r\n}\r\n/**\r\n * @returns whether the provided parameter is undefined.\r\n */\r\nfunction isUndefined(obj) {\r\n    return (typeof obj === 'undefined');\r\n}\r\n/**\r\n * @returns whether the provided parameter is undefined or null.\r\n */\r\nfunction isUndefinedOrNull(obj) {\r\n    return (isUndefined(obj) || obj === null);\r\n}\r\nfunction assertType(condition, type) {\r\n    if (!condition) {\r\n        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\r\n    }\r\n}\r\n/**\r\n * Asserts that the argument passed in is neither undefined nor null.\r\n */\r\nfunction assertIsDefined(arg) {\r\n    if (isUndefinedOrNull(arg)) {\r\n        throw new Error('Assertion Failed: argument is undefined or null');\r\n    }\r\n    return arg;\r\n}\r\n/**\r\n * @returns whether the provided parameter is a JavaScript Function or not.\r\n */\r\nfunction isFunction(obj) {\r\n    return (typeof obj === 'function');\r\n}\r\nfunction validateConstraints(args, constraints) {\r\n    const len = Math.min(args.length, constraints.length);\r\n    for (let i = 0; i < len; i++) {\r\n        validateConstraint(args[i], constraints[i]);\r\n    }\r\n}\r\nfunction validateConstraint(arg, constraint) {\r\n    if (isString(constraint)) {\r\n        if (typeof arg !== constraint) {\r\n            throw new Error(`argument does not match constraint: typeof ${constraint}`);\r\n        }\r\n    }\r\n    else if (isFunction(constraint)) {\r\n        try {\r\n            if (arg instanceof constraint) {\r\n                return;\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // ignore\r\n        }\r\n        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {\r\n            return;\r\n        }\r\n        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\r\n            return;\r\n        }\r\n        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\r\n    }\r\n}\r\nfunction getAllPropertyNames(obj) {\r\n    let res = [];\r\n    let proto = Object.getPrototypeOf(obj);\r\n    while (Object.prototype !== proto) {\r\n        res = res.concat(Object.getOwnPropertyNames(proto));\r\n        proto = Object.getPrototypeOf(proto);\r\n    }\r\n    return res;\r\n}\r\nfunction getAllMethodNames(obj) {\r\n    const methods = [];\r\n    for (const prop of getAllPropertyNames(obj)) {\r\n        if (typeof obj[prop] === 'function') {\r\n            methods.push(prop);\r\n        }\r\n    }\r\n    return methods;\r\n}\r\nfunction createProxyObject(methodNames, invoke) {\r\n    const createProxyMethod = (method) => {\r\n        return function () {\r\n            const args = Array.prototype.slice.call(arguments, 0);\r\n            return invoke(method, args);\r\n        };\r\n    };\r\n    let result = {};\r\n    for (const methodName of methodNames) {\r\n        result[methodName] = createProxyMethod(methodName);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Converts null to undefined, passes all other values through.\r\n */\r\nfunction withNullAsUndefined(x) {\r\n    return x === null ? undefined : x;\r\n}\r\nfunction assertNever(value, message = 'Unreachable') {\r\n    throw new Error(message);\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nconst INITIALIZE = '$initialize';\r\nlet webWorkerWarningLogged = false;\r\nfunction logOnceWebWorkerWarning(err) {\r\n    if (!isWeb) {\r\n        // running tests\r\n        return;\r\n    }\r\n    if (!webWorkerWarningLogged) {\r\n        webWorkerWarningLogged = true;\r\n        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\r\n    }\r\n    console.warn(err.message);\r\n}\r\nclass SimpleWorkerProtocol {\r\n    constructor(handler) {\r\n        this._workerId = -1;\r\n        this._handler = handler;\r\n        this._lastSentReq = 0;\r\n        this._pendingReplies = Object.create(null);\r\n    }\r\n    setWorkerId(workerId) {\r\n        this._workerId = workerId;\r\n    }\r\n    sendMessage(method, args) {\r\n        let req = String(++this._lastSentReq);\r\n        return new Promise((resolve, reject) => {\r\n            this._pendingReplies[req] = {\r\n                resolve: resolve,\r\n                reject: reject\r\n            };\r\n            this._send({\r\n                vsWorker: this._workerId,\r\n                req: req,\r\n                method: method,\r\n                args: args\r\n            });\r\n        });\r\n    }\r\n    handleMessage(message) {\r\n        if (!message || !message.vsWorker) {\r\n            return;\r\n        }\r\n        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n            return;\r\n        }\r\n        this._handleMessage(message);\r\n    }\r\n    _handleMessage(msg) {\r\n        if (msg.seq) {\r\n            let replyMessage = msg;\r\n            if (!this._pendingReplies[replyMessage.seq]) {\r\n                console.warn('Got reply to unknown seq');\r\n                return;\r\n            }\r\n            let reply = this._pendingReplies[replyMessage.seq];\r\n            delete this._pendingReplies[replyMessage.seq];\r\n            if (replyMessage.err) {\r\n                let err = replyMessage.err;\r\n                if (replyMessage.err.$isError) {\r\n                    err = new Error();\r\n                    err.name = replyMessage.err.name;\r\n                    err.message = replyMessage.err.message;\r\n                    err.stack = replyMessage.err.stack;\r\n                }\r\n                reply.reject(err);\r\n                return;\r\n            }\r\n            reply.resolve(replyMessage.res);\r\n            return;\r\n        }\r\n        let requestMessage = msg;\r\n        let req = requestMessage.req;\r\n        let result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\r\n        result.then((r) => {\r\n            this._send({\r\n                vsWorker: this._workerId,\r\n                seq: req,\r\n                res: r,\r\n                err: undefined\r\n            });\r\n        }, (e) => {\r\n            if (e.detail instanceof Error) {\r\n                // Loading errors have a detail property that points to the actual error\r\n                e.detail = transformErrorForSerialization(e.detail);\r\n            }\r\n            this._send({\r\n                vsWorker: this._workerId,\r\n                seq: req,\r\n                res: undefined,\r\n                err: transformErrorForSerialization(e)\r\n            });\r\n        });\r\n    }\r\n    _send(msg) {\r\n        let transfer = [];\r\n        if (msg.req) {\r\n            const m = msg;\r\n            for (let i = 0; i < m.args.length; i++) {\r\n                if (m.args[i] instanceof ArrayBuffer) {\r\n                    transfer.push(m.args[i]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            const m = msg;\r\n            if (m.res instanceof ArrayBuffer) {\r\n                transfer.push(m.res);\r\n            }\r\n        }\r\n        this._handler.sendMessage(msg, transfer);\r\n    }\r\n}\r\n/**\r\n * Main thread side\r\n */\r\nclass SimpleWorkerClient extends (/* unused pure expression or super */ null && (Disposable)) {\r\n    constructor(workerFactory, moduleId, host) {\r\n        super();\r\n        let lazyProxyReject = null;\r\n        this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {\r\n            this._protocol.handleMessage(msg);\r\n        }, (err) => {\r\n            // in Firefox, web workers fail lazily :(\r\n            // we will reject the proxy\r\n            if (lazyProxyReject) {\r\n                lazyProxyReject(err);\r\n            }\r\n        }));\r\n        this._protocol = new SimpleWorkerProtocol({\r\n            sendMessage: (msg, transfer) => {\r\n                this._worker.postMessage(msg, transfer);\r\n            },\r\n            handleMessage: (method, args) => {\r\n                if (typeof host[method] !== 'function') {\r\n                    return Promise.reject(new Error('Missing method ' + method + ' on main thread host.'));\r\n                }\r\n                try {\r\n                    return Promise.resolve(host[method].apply(host, args));\r\n                }\r\n                catch (e) {\r\n                    return Promise.reject(e);\r\n                }\r\n            }\r\n        });\r\n        this._protocol.setWorkerId(this._worker.getId());\r\n        // Gather loader configuration\r\n        let loaderConfiguration = null;\r\n        if (typeof self.require !== 'undefined' && typeof self.require.getConfig === 'function') {\r\n            // Get the configuration from the Monaco AMD Loader\r\n            loaderConfiguration = self.require.getConfig();\r\n        }\r\n        else if (typeof self.requirejs !== 'undefined') {\r\n            // Get the configuration from requirejs\r\n            loaderConfiguration = self.requirejs.s.contexts._.config;\r\n        }\r\n        const hostMethods = types.getAllMethodNames(host);\r\n        // Send initialize message\r\n        this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\r\n            this._worker.getId(),\r\n            JSON.parse(JSON.stringify(loaderConfiguration)),\r\n            moduleId,\r\n            hostMethods,\r\n        ]);\r\n        // Create proxy to loaded code\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._request(method, args);\r\n        };\r\n        this._lazyProxy = new Promise((resolve, reject) => {\r\n            lazyProxyReject = reject;\r\n            this._onModuleLoaded.then((availableMethods) => {\r\n                resolve(types.createProxyObject(availableMethods, proxyMethodRequest));\r\n            }, (e) => {\r\n                reject(e);\r\n                this._onError('Worker failed to load ' + moduleId, e);\r\n            });\r\n        });\r\n    }\r\n    getProxyObject() {\r\n        return this._lazyProxy;\r\n    }\r\n    _request(method, args) {\r\n        return new Promise((resolve, reject) => {\r\n            this._onModuleLoaded.then(() => {\r\n                this._protocol.sendMessage(method, args).then(resolve, reject);\r\n            }, reject);\r\n        });\r\n    }\r\n    _onError(message, error) {\r\n        console.error(message);\r\n        console.info(error);\r\n    }\r\n}\r\n/**\r\n * Worker side\r\n */\r\nclass SimpleWorkerServer {\r\n    constructor(postMessage, requestHandlerFactory) {\r\n        this._requestHandlerFactory = requestHandlerFactory;\r\n        this._requestHandler = null;\r\n        this._protocol = new SimpleWorkerProtocol({\r\n            sendMessage: (msg, transfer) => {\r\n                postMessage(msg, transfer);\r\n            },\r\n            handleMessage: (method, args) => this._handleMessage(method, args)\r\n        });\r\n    }\r\n    onmessage(msg) {\r\n        this._protocol.handleMessage(msg);\r\n    }\r\n    _handleMessage(method, args) {\r\n        if (method === INITIALIZE) {\r\n            return this.initialize(args[0], args[1], args[2], args[3]);\r\n        }\r\n        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\r\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\r\n        }\r\n        try {\r\n            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n    initialize(workerId, loaderConfig, moduleId, hostMethods) {\r\n        this._protocol.setWorkerId(workerId);\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._protocol.sendMessage(method, args);\r\n        };\r\n        const hostProxy = createProxyObject(hostMethods, proxyMethodRequest);\r\n        if (this._requestHandlerFactory) {\r\n            // static request handler\r\n            this._requestHandler = this._requestHandlerFactory(hostProxy);\r\n            return Promise.resolve(getAllMethodNames(this._requestHandler));\r\n        }\r\n        if (loaderConfig) {\r\n            // Remove 'baseUrl', handling it is beyond scope for now\r\n            if (typeof loaderConfig.baseUrl !== 'undefined') {\r\n                delete loaderConfig['baseUrl'];\r\n            }\r\n            if (typeof loaderConfig.paths !== 'undefined') {\r\n                if (typeof loaderConfig.paths.vs !== 'undefined') {\r\n                    delete loaderConfig.paths['vs'];\r\n                }\r\n            }\r\n            if (typeof loaderConfig.trustedTypesPolicy !== undefined) {\r\n                // don't use, it has been destroyed during serialize\r\n                delete loaderConfig['trustedTypesPolicy'];\r\n            }\r\n            // Since this is in a web worker, enable catching errors\r\n            loaderConfig.catchError = true;\r\n            self.require.config(loaderConfig);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            // Use the global require to be sure to get the global config\r\n            self.require([moduleId], (module) => {\r\n                this._requestHandler = module.create(hostProxy);\r\n                if (!this._requestHandler) {\r\n                    reject(new Error(`No RequestHandler!`));\r\n                    return;\r\n                }\r\n                resolve(getAllMethodNames(this._requestHandler));\r\n            }, reject);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Called on the worker side\r\n */\r\nfunction create(postMessage) {\r\n    return new SimpleWorkerServer(postMessage, null);\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * Represents information about a specific difference between two sequences.\r\n */\r\nclass DiffChange {\r\n    /**\r\n     * Constructs a new DiffChange with the given sequence information\r\n     * and content.\r\n     */\r\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\r\n        this.originalStart = originalStart;\r\n        this.originalLength = originalLength;\r\n        this.modifiedStart = modifiedStart;\r\n        this.modifiedLength = modifiedLength;\r\n    }\r\n    /**\r\n     * The end point (exclusive) of the change in the original sequence.\r\n     */\r\n    getOriginalEnd() {\r\n        return this.originalStart + this.originalLength;\r\n    }\r\n    /**\r\n     * The end point (exclusive) of the change in the modified sequence.\r\n     */\r\n    getModifiedEnd() {\r\n        return this.modifiedStart + this.modifiedLength;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/strings.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction isFalsyOrWhitespace(str) {\r\n    if (!str || typeof str !== 'string') {\r\n        return true;\r\n    }\r\n    return str.trim().length === 0;\r\n}\r\nconst _formatRegexp = /{(\\d+)}/g;\r\n/**\r\n * Helper to produce a string with a variable number of arguments. Insert variable segments\r\n * into the string using the {n} notation where N is the index of the argument following the string.\r\n * @param value string to which formatting is applied\r\n * @param args replacements for {n}-entries\r\n */\r\nfunction strings_format(value, ...args) {\r\n    if (args.length === 0) {\r\n        return value;\r\n    }\r\n    return value.replace(_formatRegexp, function (match, group) {\r\n        const idx = parseInt(group, 10);\r\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\r\n            match :\r\n            args[idx];\r\n    });\r\n}\r\n/**\r\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\r\n * being used e.g. in HTMLElement.innerHTML.\r\n */\r\nfunction strings_escape(html) {\r\n    return html.replace(/[<>&]/g, function (match) {\r\n        switch (match) {\r\n            case '<': return '&lt;';\r\n            case '>': return '&gt;';\r\n            case '&': return '&amp;';\r\n            default: return match;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Escapes regular expression characters in a given string\r\n */\r\nfunction escapeRegExpCharacters(value) {\r\n    return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\r\n}\r\n/**\r\n * Removes all occurrences of needle from the beginning and end of haystack.\r\n * @param haystack string to trim\r\n * @param needle the thing to trim (default is a blank)\r\n */\r\nfunction trim(haystack, needle = ' ') {\r\n    const trimmed = ltrim(haystack, needle);\r\n    return rtrim(trimmed, needle);\r\n}\r\n/**\r\n * Removes all occurrences of needle from the beginning of haystack.\r\n * @param haystack string to trim\r\n * @param needle the thing to trim\r\n */\r\nfunction ltrim(haystack, needle) {\r\n    if (!haystack || !needle) {\r\n        return haystack;\r\n    }\r\n    const needleLen = needle.length;\r\n    if (needleLen === 0 || haystack.length === 0) {\r\n        return haystack;\r\n    }\r\n    let offset = 0;\r\n    while (haystack.indexOf(needle, offset) === offset) {\r\n        offset = offset + needleLen;\r\n    }\r\n    return haystack.substring(offset);\r\n}\r\n/**\r\n * Removes all occurrences of needle from the end of haystack.\r\n * @param haystack string to trim\r\n * @param needle the thing to trim\r\n */\r\nfunction rtrim(haystack, needle) {\r\n    if (!haystack || !needle) {\r\n        return haystack;\r\n    }\r\n    const needleLen = needle.length, haystackLen = haystack.length;\r\n    if (needleLen === 0 || haystackLen === 0) {\r\n        return haystack;\r\n    }\r\n    let offset = haystackLen, idx = -1;\r\n    while (true) {\r\n        idx = haystack.lastIndexOf(needle, offset - 1);\r\n        if (idx === -1 || idx + needleLen !== offset) {\r\n            break;\r\n        }\r\n        if (idx === 0) {\r\n            return '';\r\n        }\r\n        offset = idx;\r\n    }\r\n    return haystack.substring(0, offset);\r\n}\r\nfunction convertSimple2RegExpPattern(pattern) {\r\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\r\n}\r\nfunction stripWildcards(pattern) {\r\n    return pattern.replace(/\\*/g, '');\r\n}\r\nfunction createRegExp(searchString, isRegex, options = {}) {\r\n    if (!searchString) {\r\n        throw new Error('Cannot create regex from empty string');\r\n    }\r\n    if (!isRegex) {\r\n        searchString = escapeRegExpCharacters(searchString);\r\n    }\r\n    if (options.wholeWord) {\r\n        if (!/\\B/.test(searchString.charAt(0))) {\r\n            searchString = '\\\\b' + searchString;\r\n        }\r\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\r\n            searchString = searchString + '\\\\b';\r\n        }\r\n    }\r\n    let modifiers = '';\r\n    if (options.global) {\r\n        modifiers += 'g';\r\n    }\r\n    if (!options.matchCase) {\r\n        modifiers += 'i';\r\n    }\r\n    if (options.multiline) {\r\n        modifiers += 'm';\r\n    }\r\n    if (options.unicode) {\r\n        modifiers += 'u';\r\n    }\r\n    return new RegExp(searchString, modifiers);\r\n}\r\nfunction regExpLeadsToEndlessLoop(regexp) {\r\n    // Exit early if it's one of these special cases which are meant to match\r\n    // against an empty string\r\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\r\n        return false;\r\n    }\r\n    // We check against an empty string. If the regular expression doesn't advance\r\n    // (e.g. ends in an endless loop) it will match an empty string.\r\n    const match = regexp.exec('');\r\n    return !!(match && regexp.lastIndex === 0);\r\n}\r\nfunction regExpFlags(regexp) {\r\n    return (regexp.global ? 'g' : '')\r\n        + (regexp.ignoreCase ? 'i' : '')\r\n        + (regexp.multiline ? 'm' : '')\r\n        + (regexp /* standalone editor compilation */.unicode ? 'u' : '');\r\n}\r\nfunction splitLines(str) {\r\n    return str.split(/\\r\\n|\\r|\\n/);\r\n}\r\n/**\r\n * Returns first index of the string that is not whitespace.\r\n * If string is empty or contains only whitespaces, returns -1\r\n */\r\nfunction firstNonWhitespaceIndex(str) {\r\n    for (let i = 0, len = str.length; i < len; i++) {\r\n        const chCode = str.charCodeAt(i);\r\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Returns the leading whitespace of the string.\r\n * If the string contains only whitespaces, returns entire string\r\n */\r\nfunction getLeadingWhitespace(str, start = 0, end = str.length) {\r\n    for (let i = start; i < end; i++) {\r\n        const chCode = str.charCodeAt(i);\r\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\r\n            return str.substring(start, i);\r\n        }\r\n    }\r\n    return str.substring(start, end);\r\n}\r\n/**\r\n * Returns last index of the string that is not whitespace.\r\n * If string is empty or contains only whitespaces, returns -1\r\n */\r\nfunction lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\r\n    for (let i = startIndex; i >= 0; i--) {\r\n        const chCode = str.charCodeAt(i);\r\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction compare(a, b) {\r\n    if (a < b) {\r\n        return -1;\r\n    }\r\n    else if (a > b) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nfunction compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\r\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\r\n        let codeA = a.charCodeAt(aStart);\r\n        let codeB = b.charCodeAt(bStart);\r\n        if (codeA < codeB) {\r\n            return -1;\r\n        }\r\n        else if (codeA > codeB) {\r\n            return 1;\r\n        }\r\n    }\r\n    const aLen = aEnd - aStart;\r\n    const bLen = bEnd - bStart;\r\n    if (aLen < bLen) {\r\n        return -1;\r\n    }\r\n    else if (aLen > bLen) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction compareIgnoreCase(a, b) {\r\n    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\r\n}\r\nfunction compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\r\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\r\n        let codeA = a.charCodeAt(aStart);\r\n        let codeB = b.charCodeAt(bStart);\r\n        if (codeA === codeB) {\r\n            // equal\r\n            continue;\r\n        }\r\n        const diff = codeA - codeB;\r\n        if (diff === 32 && isUpperAsciiLetter(codeB)) { //codeB =[65-90] && codeA =[97-122]\r\n            continue;\r\n        }\r\n        else if (diff === -32 && isUpperAsciiLetter(codeA)) { //codeB =[97-122] && codeA =[65-90]\r\n            continue;\r\n        }\r\n        if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\r\n            //\r\n            return diff;\r\n        }\r\n        else {\r\n            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\r\n        }\r\n    }\r\n    const aLen = aEnd - aStart;\r\n    const bLen = bEnd - bStart;\r\n    if (aLen < bLen) {\r\n        return -1;\r\n    }\r\n    else if (aLen > bLen) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction isLowerAsciiLetter(code) {\r\n    return code >= 97 /* a */ && code <= 122 /* z */;\r\n}\r\nfunction isUpperAsciiLetter(code) {\r\n    return code >= 65 /* A */ && code <= 90 /* Z */;\r\n}\r\nfunction isAsciiLetter(code) {\r\n    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\r\n}\r\nfunction equalsIgnoreCase(a, b) {\r\n    return a.length === b.length && doEqualsIgnoreCase(a, b);\r\n}\r\nfunction doEqualsIgnoreCase(a, b, stopAt = a.length) {\r\n    for (let i = 0; i < stopAt; i++) {\r\n        const codeA = a.charCodeAt(i);\r\n        const codeB = b.charCodeAt(i);\r\n        if (codeA === codeB) {\r\n            continue;\r\n        }\r\n        // a-z A-Z\r\n        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\r\n            const diff = Math.abs(codeA - codeB);\r\n            if (diff !== 0 && diff !== 32) {\r\n                return false;\r\n            }\r\n        }\r\n        // Any other charcode\r\n        else {\r\n            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction startsWithIgnoreCase(str, candidate) {\r\n    const candidateLength = candidate.length;\r\n    if (candidate.length > str.length) {\r\n        return false;\r\n    }\r\n    return doEqualsIgnoreCase(str, candidate, candidateLength);\r\n}\r\n/**\r\n * @returns the length of the common prefix of the two strings.\r\n */\r\nfunction commonPrefixLength(a, b) {\r\n    let i, len = Math.min(a.length, b.length);\r\n    for (i = 0; i < len; i++) {\r\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return len;\r\n}\r\n/**\r\n * @returns the length of the common suffix of the two strings.\r\n */\r\nfunction commonSuffixLength(a, b) {\r\n    let i, len = Math.min(a.length, b.length);\r\n    const aLastIndex = a.length - 1;\r\n    const bLastIndex = b.length - 1;\r\n    for (i = 0; i < len; i++) {\r\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return len;\r\n}\r\n/**\r\n * See http://en.wikipedia.org/wiki/Surrogate_pair\r\n */\r\nfunction isHighSurrogate(charCode) {\r\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\r\n}\r\n/**\r\n * See http://en.wikipedia.org/wiki/Surrogate_pair\r\n */\r\nfunction isLowSurrogate(charCode) {\r\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\r\n}\r\n/**\r\n * See http://en.wikipedia.org/wiki/Surrogate_pair\r\n */\r\nfunction computeCodePoint(highSurrogate, lowSurrogate) {\r\n    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\r\n}\r\n/**\r\n * get the code point that begins at offset `offset`\r\n */\r\nfunction getNextCodePoint(str, len, offset) {\r\n    const charCode = str.charCodeAt(offset);\r\n    if (isHighSurrogate(charCode) && offset + 1 < len) {\r\n        const nextCharCode = str.charCodeAt(offset + 1);\r\n        if (isLowSurrogate(nextCharCode)) {\r\n            return computeCodePoint(charCode, nextCharCode);\r\n        }\r\n    }\r\n    return charCode;\r\n}\r\n/**\r\n * get the code point that ends right before offset `offset`\r\n */\r\nfunction getPrevCodePoint(str, offset) {\r\n    const charCode = str.charCodeAt(offset - 1);\r\n    if (isLowSurrogate(charCode) && offset > 1) {\r\n        const prevCharCode = str.charCodeAt(offset - 2);\r\n        if (isHighSurrogate(prevCharCode)) {\r\n            return computeCodePoint(prevCharCode, charCode);\r\n        }\r\n    }\r\n    return charCode;\r\n}\r\nfunction nextCharLength(str, offset) {\r\n    const graphemeBreakTree = GraphemeBreakTree.getInstance();\r\n    const initialOffset = offset;\r\n    const len = str.length;\r\n    const initialCodePoint = getNextCodePoint(str, len, offset);\r\n    offset += (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\r\n    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\r\n    while (offset < len) {\r\n        const nextCodePoint = getNextCodePoint(str, len, offset);\r\n        const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);\r\n        if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\r\n            break;\r\n        }\r\n        offset += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\r\n        graphemeBreakType = nextGraphemeBreakType;\r\n    }\r\n    return (offset - initialOffset);\r\n}\r\nfunction prevCharLength(str, offset) {\r\n    const graphemeBreakTree = GraphemeBreakTree.getInstance();\r\n    const initialOffset = offset;\r\n    const initialCodePoint = getPrevCodePoint(str, offset);\r\n    offset -= (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\r\n    let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);\r\n    while (offset > 0) {\r\n        const prevCodePoint = getPrevCodePoint(str, offset);\r\n        const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);\r\n        if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\r\n            break;\r\n        }\r\n        offset -= (prevCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\r\n        graphemeBreakType = prevGraphemeBreakType;\r\n    }\r\n    return (initialOffset - offset);\r\n}\r\n/**\r\n * A manual decoding of a UTF8 string.\r\n * Use only in environments which do not offer native conversion methods!\r\n */\r\nfunction decodeUTF8(buffer) {\r\n    // https://en.wikipedia.org/wiki/UTF-8\r\n    const len = buffer.byteLength;\r\n    const result = [];\r\n    let offset = 0;\r\n    while (offset < len) {\r\n        const v0 = buffer[offset];\r\n        let codePoint;\r\n        if (v0 >= 0b11110000 && offset + 3 < len) {\r\n            // 4 bytes\r\n            codePoint = ((((buffer[offset++] & 0b00000111) << 18) >>> 0)\r\n                | (((buffer[offset++] & 0b00111111) << 12) >>> 0)\r\n                | (((buffer[offset++] & 0b00111111) << 6) >>> 0)\r\n                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));\r\n        }\r\n        else if (v0 >= 0b11100000 && offset + 2 < len) {\r\n            // 3 bytes\r\n            codePoint = ((((buffer[offset++] & 0b00001111) << 12) >>> 0)\r\n                | (((buffer[offset++] & 0b00111111) << 6) >>> 0)\r\n                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));\r\n        }\r\n        else if (v0 >= 0b11000000 && offset + 1 < len) {\r\n            // 2 bytes\r\n            codePoint = ((((buffer[offset++] & 0b00011111) << 6) >>> 0)\r\n                | (((buffer[offset++] & 0b00111111) << 0) >>> 0));\r\n        }\r\n        else {\r\n            // 1 byte\r\n            codePoint = buffer[offset++];\r\n        }\r\n        if ((codePoint >= 0 && codePoint <= 0xD7FF) || (codePoint >= 0xE000 && codePoint <= 0xFFFF)) {\r\n            // Basic Multilingual Plane\r\n            result.push(String.fromCharCode(codePoint));\r\n        }\r\n        else if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\r\n            // Supplementary Planes\r\n            const uPrime = codePoint - 0x10000;\r\n            const w1 = 0xD800 + ((uPrime & 0b11111111110000000000) >>> 10);\r\n            const w2 = 0xDC00 + ((uPrime & 0b00000000001111111111) >>> 0);\r\n            result.push(String.fromCharCode(w1));\r\n            result.push(String.fromCharCode(w2));\r\n        }\r\n        else {\r\n            // illegal code point\r\n            result.push(String.fromCharCode(0xFFFD));\r\n        }\r\n    }\r\n    return result.join('');\r\n}\r\n/**\r\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-rtl-test.js\r\n */\r\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u08BD\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE33\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDCFF]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD50-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\r\n/**\r\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\r\n */\r\nfunction containsRTL(str) {\r\n    return CONTAINS_RTL.test(str);\r\n}\r\n/**\r\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\r\n */\r\nconst CONTAINS_EMOJI = /(?:[\\u231A\\u231B\\u23F0\\u23F3\\u2600-\\u27BF\\u2B50\\u2B55]|\\uD83C[\\uDDE6-\\uDDFF\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDE4F\\uDE80-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD00-\\uDDFF\\uDE70-\\uDED6])/;\r\nfunction containsEmoji(str) {\r\n    return CONTAINS_EMOJI.test(str);\r\n}\r\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\r\n/**\r\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\r\n */\r\nfunction isBasicASCII(str) {\r\n    return IS_BASIC_ASCII.test(str);\r\n}\r\nconst UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\r\n/**\r\n * Returns true if `str` contains unusual line terminators, like LS or PS\r\n */\r\nfunction containsUnusualLineTerminators(str) {\r\n    return UNUSUAL_LINE_TERMINATORS.test(str);\r\n}\r\nfunction containsFullWidthCharacter(str) {\r\n    for (let i = 0, len = str.length; i < len; i++) {\r\n        if (isFullWidthCharacter(str.charCodeAt(i))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction isFullWidthCharacter(charCode) {\r\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\r\n    // http://jrgraphix.net/research/unicode_blocks.php\r\n    //          2E80 — 2EFF   CJK Radicals Supplement\r\n    //          2F00 — 2FDF   Kangxi Radicals\r\n    //          2FF0 — 2FFF   Ideographic Description Characters\r\n    //          3000 — 303F   CJK Symbols and Punctuation\r\n    //          3040 — 309F   Hiragana\r\n    //          30A0 — 30FF   Katakana\r\n    //          3100 — 312F   Bopomofo\r\n    //          3130 — 318F   Hangul Compatibility Jamo\r\n    //          3190 — 319F   Kanbun\r\n    //          31A0 — 31BF   Bopomofo Extended\r\n    //          31F0 — 31FF   Katakana Phonetic Extensions\r\n    //          3200 — 32FF   Enclosed CJK Letters and Months\r\n    //          3300 — 33FF   CJK Compatibility\r\n    //          3400 — 4DBF   CJK Unified Ideographs Extension A\r\n    //          4DC0 — 4DFF   Yijing Hexagram Symbols\r\n    //          4E00 — 9FFF   CJK Unified Ideographs\r\n    //          A000 — A48F   Yi Syllables\r\n    //          A490 — A4CF   Yi Radicals\r\n    //          AC00 — D7AF   Hangul Syllables\r\n    // [IGNORE] D800 — DB7F   High Surrogates\r\n    // [IGNORE] DB80 — DBFF   High Private Use Surrogates\r\n    // [IGNORE] DC00 — DFFF   Low Surrogates\r\n    // [IGNORE] E000 — F8FF   Private Use Area\r\n    //          F900 — FAFF   CJK Compatibility Ideographs\r\n    // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\r\n    // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\r\n    // [IGNORE] FE00 — FE0F   Variation Selectors\r\n    // [IGNORE] FE20 — FE2F   Combining Half Marks\r\n    // [IGNORE] FE30 — FE4F   CJK Compatibility Forms\r\n    // [IGNORE] FE50 — FE6F   Small Form Variants\r\n    // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\r\n    //          FF00 — FFEF   Halfwidth and Fullwidth Forms\r\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\r\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\r\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\r\n    // [IGNORE] FFF0 — FFFF   Specials\r\n    charCode = +charCode; // @perf\r\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\r\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\r\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\r\n}\r\n/**\r\n * A fast function (therefore imprecise) to check if code points are emojis.\r\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\r\n */\r\nfunction isEmojiImprecise(x) {\r\n    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\r\n        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\r\n        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\r\n        || (x >= 128992 && x <= 129003) || (x >= 129280 && x <= 129535)\r\n        || (x >= 129648 && x <= 129750));\r\n}\r\n// -- UTF-8 BOM\r\nconst UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);\r\nfunction startsWithUTF8BOM(str) {\r\n    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);\r\n}\r\nfunction containsUppercaseCharacter(target, ignoreEscapedChars = false) {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (ignoreEscapedChars) {\r\n        target = target.replace(/\\\\./g, '');\r\n    }\r\n    return target.toLowerCase() !== target;\r\n}\r\n/**\r\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\r\n */\r\nfunction singleLetterHash(n) {\r\n    const LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);\r\n    n = n % (2 * LETTERS_CNT);\r\n    if (n < LETTERS_CNT) {\r\n        return String.fromCharCode(97 /* a */ + n);\r\n    }\r\n    return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);\r\n}\r\n//#region Unicode Grapheme Break\r\nfunction getGraphemeBreakType(codePoint) {\r\n    const graphemeBreakTree = GraphemeBreakTree.getInstance();\r\n    return graphemeBreakTree.getGraphemeBreakType(codePoint);\r\n}\r\nfunction breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {\r\n    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\r\n    // !!! Let's make the common case a bit faster\r\n    if (breakTypeA === 0 /* Other */) {\r\n        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\r\n        return (breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */);\r\n    }\r\n    // Do not break between a CR and LF. Otherwise, break before and after controls.\r\n    // GB3                                        CR × LF\r\n    // GB4                       (Control | CR | LF) ÷\r\n    // GB5                                           ÷ (Control | CR | LF)\r\n    if (breakTypeA === 2 /* CR */) {\r\n        if (breakTypeB === 3 /* LF */) {\r\n            return false; // GB3\r\n        }\r\n    }\r\n    if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {\r\n        return true; // GB4\r\n    }\r\n    if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {\r\n        return true; // GB5\r\n    }\r\n    // Do not break Hangul syllable sequences.\r\n    // GB6                                         L × (L | V | LV | LVT)\r\n    // GB7                                  (LV | V) × (V | T)\r\n    // GB8                                 (LVT | T) × T\r\n    if (breakTypeA === 8 /* L */) {\r\n        if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {\r\n            return false; // GB6\r\n        }\r\n    }\r\n    if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {\r\n        if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {\r\n            return false; // GB7\r\n        }\r\n    }\r\n    if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {\r\n        if (breakTypeB === 10 /* T */) {\r\n            return false; // GB8\r\n        }\r\n    }\r\n    // Do not break before extending characters or ZWJ.\r\n    // GB9                                           × (Extend | ZWJ)\r\n    if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {\r\n        return false; // GB9\r\n    }\r\n    // The GB9a and GB9b rules only apply to extended grapheme clusters:\r\n    // Do not break before SpacingMarks, or after Prepend characters.\r\n    // GB9a                                          × SpacingMark\r\n    // GB9b                                  Prepend ×\r\n    if (breakTypeB === 7 /* SpacingMark */) {\r\n        return false; // GB9a\r\n    }\r\n    if (breakTypeA === 1 /* Prepend */) {\r\n        return false; // GB9b\r\n    }\r\n    // Do not break within emoji modifier sequences or emoji zwj sequences.\r\n    // GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\r\n    if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {\r\n        // Note: we are not implementing the rule entirely here to avoid introducing states\r\n        return false; // GB11\r\n    }\r\n    // GB12                          sot (RI RI)* RI × RI\r\n    // GB13                        [^RI] (RI RI)* RI × RI\r\n    if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {\r\n        // Note: we are not implementing the rule entirely here to avoid introducing states\r\n        return false; // GB12 & GB13\r\n    }\r\n    // GB999                                     Any ÷ Any\r\n    return true;\r\n}\r\nclass GraphemeBreakTree {\r\n    constructor() {\r\n        this._data = getGraphemeBreakRawData();\r\n    }\r\n    static getInstance() {\r\n        if (!GraphemeBreakTree._INSTANCE) {\r\n            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\r\n        }\r\n        return GraphemeBreakTree._INSTANCE;\r\n    }\r\n    getGraphemeBreakType(codePoint) {\r\n        // !!! Let's make 7bit ASCII a bit faster: 0..31\r\n        if (codePoint < 32) {\r\n            if (codePoint === 10 /* LineFeed */) {\r\n                return 3 /* LF */;\r\n            }\r\n            if (codePoint === 13 /* CarriageReturn */) {\r\n                return 2 /* CR */;\r\n            }\r\n            return 4 /* Control */;\r\n        }\r\n        // !!! Let's make 7bit ASCII a bit faster: 32..126\r\n        if (codePoint < 127) {\r\n            return 0 /* Other */;\r\n        }\r\n        const data = this._data;\r\n        const nodeCount = data.length / 3;\r\n        let nodeIndex = 1;\r\n        while (nodeIndex <= nodeCount) {\r\n            if (codePoint < data[3 * nodeIndex]) {\r\n                // go left\r\n                nodeIndex = 2 * nodeIndex;\r\n            }\r\n            else if (codePoint > data[3 * nodeIndex + 1]) {\r\n                // go right\r\n                nodeIndex = 2 * nodeIndex + 1;\r\n            }\r\n            else {\r\n                // hit\r\n                return data[3 * nodeIndex + 2];\r\n            }\r\n        }\r\n        return 0 /* Other */;\r\n    }\r\n}\r\nGraphemeBreakTree._INSTANCE = null;\r\nfunction getGraphemeBreakRawData() {\r\n    // generated using https://github.com/alexdima/unicode-utils/blob/master/generate-grapheme-break.js\r\n    return JSON.parse('[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]');\r\n}\r\n//#endregion\r\n/**\r\n * Computes the offset after performing a left delete on the given string,\r\n * while considering unicode grapheme/emoji rules.\r\n*/\r\nfunction getLeftDeleteOffset(offset, str) {\r\n    if (offset === 0) {\r\n        return 0;\r\n    }\r\n    // Try to delete emoji part.\r\n    const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\r\n    if (emojiOffset !== undefined) {\r\n        return emojiOffset;\r\n    }\r\n    // Otherwise, just skip a single code point.\r\n    const codePoint = getPrevCodePoint(str, offset);\r\n    offset -= getUTF16Length(codePoint);\r\n    return offset;\r\n}\r\nfunction getOffsetBeforeLastEmojiComponent(offset, str) {\r\n    // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\r\n    // structure of emojis.\r\n    let codePoint = getPrevCodePoint(str, offset);\r\n    offset -= getUTF16Length(codePoint);\r\n    // Skip modifiers\r\n    while ((isEmojiModifier(codePoint) || codePoint === 65039 /* emojiVariantSelector */ || codePoint === 8419 /* enclosingKeyCap */)) {\r\n        if (offset === 0) {\r\n            // Cannot skip modifier, no preceding emoji base.\r\n            return undefined;\r\n        }\r\n        codePoint = getPrevCodePoint(str, offset);\r\n        offset -= getUTF16Length(codePoint);\r\n    }\r\n    // Expect base emoji\r\n    if (!isEmojiImprecise(codePoint)) {\r\n        // Unexpected code point, not a valid emoji.\r\n        return undefined;\r\n    }\r\n    if (offset >= 0) {\r\n        // Skip optional ZWJ code points that combine multiple emojis.\r\n        // In theory, we should check if that ZWJ actually combines multiple emojis\r\n        // to prevent deleting ZWJs in situations we didn't account for.\r\n        const optionalZwjCodePoint = getPrevCodePoint(str, offset);\r\n        if (optionalZwjCodePoint === 8205 /* zwj */) {\r\n            offset -= getUTF16Length(optionalZwjCodePoint);\r\n        }\r\n    }\r\n    return offset;\r\n}\r\nfunction getUTF16Length(codePoint) {\r\n    return codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1;\r\n}\r\nfunction isEmojiModifier(codePoint) {\r\n    return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/hash.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * Return a hash value for an object.\r\n */\r\nfunction hash(obj) {\r\n    return doHash(obj, 0);\r\n}\r\nfunction doHash(obj, hashVal) {\r\n    switch (typeof obj) {\r\n        case 'object':\r\n            if (obj === null) {\r\n                return numberHash(349, hashVal);\r\n            }\r\n            else if (Array.isArray(obj)) {\r\n                return arrayHash(obj, hashVal);\r\n            }\r\n            return objectHash(obj, hashVal);\r\n        case 'string':\r\n            return stringHash(obj, hashVal);\r\n        case 'boolean':\r\n            return booleanHash(obj, hashVal);\r\n        case 'number':\r\n            return numberHash(obj, hashVal);\r\n        case 'undefined':\r\n            return numberHash(937, hashVal);\r\n        default:\r\n            return numberHash(617, hashVal);\r\n    }\r\n}\r\nfunction numberHash(val, initialHashVal) {\r\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\r\n}\r\nfunction booleanHash(b, initialHashVal) {\r\n    return numberHash(b ? 433 : 863, initialHashVal);\r\n}\r\nfunction stringHash(s, hashVal) {\r\n    hashVal = numberHash(149417, hashVal);\r\n    for (let i = 0, length = s.length; i < length; i++) {\r\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\r\n    }\r\n    return hashVal;\r\n}\r\nfunction arrayHash(arr, initialHashVal) {\r\n    initialHashVal = numberHash(104579, initialHashVal);\r\n    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\r\n}\r\nfunction objectHash(obj, initialHashVal) {\r\n    initialHashVal = numberHash(181387, initialHashVal);\r\n    return Object.keys(obj).sort().reduce((hashVal, key) => {\r\n        hashVal = stringHash(key, hashVal);\r\n        return doHash(obj[key], hashVal);\r\n    }, initialHashVal);\r\n}\r\nfunction leftRotate(value, bits, totalBits = 32) {\r\n    // delta + bits = totalBits\r\n    const delta = totalBits - bits;\r\n    // All ones, expect `delta` zeros aligned to the right\r\n    const mask = ~((1 << delta) - 1);\r\n    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\r\n    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;\r\n}\r\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\r\n    for (let i = 0; i < count; i++) {\r\n        dest[index + i] = value;\r\n    }\r\n}\r\nfunction leftPad(value, length, char = '0') {\r\n    while (value.length < length) {\r\n        value = char + value;\r\n    }\r\n    return value;\r\n}\r\nfunction toHexString(bufferOrValue, bitsize = 32) {\r\n    if (bufferOrValue instanceof ArrayBuffer) {\r\n        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\r\n    }\r\n    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\r\n}\r\n/**\r\n * A SHA1 implementation that works with strings and does not allocate.\r\n */\r\nclass StringSHA1 {\r\n    constructor() {\r\n        this._h0 = 0x67452301;\r\n        this._h1 = 0xEFCDAB89;\r\n        this._h2 = 0x98BADCFE;\r\n        this._h3 = 0x10325476;\r\n        this._h4 = 0xC3D2E1F0;\r\n        this._buff = new Uint8Array(64 /* BLOCK_SIZE */ + 3 /* to fit any utf-8 */);\r\n        this._buffDV = new DataView(this._buff.buffer);\r\n        this._buffLen = 0;\r\n        this._totalLen = 0;\r\n        this._leftoverHighSurrogate = 0;\r\n        this._finished = false;\r\n    }\r\n    update(str) {\r\n        const strLen = str.length;\r\n        if (strLen === 0) {\r\n            return;\r\n        }\r\n        const buff = this._buff;\r\n        let buffLen = this._buffLen;\r\n        let leftoverHighSurrogate = this._leftoverHighSurrogate;\r\n        let charCode;\r\n        let offset;\r\n        if (leftoverHighSurrogate !== 0) {\r\n            charCode = leftoverHighSurrogate;\r\n            offset = -1;\r\n            leftoverHighSurrogate = 0;\r\n        }\r\n        else {\r\n            charCode = str.charCodeAt(0);\r\n            offset = 0;\r\n        }\r\n        while (true) {\r\n            let codePoint = charCode;\r\n            if (isHighSurrogate(charCode)) {\r\n                if (offset + 1 < strLen) {\r\n                    const nextCharCode = str.charCodeAt(offset + 1);\r\n                    if (isLowSurrogate(nextCharCode)) {\r\n                        offset++;\r\n                        codePoint = computeCodePoint(charCode, nextCharCode);\r\n                    }\r\n                    else {\r\n                        // illegal => unicode replacement character\r\n                        codePoint = 65533 /* UNICODE_REPLACEMENT */;\r\n                    }\r\n                }\r\n                else {\r\n                    // last character is a surrogate pair\r\n                    leftoverHighSurrogate = charCode;\r\n                    break;\r\n                }\r\n            }\r\n            else if (isLowSurrogate(charCode)) {\r\n                // illegal => unicode replacement character\r\n                codePoint = 65533 /* UNICODE_REPLACEMENT */;\r\n            }\r\n            buffLen = this._push(buff, buffLen, codePoint);\r\n            offset++;\r\n            if (offset < strLen) {\r\n                charCode = str.charCodeAt(offset);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        this._buffLen = buffLen;\r\n        this._leftoverHighSurrogate = leftoverHighSurrogate;\r\n    }\r\n    _push(buff, buffLen, codePoint) {\r\n        if (codePoint < 0x0080) {\r\n            buff[buffLen++] = codePoint;\r\n        }\r\n        else if (codePoint < 0x0800) {\r\n            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\r\n        }\r\n        else if (codePoint < 0x10000) {\r\n            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\r\n        }\r\n        else {\r\n            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\r\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\r\n        }\r\n        if (buffLen >= 64 /* BLOCK_SIZE */) {\r\n            this._step();\r\n            buffLen -= 64 /* BLOCK_SIZE */;\r\n            this._totalLen += 64 /* BLOCK_SIZE */;\r\n            // take last 3 in case of UTF8 overflow\r\n            buff[0] = buff[64 /* BLOCK_SIZE */ + 0];\r\n            buff[1] = buff[64 /* BLOCK_SIZE */ + 1];\r\n            buff[2] = buff[64 /* BLOCK_SIZE */ + 2];\r\n        }\r\n        return buffLen;\r\n    }\r\n    digest() {\r\n        if (!this._finished) {\r\n            this._finished = true;\r\n            if (this._leftoverHighSurrogate) {\r\n                // illegal => unicode replacement character\r\n                this._leftoverHighSurrogate = 0;\r\n                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* UNICODE_REPLACEMENT */);\r\n            }\r\n            this._totalLen += this._buffLen;\r\n            this._wrapUp();\r\n        }\r\n        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\r\n    }\r\n    _wrapUp() {\r\n        this._buff[this._buffLen++] = 0x80;\r\n        fill(this._buff, this._buffLen);\r\n        if (this._buffLen > 56) {\r\n            this._step();\r\n            fill(this._buff);\r\n        }\r\n        // this will fit because the mantissa can cover up to 52 bits\r\n        const ml = 8 * this._totalLen;\r\n        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\r\n        this._buffDV.setUint32(60, ml % 4294967296, false);\r\n        this._step();\r\n    }\r\n    _step() {\r\n        const bigBlock32 = StringSHA1._bigBlock32;\r\n        const data = this._buffDV;\r\n        for (let j = 0; j < 64 /* 16*4 */; j += 4) {\r\n            bigBlock32.setUint32(j, data.getUint32(j, false), false);\r\n        }\r\n        for (let j = 64; j < 320 /* 80*4 */; j += 4) {\r\n            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\r\n        }\r\n        let a = this._h0;\r\n        let b = this._h1;\r\n        let c = this._h2;\r\n        let d = this._h3;\r\n        let e = this._h4;\r\n        let f, k;\r\n        let temp;\r\n        for (let j = 0; j < 80; j++) {\r\n            if (j < 20) {\r\n                f = (b & c) | ((~b) & d);\r\n                k = 0x5A827999;\r\n            }\r\n            else if (j < 40) {\r\n                f = b ^ c ^ d;\r\n                k = 0x6ED9EBA1;\r\n            }\r\n            else if (j < 60) {\r\n                f = (b & c) | (b & d) | (c & d);\r\n                k = 0x8F1BBCDC;\r\n            }\r\n            else {\r\n                f = b ^ c ^ d;\r\n                k = 0xCA62C1D6;\r\n            }\r\n            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = leftRotate(b, 30);\r\n            b = a;\r\n            a = temp;\r\n        }\r\n        this._h0 = (this._h0 + a) & 0xffffffff;\r\n        this._h1 = (this._h1 + b) & 0xffffffff;\r\n        this._h2 = (this._h2 + c) & 0xffffffff;\r\n        this._h3 = (this._h3 + d) & 0xffffffff;\r\n        this._h4 = (this._h4 + e) & 0xffffffff;\r\n    }\r\n}\r\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass StringDiffSequence {\r\n    constructor(source) {\r\n        this.source = source;\r\n    }\r\n    getElements() {\r\n        const source = this.source;\r\n        const characters = new Int32Array(source.length);\r\n        for (let i = 0, len = source.length; i < len; i++) {\r\n            characters[i] = source.charCodeAt(i);\r\n        }\r\n        return characters;\r\n    }\r\n}\r\nfunction stringDiff(original, modified, pretty) {\r\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\r\n}\r\n//\r\n// The code below has been ported from a C# implementation in VS\r\n//\r\nclass Debug {\r\n    static Assert(condition, message) {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n}\r\nclass MyArray {\r\n    /**\r\n     * Copies a range of elements from an Array starting at the specified source index and pastes\r\n     * them to another Array starting at the specified destination index. The length and the indexes\r\n     * are specified as 64-bit integers.\r\n     * sourceArray:\r\n     *\t\tThe Array that contains the data to copy.\r\n     * sourceIndex:\r\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n     * destinationArray:\r\n     *\t\tThe Array that receives the data.\r\n     * destinationIndex:\r\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n     * length:\r\n     *\t\tA 64-bit integer that represents the number of elements to copy.\r\n     */\r\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n}\r\n/**\r\n * A utility class which helps to create the set of DiffChanges from\r\n * a difference operation. This class accepts original DiffElements and\r\n * modified DiffElements that are involved in a particular change. The\r\n * MarktNextChange() method can be called to mark the separation between\r\n * distinct changes. At the end, the Changes property can be called to retrieve\r\n * the constructed changes.\r\n */\r\nclass DiffChangeHelper {\r\n    /**\r\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n     */\r\n    constructor() {\r\n        this.m_changes = [];\r\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n    }\r\n    /**\r\n     * Marks the beginning of the next change in the set of differences.\r\n     */\r\n    MarkNextChange() {\r\n        // Only add to the list if there is something to add\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Add the new change to our list\r\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\r\n        }\r\n        // Reset for the next change\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n    }\r\n    /**\r\n     * Adds the original element at the given position to the elements\r\n     * affected by the current change. The modified index gives context\r\n     * to the change position with respect to the original sequence.\r\n     * @param originalIndex The index of the original element to add.\r\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n     */\r\n    AddOriginalElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_originalCount++;\r\n    }\r\n    /**\r\n     * Adds the modified element at the given position to the elements\r\n     * affected by the current change. The original index gives context\r\n     * to the change position with respect to the modified sequence.\r\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n     * @param modifiedIndex The index of the modified element to add.\r\n     */\r\n    AddModifiedElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_modifiedCount++;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class.\r\n     */\r\n    getChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        return this.m_changes;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class in the reverse order\r\n     */\r\n    getReverseChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        this.m_changes.reverse();\r\n        return this.m_changes;\r\n    }\r\n}\r\n/**\r\n * An implementation of the difference algorithm described in\r\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\r\n */\r\nclass LcsDiff {\r\n    /**\r\n     * Constructs the DiffFinder\r\n     */\r\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\r\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\r\n        this._originalSequence = originalSequence;\r\n        this._modifiedSequence = modifiedSequence;\r\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\r\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\r\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\r\n        this._originalStringElements = originalStringElements;\r\n        this._originalElementsOrHash = originalElementsOrHash;\r\n        this._modifiedStringElements = modifiedStringElements;\r\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n    }\r\n    static _isStringArray(arr) {\r\n        return (arr.length > 0 && typeof arr[0] === 'string');\r\n    }\r\n    static _getElements(sequence) {\r\n        const elements = sequence.getElements();\r\n        if (LcsDiff._isStringArray(elements)) {\r\n            const hashes = new Int32Array(elements.length);\r\n            for (let i = 0, len = elements.length; i < len; i++) {\r\n                hashes[i] = stringHash(elements[i], 0);\r\n            }\r\n            return [elements, hashes, true];\r\n        }\r\n        if (elements instanceof Int32Array) {\r\n            return [[], elements, false];\r\n        }\r\n        return [[], new Int32Array(elements), false];\r\n    }\r\n    ElementsAreEqual(originalIndex, newIndex) {\r\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\r\n    }\r\n    ElementsAreStrictEqual(originalIndex, newIndex) {\r\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\r\n            return false;\r\n        }\r\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\r\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\r\n        return (originalElement === modifiedElement);\r\n    }\r\n    static _getStrictElement(sequence, index) {\r\n        if (typeof sequence.getStrictElement === 'function') {\r\n            return sequence.getStrictElement(index);\r\n        }\r\n        return null;\r\n    }\r\n    OriginalElementsAreEqual(index1, index2) {\r\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\r\n    }\r\n    ModifiedElementsAreEqual(index1, index2) {\r\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\r\n    }\r\n    ComputeDiff(pretty) {\r\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\r\n    }\r\n    /**\r\n     * Computes the differences between the original and modified input\r\n     * sequences on the bounded range.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\r\n        const quitEarlyArr = [false];\r\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\r\n        if (pretty) {\r\n            // We have to clean up the computed diff to be more intuitive\r\n            // but it turns out this cannot be done correctly until the entire set\r\n            // of diffs have been computed\r\n            changes = this.PrettifyChanges(changes);\r\n        }\r\n        return {\r\n            quitEarly: quitEarlyArr[0],\r\n            changes: changes\r\n        };\r\n    }\r\n    /**\r\n     * Private helper method which computes the differences on the bounded range\r\n     * recursively.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\r\n        quitEarlyArr[0] = false;\r\n        // Find the start of the differences\r\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\r\n            originalStart++;\r\n            modifiedStart++;\r\n        }\r\n        // Find the end of the differences\r\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\r\n            originalEnd--;\r\n            modifiedEnd--;\r\n        }\r\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\r\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\r\n            let changes;\r\n            if (modifiedStart <= modifiedEnd) {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                // All insertions\r\n                changes = [\r\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                ];\r\n            }\r\n            else if (originalStart <= originalEnd) {\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // All deletions\r\n                changes = [\r\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\r\n                ];\r\n            }\r\n            else {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // Identical sequences - No differences\r\n                changes = [];\r\n            }\r\n            return changes;\r\n        }\r\n        // This problem can be solved using the Divide-And-Conquer technique.\r\n        const midOriginalArr = [0];\r\n        const midModifiedArr = [0];\r\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\r\n        const midOriginal = midOriginalArr[0];\r\n        const midModified = midModifiedArr[0];\r\n        if (result !== null) {\r\n            // Result is not-null when there was enough memory to compute the changes while\r\n            // searching for the recursion point\r\n            return result;\r\n        }\r\n        else if (!quitEarlyArr[0]) {\r\n            // We can break the problem down recursively by finding the changes in the\r\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\r\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\r\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\r\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\r\n            let rightChanges = [];\r\n            if (!quitEarlyArr[0]) {\r\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\r\n            }\r\n            else {\r\n                // We did't have time to finish the first half, so we don't have time to compute this half.\r\n                // Consider the entire rest of the sequence different.\r\n                rightChanges = [\r\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\r\n                ];\r\n            }\r\n            return this.ConcatenateChanges(leftChanges, rightChanges);\r\n        }\r\n        // If we hit here, we quit early, and so can't return anything meaningful\r\n        return [\r\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n        ];\r\n    }\r\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\r\n        let forwardChanges = null;\r\n        let reverseChanges = null;\r\n        // First, walk backward through the forward diagonals history\r\n        let changeHelper = new DiffChangeHelper();\r\n        let diagonalMin = diagonalForwardStart;\r\n        let diagonalMax = diagonalForwardEnd;\r\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\r\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\r\n        let historyIndex = this.m_forwardHistory.length - 1;\r\n        do {\r\n            // Get the diagonal index from the relative diagonal number\r\n            const diagonal = diagonalRelative + diagonalForwardBase;\r\n            // Figure out where we came from\r\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                // Vertical line (the element is an insert)\r\n                originalIndex = forwardPoints[diagonal + 1];\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex;\r\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\r\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            else {\r\n                // Horizontal line (the element is a deletion)\r\n                originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex - 1;\r\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\r\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            if (historyIndex >= 0) {\r\n                forwardPoints = this.m_forwardHistory[historyIndex];\r\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\r\n                diagonalMin = 1;\r\n                diagonalMax = forwardPoints.length - 1;\r\n            }\r\n        } while (--historyIndex >= -1);\r\n        // Ironically, we get the forward changes as the reverse of the\r\n        // order we added them since we technically added them backwards\r\n        forwardChanges = changeHelper.getReverseChanges();\r\n        if (quitEarlyArr[0]) {\r\n            // TODO: Calculate a partial from the reverse diagonals.\r\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\r\n            let originalStartPoint = midOriginalArr[0] + 1;\r\n            let modifiedStartPoint = midModifiedArr[0] + 1;\r\n            if (forwardChanges !== null && forwardChanges.length > 0) {\r\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\r\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\r\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\r\n            }\r\n            reverseChanges = [\r\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\r\n            ];\r\n        }\r\n        else {\r\n            // Now walk backward through the reverse diagonals history\r\n            changeHelper = new DiffChangeHelper();\r\n            diagonalMin = diagonalReverseStart;\r\n            diagonalMax = diagonalReverseEnd;\r\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\r\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\r\n            do {\r\n                // Get the diagonal index from the relative diagonal number\r\n                const diagonal = diagonalRelative + diagonalReverseBase;\r\n                // Figure out where we came from\r\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    // Horizontal line (the element is a deletion))\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex + 1;\r\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                else {\r\n                    // Vertical line (the element is an insertion)\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex;\r\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                if (historyIndex >= 0) {\r\n                    reversePoints = this.m_reverseHistory[historyIndex];\r\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\r\n                    diagonalMin = 1;\r\n                    diagonalMax = reversePoints.length - 1;\r\n                }\r\n            } while (--historyIndex >= -1);\r\n            // There are cases where the reverse history will find diffs that\r\n            // are correct, but not intuitive, so we need shift them.\r\n            reverseChanges = changeHelper.getChanges();\r\n        }\r\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\r\n    }\r\n    /**\r\n     * Given the range to compute the diff on, this method finds the point:\r\n     * (midOriginal, midModified)\r\n     * that exists in the middle of the LCS of the two sequences and\r\n     * is the point at which the LCS problem may be broken down recursively.\r\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n     * point is calculated and the full trace is available in memory, then this method\r\n     * will return the change list.\r\n     * @param originalStart The start bound of the original sequence range\r\n     * @param originalEnd The end bound of the original sequence range\r\n     * @param modifiedStart The start bound of the modified sequence range\r\n     * @param modifiedEnd The end bound of the modified sequence range\r\n     * @param midOriginal The middle point of the original sequence range\r\n     * @param midModified The middle point of the modified sequence range\r\n     * @returns The diff changes, if available, otherwise null\r\n     */\r\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\r\n        let originalIndex = 0, modifiedIndex = 0;\r\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\r\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\r\n        // To traverse the edit graph and produce the proper LCS, our actual\r\n        // start position is just outside the given boundary\r\n        originalStart--;\r\n        modifiedStart--;\r\n        // We set these up to make the compiler happy, but they will\r\n        // be replaced before we return with the actual recursion point\r\n        midOriginalArr[0] = 0;\r\n        midModifiedArr[0] = 0;\r\n        // Clear out the history\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\r\n        // The integer value in the cell represents the originalIndex of the furthest\r\n        // reaching point found so far that ends in that diagonal.\r\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\r\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\r\n        const numDiagonals = maxDifferences + 1;\r\n        const forwardPoints = new Int32Array(numDiagonals);\r\n        const reversePoints = new Int32Array(numDiagonals);\r\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\r\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\r\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\r\n        const diagonalReverseBase = (originalEnd - originalStart);\r\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalForwardBase)\r\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalReverseBase)\r\n        const diagonalForwardOffset = (originalStart - modifiedStart);\r\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\r\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\r\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\r\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\r\n        const delta = diagonalReverseBase - diagonalForwardBase;\r\n        const deltaIsEven = (delta % 2 === 0);\r\n        // Here we set up the start and end points as the furthest points found so far\r\n        // in both the forward and reverse directions, respectively\r\n        forwardPoints[diagonalForwardBase] = originalStart;\r\n        reversePoints[diagonalReverseBase] = originalEnd;\r\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\r\n        quitEarlyArr[0] = false;\r\n        // A couple of points:\r\n        // --With this method, we iterate on the number of differences between the two sequences.\r\n        //   The more differences there actually are, the longer this will take.\r\n        // --Also, as the number of differences increases, we have to search on diagonals further\r\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\r\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\r\n        //   is even and odd diagonals only when numDifferences is odd.\r\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\r\n            let furthestOriginalIndex = 0;\r\n            let furthestModifiedIndex = 0;\r\n            // Run the algorithm in the forward direction\r\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalStart, modifiedStart)\r\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                    originalIndex = forwardPoints[diagonal + 1];\r\n                }\r\n                else {\r\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\r\n                // Save the current originalIndex so we can test for false overlap in step 3\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // so long as the elements are equal.\r\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\r\n                    originalIndex++;\r\n                    modifiedIndex++;\r\n                }\r\n                forwardPoints[diagonal] = originalIndex;\r\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\r\n                    furthestOriginalIndex = originalIndex;\r\n                    furthestModifiedIndex = modifiedIndex;\r\n                }\r\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\r\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\r\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\r\n                // then check for overlap.\r\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\r\n                    if (originalIndex >= reversePoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Check to see if we should be quitting early, before moving on to the next iteration.\r\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\r\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\r\n                // We can't finish, so skip ahead to generating a result from what we have.\r\n                quitEarlyArr[0] = true;\r\n                // Use the furthest distance we got in the forward direction.\r\n                midOriginalArr[0] = furthestOriginalIndex;\r\n                midModifiedArr[0] = furthestModifiedIndex;\r\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                    // Enough of the history is in memory to walk it backwards\r\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                }\r\n                else {\r\n                    // We didn't actually remember enough of the history.\r\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\r\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\r\n                    originalStart++;\r\n                    modifiedStart++;\r\n                    return [\r\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                    ];\r\n                }\r\n            }\r\n            // Run the algorithm in the reverse direction\r\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalEnd, modifiedEnd)\r\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                }\r\n                else {\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\r\n                // Save the current originalIndex so we can test for false overlap\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // as long as the elements are equal.\r\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\r\n                    originalIndex--;\r\n                    modifiedIndex--;\r\n                }\r\n                reversePoints[diagonal] = originalIndex;\r\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\r\n                // and diagonal is in the range of forward diagonals computed for numDifferences\r\n                // then check for overlap.\r\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\r\n                    if (originalIndex <= forwardPoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Save current vectors to history before the next iteration\r\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\r\n                // We are allocating space for one extra int, which we fill with\r\n                // the index of the diagonal base index\r\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\r\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\r\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\r\n                this.m_forwardHistory.push(temp);\r\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\r\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\r\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\r\n                this.m_reverseHistory.push(temp);\r\n            }\r\n        }\r\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\r\n        // NOTE: This part is a bit messy\r\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n    }\r\n    /**\r\n     * Shifts the given changes to provide a more intuitive diff.\r\n     * While the first element in a diff matches the first element after the diff,\r\n     * we shift the diff down.\r\n     *\r\n     * @param changes The list of changes to shift\r\n     * @returns The shifted changes\r\n     */\r\n    PrettifyChanges(changes) {\r\n        // Shift all the changes down first\r\n        for (let i = 0; i < changes.length; i++) {\r\n            const change = changes[i];\r\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\r\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            while (change.originalStart + change.originalLength < originalStop\r\n                && change.modifiedStart + change.modifiedLength < modifiedStop\r\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\r\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\r\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\r\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\r\n                if (endStrictEqual && !startStrictEqual) {\r\n                    // moving the change down would create an equal change, but the elements are not strict equal\r\n                    break;\r\n                }\r\n                change.originalStart++;\r\n                change.modifiedStart++;\r\n            }\r\n            let mergedChangeArr = [null];\r\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\r\n                changes[i] = mergedChangeArr[0];\r\n                changes.splice(i + 1, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n        }\r\n        // Shift changes back up until we hit empty or whitespace-only lines\r\n        for (let i = changes.length - 1; i >= 0; i--) {\r\n            const change = changes[i];\r\n            let originalStop = 0;\r\n            let modifiedStop = 0;\r\n            if (i > 0) {\r\n                const prevChange = changes[i - 1];\r\n                originalStop = prevChange.originalStart + prevChange.originalLength;\r\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\r\n            }\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            let bestDelta = 0;\r\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\r\n            for (let delta = 1;; delta++) {\r\n                const originalStart = change.originalStart - delta;\r\n                const modifiedStart = change.modifiedStart - delta;\r\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\r\n                    break;\r\n                }\r\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\r\n                    break;\r\n                }\r\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\r\n                    break;\r\n                }\r\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\r\n                const score = ((touchingPreviousChange ? 5 : 0)\r\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\r\n                if (score > bestScore) {\r\n                    bestScore = score;\r\n                    bestDelta = delta;\r\n                }\r\n            }\r\n            change.originalStart -= bestDelta;\r\n            change.modifiedStart -= bestDelta;\r\n            const mergedChangeArr = [null];\r\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\r\n                changes[i - 1] = mergedChangeArr[0];\r\n                changes.splice(i, 1);\r\n                i++;\r\n                continue;\r\n            }\r\n        }\r\n        // There could be multiple longest common substrings.\r\n        // Give preference to the ones containing longer lines\r\n        if (this._hasStrings) {\r\n            for (let i = 1, len = changes.length; i < len; i++) {\r\n                const aChange = changes[i - 1];\r\n                const bChange = changes[i];\r\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\r\n                const aOriginalStart = aChange.originalStart;\r\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\r\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\r\n                const aModifiedStart = aChange.modifiedStart;\r\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\r\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\r\n                // Avoid wasting a lot of time with these searches\r\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\r\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\r\n                    if (t) {\r\n                        const [originalMatchStart, modifiedMatchStart] = t;\r\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\r\n                            // switch to another sequence that has a better score\r\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\r\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\r\n                            bChange.originalStart = originalMatchStart + matchedLength;\r\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\r\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\r\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return changes;\r\n    }\r\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\r\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\r\n            return null;\r\n        }\r\n        const originalMax = originalStart + originalLength - desiredLength + 1;\r\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\r\n        let bestScore = 0;\r\n        let bestOriginalStart = 0;\r\n        let bestModifiedStart = 0;\r\n        for (let i = originalStart; i < originalMax; i++) {\r\n            for (let j = modifiedStart; j < modifiedMax; j++) {\r\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\r\n                if (score > 0 && score > bestScore) {\r\n                    bestScore = score;\r\n                    bestOriginalStart = i;\r\n                    bestModifiedStart = j;\r\n                }\r\n            }\r\n        }\r\n        if (bestScore > 0) {\r\n            return [bestOriginalStart, bestModifiedStart];\r\n        }\r\n        return null;\r\n    }\r\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\r\n        let score = 0;\r\n        for (let l = 0; l < length; l++) {\r\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\r\n                return 0;\r\n            }\r\n            score += this._originalStringElements[originalStart + l].length;\r\n        }\r\n        return score;\r\n    }\r\n    _OriginalIsBoundary(index) {\r\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\r\n    }\r\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\r\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\r\n            return true;\r\n        }\r\n        if (originalLength > 0) {\r\n            const originalEnd = originalStart + originalLength;\r\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _ModifiedIsBoundary(index) {\r\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\r\n    }\r\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\r\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\r\n            return true;\r\n        }\r\n        if (modifiedLength > 0) {\r\n            const modifiedEnd = modifiedStart + modifiedLength;\r\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\r\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\r\n        return (originalScore + modifiedScore);\r\n    }\r\n    /**\r\n     * Concatenates the two input DiffChange lists and returns the resulting\r\n     * list.\r\n     * @param The left changes\r\n     * @param The right changes\r\n     * @returns The concatenated list\r\n     */\r\n    ConcatenateChanges(left, right) {\r\n        let mergedChangeArr = [];\r\n        if (left.length === 0 || right.length === 0) {\r\n            return (right.length > 0) ? right : left;\r\n        }\r\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\r\n            // Since we break the problem down recursively, it is possible that we\r\n            // might recurse in the middle of a change thereby splitting it into\r\n            // two changes. Here in the combining stage, we detect and fuse those\r\n            // changes back together\r\n            const result = new Array(left.length + right.length - 1);\r\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\r\n            result[left.length - 1] = mergedChangeArr[0];\r\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new Array(left.length + right.length);\r\n            MyArray.Copy(left, 0, result, 0, left.length);\r\n            MyArray.Copy(right, 0, result, left.length, right.length);\r\n            return result;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the two changes overlap and can be merged into a single\r\n     * change\r\n     * @param left The left change\r\n     * @param right The right change\r\n     * @param mergedChange The merged change if the two overlap, null otherwise\r\n     * @returns True if the two changes overlap\r\n     */\r\n    ChangesOverlap(left, right, mergedChangeArr) {\r\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\r\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\r\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n            const originalStart = left.originalStart;\r\n            let originalLength = left.originalLength;\r\n            const modifiedStart = left.modifiedStart;\r\n            let modifiedLength = left.modifiedLength;\r\n            if (left.originalStart + left.originalLength >= right.originalStart) {\r\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\r\n            }\r\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\r\n            }\r\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\r\n            return true;\r\n        }\r\n        else {\r\n            mergedChangeArr[0] = null;\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Helper method used to clip a diagonal index to the range of valid\r\n     * diagonals. This also decides whether or not the diagonal index,\r\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n     * one inside the boundary depending on the Even/Odd status of the boundary\r\n     * and numDifferences.\r\n     * @param diagonal The index of the diagonal to clip.\r\n     * @param numDifferences The current number of differences being iterated upon.\r\n     * @param diagonalBaseIndex The base reference diagonal.\r\n     * @param numDiagonals The total number of diagonals.\r\n     * @returns The clipped diagonal index.\r\n     */\r\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\r\n        if (diagonal >= 0 && diagonal < numDiagonals) {\r\n            // Nothing to clip, its in range\r\n            return diagonal;\r\n        }\r\n        // diagonalsBelow: The number of diagonals below the reference diagonal\r\n        // diagonalsAbove: The number of diagonals above the reference diagonal\r\n        const diagonalsBelow = diagonalBaseIndex;\r\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\r\n        const diffEven = (numDifferences % 2 === 0);\r\n        if (diagonal < 0) {\r\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\r\n            return (diffEven === lowerBoundEven) ? 0 : 1;\r\n        }\r\n        else {\r\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\r\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/process.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nlet safeProcess;\r\n// Native sandbox environment\r\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\r\n    const sandboxProcess = globals.vscode.process;\r\n    safeProcess = {\r\n        get platform() { return sandboxProcess.platform; },\r\n        get env() { return sandboxProcess.env; },\r\n        cwd() { return sandboxProcess.cwd(); },\r\n        nextTick(callback) { return setImmediate(callback); }\r\n    };\r\n}\r\n// Native node.js environment\r\nelse if (typeof process !== 'undefined') {\r\n    safeProcess = {\r\n        get platform() { return process.platform; },\r\n        get env() { return \"MISSING_ENV_VAR\"; },\r\n        cwd() { return \"MISSING_ENV_VAR\"['VSCODE_CWD'] || process.cwd(); },\r\n        nextTick(callback) { return process.nextTick(callback); }\r\n    };\r\n}\r\n// Web environment\r\nelse {\r\n    safeProcess = {\r\n        // Supported\r\n        get platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\r\n        nextTick(callback) { return setImmediate(callback); },\r\n        // Unsupported\r\n        get env() { return {}; },\r\n        cwd() { return '/'; }\r\n    };\r\n}\r\n/**\r\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\r\n * environments.\r\n *\r\n * Note: in web, this property is hardcoded to be `/`.\r\n */\r\nconst cwd = safeProcess.cwd;\r\n/**\r\n * Provides safe access to the `env` property in node.js, sandboxed or web\r\n * environments.\r\n *\r\n * Note: in web, this property is hardcoded to be `{}`.\r\n */\r\nconst env = safeProcess.env;\r\n/**\r\n * Provides safe access to the `platform` property in node.js, sandboxed or web\r\n * environments.\r\n */\r\nconst platform = safeProcess.platform;\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/path.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\r\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\r\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\nconst CHAR_UPPERCASE_A = 65; /* A */\r\nconst CHAR_LOWERCASE_A = 97; /* a */\r\nconst CHAR_UPPERCASE_Z = 90; /* Z */\r\nconst CHAR_LOWERCASE_Z = 122; /* z */\r\nconst CHAR_DOT = 46; /* . */\r\nconst CHAR_FORWARD_SLASH = 47; /* / */\r\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\r\nconst CHAR_COLON = 58; /* : */\r\nconst CHAR_QUESTION_MARK = 63; /* ? */\r\nclass ErrorInvalidArgType extends Error {\r\n    constructor(name, expected, actual) {\r\n        // determiner: 'must be' or 'must not be'\r\n        let determiner;\r\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\r\n            determiner = 'must not be';\r\n            expected = expected.replace(/^not /, '');\r\n        }\r\n        else {\r\n            determiner = 'must be';\r\n        }\r\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\r\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\r\n        msg += `. Received type ${typeof actual}`;\r\n        super(msg);\r\n        this.code = 'ERR_INVALID_ARG_TYPE';\r\n    }\r\n}\r\nfunction validateString(value, name) {\r\n    if (typeof value !== 'string') {\r\n        throw new ErrorInvalidArgType(name, 'string', value);\r\n    }\r\n}\r\nfunction isPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\r\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\r\n}\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    let res = '';\r\n    let lastSegmentLength = 0;\r\n    let lastSlash = -1;\r\n    let dots = 0;\r\n    let code = 0;\r\n    for (let i = 0; i <= path.length; ++i) {\r\n        if (i < path.length) {\r\n            code = path.charCodeAt(i);\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            break;\r\n        }\r\n        else {\r\n            code = CHAR_FORWARD_SLASH;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {\r\n                // NOOP\r\n            }\r\n            else if (dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 ||\r\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\r\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\r\n                    if (res.length > 2) {\r\n                        const lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = '';\r\n                            lastSegmentLength = 0;\r\n                        }\r\n                        else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                    else if (res.length !== 0) {\r\n                        res = '';\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    res += res.length > 0 ? `${separator}..` : '..';\r\n                    lastSegmentLength = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (res.length > 0) {\r\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\r\n                }\r\n                else {\r\n                    res = path.slice(lastSlash + 1, i);\r\n                }\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        }\r\n        else if (code === CHAR_DOT && dots !== -1) {\r\n            ++dots;\r\n        }\r\n        else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    if (pathObject === null || typeof pathObject !== 'object') {\r\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n    }\r\n    const dir = pathObject.dir || pathObject.root;\r\n    const base = pathObject.base ||\r\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\r\n    if (!dir) {\r\n        return base;\r\n    }\r\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\r\n}\r\nconst win32 = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedDevice = '';\r\n        let resolvedTail = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\r\n            let path;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n                validateString(path, 'path');\r\n                // Skip empty entries\r\n                if (path.length === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (resolvedDevice.length === 0) {\r\n                path = cwd();\r\n            }\r\n            else {\r\n                // Windows has the concept of drive-specific current working\r\n                // directories. If we've resolved a drive letter but not yet an\r\n                // absolute path, get cwd for that drive, or the process cwd if\r\n                // the drive cwd is not available. We're sure the device is not\r\n                // a UNC path at this points, because UNC paths are always absolute.\r\n                path = \"MISSING_ENV_VAR\"[`=${resolvedDevice}`] || cwd();\r\n                // Verify that a cwd was found and that it actually points\r\n                // to our drive. If not, default to the drive's root.\r\n                if (path === undefined ||\r\n                    path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\r\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n                    path = `${resolvedDevice}\\\\`;\r\n                }\r\n            }\r\n            const len = path.length;\r\n            let rootEnd = 0;\r\n            let device = '';\r\n            let isAbsolute = false;\r\n            const code = path.charCodeAt(0);\r\n            // Try to match a root\r\n            if (len === 1) {\r\n                if (isPathSeparator(code)) {\r\n                    // `path` contains just a path separator\r\n                    rootEnd = 1;\r\n                    isAbsolute = true;\r\n                }\r\n            }\r\n            else if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                // If we started with a separator, we know we at least have an\r\n                // absolute path of some kind (UNC or otherwise)\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    let j = 2;\r\n                    let last = j;\r\n                    // Match 1 or more non-path separators\r\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        const firstPart = path.slice(last, j);\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                                j++;\r\n                            }\r\n                            if (j === len || j !== last) {\r\n                                // We matched a UNC root\r\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rootEnd = 1;\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON) {\r\n                // Possible device root\r\n                device = path.slice(0, 2);\r\n                rootEnd = 2;\r\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                    // Treat separator following drive name as an absolute path\r\n                    // indicator\r\n                    isAbsolute = true;\r\n                    rootEnd = 3;\r\n                }\r\n            }\r\n            if (device.length > 0) {\r\n                if (resolvedDevice.length > 0) {\r\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n                        // This path points to another device so it is not applicable\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    resolvedDevice = device;\r\n                }\r\n            }\r\n            if (resolvedAbsolute) {\r\n                if (resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\r\n                resolvedAbsolute = isAbsolute;\r\n                if (isAbsolute && resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // At this point the path should be resolved to a full absolute path,\r\n        // but handle relative paths to be safe (might happen when process.cwd()\r\n        // fails)\r\n        // Normalize the tail path\r\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\r\n        return resolvedAbsolute ?\r\n            `${resolvedDevice}\\\\${resolvedTail}` :\r\n            `${resolvedDevice}${resolvedTail}` || '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = 0;\r\n        let device;\r\n        let isAbsolute = false;\r\n        const code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len === 1) {\r\n            // `path` contains just a single char, exit early to avoid\r\n            // unnecessary work\r\n            return isPosixPathSeparator(code) ? '\\\\' : path;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            // If we started with a separator, we know we at least have an absolute\r\n            // path of some kind (UNC or otherwise)\r\n            isAbsolute = true;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    const firstPart = path.slice(last, j);\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            // Return the normalized version of the UNC root since there\r\n                            // is nothing left to process\r\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                            rootEnd = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                rootEnd = 1;\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            device = path.slice(0, 2);\r\n            rootEnd = 2;\r\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                // Treat separator following drive name as an absolute path\r\n                // indicator\r\n                isAbsolute = true;\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        let tail = rootEnd < len ?\r\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\r\n            '';\r\n        if (tail.length === 0 && !isAbsolute) {\r\n            tail = '.';\r\n        }\r\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n            tail += '\\\\';\r\n        }\r\n        if (device === undefined) {\r\n            return isAbsolute ? `\\\\${tail}` : tail;\r\n        }\r\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const code = path.charCodeAt(0);\r\n        return isPathSeparator(code) ||\r\n            // Possible device root\r\n            len > 2 &&\r\n                isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON &&\r\n                isPathSeparator(path.charCodeAt(2));\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        let firstPart;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = firstPart = arg;\r\n                }\r\n                else {\r\n                    joined += `\\\\${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        // Make sure that the joined path doesn't start with two slashes, because\r\n        // normalize() will mistake it for an UNC path then.\r\n        //\r\n        // This step is skipped when it is very clear that the user actually\r\n        // intended to point at an UNC path. This is assumed when the first\r\n        // non-empty string arguments starts with exactly two slashes followed by\r\n        // at least one more non-slash character.\r\n        //\r\n        // Note that for normalize() to treat a path as an UNC path it needs to\r\n        // have at least 2 components, so we don't filter for that here.\r\n        // This means that the user can use join to construct UNC paths from\r\n        // a server name and a share name; for example:\r\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\r\n        let needsReplace = true;\r\n        let slashCount = 0;\r\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\r\n            ++slashCount;\r\n            const firstLen = firstPart.length;\r\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\r\n                ++slashCount;\r\n                if (firstLen > 2) {\r\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\r\n                        ++slashCount;\r\n                    }\r\n                    else {\r\n                        // We matched a UNC path in the first part\r\n                        needsReplace = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (needsReplace) {\r\n            // Find any more consecutive slashes we need to replace\r\n            while (slashCount < joined.length &&\r\n                isPathSeparator(joined.charCodeAt(slashCount))) {\r\n                slashCount++;\r\n            }\r\n            // Replace the slashes if needed\r\n            if (slashCount >= 2) {\r\n                joined = `\\\\${joined.slice(slashCount)}`;\r\n            }\r\n        }\r\n        return win32.normalize(joined);\r\n    },\r\n    // It will solve the relative path from `from` to `to`, for instance:\r\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromOrig = win32.resolve(from);\r\n        const toOrig = win32.resolve(to);\r\n        if (fromOrig === toOrig) {\r\n            return '';\r\n        }\r\n        from = fromOrig.toLowerCase();\r\n        to = toOrig.toLowerCase();\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        let fromStart = 0;\r\n        while (fromStart < from.length &&\r\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\r\n            fromStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let fromEnd = from.length;\r\n        while (fromEnd - 1 > fromStart &&\r\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            fromEnd--;\r\n        }\r\n        const fromLen = fromEnd - fromStart;\r\n        // Trim any leading backslashes\r\n        let toStart = 0;\r\n        while (toStart < to.length &&\r\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            toStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let toEnd = to.length;\r\n        while (toEnd - 1 > toStart &&\r\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            toEnd--;\r\n        }\r\n        const toLen = toEnd - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = fromLen < toLen ? fromLen : toLen;\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        // We found a mismatch before the first common path separator was seen, so\r\n        // return the original `to`.\r\n        if (i !== length) {\r\n            if (lastCommonSep === -1) {\r\n                return toOrig;\r\n            }\r\n        }\r\n        else {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\r\n                    return toOrig.slice(toStart + i + 1);\r\n                }\r\n                if (i === 2) {\r\n                    // We get here if `from` is the device root.\r\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\r\n                    return toOrig.slice(toStart + i);\r\n                }\r\n            }\r\n            if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 2) {\r\n                    // We get here if `to` is the device root.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\r\n                    lastCommonSep = 3;\r\n                }\r\n            }\r\n            if (lastCommonSep === -1) {\r\n                lastCommonSep = 0;\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to` and\r\n        // `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '\\\\..';\r\n            }\r\n        }\r\n        toStart += lastCommonSep;\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\r\n        }\r\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            ++toStart;\r\n        }\r\n        return toOrig.slice(toStart, toEnd);\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Note: this will *probably* throw somewhere.\r\n        if (typeof path !== 'string') {\r\n            return path;\r\n        }\r\n        if (path.length === 0) {\r\n            return '';\r\n        }\r\n        const resolvedPath = win32.resolve(path);\r\n        if (resolvedPath.length <= 2) {\r\n            return path;\r\n        }\r\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\r\n            // Possible UNC root\r\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\r\n                const code = resolvedPath.charCodeAt(2);\r\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\r\n                    // Matched non-long UNC root, convert the path to a long UNC path\r\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\r\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\r\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n            // Matched device root, convert the path to a long UNC path\r\n            return `\\\\\\\\?\\\\${resolvedPath}`;\r\n        }\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = -1;\r\n        let offset = 0;\r\n        const code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work or a dot.\r\n            return isPathSeparator(code) ? path : '.';\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = offset = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            return path;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            // Offset by 1 to include the separator after the UNC root to\r\n                            // treat it as a \"normal root\" on top of a (UNC) root\r\n                            rootEnd = offset = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Possible device root\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\r\n            offset = rootEnd;\r\n        }\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = len - 1; i >= offset; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (rootEnd === -1) {\r\n                return '.';\r\n            }\r\n            end = rootEnd;\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\r\n            path.charCodeAt(1) === CHAR_COLON) {\r\n            start = 2;\r\n        }\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (isPathSeparator(code)) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= start; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            path.charCodeAt(1) === CHAR_COLON &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n            start = startPart = 2;\r\n        }\r\n        for (let i = path.length - 1; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '\\\\'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const len = path.length;\r\n        let rootEnd = 0;\r\n        let code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            if (isPathSeparator(code)) {\r\n                // `path` contains just a path separator, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            ret.base = ret.name = path;\r\n            return ret;\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            rootEnd = j;\r\n                        }\r\n                        else if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            rootEnd = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            if (len <= 2) {\r\n                // `path` contains just a drive root, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            rootEnd = 2;\r\n            if (isPathSeparator(path.charCodeAt(2))) {\r\n                if (len === 3) {\r\n                    // `path` contains just a drive root, exit early to avoid\r\n                    // unnecessary work\r\n                    ret.root = ret.dir = path;\r\n                    return ret;\r\n                }\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        if (rootEnd > 0) {\r\n            ret.root = path.slice(0, rootEnd);\r\n        }\r\n        let startDot = -1;\r\n        let startPart = rootEnd;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= rootEnd; --i) {\r\n            code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(startPart, startDot);\r\n                ret.base = path.slice(startPart, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        // If the directory is the root, use the entire root as the `dir` including\r\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\r\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\r\n        if (startPart > 0 && startPart !== rootEnd) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else {\r\n            ret.dir = ret.root;\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '\\\\',\r\n    delimiter: ';',\r\n    win32: null,\r\n    posix: null\r\n};\r\nconst posix = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedPath = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n            const path = i >= 0 ? pathSegments[i] : cwd();\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            resolvedPath = `${path}/${resolvedPath}`;\r\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        // Normalize the path\r\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\r\n        if (resolvedAbsolute) {\r\n            return `/${resolvedPath}`;\r\n        }\r\n        return resolvedPath.length > 0 ? resolvedPath : '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\r\n        // Normalize the path\r\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\r\n        if (path.length === 0) {\r\n            if (isAbsolute) {\r\n                return '/';\r\n            }\r\n            return trailingSeparator ? './' : '.';\r\n        }\r\n        if (trailingSeparator) {\r\n            path += '/';\r\n        }\r\n        return isAbsolute ? `/${path}` : path;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = arg;\r\n                }\r\n                else {\r\n                    joined += `/${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        return posix.normalize(joined);\r\n    },\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim leading forward slashes.\r\n        from = posix.resolve(from);\r\n        to = posix.resolve(to);\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromStart = 1;\r\n        const fromEnd = from.length;\r\n        const fromLen = fromEnd - fromStart;\r\n        const toStart = 1;\r\n        const toLen = to.length - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = (fromLen < toLen ? fromLen : toLen);\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_FORWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        if (i === length) {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n                    return to.slice(toStart + i + 1);\r\n                }\r\n                if (i === 0) {\r\n                    // We get here if `from` is the root\r\n                    // For example: from='/'; to='/foo'\r\n                    return to.slice(toStart + i);\r\n                }\r\n            }\r\n            else if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 0) {\r\n                    // We get here if `to` is the root.\r\n                    // For example: from='/foo/bar'; to='/'\r\n                    lastCommonSep = 0;\r\n                }\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to`\r\n        // and `from`.\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '/..';\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts.\r\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Non-op on posix systems\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = path.length - 1; i >= 1; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return hasRoot ? '/' : '.';\r\n        }\r\n        if (hasRoot && end === 1) {\r\n            return '//';\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (code === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= 0; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        for (let i = path.length - 1; i >= 0; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '/'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let start;\r\n        if (isAbsolute) {\r\n            ret.root = '/';\r\n            start = 1;\r\n        }\r\n        else {\r\n            start = 0;\r\n        }\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(start, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(start, startDot);\r\n                ret.base = path.slice(start, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        if (startPart > 0) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else if (isAbsolute) {\r\n            ret.dir = '/';\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '/',\r\n    delimiter: ':',\r\n    win32: null,\r\n    posix: null\r\n};\r\nposix.win32 = win32.win32 = win32;\r\nposix.posix = win32.posix = posix;\r\nconst normalize = (platform === 'win32' ? win32.normalize : posix.normalize);\r\nconst resolve = (platform === 'win32' ? win32.resolve : posix.resolve);\r\nconst relative = (platform === 'win32' ? win32.relative : posix.relative);\r\nconst dirname = (platform === 'win32' ? win32.dirname : posix.dirname);\r\nconst basename = (platform === 'win32' ? win32.basename : posix.basename);\r\nconst extname = (platform === 'win32' ? win32.extname : posix.extname);\r\nconst sep = (platform === 'win32' ? win32.sep : posix.sep);\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/uri.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\r\nconst _singleSlashStart = /^\\//;\r\nconst _doubleSlashStart = /^\\/\\//;\r\nfunction _validateUri(ret, _strict) {\r\n    // scheme, must be set\r\n    if (!ret.scheme && _strict) {\r\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\r\n    }\r\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\r\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\r\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\r\n        throw new Error('[UriError]: Scheme contains illegal characters.');\r\n    }\r\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\r\n    // If a URI contains an authority component, then the path component\r\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\r\n    // does not contain an authority component, then the path cannot begin\r\n    // with two slash characters (\"//\").\r\n    if (ret.path) {\r\n        if (ret.authority) {\r\n            if (!_singleSlashStart.test(ret.path)) {\r\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\r\n            }\r\n        }\r\n        else {\r\n            if (_doubleSlashStart.test(ret.path)) {\r\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\r\n            }\r\n        }\r\n    }\r\n}\r\n// for a while we allowed uris *without* schemes and this is the migration\r\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\r\n// back to the file-scheme. that should cause the least carnage and still be a\r\n// clear warning\r\nfunction _schemeFix(scheme, _strict) {\r\n    if (!scheme && !_strict) {\r\n        return 'file';\r\n    }\r\n    return scheme;\r\n}\r\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\r\nfunction _referenceResolution(scheme, path) {\r\n    // the slash-character is our 'default base' as we don't\r\n    // support constructing URIs relative to other URIs. This\r\n    // also means that we alter and potentially break paths.\r\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\r\n    switch (scheme) {\r\n        case 'https':\r\n        case 'http':\r\n        case 'file':\r\n            if (!path) {\r\n                path = _slash;\r\n            }\r\n            else if (path[0] !== _slash) {\r\n                path = _slash + path;\r\n            }\r\n            break;\r\n    }\r\n    return path;\r\n}\r\nconst _empty = '';\r\nconst _slash = '/';\r\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n/**\r\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\r\n * This class is a simple parser which creates the basic component parts\r\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\r\n * and encoding.\r\n *\r\n * ```txt\r\n *       foo://example.com:8042/over/there?name=ferret#nose\r\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\r\n *        |           |            |            |        |\r\n *     scheme     authority       path        query   fragment\r\n *        |   _____________________|__\r\n *       / \\ /                        \\\r\n *       urn:example:animal:ferret:nose\r\n * ```\r\n */\r\nclass URI {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\r\n        if (typeof schemeOrData === 'object') {\r\n            this.scheme = schemeOrData.scheme || _empty;\r\n            this.authority = schemeOrData.authority || _empty;\r\n            this.path = schemeOrData.path || _empty;\r\n            this.query = schemeOrData.query || _empty;\r\n            this.fragment = schemeOrData.fragment || _empty;\r\n            // no validation because it's this URI\r\n            // that creates uri components.\r\n            // _validateUri(this);\r\n        }\r\n        else {\r\n            this.scheme = _schemeFix(schemeOrData, _strict);\r\n            this.authority = authority || _empty;\r\n            this.path = _referenceResolution(this.scheme, path || _empty);\r\n            this.query = query || _empty;\r\n            this.fragment = fragment || _empty;\r\n            _validateUri(this, _strict);\r\n        }\r\n    }\r\n    static isUri(thing) {\r\n        if (thing instanceof URI) {\r\n            return true;\r\n        }\r\n        if (!thing) {\r\n            return false;\r\n        }\r\n        return typeof thing.authority === 'string'\r\n            && typeof thing.fragment === 'string'\r\n            && typeof thing.path === 'string'\r\n            && typeof thing.query === 'string'\r\n            && typeof thing.scheme === 'string'\r\n            && typeof thing.fsPath === 'string'\r\n            && typeof thing.with === 'function'\r\n            && typeof thing.toString === 'function';\r\n    }\r\n    // ---- filesystem path -----------------------\r\n    /**\r\n     * Returns a string representing the corresponding file system path of this URI.\r\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\r\n     * platform specific path separator.\r\n     *\r\n     * * Will *not* validate the path for invalid characters and semantics.\r\n     * * Will *not* look at the scheme of this URI.\r\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\r\n     *\r\n     *\r\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\r\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\r\n     *\r\n     * ```ts\r\n        const u = URI.parse('file://server/c$/folder/file.txt')\r\n        u.authority === 'server'\r\n        u.path === '/shares/c$/file.txt'\r\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\r\n    ```\r\n     *\r\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\r\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\r\n     * with URIs that represent files on disk (`file` scheme).\r\n     */\r\n    get fsPath() {\r\n        // if (this.scheme !== 'file') {\r\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\r\n        // }\r\n        return uriToFsPath(this, false);\r\n    }\r\n    // ---- modify to new -------------------------\r\n    with(change) {\r\n        if (!change) {\r\n            return this;\r\n        }\r\n        let { scheme, authority, path, query, fragment } = change;\r\n        if (scheme === undefined) {\r\n            scheme = this.scheme;\r\n        }\r\n        else if (scheme === null) {\r\n            scheme = _empty;\r\n        }\r\n        if (authority === undefined) {\r\n            authority = this.authority;\r\n        }\r\n        else if (authority === null) {\r\n            authority = _empty;\r\n        }\r\n        if (path === undefined) {\r\n            path = this.path;\r\n        }\r\n        else if (path === null) {\r\n            path = _empty;\r\n        }\r\n        if (query === undefined) {\r\n            query = this.query;\r\n        }\r\n        else if (query === null) {\r\n            query = _empty;\r\n        }\r\n        if (fragment === undefined) {\r\n            fragment = this.fragment;\r\n        }\r\n        else if (fragment === null) {\r\n            fragment = _empty;\r\n        }\r\n        if (scheme === this.scheme\r\n            && authority === this.authority\r\n            && path === this.path\r\n            && query === this.query\r\n            && fragment === this.fragment) {\r\n            return this;\r\n        }\r\n        return new Uri(scheme, authority, path, query, fragment);\r\n    }\r\n    // ---- parse & validate ------------------------\r\n    /**\r\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\r\n     * `file:///usr/home`, or `scheme:with/path`.\r\n     *\r\n     * @param value A string which represents an URI (see `URI#toString`).\r\n     */\r\n    static parse(value, _strict = false) {\r\n        const match = _regexp.exec(value);\r\n        if (!match) {\r\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\r\n        }\r\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\r\n    }\r\n    /**\r\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\r\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\r\n     *\r\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\r\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\r\n     * `URI.parse('file://' + path)` because the path might contain characters that are\r\n     * interpreted (# and ?). See the following sample:\r\n     * ```ts\r\n    const good = URI.file('/coding/c#/project1');\r\n    good.scheme === 'file';\r\n    good.path === '/coding/c#/project1';\r\n    good.fragment === '';\r\n    const bad = URI.parse('file://' + '/coding/c#/project1');\r\n    bad.scheme === 'file';\r\n    bad.path === '/coding/c'; // path is now broken\r\n    bad.fragment === '/project1';\r\n    ```\r\n     *\r\n     * @param path A file system path (see `URI#fsPath`)\r\n     */\r\n    static file(path) {\r\n        let authority = _empty;\r\n        // normalize to fwd-slashes on windows,\r\n        // on other systems bwd-slashes are valid\r\n        // filename character, eg /f\\oo/ba\\r.txt\r\n        if (isWindows) {\r\n            path = path.replace(/\\\\/g, _slash);\r\n        }\r\n        // check for authority as used in UNC shares\r\n        // or use the path as given\r\n        if (path[0] === _slash && path[1] === _slash) {\r\n            const idx = path.indexOf(_slash, 2);\r\n            if (idx === -1) {\r\n                authority = path.substring(2);\r\n                path = _slash;\r\n            }\r\n            else {\r\n                authority = path.substring(2, idx);\r\n                path = path.substring(idx) || _slash;\r\n            }\r\n        }\r\n        return new Uri('file', authority, path, _empty, _empty);\r\n    }\r\n    static from(components) {\r\n        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);\r\n        _validateUri(result, true);\r\n        return result;\r\n    }\r\n    /**\r\n     * Join a URI path with path fragments and normalizes the resulting path.\r\n     *\r\n     * @param uri The input URI.\r\n     * @param pathFragment The path fragment to add to the URI path.\r\n     * @returns The resulting URI.\r\n     */\r\n    static joinPath(uri, ...pathFragment) {\r\n        if (!uri.path) {\r\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\r\n        }\r\n        let newPath;\r\n        if (isWindows && uri.scheme === 'file') {\r\n            newPath = URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\r\n        }\r\n        else {\r\n            newPath = posix.join(uri.path, ...pathFragment);\r\n        }\r\n        return uri.with({ path: newPath });\r\n    }\r\n    // ---- printing/externalize ---------------------------\r\n    /**\r\n     * Creates a string representation for this URI. It's guaranteed that calling\r\n     * `URI.parse` with the result of this function creates an URI which is equal\r\n     * to this URI.\r\n     *\r\n     * * The result shall *not* be used for display purposes but for externalization or transport.\r\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\r\n     * ignore the scheme-specific encoding rules.\r\n     *\r\n     * @param skipEncoding Do not encode the result, default is `false`\r\n     */\r\n    toString(skipEncoding = false) {\r\n        return _asFormatted(this, skipEncoding);\r\n    }\r\n    toJSON() {\r\n        return this;\r\n    }\r\n    static revive(data) {\r\n        if (!data) {\r\n            return data;\r\n        }\r\n        else if (data instanceof URI) {\r\n            return data;\r\n        }\r\n        else {\r\n            const result = new Uri(data);\r\n            result._formatted = data.external;\r\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\r\n            return result;\r\n        }\r\n    }\r\n}\r\nconst _pathSepMarker = isWindows ? 1 : undefined;\r\n// This class exists so that URI is compatibile with vscode.Uri (API).\r\nclass Uri extends URI {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._formatted = null;\r\n        this._fsPath = null;\r\n    }\r\n    get fsPath() {\r\n        if (!this._fsPath) {\r\n            this._fsPath = uriToFsPath(this, false);\r\n        }\r\n        return this._fsPath;\r\n    }\r\n    toString(skipEncoding = false) {\r\n        if (!skipEncoding) {\r\n            if (!this._formatted) {\r\n                this._formatted = _asFormatted(this, false);\r\n            }\r\n            return this._formatted;\r\n        }\r\n        else {\r\n            // we don't cache that\r\n            return _asFormatted(this, true);\r\n        }\r\n    }\r\n    toJSON() {\r\n        const res = {\r\n            $mid: 1 /* Uri */\r\n        };\r\n        // cached state\r\n        if (this._fsPath) {\r\n            res.fsPath = this._fsPath;\r\n            res._sep = _pathSepMarker;\r\n        }\r\n        if (this._formatted) {\r\n            res.external = this._formatted;\r\n        }\r\n        // uri components\r\n        if (this.path) {\r\n            res.path = this.path;\r\n        }\r\n        if (this.scheme) {\r\n            res.scheme = this.scheme;\r\n        }\r\n        if (this.authority) {\r\n            res.authority = this.authority;\r\n        }\r\n        if (this.query) {\r\n            res.query = this.query;\r\n        }\r\n        if (this.fragment) {\r\n            res.fragment = this.fragment;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\r\nconst encodeTable = {\r\n    [58 /* Colon */]: '%3A',\r\n    [47 /* Slash */]: '%2F',\r\n    [63 /* QuestionMark */]: '%3F',\r\n    [35 /* Hash */]: '%23',\r\n    [91 /* OpenSquareBracket */]: '%5B',\r\n    [93 /* CloseSquareBracket */]: '%5D',\r\n    [64 /* AtSign */]: '%40',\r\n    [33 /* ExclamationMark */]: '%21',\r\n    [36 /* DollarSign */]: '%24',\r\n    [38 /* Ampersand */]: '%26',\r\n    [39 /* SingleQuote */]: '%27',\r\n    [40 /* OpenParen */]: '%28',\r\n    [41 /* CloseParen */]: '%29',\r\n    [42 /* Asterisk */]: '%2A',\r\n    [43 /* Plus */]: '%2B',\r\n    [44 /* Comma */]: '%2C',\r\n    [59 /* Semicolon */]: '%3B',\r\n    [61 /* Equals */]: '%3D',\r\n    [32 /* Space */]: '%20',\r\n};\r\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\r\n    let res = undefined;\r\n    let nativeEncodePos = -1;\r\n    for (let pos = 0; pos < uriComponent.length; pos++) {\r\n        const code = uriComponent.charCodeAt(pos);\r\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\r\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\r\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\r\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\r\n            || code === 45 /* Dash */\r\n            || code === 46 /* Period */\r\n            || code === 95 /* Underline */\r\n            || code === 126 /* Tilde */\r\n            || (allowSlash && code === 47 /* Slash */)) {\r\n            // check if we are delaying native encode\r\n            if (nativeEncodePos !== -1) {\r\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\r\n                nativeEncodePos = -1;\r\n            }\r\n            // check if we write into a new string (by default we try to return the param)\r\n            if (res !== undefined) {\r\n                res += uriComponent.charAt(pos);\r\n            }\r\n        }\r\n        else {\r\n            // encoding needed, we need to allocate a new string\r\n            if (res === undefined) {\r\n                res = uriComponent.substr(0, pos);\r\n            }\r\n            // check with default table first\r\n            const escaped = encodeTable[code];\r\n            if (escaped !== undefined) {\r\n                // check if we are delaying native encode\r\n                if (nativeEncodePos !== -1) {\r\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\r\n                    nativeEncodePos = -1;\r\n                }\r\n                // append escaped variant to result\r\n                res += escaped;\r\n            }\r\n            else if (nativeEncodePos === -1) {\r\n                // use native encode only when needed\r\n                nativeEncodePos = pos;\r\n            }\r\n        }\r\n    }\r\n    if (nativeEncodePos !== -1) {\r\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\r\n    }\r\n    return res !== undefined ? res : uriComponent;\r\n}\r\nfunction encodeURIComponentMinimal(path) {\r\n    let res = undefined;\r\n    for (let pos = 0; pos < path.length; pos++) {\r\n        const code = path.charCodeAt(pos);\r\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\r\n            if (res === undefined) {\r\n                res = path.substr(0, pos);\r\n            }\r\n            res += encodeTable[code];\r\n        }\r\n        else {\r\n            if (res !== undefined) {\r\n                res += path[pos];\r\n            }\r\n        }\r\n    }\r\n    return res !== undefined ? res : path;\r\n}\r\n/**\r\n * Compute `fsPath` for the given uri\r\n */\r\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\r\n    let value;\r\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\r\n        // unc path: file://shares/c$/far/boo\r\n        value = `//${uri.authority}${uri.path}`;\r\n    }\r\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\r\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\r\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\r\n        if (!keepDriveLetterCasing) {\r\n            // windows drive letter: file:///c:/far/boo\r\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\r\n        }\r\n        else {\r\n            value = uri.path.substr(1);\r\n        }\r\n    }\r\n    else {\r\n        // other path\r\n        value = uri.path;\r\n    }\r\n    if (isWindows) {\r\n        value = value.replace(/\\//g, '\\\\');\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Create the external version of a uri\r\n */\r\nfunction _asFormatted(uri, skipEncoding) {\r\n    const encoder = !skipEncoding\r\n        ? encodeURIComponentFast\r\n        : encodeURIComponentMinimal;\r\n    let res = '';\r\n    let { scheme, authority, path, query, fragment } = uri;\r\n    if (scheme) {\r\n        res += scheme;\r\n        res += ':';\r\n    }\r\n    if (authority || scheme === 'file') {\r\n        res += _slash;\r\n        res += _slash;\r\n    }\r\n    if (authority) {\r\n        let idx = authority.indexOf('@');\r\n        if (idx !== -1) {\r\n            // <user>@<auth>\r\n            const userinfo = authority.substr(0, idx);\r\n            authority = authority.substr(idx + 1);\r\n            idx = userinfo.indexOf(':');\r\n            if (idx === -1) {\r\n                res += encoder(userinfo, false);\r\n            }\r\n            else {\r\n                // <user>:<pass>@<auth>\r\n                res += encoder(userinfo.substr(0, idx), false);\r\n                res += ':';\r\n                res += encoder(userinfo.substr(idx + 1), false);\r\n            }\r\n            res += '@';\r\n        }\r\n        authority = authority.toLowerCase();\r\n        idx = authority.indexOf(':');\r\n        if (idx === -1) {\r\n            res += encoder(authority, false);\r\n        }\r\n        else {\r\n            // <auth>:<port>\r\n            res += encoder(authority.substr(0, idx), false);\r\n            res += authority.substr(idx);\r\n        }\r\n    }\r\n    if (path) {\r\n        // lower-case windows drive letters in /C:/fff or C:/fff\r\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\r\n            const code = path.charCodeAt(1);\r\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\r\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\r\n            }\r\n        }\r\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\r\n            const code = path.charCodeAt(0);\r\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\r\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\r\n            }\r\n        }\r\n        // encode the rest of the path\r\n        res += encoder(path, true);\r\n    }\r\n    if (query) {\r\n        res += '?';\r\n        res += encoder(query, false);\r\n    }\r\n    if (fragment) {\r\n        res += '#';\r\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\r\n    }\r\n    return res;\r\n}\r\n// --- decode\r\nfunction decodeURIComponentGraceful(str) {\r\n    try {\r\n        return decodeURIComponent(str);\r\n    }\r\n    catch (_a) {\r\n        if (str.length > 3) {\r\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\r\n        }\r\n        else {\r\n            return str;\r\n        }\r\n    }\r\n}\r\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\r\nfunction percentDecode(str) {\r\n    if (!str.match(_rEncodedAsHex)) {\r\n        return str;\r\n    }\r\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * A position in the editor.\r\n */\r\nclass Position {\r\n    constructor(lineNumber, column) {\r\n        this.lineNumber = lineNumber;\r\n        this.column = column;\r\n    }\r\n    /**\r\n     * Create a new position from this position.\r\n     *\r\n     * @param newLineNumber new line number\r\n     * @param newColumn new column\r\n     */\r\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\r\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\r\n            return this;\r\n        }\r\n        else {\r\n            return new Position(newLineNumber, newColumn);\r\n        }\r\n    }\r\n    /**\r\n     * Derive a new position from this position.\r\n     *\r\n     * @param deltaLineNumber line number delta\r\n     * @param deltaColumn column delta\r\n     */\r\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\r\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\r\n    }\r\n    /**\r\n     * Test if this position equals other position\r\n     */\r\n    equals(other) {\r\n        return Position.equals(this, other);\r\n    }\r\n    /**\r\n     * Test if position `a` equals position `b`\r\n     */\r\n    static equals(a, b) {\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        return (!!a &&\r\n            !!b &&\r\n            a.lineNumber === b.lineNumber &&\r\n            a.column === b.column);\r\n    }\r\n    /**\r\n     * Test if this position is before other position.\r\n     * If the two positions are equal, the result will be false.\r\n     */\r\n    isBefore(other) {\r\n        return Position.isBefore(this, other);\r\n    }\r\n    /**\r\n     * Test if position `a` is before position `b`.\r\n     * If the two positions are equal, the result will be false.\r\n     */\r\n    static isBefore(a, b) {\r\n        if (a.lineNumber < b.lineNumber) {\r\n            return true;\r\n        }\r\n        if (b.lineNumber < a.lineNumber) {\r\n            return false;\r\n        }\r\n        return a.column < b.column;\r\n    }\r\n    /**\r\n     * Test if this position is before other position.\r\n     * If the two positions are equal, the result will be true.\r\n     */\r\n    isBeforeOrEqual(other) {\r\n        return Position.isBeforeOrEqual(this, other);\r\n    }\r\n    /**\r\n     * Test if position `a` is before position `b`.\r\n     * If the two positions are equal, the result will be true.\r\n     */\r\n    static isBeforeOrEqual(a, b) {\r\n        if (a.lineNumber < b.lineNumber) {\r\n            return true;\r\n        }\r\n        if (b.lineNumber < a.lineNumber) {\r\n            return false;\r\n        }\r\n        return a.column <= b.column;\r\n    }\r\n    /**\r\n     * A function that compares positions, useful for sorting\r\n     */\r\n    static compare(a, b) {\r\n        let aLineNumber = a.lineNumber | 0;\r\n        let bLineNumber = b.lineNumber | 0;\r\n        if (aLineNumber === bLineNumber) {\r\n            let aColumn = a.column | 0;\r\n            let bColumn = b.column | 0;\r\n            return aColumn - bColumn;\r\n        }\r\n        return aLineNumber - bLineNumber;\r\n    }\r\n    /**\r\n     * Clone this position.\r\n     */\r\n    clone() {\r\n        return new Position(this.lineNumber, this.column);\r\n    }\r\n    /**\r\n     * Convert to a human-readable representation.\r\n     */\r\n    toString() {\r\n        return '(' + this.lineNumber + ',' + this.column + ')';\r\n    }\r\n    // ---\r\n    /**\r\n     * Create a `Position` from an `IPosition`.\r\n     */\r\n    static lift(pos) {\r\n        return new Position(pos.lineNumber, pos.column);\r\n    }\r\n    /**\r\n     * Test if `obj` is an `IPosition`.\r\n     */\r\n    static isIPosition(obj) {\r\n        return (obj\r\n            && (typeof obj.lineNumber === 'number')\r\n            && (typeof obj.column === 'number'));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\r\n */\r\nclass Range {\r\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\r\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\r\n            this.startLineNumber = endLineNumber;\r\n            this.startColumn = endColumn;\r\n            this.endLineNumber = startLineNumber;\r\n            this.endColumn = startColumn;\r\n        }\r\n        else {\r\n            this.startLineNumber = startLineNumber;\r\n            this.startColumn = startColumn;\r\n            this.endLineNumber = endLineNumber;\r\n            this.endColumn = endColumn;\r\n        }\r\n    }\r\n    /**\r\n     * Test if this range is empty.\r\n     */\r\n    isEmpty() {\r\n        return Range.isEmpty(this);\r\n    }\r\n    /**\r\n     * Test if `range` is empty.\r\n     */\r\n    static isEmpty(range) {\r\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\r\n    }\r\n    /**\r\n     * Test if position is in this range. If the position is at the edges, will return true.\r\n     */\r\n    containsPosition(position) {\r\n        return Range.containsPosition(this, position);\r\n    }\r\n    /**\r\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\r\n     */\r\n    static containsPosition(range, position) {\r\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if range is in this range. If the range is equal to this range, will return true.\r\n     */\r\n    containsRange(range) {\r\n        return Range.containsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\r\n     */\r\n    static containsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\r\n     */\r\n    strictContainsRange(range) {\r\n        return Range.strictContainsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\r\n     */\r\n    static strictContainsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    plusRange(range) {\r\n        return Range.plusRange(this, range);\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    static plusRange(a, b) {\r\n        let startLineNumber;\r\n        let startColumn;\r\n        let endLineNumber;\r\n        let endColumn;\r\n        if (b.startLineNumber < a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = b.startColumn;\r\n        }\r\n        else if (b.startLineNumber === a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = Math.min(b.startColumn, a.startColumn);\r\n        }\r\n        else {\r\n            startLineNumber = a.startLineNumber;\r\n            startColumn = a.startColumn;\r\n        }\r\n        if (b.endLineNumber > a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = b.endColumn;\r\n        }\r\n        else if (b.endLineNumber === a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = Math.max(b.endColumn, a.endColumn);\r\n        }\r\n        else {\r\n            endLineNumber = a.endLineNumber;\r\n            endColumn = a.endColumn;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    intersectRanges(range) {\r\n        return Range.intersectRanges(this, range);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    static intersectRanges(a, b) {\r\n        let resultStartLineNumber = a.startLineNumber;\r\n        let resultStartColumn = a.startColumn;\r\n        let resultEndLineNumber = a.endLineNumber;\r\n        let resultEndColumn = a.endColumn;\r\n        let otherStartLineNumber = b.startLineNumber;\r\n        let otherStartColumn = b.startColumn;\r\n        let otherEndLineNumber = b.endLineNumber;\r\n        let otherEndColumn = b.endColumn;\r\n        if (resultStartLineNumber < otherStartLineNumber) {\r\n            resultStartLineNumber = otherStartLineNumber;\r\n            resultStartColumn = otherStartColumn;\r\n        }\r\n        else if (resultStartLineNumber === otherStartLineNumber) {\r\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\r\n        }\r\n        if (resultEndLineNumber > otherEndLineNumber) {\r\n            resultEndLineNumber = otherEndLineNumber;\r\n            resultEndColumn = otherEndColumn;\r\n        }\r\n        else if (resultEndLineNumber === otherEndLineNumber) {\r\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\r\n        }\r\n        // Check if selection is now empty\r\n        if (resultStartLineNumber > resultEndLineNumber) {\r\n            return null;\r\n        }\r\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\r\n            return null;\r\n        }\r\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\r\n    }\r\n    /**\r\n     * Test if this range equals other.\r\n     */\r\n    equalsRange(other) {\r\n        return Range.equalsRange(this, other);\r\n    }\r\n    /**\r\n     * Test if range `a` equals `b`.\r\n     */\r\n    static equalsRange(a, b) {\r\n        return (!!a &&\r\n            !!b &&\r\n            a.startLineNumber === b.startLineNumber &&\r\n            a.startColumn === b.startColumn &&\r\n            a.endLineNumber === b.endLineNumber &&\r\n            a.endColumn === b.endColumn);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    getEndPosition() {\r\n        return Range.getEndPosition(this);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    static getEndPosition(range) {\r\n        return new Position(range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    getStartPosition() {\r\n        return Range.getStartPosition(this);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    static getStartPosition(range) {\r\n        return new Position(range.startLineNumber, range.startColumn);\r\n    }\r\n    /**\r\n     * Transform to a user presentable string representation.\r\n     */\r\n    toString() {\r\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\r\n    }\r\n    /**\r\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n     */\r\n    setEndPosition(endLineNumber, endColumn) {\r\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n     */\r\n    setStartPosition(startLineNumber, startColumn) {\r\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    collapseToStart() {\r\n        return Range.collapseToStart(this);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    static collapseToStart(range) {\r\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\r\n    }\r\n    // ---\r\n    static fromPositions(start, end = start) {\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    static lift(range) {\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Test if `obj` is an `IRange`.\r\n     */\r\n    static isIRange(obj) {\r\n        return (obj\r\n            && (typeof obj.startLineNumber === 'number')\r\n            && (typeof obj.startColumn === 'number')\r\n            && (typeof obj.endLineNumber === 'number')\r\n            && (typeof obj.endColumn === 'number'));\r\n    }\r\n    /**\r\n     * Test if the two ranges are touching in any way.\r\n     */\r\n    static areIntersectingOrTouching(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\r\n     */\r\n    static areIntersecting(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the startPosition and then on the endPosition\r\n     */\r\n    static compareRangesUsingStarts(a, b) {\r\n        if (a && b) {\r\n            const aStartLineNumber = a.startLineNumber | 0;\r\n            const bStartLineNumber = b.startLineNumber | 0;\r\n            if (aStartLineNumber === bStartLineNumber) {\r\n                const aStartColumn = a.startColumn | 0;\r\n                const bStartColumn = b.startColumn | 0;\r\n                if (aStartColumn === bStartColumn) {\r\n                    const aEndLineNumber = a.endLineNumber | 0;\r\n                    const bEndLineNumber = b.endLineNumber | 0;\r\n                    if (aEndLineNumber === bEndLineNumber) {\r\n                        const aEndColumn = a.endColumn | 0;\r\n                        const bEndColumn = b.endColumn | 0;\r\n                        return aEndColumn - bEndColumn;\r\n                    }\r\n                    return aEndLineNumber - bEndLineNumber;\r\n                }\r\n                return aStartColumn - bStartColumn;\r\n            }\r\n            return aStartLineNumber - bStartLineNumber;\r\n        }\r\n        const aExists = (a ? 1 : 0);\r\n        const bExists = (b ? 1 : 0);\r\n        return aExists - bExists;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the endPosition and then on the startPosition\r\n     */\r\n    static compareRangesUsingEnds(a, b) {\r\n        if (a.endLineNumber === b.endLineNumber) {\r\n            if (a.endColumn === b.endColumn) {\r\n                if (a.startLineNumber === b.startLineNumber) {\r\n                    return a.startColumn - b.startColumn;\r\n                }\r\n                return a.startLineNumber - b.startLineNumber;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.endLineNumber - b.endLineNumber;\r\n    }\r\n    /**\r\n     * Test if the range spans multiple lines.\r\n     */\r\n    static spansMultipleLines(range) {\r\n        return range.endLineNumber > range.startLineNumber;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\r\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\r\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\r\n    return diffAlgo.ComputeDiff(pretty);\r\n}\r\nclass LineSequence {\r\n    constructor(lines) {\r\n        const startColumns = [];\r\n        const endColumns = [];\r\n        for (let i = 0, length = lines.length; i < length; i++) {\r\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\r\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\r\n        }\r\n        this.lines = lines;\r\n        this._startColumns = startColumns;\r\n        this._endColumns = endColumns;\r\n    }\r\n    getElements() {\r\n        const elements = [];\r\n        for (let i = 0, len = this.lines.length; i < len; i++) {\r\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\r\n        }\r\n        return elements;\r\n    }\r\n    getStrictElement(index) {\r\n        return this.lines[index];\r\n    }\r\n    getStartLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    getEndLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\r\n        const charCodes = [];\r\n        const lineNumbers = [];\r\n        const columns = [];\r\n        let len = 0;\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            const lineContent = this.lines[index];\r\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\r\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\r\n            for (let col = startColumn; col < endColumn; col++) {\r\n                charCodes[len] = lineContent.charCodeAt(col - 1);\r\n                lineNumbers[len] = index + 1;\r\n                columns[len] = col;\r\n                len++;\r\n            }\r\n        }\r\n        return new CharSequence(charCodes, lineNumbers, columns);\r\n    }\r\n}\r\nclass CharSequence {\r\n    constructor(charCodes, lineNumbers, columns) {\r\n        this._charCodes = charCodes;\r\n        this._lineNumbers = lineNumbers;\r\n        this._columns = columns;\r\n    }\r\n    getElements() {\r\n        return this._charCodes;\r\n    }\r\n    getStartLineNumber(i) {\r\n        return this._lineNumbers[i];\r\n    }\r\n    getStartColumn(i) {\r\n        return this._columns[i];\r\n    }\r\n    getEndLineNumber(i) {\r\n        return this._lineNumbers[i];\r\n    }\r\n    getEndColumn(i) {\r\n        return this._columns[i] + 1;\r\n    }\r\n}\r\nclass CharChange {\r\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalStartColumn = originalStartColumn;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.originalEndColumn = originalEndColumn;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedStartColumn = modifiedStartColumn;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.modifiedEndColumn = modifiedEndColumn;\r\n    }\r\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\r\n        let originalStartLineNumber;\r\n        let originalStartColumn;\r\n        let originalEndLineNumber;\r\n        let originalEndColumn;\r\n        let modifiedStartLineNumber;\r\n        let modifiedStartColumn;\r\n        let modifiedEndLineNumber;\r\n        let modifiedEndColumn;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = 0;\r\n            originalStartColumn = 0;\r\n            originalEndLineNumber = 0;\r\n            originalEndColumn = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\r\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = 0;\r\n            modifiedStartColumn = 0;\r\n            modifiedEndLineNumber = 0;\r\n            modifiedEndColumn = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\r\n    }\r\n}\r\nfunction postProcessCharChanges(rawChanges) {\r\n    if (rawChanges.length <= 1) {\r\n        return rawChanges;\r\n    }\r\n    const result = [rawChanges[0]];\r\n    let prevChange = result[0];\r\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\r\n        const currChange = rawChanges[i];\r\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\r\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\r\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\r\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\r\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\r\n            // Merge the current change into the previous one\r\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\r\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\r\n        }\r\n        else {\r\n            // Add the current change\r\n            result.push(currChange);\r\n            prevChange = currChange;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nclass LineChange {\r\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.charChanges = charChanges;\r\n    }\r\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\r\n        let originalStartLineNumber;\r\n        let originalEndLineNumber;\r\n        let modifiedStartLineNumber;\r\n        let modifiedEndLineNumber;\r\n        let charChanges = undefined;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\r\n            originalEndLineNumber = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\r\n            modifiedEndLineNumber = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\r\n            // Compute character changes for diff chunks of at most 20 lines...\r\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\r\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\r\n            if (shouldPostProcessCharChanges) {\r\n                rawChanges = postProcessCharChanges(rawChanges);\r\n            }\r\n            charChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\r\n            }\r\n        }\r\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\r\n    }\r\n}\r\nclass DiffComputer {\r\n    constructor(originalLines, modifiedLines, opts) {\r\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\r\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\r\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\r\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\r\n        this.originalLines = originalLines;\r\n        this.modifiedLines = modifiedLines;\r\n        this.original = new LineSequence(originalLines);\r\n        this.modified = new LineSequence(modifiedLines);\r\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\r\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\r\n    }\r\n    computeDiff() {\r\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\r\n            // empty original => fast path\r\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n                return {\r\n                    quitEarly: false,\r\n                    changes: []\r\n                };\r\n            }\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: 1,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: this.modified.lines.length,\r\n                        charChanges: [{\r\n                                modifiedEndColumn: 0,\r\n                                modifiedEndLineNumber: 0,\r\n                                modifiedStartColumn: 0,\r\n                                modifiedStartLineNumber: 0,\r\n                                originalEndColumn: 0,\r\n                                originalEndLineNumber: 0,\r\n                                originalStartColumn: 0,\r\n                                originalStartLineNumber: 0\r\n                            }]\r\n                    }]\r\n            };\r\n        }\r\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n            // empty modified => fast path\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: this.original.lines.length,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: 1,\r\n                        charChanges: [{\r\n                                modifiedEndColumn: 0,\r\n                                modifiedEndLineNumber: 0,\r\n                                modifiedStartColumn: 0,\r\n                                modifiedStartLineNumber: 0,\r\n                                originalEndColumn: 0,\r\n                                originalEndLineNumber: 0,\r\n                                originalStartColumn: 0,\r\n                                originalStartLineNumber: 0\r\n                            }]\r\n                    }]\r\n            };\r\n        }\r\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\r\n        const rawChanges = diffResult.changes;\r\n        const quitEarly = diffResult.quitEarly;\r\n        // The diff is always computed with ignoring trim whitespace\r\n        // This ensures we get the prettiest diff\r\n        if (this.shouldIgnoreTrimWhitespace) {\r\n            const lineChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n            }\r\n            return {\r\n                quitEarly: quitEarly,\r\n                changes: lineChanges\r\n            };\r\n        }\r\n        // Need to post-process and introduce changes where the trim whitespace is different\r\n        // Note that we are looping starting at -1 to also cover the lines before the first change\r\n        const result = [];\r\n        let originalLineIndex = 0;\r\n        let modifiedLineIndex = 0;\r\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\r\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\r\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\r\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\r\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\r\n                const originalLine = this.originalLines[originalLineIndex];\r\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\r\n                if (originalLine !== modifiedLine) {\r\n                    // These lines differ only in trim whitespace\r\n                    // Check the leading whitespace\r\n                    {\r\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\r\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\r\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\r\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\r\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalStartColumn--;\r\n                            modifiedStartColumn--;\r\n                        }\r\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\r\n                        }\r\n                    }\r\n                    // Check the trailing whitespace\r\n                    {\r\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\r\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\r\n                        const originalMaxColumn = originalLine.length + 1;\r\n                        const modifiedMaxColumn = modifiedLine.length + 1;\r\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\r\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\r\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalEndColumn++;\r\n                            modifiedEndColumn++;\r\n                        }\r\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\r\n                        }\r\n                    }\r\n                }\r\n                originalLineIndex++;\r\n                modifiedLineIndex++;\r\n            }\r\n            if (nextChange) {\r\n                // Emit the actual change\r\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n                originalLineIndex += nextChange.originalLength;\r\n                modifiedLineIndex += nextChange.modifiedLength;\r\n            }\r\n        }\r\n        return {\r\n            quitEarly: quitEarly,\r\n            changes: result\r\n        };\r\n    }\r\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\r\n            // Merged into previous\r\n            return;\r\n        }\r\n        let charChanges = undefined;\r\n        if (this.shouldComputeCharChanges) {\r\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\r\n        }\r\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\r\n    }\r\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        const len = result.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const prevChange = result[len - 1];\r\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\r\n            // Don't merge with inserts/deletes\r\n            return false;\r\n        }\r\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\r\n            prevChange.originalEndLineNumber = originalLineNumber;\r\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\r\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\r\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction getFirstNonBlankColumn(txt, defaultValue) {\r\n    const r = firstNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 1;\r\n}\r\nfunction getLastNonBlankColumn(txt, defaultValue) {\r\n    const r = lastNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 2;\r\n}\r\nfunction createContinueProcessingPredicate(maximumRuntime) {\r\n    if (maximumRuntime === 0) {\r\n        return () => true;\r\n    }\r\n    const startTime = Date.now();\r\n    return () => {\r\n        return Date.now() - startTime < maximumRuntime;\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/uint.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction toUint8(v) {\r\n    if (v < 0) {\r\n        return 0;\r\n    }\r\n    if (v > 255 /* MAX_UINT_8 */) {\r\n        return 255 /* MAX_UINT_8 */;\r\n    }\r\n    return v | 0;\r\n}\r\nfunction toUint32(v) {\r\n    if (v < 0) {\r\n        return 0;\r\n    }\r\n    if (v > 4294967295 /* MAX_UINT_32 */) {\r\n        return 4294967295 /* MAX_UINT_32 */;\r\n    }\r\n    return v | 0;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass PrefixSumIndexOfResult {\r\n    constructor(index, remainder) {\r\n        this._prefixSumIndexOfResultBrand = undefined;\r\n        this.index = index;\r\n        this.remainder = remainder;\r\n    }\r\n}\r\nclass PrefixSumComputer {\r\n    constructor(values) {\r\n        this.values = values;\r\n        this.prefixSum = new Uint32Array(values.length);\r\n        this.prefixSumValidIndex = new Int32Array(1);\r\n        this.prefixSumValidIndex[0] = -1;\r\n    }\r\n    insertValues(insertIndex, insertValues) {\r\n        insertIndex = toUint32(insertIndex);\r\n        const oldValues = this.values;\r\n        const oldPrefixSum = this.prefixSum;\r\n        const insertValuesLen = insertValues.length;\r\n        if (insertValuesLen === 0) {\r\n            return false;\r\n        }\r\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\r\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\r\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\r\n        this.values.set(insertValues, insertIndex);\r\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\r\n            this.prefixSumValidIndex[0] = insertIndex - 1;\r\n        }\r\n        this.prefixSum = new Uint32Array(this.values.length);\r\n        if (this.prefixSumValidIndex[0] >= 0) {\r\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\r\n        }\r\n        return true;\r\n    }\r\n    changeValue(index, value) {\r\n        index = toUint32(index);\r\n        value = toUint32(value);\r\n        if (this.values[index] === value) {\r\n            return false;\r\n        }\r\n        this.values[index] = value;\r\n        if (index - 1 < this.prefixSumValidIndex[0]) {\r\n            this.prefixSumValidIndex[0] = index - 1;\r\n        }\r\n        return true;\r\n    }\r\n    removeValues(startIndex, count) {\r\n        startIndex = toUint32(startIndex);\r\n        count = toUint32(count);\r\n        const oldValues = this.values;\r\n        const oldPrefixSum = this.prefixSum;\r\n        if (startIndex >= oldValues.length) {\r\n            return false;\r\n        }\r\n        let maxCount = oldValues.length - startIndex;\r\n        if (count >= maxCount) {\r\n            count = maxCount;\r\n        }\r\n        if (count === 0) {\r\n            return false;\r\n        }\r\n        this.values = new Uint32Array(oldValues.length - count);\r\n        this.values.set(oldValues.subarray(0, startIndex), 0);\r\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\r\n        this.prefixSum = new Uint32Array(this.values.length);\r\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\r\n            this.prefixSumValidIndex[0] = startIndex - 1;\r\n        }\r\n        if (this.prefixSumValidIndex[0] >= 0) {\r\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\r\n        }\r\n        return true;\r\n    }\r\n    getTotalSum() {\r\n        if (this.values.length === 0) {\r\n            return 0;\r\n        }\r\n        return this._getPrefixSum(this.values.length - 1);\r\n    }\r\n    getPrefixSum(index) {\r\n        if (index < 0) {\r\n            return 0;\r\n        }\r\n        index = toUint32(index);\r\n        return this._getPrefixSum(index);\r\n    }\r\n    _getPrefixSum(index) {\r\n        if (index <= this.prefixSumValidIndex[0]) {\r\n            return this.prefixSum[index];\r\n        }\r\n        let startIndex = this.prefixSumValidIndex[0] + 1;\r\n        if (startIndex === 0) {\r\n            this.prefixSum[0] = this.values[0];\r\n            startIndex++;\r\n        }\r\n        if (index >= this.values.length) {\r\n            index = this.values.length - 1;\r\n        }\r\n        for (let i = startIndex; i <= index; i++) {\r\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\r\n        }\r\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\r\n        return this.prefixSum[index];\r\n    }\r\n    getIndexOf(sum) {\r\n        sum = Math.floor(sum); //@perf\r\n        // Compute all sums (to get a fully valid prefixSum)\r\n        this.getTotalSum();\r\n        let low = 0;\r\n        let high = this.values.length - 1;\r\n        let mid = 0;\r\n        let midStop = 0;\r\n        let midStart = 0;\r\n        while (low <= high) {\r\n            mid = low + ((high - low) / 2) | 0;\r\n            midStop = this.prefixSum[mid];\r\n            midStart = midStop - this.values[mid];\r\n            if (sum < midStart) {\r\n                high = mid - 1;\r\n            }\r\n            else if (sum >= midStop) {\r\n                low = mid + 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nclass MirrorTextModel {\r\n    constructor(uri, lines, eol, versionId) {\r\n        this._uri = uri;\r\n        this._lines = lines;\r\n        this._eol = eol;\r\n        this._versionId = versionId;\r\n        this._lineStarts = null;\r\n        this._cachedTextValue = null;\r\n    }\r\n    dispose() {\r\n        this._lines.length = 0;\r\n    }\r\n    get version() {\r\n        return this._versionId;\r\n    }\r\n    getText() {\r\n        if (this._cachedTextValue === null) {\r\n            this._cachedTextValue = this._lines.join(this._eol);\r\n        }\r\n        return this._cachedTextValue;\r\n    }\r\n    onEvents(e) {\r\n        if (e.eol && e.eol !== this._eol) {\r\n            this._eol = e.eol;\r\n            this._lineStarts = null;\r\n        }\r\n        // Update my lines\r\n        const changes = e.changes;\r\n        for (const change of changes) {\r\n            this._acceptDeleteRange(change.range);\r\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\r\n        }\r\n        this._versionId = e.versionId;\r\n        this._cachedTextValue = null;\r\n    }\r\n    _ensureLineStarts() {\r\n        if (!this._lineStarts) {\r\n            const eolLength = this._eol.length;\r\n            const linesLength = this._lines.length;\r\n            const lineStartValues = new Uint32Array(linesLength);\r\n            for (let i = 0; i < linesLength; i++) {\r\n                lineStartValues[i] = this._lines[i].length + eolLength;\r\n            }\r\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\r\n        }\r\n    }\r\n    /**\r\n     * All changes to a line's text go through this method\r\n     */\r\n    _setLineText(lineIndex, newValue) {\r\n        this._lines[lineIndex] = newValue;\r\n        if (this._lineStarts) {\r\n            // update prefix sum\r\n            this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\r\n        }\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            // Delete text on the affected line\r\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\r\n            return;\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\r\n        // Delete middle lines\r\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n        if (this._lineStarts) {\r\n            // update prefix sum\r\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n        }\r\n    }\r\n    _acceptInsertText(position, insertText) {\r\n        if (insertText.length === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        let insertLines = splitLines(insertText);\r\n        if (insertLines.length === 1) {\r\n            // Inserting text on one line\r\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n                + insertLines[0]\r\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\r\n            return;\r\n        }\r\n        // Append overflowing text from first line to the end of text to insert\r\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\r\n        // Delete overflowing text from first line and insert text on first line\r\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n            + insertLines[0]);\r\n        // Insert new lines & store lengths\r\n        let newLengths = new Uint32Array(insertLines.length - 1);\r\n        for (let i = 1; i < insertLines.length; i++) {\r\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\r\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\r\n        }\r\n        if (this._lineStarts) {\r\n            // update prefix sum\r\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords = '') {\r\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (const sep of USUAL_WORD_SEPARATORS) {\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nconst DEFAULT_WORD_REGEXP = createWordRegExp();\r\nfunction ensureValidWordDefinition(wordDefinition) {\r\n    let result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            let flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nconst _defaultConfig = {\r\n    maxLen: 1000,\r\n    windowSize: 15,\r\n    timeBudget: 150\r\n};\r\nfunction getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\r\n    if (text.length > config.maxLen) {\r\n        // don't throw strings that long at the regexp\r\n        // but use a sub-string in which a word must occur\r\n        let start = column - config.maxLen / 2;\r\n        if (start < 0) {\r\n            start = 0;\r\n        }\r\n        else {\r\n            textOffset += start;\r\n        }\r\n        text = text.substring(start, column + config.maxLen / 2);\r\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\r\n    }\r\n    const t1 = Date.now();\r\n    const pos = column - 1 - textOffset;\r\n    let prevRegexIndex = -1;\r\n    let match = null;\r\n    for (let i = 1;; i++) {\r\n        // check time budget\r\n        if (Date.now() - t1 >= config.timeBudget) {\r\n            break;\r\n        }\r\n        // reset the index at which the regexp should start matching, also know where it\r\n        // should stop so that subsequent search don't repeat previous searches\r\n        const regexIndex = pos - config.windowSize * i;\r\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\r\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\r\n        if (!thisMatch && match) {\r\n            // stop: we have something\r\n            break;\r\n        }\r\n        match = thisMatch;\r\n        // stop: searched at start\r\n        if (regexIndex <= 0) {\r\n            break;\r\n        }\r\n        prevRegexIndex = regexIndex;\r\n    }\r\n    if (match) {\r\n        let result = {\r\n            word: match[0],\r\n            startColumn: textOffset + 1 + match.index,\r\n            endColumn: textOffset + 1 + match.index + match[0].length\r\n        };\r\n        wordDefinition.lastIndex = 0;\r\n        return result;\r\n    }\r\n    return null;\r\n}\r\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\r\n    let match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        const matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return match;\r\n        }\r\n        else if (stopPos > 0 && matchIndex > stopPos) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n/**\r\n * A fast character classifier that uses a compact array for ASCII values.\r\n */\r\nclass CharacterClassifier {\r\n    constructor(_defaultValue) {\r\n        let defaultValue = toUint8(_defaultValue);\r\n        this._defaultValue = defaultValue;\r\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\r\n        this._map = new Map();\r\n    }\r\n    static _createAsciiMap(defaultValue) {\r\n        let asciiMap = new Uint8Array(256);\r\n        for (let i = 0; i < 256; i++) {\r\n            asciiMap[i] = defaultValue;\r\n        }\r\n        return asciiMap;\r\n    }\r\n    set(charCode, _value) {\r\n        let value = toUint8(_value);\r\n        if (charCode >= 0 && charCode < 256) {\r\n            this._asciiMap[charCode] = value;\r\n        }\r\n        else {\r\n            this._map.set(charCode, value);\r\n        }\r\n    }\r\n    get(charCode) {\r\n        if (charCode >= 0 && charCode < 256) {\r\n            return this._asciiMap[charCode];\r\n        }\r\n        else {\r\n            return (this._map.get(charCode) || this._defaultValue);\r\n        }\r\n    }\r\n}\r\nclass CharacterSet {\r\n    constructor() {\r\n        this._actual = new CharacterClassifier(0 /* False */);\r\n    }\r\n    add(charCode) {\r\n        this._actual.set(charCode, 1 /* True */);\r\n    }\r\n    has(charCode) {\r\n        return (this._actual.get(charCode) === 1 /* True */);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass Uint8Matrix {\r\n    constructor(rows, cols, defaultValue) {\r\n        const data = new Uint8Array(rows * cols);\r\n        for (let i = 0, len = rows * cols; i < len; i++) {\r\n            data[i] = defaultValue;\r\n        }\r\n        this._data = data;\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n    }\r\n    get(row, col) {\r\n        return this._data[row * this.cols + col];\r\n    }\r\n    set(row, col, value) {\r\n        this._data[row * this.cols + col] = value;\r\n    }\r\n}\r\nclass StateMachine {\r\n    constructor(edges) {\r\n        let maxCharCode = 0;\r\n        let maxState = 0 /* Invalid */;\r\n        for (let i = 0, len = edges.length; i < len; i++) {\r\n            let [from, chCode, to] = edges[i];\r\n            if (chCode > maxCharCode) {\r\n                maxCharCode = chCode;\r\n            }\r\n            if (from > maxState) {\r\n                maxState = from;\r\n            }\r\n            if (to > maxState) {\r\n                maxState = to;\r\n            }\r\n        }\r\n        maxCharCode++;\r\n        maxState++;\r\n        let states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);\r\n        for (let i = 0, len = edges.length; i < len; i++) {\r\n            let [from, chCode, to] = edges[i];\r\n            states.set(from, chCode, to);\r\n        }\r\n        this._states = states;\r\n        this._maxCharCode = maxCharCode;\r\n    }\r\n    nextState(currentState, chCode) {\r\n        if (chCode < 0 || chCode >= this._maxCharCode) {\r\n            return 0 /* Invalid */;\r\n        }\r\n        return this._states.get(currentState, chCode);\r\n    }\r\n}\r\n// State machine for http:// or https:// or file://\r\nlet _stateMachine = null;\r\nfunction getStateMachine() {\r\n    if (_stateMachine === null) {\r\n        _stateMachine = new StateMachine([\r\n            [1 /* Start */, 104 /* h */, 2 /* H */],\r\n            [1 /* Start */, 72 /* H */, 2 /* H */],\r\n            [1 /* Start */, 102 /* f */, 6 /* F */],\r\n            [1 /* Start */, 70 /* F */, 6 /* F */],\r\n            [2 /* H */, 116 /* t */, 3 /* HT */],\r\n            [2 /* H */, 84 /* T */, 3 /* HT */],\r\n            [3 /* HT */, 116 /* t */, 4 /* HTT */],\r\n            [3 /* HT */, 84 /* T */, 4 /* HTT */],\r\n            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],\r\n            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],\r\n            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],\r\n            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],\r\n            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],\r\n            [6 /* F */, 105 /* i */, 7 /* FI */],\r\n            [6 /* F */, 73 /* I */, 7 /* FI */],\r\n            [7 /* FI */, 108 /* l */, 8 /* FIL */],\r\n            [7 /* FI */, 76 /* L */, 8 /* FIL */],\r\n            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],\r\n            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],\r\n            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],\r\n            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],\r\n            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],\r\n        ]);\r\n    }\r\n    return _stateMachine;\r\n}\r\nlet _classifier = null;\r\nfunction getClassifier() {\r\n    if (_classifier === null) {\r\n        _classifier = new CharacterClassifier(0 /* None */);\r\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…';\r\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\r\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);\r\n        }\r\n        const CANNOT_END_WITH_CHARACTERS = '.,;';\r\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\r\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);\r\n        }\r\n    }\r\n    return _classifier;\r\n}\r\nclass LinkComputer {\r\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\r\n        // Do not allow to end link in certain characters...\r\n        let lastIncludedCharIndex = linkEndIndex - 1;\r\n        do {\r\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\r\n            const chClass = classifier.get(chCode);\r\n            if (chClass !== 2 /* CannotEndIn */) {\r\n                break;\r\n            }\r\n            lastIncludedCharIndex--;\r\n        } while (lastIncludedCharIndex > linkBeginIndex);\r\n        // Handle links enclosed in parens, square brackets and curlys.\r\n        if (linkBeginIndex > 0) {\r\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\r\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\r\n            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)\r\n                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)\r\n                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {\r\n                // Do not end in ) if ( is before the link start\r\n                // Do not end in ] if [ is before the link start\r\n                // Do not end in } if { is before the link start\r\n                lastIncludedCharIndex--;\r\n            }\r\n        }\r\n        return {\r\n            range: {\r\n                startLineNumber: lineNumber,\r\n                startColumn: linkBeginIndex + 1,\r\n                endLineNumber: lineNumber,\r\n                endColumn: lastIncludedCharIndex + 2\r\n            },\r\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\r\n        };\r\n    }\r\n    static computeLinks(model, stateMachine = getStateMachine()) {\r\n        const classifier = getClassifier();\r\n        let result = [];\r\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\r\n            const line = model.getLineContent(i);\r\n            const len = line.length;\r\n            let j = 0;\r\n            let linkBeginIndex = 0;\r\n            let linkBeginChCode = 0;\r\n            let state = 1 /* Start */;\r\n            let hasOpenParens = false;\r\n            let hasOpenSquareBracket = false;\r\n            let inSquareBrackets = false;\r\n            let hasOpenCurlyBracket = false;\r\n            while (j < len) {\r\n                let resetStateMachine = false;\r\n                const chCode = line.charCodeAt(j);\r\n                if (state === 13 /* Accept */) {\r\n                    let chClass;\r\n                    switch (chCode) {\r\n                        case 40 /* OpenParen */:\r\n                            hasOpenParens = true;\r\n                            chClass = 0 /* None */;\r\n                            break;\r\n                        case 41 /* CloseParen */:\r\n                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);\r\n                            break;\r\n                        case 91 /* OpenSquareBracket */:\r\n                            inSquareBrackets = true;\r\n                            hasOpenSquareBracket = true;\r\n                            chClass = 0 /* None */;\r\n                            break;\r\n                        case 93 /* CloseSquareBracket */:\r\n                            inSquareBrackets = false;\r\n                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);\r\n                            break;\r\n                        case 123 /* OpenCurlyBrace */:\r\n                            hasOpenCurlyBracket = true;\r\n                            chClass = 0 /* None */;\r\n                            break;\r\n                        case 125 /* CloseCurlyBrace */:\r\n                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);\r\n                            break;\r\n                        /* The following three rules make it that ' or \" or ` are allowed inside links if the link began with a different one */\r\n                        case 39 /* SingleQuote */:\r\n                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\r\n                            break;\r\n                        case 34 /* DoubleQuote */:\r\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;\r\n                            break;\r\n                        case 96 /* BackTick */:\r\n                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;\r\n                            break;\r\n                        case 42 /* Asterisk */:\r\n                            // `*` terminates a link if the link began with `*`\r\n                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;\r\n                            break;\r\n                        case 124 /* Pipe */:\r\n                            // `|` terminates a link if the link began with `|`\r\n                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;\r\n                            break;\r\n                        case 32 /* Space */:\r\n                            // ` ` allow space in between [ and ]\r\n                            chClass = (inSquareBrackets ? 0 /* None */ : 1 /* ForceTermination */);\r\n                            break;\r\n                        default:\r\n                            chClass = classifier.get(chCode);\r\n                    }\r\n                    // Check if character terminates link\r\n                    if (chClass === 1 /* ForceTermination */) {\r\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\r\n                        resetStateMachine = true;\r\n                    }\r\n                }\r\n                else if (state === 12 /* End */) {\r\n                    let chClass;\r\n                    if (chCode === 91 /* OpenSquareBracket */) {\r\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\r\n                        hasOpenSquareBracket = true;\r\n                        chClass = 0 /* None */;\r\n                    }\r\n                    else {\r\n                        chClass = classifier.get(chCode);\r\n                    }\r\n                    // Check if character terminates link\r\n                    if (chClass === 1 /* ForceTermination */) {\r\n                        resetStateMachine = true;\r\n                    }\r\n                    else {\r\n                        state = 13 /* Accept */;\r\n                    }\r\n                }\r\n                else {\r\n                    state = stateMachine.nextState(state, chCode);\r\n                    if (state === 0 /* Invalid */) {\r\n                        resetStateMachine = true;\r\n                    }\r\n                }\r\n                if (resetStateMachine) {\r\n                    state = 1 /* Start */;\r\n                    hasOpenParens = false;\r\n                    hasOpenSquareBracket = false;\r\n                    hasOpenCurlyBracket = false;\r\n                    // Record where the link started\r\n                    linkBeginIndex = j + 1;\r\n                    linkBeginChCode = chCode;\r\n                }\r\n                j++;\r\n            }\r\n            if (state === 13 /* Accept */) {\r\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * Returns an array of all links contains in the provided\r\n * document. *Note* that this operation is computational\r\n * expensive and should not run in the UI thread.\r\n */\r\nfunction computeLinks(model) {\r\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\r\n        // Unknown caller!\r\n        return [];\r\n    }\r\n    return LinkComputer.computeLinks(model);\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass BasicInplaceReplace {\r\n    constructor() {\r\n        this._defaultValueSet = [\r\n            ['true', 'false'],\r\n            ['True', 'False'],\r\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\r\n            ['public', 'protected', 'private'],\r\n        ];\r\n    }\r\n    navigateValueSet(range1, text1, range2, text2, up) {\r\n        if (range1 && text1) {\r\n            let result = this.doNavigateValueSet(text1, up);\r\n            if (result) {\r\n                return {\r\n                    range: range1,\r\n                    value: result\r\n                };\r\n            }\r\n        }\r\n        if (range2 && text2) {\r\n            let result = this.doNavigateValueSet(text2, up);\r\n            if (result) {\r\n                return {\r\n                    range: range2,\r\n                    value: result\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    doNavigateValueSet(text, up) {\r\n        let numberResult = this.numberReplace(text, up);\r\n        if (numberResult !== null) {\r\n            return numberResult;\r\n        }\r\n        return this.textReplace(text, up);\r\n    }\r\n    numberReplace(value, up) {\r\n        let precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\r\n        let n1 = Number(value);\r\n        let n2 = parseFloat(value);\r\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\r\n            if (n1 === 0 && !up) {\r\n                return null; // don't do negative\r\n                //\t\t\t} else if(n1 === 9 && up) {\r\n                //\t\t\t\treturn null; // don't insert 10 into a number\r\n            }\r\n            else {\r\n                n1 = Math.floor(n1 * precision);\r\n                n1 += up ? precision : -precision;\r\n                return String(n1 / precision);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    textReplace(value, up) {\r\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\r\n    }\r\n    valueSetsReplace(valueSets, value, up) {\r\n        let result = null;\r\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\r\n            result = this.valueSetReplace(valueSets[i], value, up);\r\n        }\r\n        return result;\r\n    }\r\n    valueSetReplace(valueSet, value, up) {\r\n        let idx = valueSet.indexOf(value);\r\n        if (idx >= 0) {\r\n            idx += up ? +1 : -1;\r\n            if (idx < 0) {\r\n                idx = valueSet.length - 1;\r\n            }\r\n            else {\r\n                idx %= valueSet.length;\r\n            }\r\n            return valueSet[idx];\r\n        }\r\n        return null;\r\n    }\r\n}\r\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Node {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.next = Node.Undefined;\r\n        this.prev = Node.Undefined;\r\n    }\r\n}\r\nNode.Undefined = new Node(undefined);\r\nclass linkedList_LinkedList {\r\n    constructor() {\r\n        this._first = Node.Undefined;\r\n        this._last = Node.Undefined;\r\n        this._size = 0;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    isEmpty() {\r\n        return this._first === Node.Undefined;\r\n    }\r\n    clear() {\r\n        let node = this._first;\r\n        while (node !== Node.Undefined) {\r\n            const next = node.next;\r\n            node.prev = Node.Undefined;\r\n            node.next = Node.Undefined;\r\n            node = next;\r\n        }\r\n        this._first = Node.Undefined;\r\n        this._last = Node.Undefined;\r\n        this._size = 0;\r\n    }\r\n    unshift(element) {\r\n        return this._insert(element, false);\r\n    }\r\n    push(element) {\r\n        return this._insert(element, true);\r\n    }\r\n    _insert(element, atTheEnd) {\r\n        const newNode = new Node(element);\r\n        if (this._first === Node.Undefined) {\r\n            this._first = newNode;\r\n            this._last = newNode;\r\n        }\r\n        else if (atTheEnd) {\r\n            // push\r\n            const oldLast = this._last;\r\n            this._last = newNode;\r\n            newNode.prev = oldLast;\r\n            oldLast.next = newNode;\r\n        }\r\n        else {\r\n            // unshift\r\n            const oldFirst = this._first;\r\n            this._first = newNode;\r\n            newNode.next = oldFirst;\r\n            oldFirst.prev = newNode;\r\n        }\r\n        this._size += 1;\r\n        let didRemove = false;\r\n        return () => {\r\n            if (!didRemove) {\r\n                didRemove = true;\r\n                this._remove(newNode);\r\n            }\r\n        };\r\n    }\r\n    shift() {\r\n        if (this._first === Node.Undefined) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            const res = this._first.element;\r\n            this._remove(this._first);\r\n            return res;\r\n        }\r\n    }\r\n    pop() {\r\n        if (this._last === Node.Undefined) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            const res = this._last.element;\r\n            this._remove(this._last);\r\n            return res;\r\n        }\r\n    }\r\n    _remove(node) {\r\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\r\n            // middle\r\n            const anchor = node.prev;\r\n            anchor.next = node.next;\r\n            node.next.prev = anchor;\r\n        }\r\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\r\n            // only node\r\n            this._first = Node.Undefined;\r\n            this._last = Node.Undefined;\r\n        }\r\n        else if (node.next === Node.Undefined) {\r\n            // last\r\n            this._last = this._last.prev;\r\n            this._last.next = Node.Undefined;\r\n        }\r\n        else if (node.prev === Node.Undefined) {\r\n            // first\r\n            this._first = this._first.next;\r\n            this._first.prev = Node.Undefined;\r\n        }\r\n        // done\r\n        this._size -= 1;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        let node = this._first;\r\n        while (node !== Node.Undefined) {\r\n            yield node.element;\r\n            node = node.next;\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nconst hasPerformanceNow = (globals.performance && typeof globals.performance.now === 'function');\r\nclass StopWatch {\r\n    constructor(highResolution) {\r\n        this._highResolution = hasPerformanceNow && highResolution;\r\n        this._startTime = this._now();\r\n        this._stopTime = -1;\r\n    }\r\n    static create(highResolution = true) {\r\n        return new StopWatch(highResolution);\r\n    }\r\n    stop() {\r\n        this._stopTime = this._now();\r\n    }\r\n    elapsed() {\r\n        if (this._stopTime !== -1) {\r\n            return this._stopTime - this._startTime;\r\n        }\r\n        return this._now() - this._startTime;\r\n    }\r\n    _now() {\r\n        return this._highResolution ? globals.performance.now() : Date.now();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/event.js\n\r\n\r\n\r\n\r\nvar Event;\r\n(function (Event) {\r\n    Event.None = () => lifecycle_Disposable.None;\r\n    /**\r\n     * Given an event, returns another event which only fires once.\r\n     */\r\n    function once(event) {\r\n        return (listener, thisArgs = null, disposables) => {\r\n            // we need this, in case the event fires during the listener call\r\n            let didFire = false;\r\n            let result;\r\n            result = event(e => {\r\n                if (didFire) {\r\n                    return;\r\n                }\r\n                else if (result) {\r\n                    result.dispose();\r\n                }\r\n                else {\r\n                    didFire = true;\r\n                }\r\n                return listener.call(thisArgs, e);\r\n            }, null, disposables);\r\n            if (didFire) {\r\n                result.dispose();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    Event.once = once;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function map(event, map) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\r\n    }\r\n    Event.map = map;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function forEach(event, each) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\r\n    }\r\n    Event.forEach = forEach;\r\n    function filter(event, filter) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\r\n    }\r\n    Event.filter = filter;\r\n    /**\r\n     * Given an event, returns the same event but typed as `Event<void>`.\r\n     */\r\n    function signal(event) {\r\n        return event;\r\n    }\r\n    Event.signal = signal;\r\n    function any(...events) {\r\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\r\n    }\r\n    Event.any = any;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function reduce(event, merge, initial) {\r\n        let output = initial;\r\n        return map(event, e => {\r\n            output = merge(output, e);\r\n            return output;\r\n        });\r\n    }\r\n    Event.reduce = reduce;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function snapshot(event) {\r\n        let listener;\r\n        const emitter = new Emitter({\r\n            onFirstListenerAdd() {\r\n                listener = event(emitter.fire, emitter);\r\n            },\r\n            onLastListenerRemove() {\r\n                listener.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\r\n        let subscription;\r\n        let output = undefined;\r\n        let handle = undefined;\r\n        let numDebouncedCalls = 0;\r\n        const emitter = new Emitter({\r\n            leakWarningThreshold,\r\n            onFirstListenerAdd() {\r\n                subscription = event(cur => {\r\n                    numDebouncedCalls++;\r\n                    output = merge(output, cur);\r\n                    if (leading && !handle) {\r\n                        emitter.fire(output);\r\n                        output = undefined;\r\n                    }\r\n                    clearTimeout(handle);\r\n                    handle = setTimeout(() => {\r\n                        const _output = output;\r\n                        output = undefined;\r\n                        handle = undefined;\r\n                        if (!leading || numDebouncedCalls > 1) {\r\n                            emitter.fire(_output);\r\n                        }\r\n                        numDebouncedCalls = 0;\r\n                    }, delay);\r\n                });\r\n            },\r\n            onLastListenerRemove() {\r\n                subscription.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.debounce = debounce;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function latch(event, equals = (a, b) => a === b) {\r\n        let firstCall = true;\r\n        let cache;\r\n        return filter(event, value => {\r\n            const shouldEmit = firstCall || !equals(value, cache);\r\n            firstCall = false;\r\n            cache = value;\r\n            return shouldEmit;\r\n        });\r\n    }\r\n    Event.latch = latch;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function split(event, isT) {\r\n        return [\r\n            Event.filter(event, isT),\r\n            Event.filter(event, e => !isT(e)),\r\n        ];\r\n    }\r\n    Event.split = split;\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function buffer(event, nextTick = false, _buffer = []) {\r\n        let buffer = _buffer.slice();\r\n        let listener = event(e => {\r\n            if (buffer) {\r\n                buffer.push(e);\r\n            }\r\n            else {\r\n                emitter.fire(e);\r\n            }\r\n        });\r\n        const flush = () => {\r\n            if (buffer) {\r\n                buffer.forEach(e => emitter.fire(e));\r\n            }\r\n            buffer = null;\r\n        };\r\n        const emitter = new Emitter({\r\n            onFirstListenerAdd() {\r\n                if (!listener) {\r\n                    listener = event(e => emitter.fire(e));\r\n                }\r\n            },\r\n            onFirstListenerDidAdd() {\r\n                if (buffer) {\r\n                    if (nextTick) {\r\n                        setTimeout(flush);\r\n                    }\r\n                    else {\r\n                        flush();\r\n                    }\r\n                }\r\n            },\r\n            onLastListenerRemove() {\r\n                if (listener) {\r\n                    listener.dispose();\r\n                }\r\n                listener = null;\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.buffer = buffer;\r\n    class ChainableEvent {\r\n        constructor(event) {\r\n            this.event = event;\r\n        }\r\n        map(fn) {\r\n            return new ChainableEvent(map(this.event, fn));\r\n        }\r\n        forEach(fn) {\r\n            return new ChainableEvent(forEach(this.event, fn));\r\n        }\r\n        filter(fn) {\r\n            return new ChainableEvent(filter(this.event, fn));\r\n        }\r\n        reduce(merge, initial) {\r\n            return new ChainableEvent(reduce(this.event, merge, initial));\r\n        }\r\n        latch() {\r\n            return new ChainableEvent(latch(this.event));\r\n        }\r\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\r\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\r\n        }\r\n        on(listener, thisArgs, disposables) {\r\n            return this.event(listener, thisArgs, disposables);\r\n        }\r\n        once(listener, thisArgs, disposables) {\r\n            return once(this.event)(listener, thisArgs, disposables);\r\n        }\r\n    }\r\n    /**\r\n     * @deprecated DO NOT use, this leaks memory\r\n     */\r\n    function chain(event) {\r\n        return new ChainableEvent(event);\r\n    }\r\n    Event.chain = chain;\r\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\r\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\r\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\r\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\r\n    function toPromise(event) {\r\n        return new Promise(resolve => once(event)(resolve));\r\n    }\r\n    Event.toPromise = toPromise;\r\n})(Event || (Event = {}));\r\nclass EventProfiling {\r\n    constructor(name) {\r\n        this._listenerCount = 0;\r\n        this._invocationCount = 0;\r\n        this._elapsedOverall = 0;\r\n        this._name = `${name}_${EventProfiling._idPool++}`;\r\n    }\r\n    start(listenerCount) {\r\n        this._stopWatch = new StopWatch(true);\r\n        this._listenerCount = listenerCount;\r\n    }\r\n    stop() {\r\n        if (this._stopWatch) {\r\n            const elapsed = this._stopWatch.elapsed();\r\n            this._elapsedOverall += elapsed;\r\n            this._invocationCount += 1;\r\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\r\n            this._stopWatch = undefined;\r\n        }\r\n    }\r\n}\r\nEventProfiling._idPool = 0;\r\nlet _globalLeakWarningThreshold = -1;\r\nclass LeakageMonitor {\r\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\r\n        this.customThreshold = customThreshold;\r\n        this.name = name;\r\n        this._warnCountdown = 0;\r\n    }\r\n    dispose() {\r\n        if (this._stacks) {\r\n            this._stacks.clear();\r\n        }\r\n    }\r\n    check(listenerCount) {\r\n        let threshold = _globalLeakWarningThreshold;\r\n        if (typeof this.customThreshold === 'number') {\r\n            threshold = this.customThreshold;\r\n        }\r\n        if (threshold <= 0 || listenerCount < threshold) {\r\n            return undefined;\r\n        }\r\n        if (!this._stacks) {\r\n            this._stacks = new Map();\r\n        }\r\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\r\n        const count = (this._stacks.get(stack) || 0);\r\n        this._stacks.set(stack, count + 1);\r\n        this._warnCountdown -= 1;\r\n        if (this._warnCountdown <= 0) {\r\n            // only warn on first exceed and then every time the limit\r\n            // is exceeded by 50% again\r\n            this._warnCountdown = threshold * 0.5;\r\n            // find most frequent listener and print warning\r\n            let topStack;\r\n            let topCount = 0;\r\n            for (const [stack, count] of this._stacks) {\r\n                if (!topStack || topCount < count) {\r\n                    topStack = stack;\r\n                    topCount = count;\r\n                }\r\n            }\r\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\r\n            console.warn(topStack);\r\n        }\r\n        return () => {\r\n            const count = (this._stacks.get(stack) || 0);\r\n            this._stacks.set(stack, count - 1);\r\n        };\r\n    }\r\n}\r\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\r\nclass Emitter {\r\n    constructor(options) {\r\n        var _a;\r\n        this._disposed = false;\r\n        this._options = options;\r\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\r\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                var _a;\r\n                if (!this._listeners) {\r\n                    this._listeners = new linkedList_LinkedList();\r\n                }\r\n                const firstListener = this._listeners.isEmpty();\r\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\r\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\r\n                    this._options.onFirstListenerDidAdd(this);\r\n                }\r\n                if (this._options && this._options.onListenerDidAdd) {\r\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\r\n                }\r\n                // check and record this emitter for potential leakage\r\n                const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\r\n                const result = toDisposable(() => {\r\n                    if (removeMonitor) {\r\n                        removeMonitor();\r\n                    }\r\n                    if (!this._disposed) {\r\n                        remove();\r\n                        if (this._options && this._options.onLastListenerRemove) {\r\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\r\n                            if (!hasListeners) {\r\n                                this._options.onLastListenerRemove(this);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                if (disposables instanceof DisposableStore) {\r\n                    disposables.add(result);\r\n                }\r\n                else if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        var _a, _b;\r\n        if (this._listeners) {\r\n            // put all [listener,event]-pairs into delivery queue\r\n            // then emit all event. an inner/nested event might be\r\n            // the driver of this\r\n            if (!this._deliveryQueue) {\r\n                this._deliveryQueue = new linkedList_LinkedList();\r\n            }\r\n            for (let listener of this._listeners) {\r\n                this._deliveryQueue.push([listener, event]);\r\n            }\r\n            // start/stop performance insight collection\r\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\r\n            while (this._deliveryQueue.size > 0) {\r\n                const [listener, event] = this._deliveryQueue.shift();\r\n                try {\r\n                    if (typeof listener === 'function') {\r\n                        listener.call(undefined, event);\r\n                    }\r\n                    else {\r\n                        listener[0].call(listener[1], event);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    onUnexpectedError(e);\r\n                }\r\n            }\r\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\r\n        }\r\n    }\r\n    dispose() {\r\n        var _a, _b, _c, _d, _e;\r\n        if (!this._disposed) {\r\n            this._disposed = true;\r\n            (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\r\n            (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\r\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onLastListenerRemove) === null || _d === void 0 ? void 0 : _d.call(_c);\r\n            (_e = this._leakageMon) === null || _e === void 0 ? void 0 : _e.dispose();\r\n        }\r\n    }\r\n}\r\nclass PauseableEmitter extends (/* unused pure expression or super */ null && (Emitter)) {\r\n    constructor(options) {\r\n        super(options);\r\n        this._isPaused = 0;\r\n        this._eventQueue = new LinkedList();\r\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\r\n    }\r\n    pause() {\r\n        this._isPaused++;\r\n    }\r\n    resume() {\r\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\r\n            if (this._mergeFn) {\r\n                // use the merge function to create a single composite\r\n                // event. make a copy in case firing pauses this emitter\r\n                const events = Array.from(this._eventQueue);\r\n                this._eventQueue.clear();\r\n                super.fire(this._mergeFn(events));\r\n            }\r\n            else {\r\n                // no merging, fire each event individually and test\r\n                // that this emitter isn't paused halfway through\r\n                while (!this._isPaused && this._eventQueue.size !== 0) {\r\n                    super.fire(this._eventQueue.shift());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    fire(event) {\r\n        if (this._listeners) {\r\n            if (this._isPaused !== 0) {\r\n                this._eventQueue.push(event);\r\n            }\r\n            else {\r\n                super.fire(event);\r\n            }\r\n        }\r\n    }\r\n}\r\nclass DebounceEmitter extends (/* unused pure expression or super */ null && (PauseableEmitter)) {\r\n    constructor(options) {\r\n        var _a;\r\n        super(options);\r\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\r\n    }\r\n    fire(event) {\r\n        if (!this._handle) {\r\n            this.pause();\r\n            this._handle = setTimeout(() => {\r\n                this._handle = undefined;\r\n                this.resume();\r\n            }, this._delay);\r\n        }\r\n        super.fire(event);\r\n    }\r\n}\r\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\r\nclass EventBufferer {\r\n    constructor() {\r\n        this.buffers = [];\r\n    }\r\n    wrapEvent(event) {\r\n        return (listener, thisArgs, disposables) => {\r\n            return event(i => {\r\n                const buffer = this.buffers[this.buffers.length - 1];\r\n                if (buffer) {\r\n                    buffer.push(() => listener.call(thisArgs, i));\r\n                }\r\n                else {\r\n                    listener.call(thisArgs, i);\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n    }\r\n    bufferEvents(fn) {\r\n        const buffer = [];\r\n        this.buffers.push(buffer);\r\n        const r = fn();\r\n        this.buffers.pop();\r\n        buffer.forEach(flush => flush());\r\n        return r;\r\n    }\r\n}\r\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\r\nclass Relay {\r\n    constructor() {\r\n        this.listening = false;\r\n        this.inputEvent = Event.None;\r\n        this.inputEventListener = Disposable.None;\r\n        this.emitter = new Emitter({\r\n            onFirstListenerDidAdd: () => {\r\n                this.listening = true;\r\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\r\n            },\r\n            onLastListenerRemove: () => {\r\n                this.listening = false;\r\n                this.inputEventListener.dispose();\r\n            }\r\n        });\r\n        this.event = this.emitter.event;\r\n    }\r\n    set input(event) {\r\n        this.inputEvent = event;\r\n        if (this.listening) {\r\n            this.inputEventListener.dispose();\r\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\r\n        }\r\n    }\r\n    dispose() {\r\n        this.inputEventListener.dispose();\r\n        this.emitter.dispose();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nconst shortcutEvent = Object.freeze(function (callback, context) {\r\n    const handle = setTimeout(callback.bind(context), 0);\r\n    return { dispose() { clearTimeout(handle); } };\r\n});\r\nvar CancellationToken;\r\n(function (CancellationToken) {\r\n    function isCancellationToken(thing) {\r\n        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\r\n            return true;\r\n        }\r\n        if (thing instanceof MutableToken) {\r\n            return true;\r\n        }\r\n        if (!thing || typeof thing !== 'object') {\r\n            return false;\r\n        }\r\n        return typeof thing.isCancellationRequested === 'boolean'\r\n            && typeof thing.onCancellationRequested === 'function';\r\n    }\r\n    CancellationToken.isCancellationToken = isCancellationToken;\r\n    CancellationToken.None = Object.freeze({\r\n        isCancellationRequested: false,\r\n        onCancellationRequested: Event.None\r\n    });\r\n    CancellationToken.Cancelled = Object.freeze({\r\n        isCancellationRequested: true,\r\n        onCancellationRequested: shortcutEvent\r\n    });\r\n})(CancellationToken || (CancellationToken = {}));\r\nclass MutableToken {\r\n    constructor() {\r\n        this._isCancelled = false;\r\n        this._emitter = null;\r\n    }\r\n    cancel() {\r\n        if (!this._isCancelled) {\r\n            this._isCancelled = true;\r\n            if (this._emitter) {\r\n                this._emitter.fire(undefined);\r\n                this.dispose();\r\n            }\r\n        }\r\n    }\r\n    get isCancellationRequested() {\r\n        return this._isCancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        if (this._isCancelled) {\r\n            return shortcutEvent;\r\n        }\r\n        if (!this._emitter) {\r\n            this._emitter = new Emitter();\r\n        }\r\n        return this._emitter.event;\r\n    }\r\n    dispose() {\r\n        if (this._emitter) {\r\n            this._emitter.dispose();\r\n            this._emitter = null;\r\n        }\r\n    }\r\n}\r\nclass CancellationTokenSource {\r\n    constructor(parent) {\r\n        this._token = undefined;\r\n        this._parentListener = undefined;\r\n        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\r\n    }\r\n    get token() {\r\n        if (!this._token) {\r\n            // be lazy and create the token only when\r\n            // actually needed\r\n            this._token = new MutableToken();\r\n        }\r\n        return this._token;\r\n    }\r\n    cancel() {\r\n        if (!this._token) {\r\n            // save an object by returning the default\r\n            // cancelled token when cancellation happens\r\n            // before someone asks for the token\r\n            this._token = CancellationToken.Cancelled;\r\n        }\r\n        else if (this._token instanceof MutableToken) {\r\n            // actually cancel\r\n            this._token.cancel();\r\n        }\r\n    }\r\n    dispose(cancel = false) {\r\n        if (cancel) {\r\n            this.cancel();\r\n        }\r\n        if (this._parentListener) {\r\n            this._parentListener.dispose();\r\n        }\r\n        if (!this._token) {\r\n            // ensure to initialize with an empty token if we had none\r\n            this._token = CancellationToken.None;\r\n        }\r\n        else if (this._token instanceof MutableToken) {\r\n            // actually dispose\r\n            this._token.dispose();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass KeyCodeStrMap {\r\n    constructor() {\r\n        this._keyCodeToStr = [];\r\n        this._strToKeyCode = Object.create(null);\r\n    }\r\n    define(keyCode, str) {\r\n        this._keyCodeToStr[keyCode] = str;\r\n        this._strToKeyCode[str.toLowerCase()] = keyCode;\r\n    }\r\n    keyCodeToStr(keyCode) {\r\n        return this._keyCodeToStr[keyCode];\r\n    }\r\n    strToKeyCode(str) {\r\n        return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;\r\n    }\r\n}\r\nconst uiMap = new KeyCodeStrMap();\r\nconst userSettingsUSMap = new KeyCodeStrMap();\r\nconst userSettingsGeneralMap = new KeyCodeStrMap();\r\n(function () {\r\n    function define(keyCode, uiLabel, usUserSettingsLabel = uiLabel, generalUserSettingsLabel = usUserSettingsLabel) {\r\n        uiMap.define(keyCode, uiLabel);\r\n        userSettingsUSMap.define(keyCode, usUserSettingsLabel);\r\n        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);\r\n    }\r\n    define(0 /* Unknown */, 'unknown');\r\n    define(1 /* Backspace */, 'Backspace');\r\n    define(2 /* Tab */, 'Tab');\r\n    define(3 /* Enter */, 'Enter');\r\n    define(4 /* Shift */, 'Shift');\r\n    define(5 /* Ctrl */, 'Ctrl');\r\n    define(6 /* Alt */, 'Alt');\r\n    define(7 /* PauseBreak */, 'PauseBreak');\r\n    define(8 /* CapsLock */, 'CapsLock');\r\n    define(9 /* Escape */, 'Escape');\r\n    define(10 /* Space */, 'Space');\r\n    define(11 /* PageUp */, 'PageUp');\r\n    define(12 /* PageDown */, 'PageDown');\r\n    define(13 /* End */, 'End');\r\n    define(14 /* Home */, 'Home');\r\n    define(15 /* LeftArrow */, 'LeftArrow', 'Left');\r\n    define(16 /* UpArrow */, 'UpArrow', 'Up');\r\n    define(17 /* RightArrow */, 'RightArrow', 'Right');\r\n    define(18 /* DownArrow */, 'DownArrow', 'Down');\r\n    define(19 /* Insert */, 'Insert');\r\n    define(20 /* Delete */, 'Delete');\r\n    define(21 /* KEY_0 */, '0');\r\n    define(22 /* KEY_1 */, '1');\r\n    define(23 /* KEY_2 */, '2');\r\n    define(24 /* KEY_3 */, '3');\r\n    define(25 /* KEY_4 */, '4');\r\n    define(26 /* KEY_5 */, '5');\r\n    define(27 /* KEY_6 */, '6');\r\n    define(28 /* KEY_7 */, '7');\r\n    define(29 /* KEY_8 */, '8');\r\n    define(30 /* KEY_9 */, '9');\r\n    define(31 /* KEY_A */, 'A');\r\n    define(32 /* KEY_B */, 'B');\r\n    define(33 /* KEY_C */, 'C');\r\n    define(34 /* KEY_D */, 'D');\r\n    define(35 /* KEY_E */, 'E');\r\n    define(36 /* KEY_F */, 'F');\r\n    define(37 /* KEY_G */, 'G');\r\n    define(38 /* KEY_H */, 'H');\r\n    define(39 /* KEY_I */, 'I');\r\n    define(40 /* KEY_J */, 'J');\r\n    define(41 /* KEY_K */, 'K');\r\n    define(42 /* KEY_L */, 'L');\r\n    define(43 /* KEY_M */, 'M');\r\n    define(44 /* KEY_N */, 'N');\r\n    define(45 /* KEY_O */, 'O');\r\n    define(46 /* KEY_P */, 'P');\r\n    define(47 /* KEY_Q */, 'Q');\r\n    define(48 /* KEY_R */, 'R');\r\n    define(49 /* KEY_S */, 'S');\r\n    define(50 /* KEY_T */, 'T');\r\n    define(51 /* KEY_U */, 'U');\r\n    define(52 /* KEY_V */, 'V');\r\n    define(53 /* KEY_W */, 'W');\r\n    define(54 /* KEY_X */, 'X');\r\n    define(55 /* KEY_Y */, 'Y');\r\n    define(56 /* KEY_Z */, 'Z');\r\n    define(57 /* Meta */, 'Meta');\r\n    define(58 /* ContextMenu */, 'ContextMenu');\r\n    define(59 /* F1 */, 'F1');\r\n    define(60 /* F2 */, 'F2');\r\n    define(61 /* F3 */, 'F3');\r\n    define(62 /* F4 */, 'F4');\r\n    define(63 /* F5 */, 'F5');\r\n    define(64 /* F6 */, 'F6');\r\n    define(65 /* F7 */, 'F7');\r\n    define(66 /* F8 */, 'F8');\r\n    define(67 /* F9 */, 'F9');\r\n    define(68 /* F10 */, 'F10');\r\n    define(69 /* F11 */, 'F11');\r\n    define(70 /* F12 */, 'F12');\r\n    define(71 /* F13 */, 'F13');\r\n    define(72 /* F14 */, 'F14');\r\n    define(73 /* F15 */, 'F15');\r\n    define(74 /* F16 */, 'F16');\r\n    define(75 /* F17 */, 'F17');\r\n    define(76 /* F18 */, 'F18');\r\n    define(77 /* F19 */, 'F19');\r\n    define(78 /* NumLock */, 'NumLock');\r\n    define(79 /* ScrollLock */, 'ScrollLock');\r\n    define(80 /* US_SEMICOLON */, ';', ';', 'OEM_1');\r\n    define(81 /* US_EQUAL */, '=', '=', 'OEM_PLUS');\r\n    define(82 /* US_COMMA */, ',', ',', 'OEM_COMMA');\r\n    define(83 /* US_MINUS */, '-', '-', 'OEM_MINUS');\r\n    define(84 /* US_DOT */, '.', '.', 'OEM_PERIOD');\r\n    define(85 /* US_SLASH */, '/', '/', 'OEM_2');\r\n    define(86 /* US_BACKTICK */, '`', '`', 'OEM_3');\r\n    define(110 /* ABNT_C1 */, 'ABNT_C1');\r\n    define(111 /* ABNT_C2 */, 'ABNT_C2');\r\n    define(87 /* US_OPEN_SQUARE_BRACKET */, '[', '[', 'OEM_4');\r\n    define(88 /* US_BACKSLASH */, '\\\\', '\\\\', 'OEM_5');\r\n    define(89 /* US_CLOSE_SQUARE_BRACKET */, ']', ']', 'OEM_6');\r\n    define(90 /* US_QUOTE */, '\\'', '\\'', 'OEM_7');\r\n    define(91 /* OEM_8 */, 'OEM_8');\r\n    define(92 /* OEM_102 */, 'OEM_102');\r\n    define(93 /* NUMPAD_0 */, 'NumPad0');\r\n    define(94 /* NUMPAD_1 */, 'NumPad1');\r\n    define(95 /* NUMPAD_2 */, 'NumPad2');\r\n    define(96 /* NUMPAD_3 */, 'NumPad3');\r\n    define(97 /* NUMPAD_4 */, 'NumPad4');\r\n    define(98 /* NUMPAD_5 */, 'NumPad5');\r\n    define(99 /* NUMPAD_6 */, 'NumPad6');\r\n    define(100 /* NUMPAD_7 */, 'NumPad7');\r\n    define(101 /* NUMPAD_8 */, 'NumPad8');\r\n    define(102 /* NUMPAD_9 */, 'NumPad9');\r\n    define(103 /* NUMPAD_MULTIPLY */, 'NumPad_Multiply');\r\n    define(104 /* NUMPAD_ADD */, 'NumPad_Add');\r\n    define(105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator');\r\n    define(106 /* NUMPAD_SUBTRACT */, 'NumPad_Subtract');\r\n    define(107 /* NUMPAD_DECIMAL */, 'NumPad_Decimal');\r\n    define(108 /* NUMPAD_DIVIDE */, 'NumPad_Divide');\r\n})();\r\nvar KeyCodeUtils;\r\n(function (KeyCodeUtils) {\r\n    function toString(keyCode) {\r\n        return uiMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toString = toString;\r\n    function fromString(key) {\r\n        return uiMap.strToKeyCode(key);\r\n    }\r\n    KeyCodeUtils.fromString = fromString;\r\n    function toUserSettingsUS(keyCode) {\r\n        return userSettingsUSMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;\r\n    function toUserSettingsGeneral(keyCode) {\r\n        return userSettingsGeneralMap.keyCodeToStr(keyCode);\r\n    }\r\n    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;\r\n    function fromUserSettings(key) {\r\n        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\r\n    }\r\n    KeyCodeUtils.fromUserSettings = fromUserSettings;\r\n})(KeyCodeUtils || (KeyCodeUtils = {}));\r\nfunction KeyChord(firstPart, secondPart) {\r\n    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\r\n    return (firstPart | chordPart) >>> 0;\r\n}\r\nfunction createKeybinding(keybinding, OS) {\r\n    if (keybinding === 0) {\r\n        return null;\r\n    }\r\n    const firstPart = (keybinding & 0x0000FFFF) >>> 0;\r\n    const chordPart = (keybinding & 0xFFFF0000) >>> 16;\r\n    if (chordPart !== 0) {\r\n        return new ChordKeybinding([\r\n            createSimpleKeybinding(firstPart, OS),\r\n            createSimpleKeybinding(chordPart, OS)\r\n        ]);\r\n    }\r\n    return new ChordKeybinding([createSimpleKeybinding(firstPart, OS)]);\r\n}\r\nfunction createSimpleKeybinding(keybinding, OS) {\r\n    const ctrlCmd = (keybinding & 2048 /* CtrlCmd */ ? true : false);\r\n    const winCtrl = (keybinding & 256 /* WinCtrl */ ? true : false);\r\n    const ctrlKey = (OS === 2 /* Macintosh */ ? winCtrl : ctrlCmd);\r\n    const shiftKey = (keybinding & 1024 /* Shift */ ? true : false);\r\n    const altKey = (keybinding & 512 /* Alt */ ? true : false);\r\n    const metaKey = (OS === 2 /* Macintosh */ ? ctrlCmd : winCtrl);\r\n    const keyCode = (keybinding & 255 /* KeyCode */);\r\n    return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);\r\n}\r\nclass SimpleKeybinding {\r\n    constructor(ctrlKey, shiftKey, altKey, metaKey, keyCode) {\r\n        this.ctrlKey = ctrlKey;\r\n        this.shiftKey = shiftKey;\r\n        this.altKey = altKey;\r\n        this.metaKey = metaKey;\r\n        this.keyCode = keyCode;\r\n    }\r\n    equals(other) {\r\n        return (this.ctrlKey === other.ctrlKey\r\n            && this.shiftKey === other.shiftKey\r\n            && this.altKey === other.altKey\r\n            && this.metaKey === other.metaKey\r\n            && this.keyCode === other.keyCode);\r\n    }\r\n    isModifierKey() {\r\n        return (this.keyCode === 0 /* Unknown */\r\n            || this.keyCode === 5 /* Ctrl */\r\n            || this.keyCode === 57 /* Meta */\r\n            || this.keyCode === 6 /* Alt */\r\n            || this.keyCode === 4 /* Shift */);\r\n    }\r\n    toChord() {\r\n        return new ChordKeybinding([this]);\r\n    }\r\n    /**\r\n     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\r\n     */\r\n    isDuplicateModifierCase() {\r\n        return ((this.ctrlKey && this.keyCode === 5 /* Ctrl */)\r\n            || (this.shiftKey && this.keyCode === 4 /* Shift */)\r\n            || (this.altKey && this.keyCode === 6 /* Alt */)\r\n            || (this.metaKey && this.keyCode === 57 /* Meta */));\r\n    }\r\n}\r\nclass ChordKeybinding {\r\n    constructor(parts) {\r\n        if (parts.length === 0) {\r\n            throw illegalArgument(`parts`);\r\n        }\r\n        this.parts = parts;\r\n    }\r\n}\r\nclass ResolvedKeybindingPart {\r\n    constructor(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {\r\n        this.ctrlKey = ctrlKey;\r\n        this.shiftKey = shiftKey;\r\n        this.altKey = altKey;\r\n        this.metaKey = metaKey;\r\n        this.keyLabel = kbLabel;\r\n        this.keyAriaLabel = kbAriaLabel;\r\n    }\r\n}\r\n/**\r\n * A resolved keybinding. Can be a simple keybinding or a chord keybinding.\r\n */\r\nclass ResolvedKeybinding {\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n/**\r\n * A selection in the editor.\r\n * The selection is a range that has an orientation.\r\n */\r\nclass Selection extends Range {\r\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\r\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\r\n        this.selectionStartLineNumber = selectionStartLineNumber;\r\n        this.selectionStartColumn = selectionStartColumn;\r\n        this.positionLineNumber = positionLineNumber;\r\n        this.positionColumn = positionColumn;\r\n    }\r\n    /**\r\n     * Transform to a human-readable representation.\r\n     */\r\n    toString() {\r\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\r\n    }\r\n    /**\r\n     * Test if equals other selection.\r\n     */\r\n    equalsSelection(other) {\r\n        return (Selection.selectionsEqual(this, other));\r\n    }\r\n    /**\r\n     * Test if the two selections are equal.\r\n     */\r\n    static selectionsEqual(a, b) {\r\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\r\n            a.selectionStartColumn === b.selectionStartColumn &&\r\n            a.positionLineNumber === b.positionLineNumber &&\r\n            a.positionColumn === b.positionColumn);\r\n    }\r\n    /**\r\n     * Get directions (LTR or RTL).\r\n     */\r\n    getDirection() {\r\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\r\n            return 0 /* LTR */;\r\n        }\r\n        return 1 /* RTL */;\r\n    }\r\n    /**\r\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\r\n     */\r\n    setEndPosition(endLineNumber, endColumn) {\r\n        if (this.getDirection() === 0 /* LTR */) {\r\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n        }\r\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\r\n    }\r\n    /**\r\n     * Get the position at `positionLineNumber` and `positionColumn`.\r\n     */\r\n    getPosition() {\r\n        return new Position(this.positionLineNumber, this.positionColumn);\r\n    }\r\n    /**\r\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\r\n     */\r\n    setStartPosition(startLineNumber, startColumn) {\r\n        if (this.getDirection() === 0 /* LTR */) {\r\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n        }\r\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\r\n    }\r\n    // ----\r\n    /**\r\n     * Create a `Selection` from one or two positions\r\n     */\r\n    static fromPositions(start, end = start) {\r\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    /**\r\n     * Create a `Selection` from an `ISelection`.\r\n     */\r\n    static liftSelection(sel) {\r\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\r\n    }\r\n    /**\r\n     * `a` equals `b`.\r\n     */\r\n    static selectionsArrEqual(a, b) {\r\n        if (a && !b || !a && b) {\r\n            return false;\r\n        }\r\n        if (!a && !b) {\r\n            return true;\r\n        }\r\n        if (a.length !== b.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = a.length; i < len; i++) {\r\n            if (!this.selectionsEqual(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `obj` is an `ISelection`.\r\n     */\r\n    static isISelection(obj) {\r\n        return (obj\r\n            && (typeof obj.selectionStartLineNumber === 'number')\r\n            && (typeof obj.selectionStartColumn === 'number')\r\n            && (typeof obj.positionLineNumber === 'number')\r\n            && (typeof obj.positionColumn === 'number'));\r\n    }\r\n    /**\r\n     * Create with a direction.\r\n     */\r\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\r\n        if (direction === 0 /* LTR */) {\r\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\r\n        }\r\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/token.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Token {\r\n    constructor(offset, type, language) {\r\n        this._tokenBrand = undefined;\r\n        this.offset = offset | 0; // @perf\r\n        this.type = type;\r\n        this.language = language;\r\n    }\r\n    toString() {\r\n        return '(' + this.offset + ', ' + this.type + ')';\r\n    }\r\n}\r\nclass TokenizationResult {\r\n    constructor(tokens, endState) {\r\n        this._tokenizationResultBrand = undefined;\r\n        this.tokens = tokens;\r\n        this.endState = endState;\r\n    }\r\n}\r\nclass TokenizationResult2 {\r\n    constructor(tokens, endState) {\r\n        this._tokenizationResult2Brand = undefined;\r\n        this.tokens = tokens;\r\n        this.endState = endState;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.\r\nvar AccessibilitySupport;\r\n(function (AccessibilitySupport) {\r\n    /**\r\n     * This should be the browser case where it is not known if a screen reader is attached or no.\r\n     */\r\n    AccessibilitySupport[AccessibilitySupport[\"Unknown\"] = 0] = \"Unknown\";\r\n    AccessibilitySupport[AccessibilitySupport[\"Disabled\"] = 1] = \"Disabled\";\r\n    AccessibilitySupport[AccessibilitySupport[\"Enabled\"] = 2] = \"Enabled\";\r\n})(AccessibilitySupport || (AccessibilitySupport = {}));\r\nvar CompletionItemInsertTextRule;\r\n(function (CompletionItemInsertTextRule) {\r\n    /**\r\n     * Adjust whitespace/indentation of multiline insert texts to\r\n     * match the current line indentation.\r\n     */\r\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\r\n    /**\r\n     * `insertText` is a snippet.\r\n     */\r\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\r\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));\r\nvar CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind[CompletionItemKind[\"Method\"] = 0] = \"Method\";\r\n    CompletionItemKind[CompletionItemKind[\"Function\"] = 1] = \"Function\";\r\n    CompletionItemKind[CompletionItemKind[\"Constructor\"] = 2] = \"Constructor\";\r\n    CompletionItemKind[CompletionItemKind[\"Field\"] = 3] = \"Field\";\r\n    CompletionItemKind[CompletionItemKind[\"Variable\"] = 4] = \"Variable\";\r\n    CompletionItemKind[CompletionItemKind[\"Class\"] = 5] = \"Class\";\r\n    CompletionItemKind[CompletionItemKind[\"Struct\"] = 6] = \"Struct\";\r\n    CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\r\n    CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\r\n    CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\r\n    CompletionItemKind[CompletionItemKind[\"Event\"] = 10] = \"Event\";\r\n    CompletionItemKind[CompletionItemKind[\"Operator\"] = 11] = \"Operator\";\r\n    CompletionItemKind[CompletionItemKind[\"Unit\"] = 12] = \"Unit\";\r\n    CompletionItemKind[CompletionItemKind[\"Value\"] = 13] = \"Value\";\r\n    CompletionItemKind[CompletionItemKind[\"Constant\"] = 14] = \"Constant\";\r\n    CompletionItemKind[CompletionItemKind[\"Enum\"] = 15] = \"Enum\";\r\n    CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 16] = \"EnumMember\";\r\n    CompletionItemKind[CompletionItemKind[\"Keyword\"] = 17] = \"Keyword\";\r\n    CompletionItemKind[CompletionItemKind[\"Text\"] = 18] = \"Text\";\r\n    CompletionItemKind[CompletionItemKind[\"Color\"] = 19] = \"Color\";\r\n    CompletionItemKind[CompletionItemKind[\"File\"] = 20] = \"File\";\r\n    CompletionItemKind[CompletionItemKind[\"Reference\"] = 21] = \"Reference\";\r\n    CompletionItemKind[CompletionItemKind[\"Customcolor\"] = 22] = \"Customcolor\";\r\n    CompletionItemKind[CompletionItemKind[\"Folder\"] = 23] = \"Folder\";\r\n    CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\r\n    CompletionItemKind[CompletionItemKind[\"User\"] = 25] = \"User\";\r\n    CompletionItemKind[CompletionItemKind[\"Issue\"] = 26] = \"Issue\";\r\n    CompletionItemKind[CompletionItemKind[\"Snippet\"] = 27] = \"Snippet\";\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\nvar CompletionItemTag;\r\n(function (CompletionItemTag) {\r\n    CompletionItemTag[CompletionItemTag[\"Deprecated\"] = 1] = \"Deprecated\";\r\n})(CompletionItemTag || (CompletionItemTag = {}));\r\n/**\r\n * How a suggest provider was triggered.\r\n */\r\nvar CompletionTriggerKind;\r\n(function (CompletionTriggerKind) {\r\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\r\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\r\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\r\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\r\n/**\r\n * A positioning preference for rendering content widgets.\r\n */\r\nvar ContentWidgetPositionPreference;\r\n(function (ContentWidgetPositionPreference) {\r\n    /**\r\n     * Place the content widget exactly at a position\r\n     */\r\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"EXACT\"] = 0] = \"EXACT\";\r\n    /**\r\n     * Place the content widget above a position\r\n     */\r\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"ABOVE\"] = 1] = \"ABOVE\";\r\n    /**\r\n     * Place the content widget below a position\r\n     */\r\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"BELOW\"] = 2] = \"BELOW\";\r\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));\r\n/**\r\n * Describes the reason the cursor has changed its position.\r\n */\r\nvar CursorChangeReason;\r\n(function (CursorChangeReason) {\r\n    /**\r\n     * Unknown or not set.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"NotSet\"] = 0] = \"NotSet\";\r\n    /**\r\n     * A `model.setValue()` was called.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"ContentFlush\"] = 1] = \"ContentFlush\";\r\n    /**\r\n     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\r\n    /**\r\n     * There was an explicit user gesture.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Explicit\"] = 3] = \"Explicit\";\r\n    /**\r\n     * There was a Paste.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Paste\"] = 4] = \"Paste\";\r\n    /**\r\n     * There was an Undo.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Undo\"] = 5] = \"Undo\";\r\n    /**\r\n     * There was a Redo.\r\n     */\r\n    CursorChangeReason[CursorChangeReason[\"Redo\"] = 6] = \"Redo\";\r\n})(CursorChangeReason || (CursorChangeReason = {}));\r\n/**\r\n * The default end of line to use when instantiating models.\r\n */\r\nvar DefaultEndOfLine;\r\n(function (DefaultEndOfLine) {\r\n    /**\r\n     * Use line feed (\\n) as the end of line character.\r\n     */\r\n    DefaultEndOfLine[DefaultEndOfLine[\"LF\"] = 1] = \"LF\";\r\n    /**\r\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\r\n     */\r\n    DefaultEndOfLine[DefaultEndOfLine[\"CRLF\"] = 2] = \"CRLF\";\r\n})(DefaultEndOfLine || (DefaultEndOfLine = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nvar DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * Configuration options for auto indentation in the editor\r\n */\r\nvar EditorAutoIndentStrategy;\r\n(function (EditorAutoIndentStrategy) {\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"None\"] = 0] = \"None\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Keep\"] = 1] = \"Keep\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Brackets\"] = 2] = \"Brackets\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Advanced\"] = 3] = \"Advanced\";\r\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Full\"] = 4] = \"Full\";\r\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));\r\nvar EditorOption;\r\n(function (EditorOption) {\r\n    EditorOption[EditorOption[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\r\n    EditorOption[EditorOption[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\r\n    EditorOption[EditorOption[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\r\n    EditorOption[EditorOption[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\r\n    EditorOption[EditorOption[\"ariaLabel\"] = 4] = \"ariaLabel\";\r\n    EditorOption[EditorOption[\"autoClosingBrackets\"] = 5] = \"autoClosingBrackets\";\r\n    EditorOption[EditorOption[\"autoClosingDelete\"] = 6] = \"autoClosingDelete\";\r\n    EditorOption[EditorOption[\"autoClosingOvertype\"] = 7] = \"autoClosingOvertype\";\r\n    EditorOption[EditorOption[\"autoClosingQuotes\"] = 8] = \"autoClosingQuotes\";\r\n    EditorOption[EditorOption[\"autoIndent\"] = 9] = \"autoIndent\";\r\n    EditorOption[EditorOption[\"automaticLayout\"] = 10] = \"automaticLayout\";\r\n    EditorOption[EditorOption[\"autoSurround\"] = 11] = \"autoSurround\";\r\n    EditorOption[EditorOption[\"codeLens\"] = 12] = \"codeLens\";\r\n    EditorOption[EditorOption[\"codeLensFontFamily\"] = 13] = \"codeLensFontFamily\";\r\n    EditorOption[EditorOption[\"codeLensFontSize\"] = 14] = \"codeLensFontSize\";\r\n    EditorOption[EditorOption[\"colorDecorators\"] = 15] = \"colorDecorators\";\r\n    EditorOption[EditorOption[\"columnSelection\"] = 16] = \"columnSelection\";\r\n    EditorOption[EditorOption[\"comments\"] = 17] = \"comments\";\r\n    EditorOption[EditorOption[\"contextmenu\"] = 18] = \"contextmenu\";\r\n    EditorOption[EditorOption[\"copyWithSyntaxHighlighting\"] = 19] = \"copyWithSyntaxHighlighting\";\r\n    EditorOption[EditorOption[\"cursorBlinking\"] = 20] = \"cursorBlinking\";\r\n    EditorOption[EditorOption[\"cursorSmoothCaretAnimation\"] = 21] = \"cursorSmoothCaretAnimation\";\r\n    EditorOption[EditorOption[\"cursorStyle\"] = 22] = \"cursorStyle\";\r\n    EditorOption[EditorOption[\"cursorSurroundingLines\"] = 23] = \"cursorSurroundingLines\";\r\n    EditorOption[EditorOption[\"cursorSurroundingLinesStyle\"] = 24] = \"cursorSurroundingLinesStyle\";\r\n    EditorOption[EditorOption[\"cursorWidth\"] = 25] = \"cursorWidth\";\r\n    EditorOption[EditorOption[\"disableLayerHinting\"] = 26] = \"disableLayerHinting\";\r\n    EditorOption[EditorOption[\"disableMonospaceOptimizations\"] = 27] = \"disableMonospaceOptimizations\";\r\n    EditorOption[EditorOption[\"domReadOnly\"] = 28] = \"domReadOnly\";\r\n    EditorOption[EditorOption[\"dragAndDrop\"] = 29] = \"dragAndDrop\";\r\n    EditorOption[EditorOption[\"emptySelectionClipboard\"] = 30] = \"emptySelectionClipboard\";\r\n    EditorOption[EditorOption[\"extraEditorClassName\"] = 31] = \"extraEditorClassName\";\r\n    EditorOption[EditorOption[\"fastScrollSensitivity\"] = 32] = \"fastScrollSensitivity\";\r\n    EditorOption[EditorOption[\"find\"] = 33] = \"find\";\r\n    EditorOption[EditorOption[\"fixedOverflowWidgets\"] = 34] = \"fixedOverflowWidgets\";\r\n    EditorOption[EditorOption[\"folding\"] = 35] = \"folding\";\r\n    EditorOption[EditorOption[\"foldingStrategy\"] = 36] = \"foldingStrategy\";\r\n    EditorOption[EditorOption[\"foldingHighlight\"] = 37] = \"foldingHighlight\";\r\n    EditorOption[EditorOption[\"foldingImportsByDefault\"] = 38] = \"foldingImportsByDefault\";\r\n    EditorOption[EditorOption[\"unfoldOnClickAfterEndOfLine\"] = 39] = \"unfoldOnClickAfterEndOfLine\";\r\n    EditorOption[EditorOption[\"fontFamily\"] = 40] = \"fontFamily\";\r\n    EditorOption[EditorOption[\"fontInfo\"] = 41] = \"fontInfo\";\r\n    EditorOption[EditorOption[\"fontLigatures\"] = 42] = \"fontLigatures\";\r\n    EditorOption[EditorOption[\"fontSize\"] = 43] = \"fontSize\";\r\n    EditorOption[EditorOption[\"fontWeight\"] = 44] = \"fontWeight\";\r\n    EditorOption[EditorOption[\"formatOnPaste\"] = 45] = \"formatOnPaste\";\r\n    EditorOption[EditorOption[\"formatOnType\"] = 46] = \"formatOnType\";\r\n    EditorOption[EditorOption[\"glyphMargin\"] = 47] = \"glyphMargin\";\r\n    EditorOption[EditorOption[\"gotoLocation\"] = 48] = \"gotoLocation\";\r\n    EditorOption[EditorOption[\"hideCursorInOverviewRuler\"] = 49] = \"hideCursorInOverviewRuler\";\r\n    EditorOption[EditorOption[\"highlightActiveIndentGuide\"] = 50] = \"highlightActiveIndentGuide\";\r\n    EditorOption[EditorOption[\"hover\"] = 51] = \"hover\";\r\n    EditorOption[EditorOption[\"inDiffEditor\"] = 52] = \"inDiffEditor\";\r\n    EditorOption[EditorOption[\"inlineSuggest\"] = 53] = \"inlineSuggest\";\r\n    EditorOption[EditorOption[\"letterSpacing\"] = 54] = \"letterSpacing\";\r\n    EditorOption[EditorOption[\"lightbulb\"] = 55] = \"lightbulb\";\r\n    EditorOption[EditorOption[\"lineDecorationsWidth\"] = 56] = \"lineDecorationsWidth\";\r\n    EditorOption[EditorOption[\"lineHeight\"] = 57] = \"lineHeight\";\r\n    EditorOption[EditorOption[\"lineNumbers\"] = 58] = \"lineNumbers\";\r\n    EditorOption[EditorOption[\"lineNumbersMinChars\"] = 59] = \"lineNumbersMinChars\";\r\n    EditorOption[EditorOption[\"linkedEditing\"] = 60] = \"linkedEditing\";\r\n    EditorOption[EditorOption[\"links\"] = 61] = \"links\";\r\n    EditorOption[EditorOption[\"matchBrackets\"] = 62] = \"matchBrackets\";\r\n    EditorOption[EditorOption[\"minimap\"] = 63] = \"minimap\";\r\n    EditorOption[EditorOption[\"mouseStyle\"] = 64] = \"mouseStyle\";\r\n    EditorOption[EditorOption[\"mouseWheelScrollSensitivity\"] = 65] = \"mouseWheelScrollSensitivity\";\r\n    EditorOption[EditorOption[\"mouseWheelZoom\"] = 66] = \"mouseWheelZoom\";\r\n    EditorOption[EditorOption[\"multiCursorMergeOverlapping\"] = 67] = \"multiCursorMergeOverlapping\";\r\n    EditorOption[EditorOption[\"multiCursorModifier\"] = 68] = \"multiCursorModifier\";\r\n    EditorOption[EditorOption[\"multiCursorPaste\"] = 69] = \"multiCursorPaste\";\r\n    EditorOption[EditorOption[\"occurrencesHighlight\"] = 70] = \"occurrencesHighlight\";\r\n    EditorOption[EditorOption[\"overviewRulerBorder\"] = 71] = \"overviewRulerBorder\";\r\n    EditorOption[EditorOption[\"overviewRulerLanes\"] = 72] = \"overviewRulerLanes\";\r\n    EditorOption[EditorOption[\"padding\"] = 73] = \"padding\";\r\n    EditorOption[EditorOption[\"parameterHints\"] = 74] = \"parameterHints\";\r\n    EditorOption[EditorOption[\"peekWidgetDefaultFocus\"] = 75] = \"peekWidgetDefaultFocus\";\r\n    EditorOption[EditorOption[\"definitionLinkOpensInPeek\"] = 76] = \"definitionLinkOpensInPeek\";\r\n    EditorOption[EditorOption[\"quickSuggestions\"] = 77] = \"quickSuggestions\";\r\n    EditorOption[EditorOption[\"quickSuggestionsDelay\"] = 78] = \"quickSuggestionsDelay\";\r\n    EditorOption[EditorOption[\"readOnly\"] = 79] = \"readOnly\";\r\n    EditorOption[EditorOption[\"renameOnType\"] = 80] = \"renameOnType\";\r\n    EditorOption[EditorOption[\"renderControlCharacters\"] = 81] = \"renderControlCharacters\";\r\n    EditorOption[EditorOption[\"renderIndentGuides\"] = 82] = \"renderIndentGuides\";\r\n    EditorOption[EditorOption[\"renderFinalNewline\"] = 83] = \"renderFinalNewline\";\r\n    EditorOption[EditorOption[\"renderLineHighlight\"] = 84] = \"renderLineHighlight\";\r\n    EditorOption[EditorOption[\"renderLineHighlightOnlyWhenFocus\"] = 85] = \"renderLineHighlightOnlyWhenFocus\";\r\n    EditorOption[EditorOption[\"renderValidationDecorations\"] = 86] = \"renderValidationDecorations\";\r\n    EditorOption[EditorOption[\"renderWhitespace\"] = 87] = \"renderWhitespace\";\r\n    EditorOption[EditorOption[\"revealHorizontalRightPadding\"] = 88] = \"revealHorizontalRightPadding\";\r\n    EditorOption[EditorOption[\"roundedSelection\"] = 89] = \"roundedSelection\";\r\n    EditorOption[EditorOption[\"rulers\"] = 90] = \"rulers\";\r\n    EditorOption[EditorOption[\"scrollbar\"] = 91] = \"scrollbar\";\r\n    EditorOption[EditorOption[\"scrollBeyondLastColumn\"] = 92] = \"scrollBeyondLastColumn\";\r\n    EditorOption[EditorOption[\"scrollBeyondLastLine\"] = 93] = \"scrollBeyondLastLine\";\r\n    EditorOption[EditorOption[\"scrollPredominantAxis\"] = 94] = \"scrollPredominantAxis\";\r\n    EditorOption[EditorOption[\"selectionClipboard\"] = 95] = \"selectionClipboard\";\r\n    EditorOption[EditorOption[\"selectionHighlight\"] = 96] = \"selectionHighlight\";\r\n    EditorOption[EditorOption[\"selectOnLineNumbers\"] = 97] = \"selectOnLineNumbers\";\r\n    EditorOption[EditorOption[\"showFoldingControls\"] = 98] = \"showFoldingControls\";\r\n    EditorOption[EditorOption[\"showUnused\"] = 99] = \"showUnused\";\r\n    EditorOption[EditorOption[\"snippetSuggestions\"] = 100] = \"snippetSuggestions\";\r\n    EditorOption[EditorOption[\"smartSelect\"] = 101] = \"smartSelect\";\r\n    EditorOption[EditorOption[\"smoothScrolling\"] = 102] = \"smoothScrolling\";\r\n    EditorOption[EditorOption[\"stickyTabStops\"] = 103] = \"stickyTabStops\";\r\n    EditorOption[EditorOption[\"stopRenderingLineAfter\"] = 104] = \"stopRenderingLineAfter\";\r\n    EditorOption[EditorOption[\"suggest\"] = 105] = \"suggest\";\r\n    EditorOption[EditorOption[\"suggestFontSize\"] = 106] = \"suggestFontSize\";\r\n    EditorOption[EditorOption[\"suggestLineHeight\"] = 107] = \"suggestLineHeight\";\r\n    EditorOption[EditorOption[\"suggestOnTriggerCharacters\"] = 108] = \"suggestOnTriggerCharacters\";\r\n    EditorOption[EditorOption[\"suggestSelection\"] = 109] = \"suggestSelection\";\r\n    EditorOption[EditorOption[\"tabCompletion\"] = 110] = \"tabCompletion\";\r\n    EditorOption[EditorOption[\"tabIndex\"] = 111] = \"tabIndex\";\r\n    EditorOption[EditorOption[\"unusualLineTerminators\"] = 112] = \"unusualLineTerminators\";\r\n    EditorOption[EditorOption[\"useShadowDOM\"] = 113] = \"useShadowDOM\";\r\n    EditorOption[EditorOption[\"useTabStops\"] = 114] = \"useTabStops\";\r\n    EditorOption[EditorOption[\"wordSeparators\"] = 115] = \"wordSeparators\";\r\n    EditorOption[EditorOption[\"wordWrap\"] = 116] = \"wordWrap\";\r\n    EditorOption[EditorOption[\"wordWrapBreakAfterCharacters\"] = 117] = \"wordWrapBreakAfterCharacters\";\r\n    EditorOption[EditorOption[\"wordWrapBreakBeforeCharacters\"] = 118] = \"wordWrapBreakBeforeCharacters\";\r\n    EditorOption[EditorOption[\"wordWrapColumn\"] = 119] = \"wordWrapColumn\";\r\n    EditorOption[EditorOption[\"wordWrapOverride1\"] = 120] = \"wordWrapOverride1\";\r\n    EditorOption[EditorOption[\"wordWrapOverride2\"] = 121] = \"wordWrapOverride2\";\r\n    EditorOption[EditorOption[\"wrappingIndent\"] = 122] = \"wrappingIndent\";\r\n    EditorOption[EditorOption[\"wrappingStrategy\"] = 123] = \"wrappingStrategy\";\r\n    EditorOption[EditorOption[\"showDeprecated\"] = 124] = \"showDeprecated\";\r\n    EditorOption[EditorOption[\"inlayHints\"] = 125] = \"inlayHints\";\r\n    EditorOption[EditorOption[\"editorClassName\"] = 126] = \"editorClassName\";\r\n    EditorOption[EditorOption[\"pixelRatio\"] = 127] = \"pixelRatio\";\r\n    EditorOption[EditorOption[\"tabFocusMode\"] = 128] = \"tabFocusMode\";\r\n    EditorOption[EditorOption[\"layoutInfo\"] = 129] = \"layoutInfo\";\r\n    EditorOption[EditorOption[\"wrappingInfo\"] = 130] = \"wrappingInfo\";\r\n})(EditorOption || (EditorOption = {}));\r\n/**\r\n * End of line character preference.\r\n */\r\nvar EndOfLinePreference;\r\n(function (EndOfLinePreference) {\r\n    /**\r\n     * Use the end of line character identified in the text buffer.\r\n     */\r\n    EndOfLinePreference[EndOfLinePreference[\"TextDefined\"] = 0] = \"TextDefined\";\r\n    /**\r\n     * Use line feed (\\n) as the end of line character.\r\n     */\r\n    EndOfLinePreference[EndOfLinePreference[\"LF\"] = 1] = \"LF\";\r\n    /**\r\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\r\n     */\r\n    EndOfLinePreference[EndOfLinePreference[\"CRLF\"] = 2] = \"CRLF\";\r\n})(EndOfLinePreference || (EndOfLinePreference = {}));\r\n/**\r\n * End of line character preference.\r\n */\r\nvar EndOfLineSequence;\r\n(function (EndOfLineSequence) {\r\n    /**\r\n     * Use line feed (\\n) as the end of line character.\r\n     */\r\n    EndOfLineSequence[EndOfLineSequence[\"LF\"] = 0] = \"LF\";\r\n    /**\r\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\r\n     */\r\n    EndOfLineSequence[EndOfLineSequence[\"CRLF\"] = 1] = \"CRLF\";\r\n})(EndOfLineSequence || (EndOfLineSequence = {}));\r\n/**\r\n * Describes what to do with the indentation when pressing Enter.\r\n */\r\nvar IndentAction;\r\n(function (IndentAction) {\r\n    /**\r\n     * Insert new line and copy the previous line's indentation.\r\n     */\r\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Insert new line and indent once (relative to the previous line's indentation).\r\n     */\r\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\r\n    /**\r\n     * Insert two new lines:\r\n     *  - the first one indented which will hold the cursor\r\n     *  - the second one at the same indentation level\r\n     */\r\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\r\n    /**\r\n     * Insert new line and outdent once (relative to the previous line's indentation).\r\n     */\r\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\r\n})(IndentAction || (IndentAction = {}));\r\nvar InlayHintKind;\r\n(function (InlayHintKind) {\r\n    InlayHintKind[InlayHintKind[\"Other\"] = 0] = \"Other\";\r\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\r\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\r\n})(InlayHintKind || (InlayHintKind = {}));\r\n/**\r\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\r\n */\r\nvar InlineCompletionTriggerKind;\r\n(function (InlineCompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered automatically while editing.\r\n     * It is sufficient to return a single completion item in this case.\r\n     */\r\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\r\n    /**\r\n     * Completion was triggered explicitly by a user gesture.\r\n     * Return multiple completion items to enable cycling through them.\r\n     */\r\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\r\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\r\n/**\r\n * Virtual Key Codes, the value does not hold any inherent meaning.\r\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\r\n * But these are \"more general\", as they should work across browsers & OS`s.\r\n */\r\nvar KeyCode;\r\n(function (KeyCode) {\r\n    KeyCode[KeyCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\r\n    /**\r\n     * Placed first to cover the 0 value of the enum.\r\n     */\r\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\r\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\r\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\r\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\r\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\r\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\r\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\r\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\r\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\r\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\r\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\r\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\r\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\r\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\r\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\r\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\r\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\r\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\r\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\r\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\r\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\r\n    KeyCode[KeyCode[\"KEY_0\"] = 21] = \"KEY_0\";\r\n    KeyCode[KeyCode[\"KEY_1\"] = 22] = \"KEY_1\";\r\n    KeyCode[KeyCode[\"KEY_2\"] = 23] = \"KEY_2\";\r\n    KeyCode[KeyCode[\"KEY_3\"] = 24] = \"KEY_3\";\r\n    KeyCode[KeyCode[\"KEY_4\"] = 25] = \"KEY_4\";\r\n    KeyCode[KeyCode[\"KEY_5\"] = 26] = \"KEY_5\";\r\n    KeyCode[KeyCode[\"KEY_6\"] = 27] = \"KEY_6\";\r\n    KeyCode[KeyCode[\"KEY_7\"] = 28] = \"KEY_7\";\r\n    KeyCode[KeyCode[\"KEY_8\"] = 29] = \"KEY_8\";\r\n    KeyCode[KeyCode[\"KEY_9\"] = 30] = \"KEY_9\";\r\n    KeyCode[KeyCode[\"KEY_A\"] = 31] = \"KEY_A\";\r\n    KeyCode[KeyCode[\"KEY_B\"] = 32] = \"KEY_B\";\r\n    KeyCode[KeyCode[\"KEY_C\"] = 33] = \"KEY_C\";\r\n    KeyCode[KeyCode[\"KEY_D\"] = 34] = \"KEY_D\";\r\n    KeyCode[KeyCode[\"KEY_E\"] = 35] = \"KEY_E\";\r\n    KeyCode[KeyCode[\"KEY_F\"] = 36] = \"KEY_F\";\r\n    KeyCode[KeyCode[\"KEY_G\"] = 37] = \"KEY_G\";\r\n    KeyCode[KeyCode[\"KEY_H\"] = 38] = \"KEY_H\";\r\n    KeyCode[KeyCode[\"KEY_I\"] = 39] = \"KEY_I\";\r\n    KeyCode[KeyCode[\"KEY_J\"] = 40] = \"KEY_J\";\r\n    KeyCode[KeyCode[\"KEY_K\"] = 41] = \"KEY_K\";\r\n    KeyCode[KeyCode[\"KEY_L\"] = 42] = \"KEY_L\";\r\n    KeyCode[KeyCode[\"KEY_M\"] = 43] = \"KEY_M\";\r\n    KeyCode[KeyCode[\"KEY_N\"] = 44] = \"KEY_N\";\r\n    KeyCode[KeyCode[\"KEY_O\"] = 45] = \"KEY_O\";\r\n    KeyCode[KeyCode[\"KEY_P\"] = 46] = \"KEY_P\";\r\n    KeyCode[KeyCode[\"KEY_Q\"] = 47] = \"KEY_Q\";\r\n    KeyCode[KeyCode[\"KEY_R\"] = 48] = \"KEY_R\";\r\n    KeyCode[KeyCode[\"KEY_S\"] = 49] = \"KEY_S\";\r\n    KeyCode[KeyCode[\"KEY_T\"] = 50] = \"KEY_T\";\r\n    KeyCode[KeyCode[\"KEY_U\"] = 51] = \"KEY_U\";\r\n    KeyCode[KeyCode[\"KEY_V\"] = 52] = \"KEY_V\";\r\n    KeyCode[KeyCode[\"KEY_W\"] = 53] = \"KEY_W\";\r\n    KeyCode[KeyCode[\"KEY_X\"] = 54] = \"KEY_X\";\r\n    KeyCode[KeyCode[\"KEY_Y\"] = 55] = \"KEY_Y\";\r\n    KeyCode[KeyCode[\"KEY_Z\"] = 56] = \"KEY_Z\";\r\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\r\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\r\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\r\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\r\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\r\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\r\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\r\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\r\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\r\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\r\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\r\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\r\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\r\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\r\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\r\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\r\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\r\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\r\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\r\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\r\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\r\n    KeyCode[KeyCode[\"NumLock\"] = 78] = \"NumLock\";\r\n    KeyCode[KeyCode[\"ScrollLock\"] = 79] = \"ScrollLock\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the ';:' key\r\n     */\r\n    KeyCode[KeyCode[\"US_SEMICOLON\"] = 80] = \"US_SEMICOLON\";\r\n    /**\r\n     * For any country/region, the '+' key\r\n     * For the US standard keyboard, the '=+' key\r\n     */\r\n    KeyCode[KeyCode[\"US_EQUAL\"] = 81] = \"US_EQUAL\";\r\n    /**\r\n     * For any country/region, the ',' key\r\n     * For the US standard keyboard, the ',<' key\r\n     */\r\n    KeyCode[KeyCode[\"US_COMMA\"] = 82] = \"US_COMMA\";\r\n    /**\r\n     * For any country/region, the '-' key\r\n     * For the US standard keyboard, the '-_' key\r\n     */\r\n    KeyCode[KeyCode[\"US_MINUS\"] = 83] = \"US_MINUS\";\r\n    /**\r\n     * For any country/region, the '.' key\r\n     * For the US standard keyboard, the '.>' key\r\n     */\r\n    KeyCode[KeyCode[\"US_DOT\"] = 84] = \"US_DOT\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '/?' key\r\n     */\r\n    KeyCode[KeyCode[\"US_SLASH\"] = 85] = \"US_SLASH\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '`~' key\r\n     */\r\n    KeyCode[KeyCode[\"US_BACKTICK\"] = 86] = \"US_BACKTICK\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '[{' key\r\n     */\r\n    KeyCode[KeyCode[\"US_OPEN_SQUARE_BRACKET\"] = 87] = \"US_OPEN_SQUARE_BRACKET\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the '\\|' key\r\n     */\r\n    KeyCode[KeyCode[\"US_BACKSLASH\"] = 88] = \"US_BACKSLASH\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the ']}' key\r\n     */\r\n    KeyCode[KeyCode[\"US_CLOSE_SQUARE_BRACKET\"] = 89] = \"US_CLOSE_SQUARE_BRACKET\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     * For the US standard keyboard, the ''\"' key\r\n     */\r\n    KeyCode[KeyCode[\"US_QUOTE\"] = 90] = \"US_QUOTE\";\r\n    /**\r\n     * Used for miscellaneous characters; it can vary by keyboard.\r\n     */\r\n    KeyCode[KeyCode[\"OEM_8\"] = 91] = \"OEM_8\";\r\n    /**\r\n     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\r\n     */\r\n    KeyCode[KeyCode[\"OEM_102\"] = 92] = \"OEM_102\";\r\n    KeyCode[KeyCode[\"NUMPAD_0\"] = 93] = \"NUMPAD_0\";\r\n    KeyCode[KeyCode[\"NUMPAD_1\"] = 94] = \"NUMPAD_1\";\r\n    KeyCode[KeyCode[\"NUMPAD_2\"] = 95] = \"NUMPAD_2\";\r\n    KeyCode[KeyCode[\"NUMPAD_3\"] = 96] = \"NUMPAD_3\";\r\n    KeyCode[KeyCode[\"NUMPAD_4\"] = 97] = \"NUMPAD_4\";\r\n    KeyCode[KeyCode[\"NUMPAD_5\"] = 98] = \"NUMPAD_5\";\r\n    KeyCode[KeyCode[\"NUMPAD_6\"] = 99] = \"NUMPAD_6\";\r\n    KeyCode[KeyCode[\"NUMPAD_7\"] = 100] = \"NUMPAD_7\";\r\n    KeyCode[KeyCode[\"NUMPAD_8\"] = 101] = \"NUMPAD_8\";\r\n    KeyCode[KeyCode[\"NUMPAD_9\"] = 102] = \"NUMPAD_9\";\r\n    KeyCode[KeyCode[\"NUMPAD_MULTIPLY\"] = 103] = \"NUMPAD_MULTIPLY\";\r\n    KeyCode[KeyCode[\"NUMPAD_ADD\"] = 104] = \"NUMPAD_ADD\";\r\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 105] = \"NUMPAD_SEPARATOR\";\r\n    KeyCode[KeyCode[\"NUMPAD_SUBTRACT\"] = 106] = \"NUMPAD_SUBTRACT\";\r\n    KeyCode[KeyCode[\"NUMPAD_DECIMAL\"] = 107] = \"NUMPAD_DECIMAL\";\r\n    KeyCode[KeyCode[\"NUMPAD_DIVIDE\"] = 108] = \"NUMPAD_DIVIDE\";\r\n    /**\r\n     * Cover all key codes when IME is processing input.\r\n     */\r\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 109] = \"KEY_IN_COMPOSITION\";\r\n    KeyCode[KeyCode[\"ABNT_C1\"] = 110] = \"ABNT_C1\";\r\n    KeyCode[KeyCode[\"ABNT_C2\"] = 111] = \"ABNT_C2\";\r\n    /**\r\n     * Placed last to cover the length of the enum.\r\n     * Please do not depend on this value!\r\n     */\r\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 112] = \"MAX_VALUE\";\r\n})(KeyCode || (KeyCode = {}));\r\nvar MarkerSeverity;\r\n(function (MarkerSeverity) {\r\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\r\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\r\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\r\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\r\n})(MarkerSeverity || (MarkerSeverity = {}));\r\nvar MarkerTag;\r\n(function (MarkerTag) {\r\n    MarkerTag[MarkerTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\r\n    MarkerTag[MarkerTag[\"Deprecated\"] = 2] = \"Deprecated\";\r\n})(MarkerTag || (MarkerTag = {}));\r\n/**\r\n * Position in the minimap to render the decoration.\r\n */\r\nvar MinimapPosition;\r\n(function (MinimapPosition) {\r\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\r\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\r\n})(MinimapPosition || (MinimapPosition = {}));\r\n/**\r\n * Type of hit element with the mouse in the editor.\r\n */\r\nvar MouseTargetType;\r\n(function (MouseTargetType) {\r\n    /**\r\n     * Mouse is on top of an unknown element.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\r\n    /**\r\n     * Mouse is on top of the textarea used for input.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\r\n    /**\r\n     * Mouse is on top of the glyph margin\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\r\n    /**\r\n     * Mouse is on top of the line numbers\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\r\n    /**\r\n     * Mouse is on top of the line decorations\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\r\n    /**\r\n     * Mouse is on top of the whitespace left in the gutter by a view zone.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\r\n    /**\r\n     * Mouse is on top of text in the content.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\r\n    /**\r\n     * Mouse is on top of empty space in the content (e.g. after line text or below last line)\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\r\n    /**\r\n     * Mouse is on top of a view zone in the content.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\r\n    /**\r\n     * Mouse is on top of a content widget.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\r\n    /**\r\n     * Mouse is on top of the decorations overview ruler.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\r\n    /**\r\n     * Mouse is on top of a scrollbar.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\r\n    /**\r\n     * Mouse is on top of an overlay widget.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\r\n    /**\r\n     * Mouse is outside of the editor.\r\n     */\r\n    MouseTargetType[MouseTargetType[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\r\n})(MouseTargetType || (MouseTargetType = {}));\r\n/**\r\n * A positioning preference for rendering overlay widgets.\r\n */\r\nvar OverlayWidgetPositionPreference;\r\n(function (OverlayWidgetPositionPreference) {\r\n    /**\r\n     * Position the overlay widget in the top right corner\r\n     */\r\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\r\n    /**\r\n     * Position the overlay widget in the bottom right corner\r\n     */\r\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\r\n    /**\r\n     * Position the overlay widget in the top center\r\n     */\r\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\r\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));\r\n/**\r\n * Vertical Lane in the overview ruler of the editor.\r\n */\r\nvar OverviewRulerLane;\r\n(function (OverviewRulerLane) {\r\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\r\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\r\n})(OverviewRulerLane || (OverviewRulerLane = {}));\r\nvar RenderLineNumbersType;\r\n(function (RenderLineNumbersType) {\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Off\"] = 0] = \"Off\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"On\"] = 1] = \"On\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Relative\"] = 2] = \"Relative\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Interval\"] = 3] = \"Interval\";\r\n    RenderLineNumbersType[RenderLineNumbersType[\"Custom\"] = 4] = \"Custom\";\r\n})(RenderLineNumbersType || (RenderLineNumbersType = {}));\r\nvar RenderMinimap;\r\n(function (RenderMinimap) {\r\n    RenderMinimap[RenderMinimap[\"None\"] = 0] = \"None\";\r\n    RenderMinimap[RenderMinimap[\"Text\"] = 1] = \"Text\";\r\n    RenderMinimap[RenderMinimap[\"Blocks\"] = 2] = \"Blocks\";\r\n})(RenderMinimap || (RenderMinimap = {}));\r\nvar ScrollType;\r\n(function (ScrollType) {\r\n    ScrollType[ScrollType[\"Smooth\"] = 0] = \"Smooth\";\r\n    ScrollType[ScrollType[\"Immediate\"] = 1] = \"Immediate\";\r\n})(ScrollType || (ScrollType = {}));\r\nvar ScrollbarVisibility;\r\n(function (ScrollbarVisibility) {\r\n    ScrollbarVisibility[ScrollbarVisibility[\"Auto\"] = 1] = \"Auto\";\r\n    ScrollbarVisibility[ScrollbarVisibility[\"Hidden\"] = 2] = \"Hidden\";\r\n    ScrollbarVisibility[ScrollbarVisibility[\"Visible\"] = 3] = \"Visible\";\r\n})(ScrollbarVisibility || (ScrollbarVisibility = {}));\r\n/**\r\n * The direction of a selection.\r\n */\r\nvar SelectionDirection;\r\n(function (SelectionDirection) {\r\n    /**\r\n     * The selection starts above where it ends.\r\n     */\r\n    SelectionDirection[SelectionDirection[\"LTR\"] = 0] = \"LTR\";\r\n    /**\r\n     * The selection starts below where it ends.\r\n     */\r\n    SelectionDirection[SelectionDirection[\"RTL\"] = 1] = \"RTL\";\r\n})(SelectionDirection || (SelectionDirection = {}));\r\nvar SignatureHelpTriggerKind;\r\n(function (SignatureHelpTriggerKind) {\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\r\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\r\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nvar SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\r\n    SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\r\n    SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\r\n    SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\r\n    SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\r\n    SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\r\n    SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\r\n    SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\r\n    SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\r\n    SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\r\n    SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\r\n    SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\r\n    SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\r\n    SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\r\n    SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\r\n    SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\r\n    SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\r\n    SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\r\n    SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\r\n    SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\r\n    SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\r\n    SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\r\n    SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\r\n    SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\r\n    SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\r\n    SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\r\n})(SymbolKind || (SymbolKind = {}));\r\nvar SymbolTag;\r\n(function (SymbolTag) {\r\n    SymbolTag[SymbolTag[\"Deprecated\"] = 1] = \"Deprecated\";\r\n})(SymbolTag || (SymbolTag = {}));\r\n/**\r\n * The kind of animation in which the editor's cursor should be rendered.\r\n */\r\nvar TextEditorCursorBlinkingStyle;\r\n(function (TextEditorCursorBlinkingStyle) {\r\n    /**\r\n     * Hidden\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Hidden\"] = 0] = \"Hidden\";\r\n    /**\r\n     * Blinking\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Blink\"] = 1] = \"Blink\";\r\n    /**\r\n     * Blinking with smooth fading\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Smooth\"] = 2] = \"Smooth\";\r\n    /**\r\n     * Blinking with prolonged filled state and smooth fading\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Phase\"] = 3] = \"Phase\";\r\n    /**\r\n     * Expand collapse animation on the y axis\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Expand\"] = 4] = \"Expand\";\r\n    /**\r\n     * No-Blinking\r\n     */\r\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Solid\"] = 5] = \"Solid\";\r\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));\r\n/**\r\n * The style in which the editor's cursor should be rendered.\r\n */\r\nvar TextEditorCursorStyle;\r\n(function (TextEditorCursorStyle) {\r\n    /**\r\n     * As a vertical line (sitting between two characters).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\r\n    /**\r\n     * As a block (sitting on top of a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\r\n    /**\r\n     * As a horizontal line (sitting under a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\r\n    /**\r\n     * As a thin vertical line (sitting between two characters).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\r\n    /**\r\n     * As an outlined block (sitting on top of a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\r\n    /**\r\n     * As a thin horizontal line (sitting under a character).\r\n     */\r\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\r\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\r\n/**\r\n * Describes the behavior of decorations when typing/editing near their edges.\r\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\r\n */\r\nvar TrackedRangeStickiness;\r\n(function (TrackedRangeStickiness) {\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\r\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\r\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));\r\n/**\r\n * Describes how to indent wrapped lines.\r\n */\r\nvar WrappingIndent;\r\n(function (WrappingIndent) {\r\n    /**\r\n     * No indentation => wrapped lines begin at column 1.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Same => wrapped lines get the same indentation as the parent.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"Same\"] = 1] = \"Same\";\r\n    /**\r\n     * Indent => wrapped lines get +1 indentation toward the parent.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"Indent\"] = 2] = \"Indent\";\r\n    /**\r\n     * DeepIndent => wrapped lines get +2 indentation toward the parent.\r\n     */\r\n    WrappingIndent[WrappingIndent[\"DeepIndent\"] = 3] = \"DeepIndent\";\r\n})(WrappingIndent || (WrappingIndent = {}));\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KeyMod {\r\n    static chord(firstPart, secondPart) {\r\n        return KeyChord(firstPart, secondPart);\r\n    }\r\n}\r\nKeyMod.CtrlCmd = 2048 /* CtrlCmd */;\r\nKeyMod.Shift = 1024 /* Shift */;\r\nKeyMod.Alt = 512 /* Alt */;\r\nKeyMod.WinCtrl = 256 /* WinCtrl */;\r\nfunction createMonacoBaseAPI() {\r\n    return {\r\n        editor: undefined,\r\n        languages: undefined,\r\n        CancellationTokenSource: CancellationTokenSource,\r\n        Emitter: Emitter,\r\n        KeyCode: KeyCode,\r\n        KeyMod: KeyMod,\r\n        Position: Position,\r\n        Range: Range,\r\n        Selection: Selection,\r\n        SelectionDirection: SelectionDirection,\r\n        MarkerSeverity: MarkerSeverity,\r\n        MarkerTag: MarkerTag,\r\n        Uri: URI,\r\n        Token: Token\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @internal\r\n */\r\nclass MirrorModel extends MirrorTextModel {\r\n    get uri() {\r\n        return this._uri;\r\n    }\r\n    get eol() {\r\n        return this._eol;\r\n    }\r\n    getValue() {\r\n        return this.getText();\r\n    }\r\n    getLinesContent() {\r\n        return this._lines.slice(0);\r\n    }\r\n    getLineCount() {\r\n        return this._lines.length;\r\n    }\r\n    getLineContent(lineNumber) {\r\n        return this._lines[lineNumber - 1];\r\n    }\r\n    getWordAtPosition(position, wordDefinition) {\r\n        let wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\r\n        if (wordAtText) {\r\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\r\n        }\r\n        return null;\r\n    }\r\n    words(wordDefinition) {\r\n        const lines = this._lines;\r\n        const wordenize = this._wordenize.bind(this);\r\n        let lineNumber = 0;\r\n        let lineText = '';\r\n        let wordRangesIdx = 0;\r\n        let wordRanges = [];\r\n        return {\r\n            *[Symbol.iterator]() {\r\n                while (true) {\r\n                    if (wordRangesIdx < wordRanges.length) {\r\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\r\n                        wordRangesIdx += 1;\r\n                        yield value;\r\n                    }\r\n                    else {\r\n                        if (lineNumber < lines.length) {\r\n                            lineText = lines[lineNumber];\r\n                            wordRanges = wordenize(lineText, wordDefinition);\r\n                            wordRangesIdx = 0;\r\n                            lineNumber += 1;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    getLineWords(lineNumber, wordDefinition) {\r\n        let content = this._lines[lineNumber - 1];\r\n        let ranges = this._wordenize(content, wordDefinition);\r\n        let words = [];\r\n        for (const range of ranges) {\r\n            words.push({\r\n                word: content.substring(range.start, range.end),\r\n                startColumn: range.start + 1,\r\n                endColumn: range.end + 1\r\n            });\r\n        }\r\n        return words;\r\n    }\r\n    _wordenize(content, wordDefinition) {\r\n        const result = [];\r\n        let match;\r\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\r\n        while (match = wordDefinition.exec(content)) {\r\n            if (match[0].length === 0) {\r\n                // it did match the empty string\r\n                break;\r\n            }\r\n            result.push({ start: match.index, end: match.index + match[0].length });\r\n        }\r\n        return result;\r\n    }\r\n    getValueInRange(range) {\r\n        range = this._validateRange(range);\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\r\n        }\r\n        let lineEnding = this._eol;\r\n        let startLineIndex = range.startLineNumber - 1;\r\n        let endLineIndex = range.endLineNumber - 1;\r\n        let resultLines = [];\r\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\r\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\r\n            resultLines.push(this._lines[i]);\r\n        }\r\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\r\n        return resultLines.join(lineEnding);\r\n    }\r\n    offsetAt(position) {\r\n        position = this._validatePosition(position);\r\n        this._ensureLineStarts();\r\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\r\n    }\r\n    positionAt(offset) {\r\n        offset = Math.floor(offset);\r\n        offset = Math.max(0, offset);\r\n        this._ensureLineStarts();\r\n        let out = this._lineStarts.getIndexOf(offset);\r\n        let lineLength = this._lines[out.index].length;\r\n        // Ensure we return a valid position\r\n        return {\r\n            lineNumber: 1 + out.index,\r\n            column: 1 + Math.min(out.remainder, lineLength)\r\n        };\r\n    }\r\n    _validateRange(range) {\r\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\r\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\r\n        if (start.lineNumber !== range.startLineNumber\r\n            || start.column !== range.startColumn\r\n            || end.lineNumber !== range.endLineNumber\r\n            || end.column !== range.endColumn) {\r\n            return {\r\n                startLineNumber: start.lineNumber,\r\n                startColumn: start.column,\r\n                endLineNumber: end.lineNumber,\r\n                endColumn: end.column\r\n            };\r\n        }\r\n        return range;\r\n    }\r\n    _validatePosition(position) {\r\n        if (!Position.isIPosition(position)) {\r\n            throw new Error('bad position');\r\n        }\r\n        let { lineNumber, column } = position;\r\n        let hasChanged = false;\r\n        if (lineNumber < 1) {\r\n            lineNumber = 1;\r\n            column = 1;\r\n            hasChanged = true;\r\n        }\r\n        else if (lineNumber > this._lines.length) {\r\n            lineNumber = this._lines.length;\r\n            column = this._lines[lineNumber - 1].length + 1;\r\n            hasChanged = true;\r\n        }\r\n        else {\r\n            let maxCharacter = this._lines[lineNumber - 1].length + 1;\r\n            if (column < 1) {\r\n                column = 1;\r\n                hasChanged = true;\r\n            }\r\n            else if (column > maxCharacter) {\r\n                column = maxCharacter;\r\n                hasChanged = true;\r\n            }\r\n        }\r\n        if (!hasChanged) {\r\n            return position;\r\n        }\r\n        else {\r\n            return { lineNumber, column };\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass EditorSimpleWorker {\r\n    constructor(host, foreignModuleFactory) {\r\n        this._host = host;\r\n        this._models = Object.create(null);\r\n        this._foreignModuleFactory = foreignModuleFactory;\r\n        this._foreignModule = null;\r\n    }\r\n    dispose() {\r\n        this._models = Object.create(null);\r\n    }\r\n    _getModel(uri) {\r\n        return this._models[uri];\r\n    }\r\n    _getModels() {\r\n        let all = [];\r\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\r\n        return all;\r\n    }\r\n    acceptNewModel(data) {\r\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\r\n    }\r\n    acceptModelChanged(strURL, e) {\r\n        if (!this._models[strURL]) {\r\n            return;\r\n        }\r\n        let model = this._models[strURL];\r\n        model.onEvents(e);\r\n    }\r\n    acceptRemovedModel(strURL) {\r\n        if (!this._models[strURL]) {\r\n            return;\r\n        }\r\n        delete this._models[strURL];\r\n    }\r\n    // ---- BEGIN diff --------------------------------------------------------------------------\r\n    computeDiff(originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const original = this._getModel(originalUrl);\r\n            const modified = this._getModel(modifiedUrl);\r\n            if (!original || !modified) {\r\n                return null;\r\n            }\r\n            const originalLines = original.getLinesContent();\r\n            const modifiedLines = modified.getLinesContent();\r\n            const diffComputer = new DiffComputer(originalLines, modifiedLines, {\r\n                shouldComputeCharChanges: true,\r\n                shouldPostProcessCharChanges: true,\r\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\r\n                shouldMakePrettyDiff: true,\r\n                maxComputationTime: maxComputationTime\r\n            });\r\n            const diffResult = diffComputer.computeDiff();\r\n            const identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));\r\n            return {\r\n                quitEarly: diffResult.quitEarly,\r\n                identical: identical,\r\n                changes: diffResult.changes\r\n            };\r\n        });\r\n    }\r\n    _modelsAreIdentical(original, modified) {\r\n        const originalLineCount = original.getLineCount();\r\n        const modifiedLineCount = modified.getLineCount();\r\n        if (originalLineCount !== modifiedLineCount) {\r\n            return false;\r\n        }\r\n        for (let line = 1; line <= originalLineCount; line++) {\r\n            const originalLine = original.getLineContent(line);\r\n            const modifiedLine = modified.getLineContent(line);\r\n            if (originalLine !== modifiedLine) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    computeMoreMinimalEdits(modelUrl, edits) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return edits;\r\n            }\r\n            const result = [];\r\n            let lastEol = undefined;\r\n            edits = edits.slice(0).sort((a, b) => {\r\n                if (a.range && b.range) {\r\n                    return Range.compareRangesUsingStarts(a.range, b.range);\r\n                }\r\n                // eol only changes should go to the end\r\n                let aRng = a.range ? 0 : 1;\r\n                let bRng = b.range ? 0 : 1;\r\n                return aRng - bRng;\r\n            });\r\n            for (let { range, text, eol } of edits) {\r\n                if (typeof eol === 'number') {\r\n                    lastEol = eol;\r\n                }\r\n                if (Range.isEmpty(range) && !text) {\r\n                    // empty change\r\n                    continue;\r\n                }\r\n                const original = model.getValueInRange(range);\r\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\r\n                if (original === text) {\r\n                    // noop\r\n                    continue;\r\n                }\r\n                // make sure diff won't take too long\r\n                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\r\n                    result.push({ range, text });\r\n                    continue;\r\n                }\r\n                // compute diff between original and edit.text\r\n                const changes = stringDiff(original, text, false);\r\n                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\r\n                for (const change of changes) {\r\n                    const start = model.positionAt(editOffset + change.originalStart);\r\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\r\n                    const newEdit = {\r\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\r\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\r\n                    };\r\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\r\n                        result.push(newEdit);\r\n                    }\r\n                }\r\n            }\r\n            if (typeof lastEol === 'number') {\r\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    // ---- END minimal edits ---------------------------------------------------------------\r\n    computeLinks(modelUrl) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            return computeLinks(model);\r\n        });\r\n    }\r\n    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const sw = new StopWatch(true);\r\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            const seen = new Set();\r\n            outer: for (let url of modelUrls) {\r\n                const model = this._getModel(url);\r\n                if (!model) {\r\n                    continue;\r\n                }\r\n                for (let word of model.words(wordDefRegExp)) {\r\n                    if (word === leadingWord || !isNaN(Number(word))) {\r\n                        continue;\r\n                    }\r\n                    seen.add(word);\r\n                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {\r\n                        break outer;\r\n                    }\r\n                }\r\n            }\r\n            return { words: Array.from(seen), duration: sw.elapsed() };\r\n        });\r\n    }\r\n    // ---- END suggest --------------------------------------------------------------------------\r\n    //#region -- word ranges --\r\n    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return Object.create(null);\r\n            }\r\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            const result = Object.create(null);\r\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\r\n                let words = model.getLineWords(line, wordDefRegExp);\r\n                for (const word of words) {\r\n                    if (!isNaN(Number(word.word))) {\r\n                        continue;\r\n                    }\r\n                    let array = result[word.word];\r\n                    if (!array) {\r\n                        array = [];\r\n                        result[word.word] = array;\r\n                    }\r\n                    array.push({\r\n                        startLineNumber: line,\r\n                        startColumn: word.startColumn,\r\n                        endLineNumber: line,\r\n                        endColumn: word.endColumn\r\n                    });\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    //#endregion\r\n    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let model = this._getModel(modelUrl);\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            let wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            if (range.startColumn === range.endColumn) {\r\n                range = {\r\n                    startLineNumber: range.startLineNumber,\r\n                    startColumn: range.startColumn,\r\n                    endLineNumber: range.endLineNumber,\r\n                    endColumn: range.endColumn + 1\r\n                };\r\n            }\r\n            let selectionText = model.getValueInRange(range);\r\n            let wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\r\n            if (!wordRange) {\r\n                return null;\r\n            }\r\n            let word = model.getValueInRange(wordRange);\r\n            let result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\r\n            return result;\r\n        });\r\n    }\r\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\r\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\r\n        const proxyMethodRequest = (method, args) => {\r\n            return this._host.fhr(method, args);\r\n        };\r\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\r\n        let ctx = {\r\n            host: foreignHost,\r\n            getMirrorModels: () => {\r\n                return this._getModels();\r\n            }\r\n        };\r\n        if (this._foreignModuleFactory) {\r\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\r\n            // static foreing module\r\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\r\n        }\r\n        // ESM-comment-begin\r\n        // \t\treturn new Promise<any>((resolve, reject) => {\r\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\r\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\r\n        // \r\n        // \t\t\t\tresolve(types.getAllMethodNames(this._foreignModule));\r\n        // \r\n        // \t\t\t}, reject);\r\n        // \t\t});\r\n        // ESM-comment-end\r\n        // ESM-uncomment-begin\r\n        return Promise.reject(new Error(`Unexpected usage`));\r\n        // ESM-uncomment-end\r\n    }\r\n    // foreign method request\r\n    fmr(method, args) {\r\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\r\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\r\n        }\r\n        try {\r\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n}\r\n// ---- END diff --------------------------------------------------------------------------\r\n// ---- BEGIN minimal edits ---------------------------------------------------------------\r\nEditorSimpleWorker._diffLimit = 100000;\r\n// ---- BEGIN suggest --------------------------------------------------------------------------\r\nEditorSimpleWorker._suggestionsLimit = 10000;\r\n/**\r\n * Called on the worker side\r\n * @internal\r\n */\r\nfunction editorSimpleWorker_create(host) {\r\n    return new EditorSimpleWorker(host, null);\r\n}\r\nif (typeof importScripts === 'function') {\r\n    // Running in a web worker\r\n    globals.monaco = createMonacoBaseAPI();\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/editor.worker.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nlet initialized = false;\r\nfunction initialize(foreignModule) {\r\n    if (initialized) {\r\n        return;\r\n    }\r\n    initialized = true;\r\n    const simpleWorker = new SimpleWorkerServer((msg) => {\r\n        self.postMessage(msg);\r\n    }, (host) => new EditorSimpleWorker(host, foreignModule));\r\n    self.onmessage = (e) => {\r\n        simpleWorker.onmessage(e.data);\r\n    };\r\n}\r\nself.onmessage = (e) => {\r\n    // Ignore first message in this case and initialize if not yet initialized\r\n    if (!initialized) {\r\n        initialize(null);\r\n    }\r\n};\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/scanner.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nfunction createScanner(text, ignoreTrivia) {\n    if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n    var len = text.length;\n    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;\n    function scanHexDigits(count, exact) {\n        var digits = 0;\n        var value = 0;\n        while (digits < count || !exact) {\n            var ch = text.charCodeAt(pos);\n            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                value = value * 16 + ch - 48 /* _0 */;\n            }\n            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                value = value * 16 + ch - 65 /* A */ + 10;\n            }\n            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                value = value * 16 + ch - 97 /* a */ + 10;\n            }\n            else {\n                break;\n            }\n            pos++;\n            digits++;\n        }\n        if (digits < count) {\n            value = -1;\n        }\n        return value;\n    }\n    function setPosition(newPosition) {\n        pos = newPosition;\n        value = '';\n        tokenOffset = 0;\n        token = 16 /* Unknown */;\n        scanError = 0 /* None */;\n    }\n    function scanNumber() {\n        var start = pos;\n        if (text.charCodeAt(pos) === 48 /* _0 */) {\n            pos++;\n        }\n        else {\n            pos++;\n            while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n        }\n        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n            pos++;\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n                return text.substring(start, pos);\n            }\n        }\n        var end = pos;\n        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n            pos++;\n            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                pos++;\n            }\n            if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n                end = pos;\n            }\n            else {\n                scanError = 3 /* UnexpectedEndOfNumber */;\n            }\n        }\n        return text.substring(start, end);\n    }\n    function scanString() {\n        var result = '', start = pos;\n        while (true) {\n            if (pos >= len) {\n                result += text.substring(start, pos);\n                scanError = 2 /* UnexpectedEndOfString */;\n                break;\n            }\n            var ch = text.charCodeAt(pos);\n            if (ch === 34 /* doubleQuote */) {\n                result += text.substring(start, pos);\n                pos++;\n                break;\n            }\n            if (ch === 92 /* backslash */) {\n                result += text.substring(start, pos);\n                pos++;\n                if (pos >= len) {\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                var ch2 = text.charCodeAt(pos++);\n                switch (ch2) {\n                    case 34 /* doubleQuote */:\n                        result += '\\\"';\n                        break;\n                    case 92 /* backslash */:\n                        result += '\\\\';\n                        break;\n                    case 47 /* slash */:\n                        result += '/';\n                        break;\n                    case 98 /* b */:\n                        result += '\\b';\n                        break;\n                    case 102 /* f */:\n                        result += '\\f';\n                        break;\n                    case 110 /* n */:\n                        result += '\\n';\n                        break;\n                    case 114 /* r */:\n                        result += '\\r';\n                        break;\n                    case 116 /* t */:\n                        result += '\\t';\n                        break;\n                    case 117 /* u */:\n                        var ch3 = scanHexDigits(4, true);\n                        if (ch3 >= 0) {\n                            result += String.fromCharCode(ch3);\n                        }\n                        else {\n                            scanError = 4 /* InvalidUnicode */;\n                        }\n                        break;\n                    default:\n                        scanError = 5 /* InvalidEscapeCharacter */;\n                }\n                start = pos;\n                continue;\n            }\n            if (ch >= 0 && ch <= 0x1f) {\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                else {\n                    scanError = 6 /* InvalidCharacter */;\n                    // mark as error but continue with string\n                }\n            }\n            pos++;\n        }\n        return result;\n    }\n    function scanNext() {\n        value = '';\n        scanError = 0 /* None */;\n        tokenOffset = pos;\n        lineStartOffset = lineNumber;\n        prevTokenLineStartOffset = tokenLineStartOffset;\n        if (pos >= len) {\n            // at the end\n            tokenOffset = len;\n            return token = 17 /* EOF */;\n        }\n        var code = text.charCodeAt(pos);\n        // trivia: whitespace\n        if (isWhiteSpace(code)) {\n            do {\n                pos++;\n                value += String.fromCharCode(code);\n                code = text.charCodeAt(pos);\n            } while (isWhiteSpace(code));\n            return token = 15 /* Trivia */;\n        }\n        // trivia: newlines\n        if (isLineBreak(code)) {\n            pos++;\n            value += String.fromCharCode(code);\n            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                pos++;\n                value += '\\n';\n            }\n            lineNumber++;\n            tokenLineStartOffset = pos;\n            return token = 14 /* LineBreakTrivia */;\n        }\n        switch (code) {\n            // tokens: []{}:,\n            case 123 /* openBrace */:\n                pos++;\n                return token = 1 /* OpenBraceToken */;\n            case 125 /* closeBrace */:\n                pos++;\n                return token = 2 /* CloseBraceToken */;\n            case 91 /* openBracket */:\n                pos++;\n                return token = 3 /* OpenBracketToken */;\n            case 93 /* closeBracket */:\n                pos++;\n                return token = 4 /* CloseBracketToken */;\n            case 58 /* colon */:\n                pos++;\n                return token = 6 /* ColonToken */;\n            case 44 /* comma */:\n                pos++;\n                return token = 5 /* CommaToken */;\n            // strings\n            case 34 /* doubleQuote */:\n                pos++;\n                value = scanString();\n                return token = 10 /* StringLiteral */;\n            // comments\n            case 47 /* slash */:\n                var start = pos - 1;\n                // Single-line comment\n                if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                    pos += 2;\n                    while (pos < len) {\n                        if (isLineBreak(text.charCodeAt(pos))) {\n                            break;\n                        }\n                        pos++;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 12 /* LineCommentTrivia */;\n                }\n                // Multi-line comment\n                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                    pos += 2;\n                    var safeLength = len - 1; // For lookahead.\n                    var commentClosed = false;\n                    while (pos < safeLength) {\n                        var ch = text.charCodeAt(pos);\n                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            commentClosed = true;\n                            break;\n                        }\n                        pos++;\n                        if (isLineBreak(ch)) {\n                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                                pos++;\n                            }\n                            lineNumber++;\n                            tokenLineStartOffset = pos;\n                        }\n                    }\n                    if (!commentClosed) {\n                        pos++;\n                        scanError = 1 /* UnexpectedEndOfComment */;\n                    }\n                    value = text.substring(start, pos);\n                    return token = 13 /* BlockCommentTrivia */;\n                }\n                // just a single slash\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n            // numbers\n            case 45 /* minus */:\n                value += String.fromCharCode(code);\n                pos++;\n                if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                    return token = 16 /* Unknown */;\n                }\n            // found a minus, followed by a number so\n            // we fall through to proceed with scanning\n            // numbers\n            case 48 /* _0 */:\n            case 49 /* _1 */:\n            case 50 /* _2 */:\n            case 51 /* _3 */:\n            case 52 /* _4 */:\n            case 53 /* _5 */:\n            case 54 /* _6 */:\n            case 55 /* _7 */:\n            case 56 /* _8 */:\n            case 57 /* _9 */:\n                value += scanNumber();\n                return token = 11 /* NumericLiteral */;\n            // literals and unknown symbols\n            default:\n                // is a literal? Read the full word.\n                while (pos < len && isUnknownContentCharacter(code)) {\n                    pos++;\n                    code = text.charCodeAt(pos);\n                }\n                if (tokenOffset !== pos) {\n                    value = text.substring(tokenOffset, pos);\n                    // keywords: true, false, null\n                    switch (value) {\n                        case 'true': return token = 8 /* TrueKeyword */;\n                        case 'false': return token = 9 /* FalseKeyword */;\n                        case 'null': return token = 7 /* NullKeyword */;\n                    }\n                    return token = 16 /* Unknown */;\n                }\n                // some\n                value += String.fromCharCode(code);\n                pos++;\n                return token = 16 /* Unknown */;\n        }\n    }\n    function isUnknownContentCharacter(code) {\n        if (isWhiteSpace(code) || isLineBreak(code)) {\n            return false;\n        }\n        switch (code) {\n            case 125 /* closeBrace */:\n            case 93 /* closeBracket */:\n            case 123 /* openBrace */:\n            case 91 /* openBracket */:\n            case 34 /* doubleQuote */:\n            case 58 /* colon */:\n            case 44 /* comma */:\n            case 47 /* slash */:\n                return false;\n        }\n        return true;\n    }\n    function scanNextNonTrivia() {\n        var result;\n        do {\n            result = scanNext();\n        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n        return result;\n    }\n    return {\n        setPosition: setPosition,\n        getPosition: function () { return pos; },\n        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n        getToken: function () { return token; },\n        getTokenValue: function () { return value; },\n        getTokenOffset: function () { return tokenOffset; },\n        getTokenLength: function () { return pos - tokenOffset; },\n        getTokenStartLine: function () { return lineStartOffset; },\n        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },\n        getTokenError: function () { return scanError; },\n    };\n}\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n}\nfunction isLineBreak(ch) {\n    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n}\nfunction isDigit(ch) {\n    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/format.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction format_format(documentText, range, options) {\n    var initialIndentLevel;\n    var formatText;\n    var formatTextStart;\n    var rangeStart;\n    var rangeEnd;\n    if (range) {\n        rangeStart = range.offset;\n        rangeEnd = rangeStart + range.length;\n        formatTextStart = rangeStart;\n        while (formatTextStart > 0 && !format_isEOL(documentText, formatTextStart - 1)) {\n            formatTextStart--;\n        }\n        var endOffset = rangeEnd;\n        while (endOffset < documentText.length && !format_isEOL(documentText, endOffset)) {\n            endOffset++;\n        }\n        formatText = documentText.substring(formatTextStart, endOffset);\n        initialIndentLevel = computeIndentLevel(formatText, options);\n    }\n    else {\n        formatText = documentText;\n        initialIndentLevel = 0;\n        formatTextStart = 0;\n        rangeStart = 0;\n        rangeEnd = documentText.length;\n    }\n    var eol = getEOL(options, documentText);\n    var lineBreak = false;\n    var indentLevel = 0;\n    var indentValue;\n    if (options.insertSpaces) {\n        indentValue = repeat(' ', options.tabSize || 4);\n    }\n    else {\n        indentValue = '\\t';\n    }\n    var scanner = createScanner(formatText, false);\n    var hasError = false;\n    function newLineAndIndent() {\n        return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n    }\n    function scanNext() {\n        var token = scanner.scan();\n        lineBreak = false;\n        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n            token = scanner.scan();\n        }\n        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n        return token;\n    }\n    var editOperations = [];\n    function addEdit(text, startOffset, endOffset) {\n        if (!hasError && (!range || (startOffset < rangeEnd && endOffset > rangeStart)) && documentText.substring(startOffset, endOffset) !== text) {\n            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n        }\n    }\n    var firstToken = scanNext();\n    if (firstToken !== 17 /* EOF */) {\n        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n        var initialIndent = repeat(indentValue, initialIndentLevel);\n        addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n    while (firstToken !== 17 /* EOF */) {\n        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n        var secondToken = scanNext();\n        var replaceContent = '';\n        var needsLineBreak = false;\n        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n            // comments on the same line: keep them on the same line, but ignore them otherwise\n            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(' ', firstTokenEnd, commentTokenStart);\n            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            needsLineBreak = secondToken === 12 /* LineCommentTrivia */;\n            replaceContent = needsLineBreak ? newLineAndIndent() : '';\n            secondToken = scanNext();\n        }\n        if (secondToken === 2 /* CloseBraceToken */) {\n            if (firstToken !== 1 /* OpenBraceToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else if (secondToken === 4 /* CloseBracketToken */) {\n            if (firstToken !== 3 /* OpenBracketToken */) {\n                indentLevel--;\n                replaceContent = newLineAndIndent();\n            }\n        }\n        else {\n            switch (firstToken) {\n                case 3 /* OpenBracketToken */:\n                case 1 /* OpenBraceToken */:\n                    indentLevel++;\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 5 /* CommaToken */:\n                case 12 /* LineCommentTrivia */:\n                    replaceContent = newLineAndIndent();\n                    break;\n                case 13 /* BlockCommentTrivia */:\n                    if (lineBreak) {\n                        replaceContent = newLineAndIndent();\n                    }\n                    else if (!needsLineBreak) {\n                        // symbol following comment on the same line: keep on same line, separate with ' '\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 6 /* ColonToken */:\n                    if (!needsLineBreak) {\n                        replaceContent = ' ';\n                    }\n                    break;\n                case 10 /* StringLiteral */:\n                    if (secondToken === 6 /* ColonToken */) {\n                        if (!needsLineBreak) {\n                            replaceContent = '';\n                        }\n                        break;\n                    }\n                // fall through\n                case 7 /* NullKeyword */:\n                case 8 /* TrueKeyword */:\n                case 9 /* FalseKeyword */:\n                case 11 /* NumericLiteral */:\n                case 2 /* CloseBraceToken */:\n                case 4 /* CloseBracketToken */:\n                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                        if (!needsLineBreak) {\n                            replaceContent = ' ';\n                        }\n                    }\n                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                        hasError = true;\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    hasError = true;\n                    break;\n            }\n            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                replaceContent = newLineAndIndent();\n            }\n        }\n        if (secondToken === 17 /* EOF */) {\n            replaceContent = options.insertFinalNewline ? eol : '';\n        }\n        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n        addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n        firstToken = secondToken;\n    }\n    return editOperations;\n}\nfunction repeat(s, count) {\n    var result = '';\n    for (var i = 0; i < count; i++) {\n        result += s;\n    }\n    return result;\n}\nfunction computeIndentLevel(content, options) {\n    var i = 0;\n    var nChars = 0;\n    var tabSize = options.tabSize || 4;\n    while (i < content.length) {\n        var ch = content.charAt(i);\n        if (ch === ' ') {\n            nChars++;\n        }\n        else if (ch === '\\t') {\n            nChars += tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    return Math.floor(nChars / tabSize);\n}\nfunction getEOL(options, text) {\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\r') {\n            if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                return '\\r\\n';\n            }\n            return '\\r';\n        }\n        else if (ch === '\\n') {\n            return '\\n';\n        }\n    }\n    return (options && options.eol) || '\\n';\n}\nfunction format_isEOL(text, offset) {\n    return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/parser.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nfunction getLocation(text, position) {\n    var segments = []; // strings or numbers\n    var earlyReturnException = new Object();\n    var previousNode = undefined;\n    var previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    var isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: function (name, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: function (offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: function (value, offset, length) {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: function (sep, offset, length) {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    var last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode: previousNode,\n        isAtPropertyKey: isAtPropertyKey,\n        matches: function (pattern) {\n            var k = 0;\n            for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nfunction parse(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentProperty = null;\n    var currentParent = [];\n    var previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    var visitor = {\n        onObjectBegin: function () {\n            var object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: function (name) {\n            currentProperty = name;\n        },\n        onObjectEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: function () {\n            var array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: function () {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nfunction parser_parseTree(text, errors, options) {\n    if (errors === void 0) { errors = []; }\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    var visitor = {\n        onObjectBegin: function (offset) {\n            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: function (name, offset, length) {\n            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n        },\n        onObjectEnd: function (offset, length) {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: function (offset, length) {\n            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: function (offset, length) {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: function (value, offset, length) {\n            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: function (sep, offset, length) {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: function (error, offset, length) {\n            errors.push({ error: error, offset: offset, length: length });\n        }\n    };\n    visit(text, visitor, options);\n    var result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nfunction parser_findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    var node = root;\n    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n        var segment = path_1[_i];\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            var found = false;\n            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                var propertyNode = _b[_a];\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            var index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nfunction getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    var path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        var key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        var index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nfunction getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            var obj = Object.create(null);\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nfunction contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nfunction findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    if (contains(node, offset, includeRightBound)) {\n        var children = node.children;\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nfunction visit(text, visitor, options) {\n    if (options === void 0) { options = ParseOptions.DEFAULT; }\n    var _scanner = createScanner(text, false);\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n    }\n    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    var disallowComments = options && options.disallowComments;\n    var allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            var token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* InvalidUnicode */:\n                    handleError(14 /* InvalidUnicode */);\n                    break;\n                case 5 /* InvalidEscapeCharacter */:\n                    handleError(15 /* InvalidEscapeCharacter */);\n                    break;\n                case 3 /* UnexpectedEndOfNumber */:\n                    handleError(13 /* UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* UnexpectedEndOfString */:\n                    handleError(12 /* UnexpectedEndOfString */);\n                    break;\n                case 6 /* InvalidCharacter */:\n                    handleError(16 /* InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* Unknown */:\n                    handleError(1 /* InvalidSymbol */);\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter, skipUntil) {\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token = _scanner.getToken();\n            while (token !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        var value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* NumericLiteral */:\n                var tokenValue = _scanner.getTokenValue();\n                var value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* StringLiteral */) {\n            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        var needsComma = false;\n        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        var needsComma = false;\n        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n            if (_scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* CommaExpected */, [], []);\n            }\n            if (!parseValue()) {\n                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* OpenBracketToken */:\n                return parseArray();\n            case 1 /* OpenBraceToken */:\n                return parseObject();\n            case 10 /* StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* EOF */) {\n        handleError(9 /* EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nfunction stripComments(text, replaceCh) {\n    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* LineCommentTrivia */:\n            case 13 /* BlockCommentTrivia */:\n            case 17 /* EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* EOF */);\n    return parts.join('');\n}\nfunction getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/edit.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nfunction removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nfunction setProperty(text, originalPath, value, options) {\n    var _a;\n    var path = originalPath.slice();\n    var errors = [];\n    var root = parseTree(text, errors);\n    var parent = void 0;\n    var lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = (_a = {}, _a[lastSegment] = value, _a);\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        var existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                var propertyIndex = parent.children.indexOf(existing.parent);\n                var removeBegin = void 0;\n                var removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    var previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        var next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n            var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n            var edit = void 0;\n            if (index > 0) {\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        var insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            var newProperty = \"\" + JSON.stringify(value);\n            var edit = void 0;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                var previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            var removalIndex = lastSegment;\n            var toRemove = parent.children[removalIndex];\n            var edit = void 0;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                var previous = parent.children[removalIndex - 1];\n                var offset = previous.offset + previous.length;\n                var parentEndOffset = parent.offset + parent.length;\n                edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            var edit = void 0;\n            var newProperty = \"\" + JSON.stringify(value);\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                var toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                var previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(\"Can not \" + (value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')) + \" Array index \" + insertIndex + \" as length is not sufficient\");\n        }\n    }\n    else {\n        throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    var newText = applyEdit(text, edit);\n    // format the new text\n    var begin = edit.offset;\n    var end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    var edits = format(newText, { offset: begin, length: end - begin }, options.formattingOptions);\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (var i = edits.length - 1; i >= 0; i--) {\n        var edit_1 = edits[i];\n        newText = applyEdit(newText, edit_1);\n        begin = Math.min(begin, edit_1.offset);\n        end = Math.max(end, edit_1.offset + edit_1.length);\n        end += edit_1.content.length - edit_1.length;\n    }\n    // create a single edit with all changes\n    var editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nfunction applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nfunction isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/main.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nvar main_createScanner = createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nvar main_getLocation = getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nvar main_parse = parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nvar main_parseTree = parser_parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nvar main_findNodeAtLocation = parser_findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nvar main_findNodeAtOffset = findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nvar main_getNodePath = getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nvar main_getNodeValue = getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nvar main_visit = visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nvar main_stripComments = stripComments;\nfunction printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ValueExpected */: return 'ValueExpected';\n        case 5 /* ColonExpected */: return 'ColonExpected';\n        case 6 /* CommaExpected */: return 'CommaExpected';\n        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nfunction main_format(documentText, range, options) {\n    return format_format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\nfunction modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to a input string.\n */\nfunction applyEdits(text, edits) {\n    for (var i = edits.length - 1; i >= 0; i--) {\n        text = edit.applyEdit(text, edits[i]);\n    }\n    return text;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/objects.js\n/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nfunction equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if ((Array.isArray(one)) !== (Array.isArray(other))) {\n        return false;\n    }\n    var i, key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        var oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        var otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction objects_isNumber(val) {\n    return typeof val === 'number';\n}\nfunction isDefined(val) {\n    return typeof val !== 'undefined';\n}\nfunction objects_isBoolean(val) {\n    return typeof val === 'boolean';\n}\nfunction objects_isString(val) {\n    return typeof val === 'string';\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/strings.js\n/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nfunction startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    for (var i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Determines if haystack ends with needle.\n */\nfunction endsWith(haystack, needle) {\n    var diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.lastIndexOf(needle) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\nfunction strings_convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nfunction strings_repeat(value, count) {\n    var s = '';\n    while (count > 0) {\n        if ((count & 1) === 1) {\n            s += value;\n        }\n        value += value;\n        count = count >>> 1;\n    }\n    return s;\n}\nfunction extendedRegExp(pattern) {\n    if (startsWith(pattern, '(?i)')) {\n        return new RegExp(pattern.substring(4), 'i');\n    }\n    else {\n        return new RegExp(pattern);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-languageserver-types/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n})(integer || (integer = {}));\nvar uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * [Position](#Position) literals.\n */\nvar main_Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line: line, character: character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Position](#Position) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(main_Position || (main_Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * [Range](#Range) literals.\n */\nvar main_Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: main_Position.create(one, two), end: main_Position.create(three, four) };\n        }\n        else if (main_Position.is(one) && main_Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && main_Position.is(candidate.start) && main_Position.is(candidate.end);\n    }\n    Range.is = is;\n})(main_Range || (main_Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * [Location](#Location) literals.\n */\nvar Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri: uri, range: range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * [LocationLink](#LocationLink) literals.\n */\nvar LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && (main_Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))\n            && (main_Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [Color](#Color) literals.\n */\nvar Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * [ColorInformation](#ColorInformation) literals.\n */\nvar ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range: range,\n            color: color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return main_Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [ColorPresentation](#ColorPresentation) literals.\n */\nvar ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * Enum of known range kinds\n */\nvar FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind[\"Comment\"] = \"comment\";\n    /**\n     * Folding range for a imports or includes\n     */\n    FoldingRangeKind[\"Imports\"] = \"imports\";\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind[\"Region\"] = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * [FoldingRange](#FoldingRange) literals.\n */\nvar FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\n        var result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\n */\nvar DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nvar DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nvar DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nvar CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * [Diagnostic](#Diagnostic) literals.\n */\nvar Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        var result = { range: range, message: message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\n     */\n    function is(value) {\n        var _a;\n        var candidate = value;\n        return Is.defined(candidate)\n            && main_Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * [Command](#Command) literals.\n */\nvar Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var result = { title: title, command: command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nvar TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range: range, newText: newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates a insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText: newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range: range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && main_Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        var result = { label: label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        var candidate = value;\n        return typeof candidate === 'string';\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range: range, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range: range, newText: '', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nvar TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument: textDocument, edits: edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'create',\n            uri: uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        var result = {\n            kind: 'rename',\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: 'delete',\n            uri: uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = /** @class */ (function () {\n    function TextEditChangeImpl(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.delete = function (range, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.add = function (edit) {\n        this.edits.push(edit);\n    };\n    TextEditChangeImpl.prototype.all = function () {\n        return this.edits;\n    };\n    TextEditChangeImpl.prototype.clear = function () {\n        this.edits.splice(0, this.edits.length);\n    };\n    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n        if (value === undefined) {\n            throw new Error(\"Text edit change is not configured to manage change annotations.\");\n        }\n    };\n    return TextEditChangeImpl;\n}());\n/**\n * A helper class\n */\nvar ChangeAnnotations = /** @class */ (function () {\n    function ChangeAnnotations(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    ChangeAnnotations.prototype.all = function () {\n        return this._annotations;\n    };\n    Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n        var id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(\"Id \" + id + \" is already in use.\");\n        }\n        if (annotation === undefined) {\n            throw new Error(\"No annotation provided for id \" + id);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    };\n    ChangeAnnotations.prototype.nextId = function () {\n        this._counter++;\n        return this._counter.toString();\n    };\n    return ChangeAnnotations;\n}());\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nvar WorkspaceChange = /** @class */ (function () {\n    function WorkspaceChange(workspaceEdit) {\n        var _this = this;\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach(function (change) {\n                    if (TextDocumentEdit.is(change)) {\n                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n        /**\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\n         * use to be returned from a workspace edit operation like rename.\n         */\n        get: function () {\n            this.initDocumentChanges();\n            if (this._changeAnnotations !== undefined) {\n                if (this._changeAnnotations.size === 0) {\n                    this._workspaceEdit.changeAnnotations = undefined;\n                }\n                else {\n                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n            }\n            return this._workspaceEdit;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var textDocument = { uri: key.uri, version: key.version };\n            var result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                var edits = [];\n                var textDocumentEdit = {\n                    textDocument: textDocument,\n                    edits: edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            var result = this._textEditChanges[key];\n            if (!result) {\n                var edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    };\n    WorkspaceChange.prototype.initDocumentChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    };\n    WorkspaceChange.prototype.initChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    };\n    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    return WorkspaceChange;\n}());\n\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\n */\nvar TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri: uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\n */\nvar VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param uri The document's text.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.\n */\nvar OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param uri The document's text.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * [TextDocumentItem](#TextDocumentItem) literals.\n */\nvar TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri: uri, languageId: languageId, version: version, text: text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nvar MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n})(MarkupKind || (MarkupKind = {}));\n(function (MarkupKind) {\n    /**\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nvar main_CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(main_CompletionItemKind || (main_CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nvar InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nvar main_CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(main_CompletionItemTag || (main_CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nvar InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText: newText, insert: insert, replace: replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.newText) && main_Range.is(candidate.insert) && main_Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nvar InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nvar CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label: label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nvar CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || main_Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * [ParameterInformation](#ParameterInformation) literals.\n */\nvar ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label: label, documentation: documentation } : { label: label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * [SignatureInformation](#SignatureInformation) literals.\n */\nvar SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation) {\n        var parameters = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            parameters[_i - 2] = arguments[_i];\n        }\n        var result = { label: label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nvar main_DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(main_DocumentHighlightKind || (main_DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * [DocumentHighlight](#DocumentHighlight) literals.\n */\nvar DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     */\n    function create(range, kind) {\n        var result = { range: range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nvar main_SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(main_SymbolKind || (main_SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n * @since 3.16\n */\nvar main_SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(main_SymbolTag || (main_SymbolTag = {}));\nvar SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol, defaults to the current document.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        var result = {\n            name: name,\n            kind: kind,\n            location: { uri: uri, range: range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        var result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            main_Range.is(candidate.range) && main_Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nvar CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * [CodeActionContext](#CodeActionContext) literals.\n */\nvar CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only) {\n        var result = { diagnostics: diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        var result = { title: title };\n        var checkKind = true;\n        if (typeof kindOrCommandOrEdit === 'string') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * [CodeLens](#CodeLens) literals.\n */\nvar CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        var result = { range: range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * [FormattingOptions](#FormattingOptions) literals.\n */\nvar FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * [DocumentLink](#DocumentLink) literals.\n */\nvar DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range: range, target: target, data: data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nvar SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range: range, parent: parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && main_Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\nvar EOL = (/* unused pure expression or super */ null && (['\\n', '\\r\\n', '\\r']));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits, function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = text.length;\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\n            var e = sortedEdits[i];\n            var startOffset = document.offsetAt(e.range.start);\n            var endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            var lineOffsets = [];\n            var text = this._content;\n            var isLineStart = true;\n            for (var i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                var ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return main_Position.create(0, offset);\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return main_Position.create(line, offset - lineOffsets[line]);\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return FullTextDocument;\n}());\nvar Is;\n(function (Is) {\n    var toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-languageserver-textdocument/lib/esm/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar main_FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (changes, version) {\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n            var change = changes_1[_i];\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                var range = getWellformedRange(change.range);\n                // update content\n                var startOffset = this.offsetAt(range.start);\n                var endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                var startLine = Math.max(range.start.line, 0);\n                var endLine = Math.max(range.end.line, 0);\n                var lineOffsets = this._lineOffsets;\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                var diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return { line: line, character: offset - lineOffsets[line] };\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.isIncremental = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    };\n    FullTextDocument.isFull = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    };\n    return FullTextDocument;\n}());\nvar main_TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new main_FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifing its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof main_FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = 0;\n        var spans = [];\n        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n            var e = sortedEdits_1[_i];\n            var startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(main_TextDocument || (main_TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    var p = (data.length / 2) | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        var ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n    if (textOffset === void 0) { textOffset = 0; }\n    var result = isAtLineStart ? [textOffset] : [];\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charCodeAt(i);\n        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {\n            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    var start = range.start;\n    var end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    var range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range: range };\n    }\n    return textEdit;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/jsonLanguageTypes.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n/**\n * Error codes used by diagnostics\n */\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode[\"Undefined\"] = 0] = \"Undefined\";\n    ErrorCode[ErrorCode[\"EnumValueMismatch\"] = 1] = \"EnumValueMismatch\";\n    ErrorCode[ErrorCode[\"Deprecated\"] = 2] = \"Deprecated\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfComment\"] = 257] = \"UnexpectedEndOfComment\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfString\"] = 258] = \"UnexpectedEndOfString\";\n    ErrorCode[ErrorCode[\"UnexpectedEndOfNumber\"] = 259] = \"UnexpectedEndOfNumber\";\n    ErrorCode[ErrorCode[\"InvalidUnicode\"] = 260] = \"InvalidUnicode\";\n    ErrorCode[ErrorCode[\"InvalidEscapeCharacter\"] = 261] = \"InvalidEscapeCharacter\";\n    ErrorCode[ErrorCode[\"InvalidCharacter\"] = 262] = \"InvalidCharacter\";\n    ErrorCode[ErrorCode[\"PropertyExpected\"] = 513] = \"PropertyExpected\";\n    ErrorCode[ErrorCode[\"CommaExpected\"] = 514] = \"CommaExpected\";\n    ErrorCode[ErrorCode[\"ColonExpected\"] = 515] = \"ColonExpected\";\n    ErrorCode[ErrorCode[\"ValueExpected\"] = 516] = \"ValueExpected\";\n    ErrorCode[ErrorCode[\"CommaOrCloseBacketExpected\"] = 517] = \"CommaOrCloseBacketExpected\";\n    ErrorCode[ErrorCode[\"CommaOrCloseBraceExpected\"] = 518] = \"CommaOrCloseBraceExpected\";\n    ErrorCode[ErrorCode[\"TrailingComma\"] = 519] = \"TrailingComma\";\n    ErrorCode[ErrorCode[\"DuplicateKey\"] = 520] = \"DuplicateKey\";\n    ErrorCode[ErrorCode[\"CommentNotPermitted\"] = 521] = \"CommentNotPermitted\";\n    ErrorCode[ErrorCode[\"SchemaResolveError\"] = 768] = \"SchemaResolveError\";\n})(ErrorCode || (ErrorCode = {}));\nvar ClientCapabilities;\n(function (ClientCapabilities) {\n    ClientCapabilities.LATEST = {\n        textDocument: {\n            completion: {\n                completionItem: {\n                    documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],\n                    commitCharactersSupport: true\n                }\n            }\n        }\n    };\n})(ClientCapabilities || (ClientCapabilities = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/fillers/vscode-nls.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction vscode_nls_format(message, args) {\r\n    var result;\r\n    if (args.length === 0) {\r\n        result = message;\r\n    }\r\n    else {\r\n        result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\r\n            var index = rest[0];\r\n            return typeof args[index] !== 'undefined' ? args[index] : match;\r\n        });\r\n    }\r\n    return result;\r\n}\r\nfunction localize(key, message) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    return vscode_nls_format(message, args);\r\n}\r\nfunction loadMessageBundle(file) {\r\n    return localize;\r\n}\r\nfunction config(opt) {\r\n    return loadMessageBundle;\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/parser/jsonParser.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar jsonParser_localize = loadMessageBundle();\nvar formats = {\n    'color-hex': { errorMessage: jsonParser_localize('colorHexFormatWarning', 'Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },\n    'date-time': { errorMessage: jsonParser_localize('dateTimeFormatWarning', 'String is not a RFC3339 date-time.'), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n    'date': { errorMessage: jsonParser_localize('dateFormatWarning', 'String is not a RFC3339 date.'), pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },\n    'time': { errorMessage: jsonParser_localize('timeFormatWarning', 'String is not a RFC3339 time.'), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },\n    'email': { errorMessage: jsonParser_localize('emailFormatWarning', 'String is not an e-mail address.'), pattern: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/ }\n};\nvar ASTNodeImpl = /** @class */ (function () {\n    function ASTNodeImpl(parent, offset, length) {\n        if (length === void 0) { length = 0; }\n        this.offset = offset;\n        this.length = length;\n        this.parent = parent;\n    }\n    Object.defineProperty(ASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return [];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ASTNodeImpl.prototype.toString = function () {\n        return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');\n    };\n    return ASTNodeImpl;\n}());\n\nvar NullASTNodeImpl = /** @class */ (function (_super) {\n    __extends(NullASTNodeImpl, _super);\n    function NullASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'null';\n        _this.value = null;\n        return _this;\n    }\n    return NullASTNodeImpl;\n}(ASTNodeImpl));\n\nvar BooleanASTNodeImpl = /** @class */ (function (_super) {\n    __extends(BooleanASTNodeImpl, _super);\n    function BooleanASTNodeImpl(parent, boolValue, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'boolean';\n        _this.value = boolValue;\n        return _this;\n    }\n    return BooleanASTNodeImpl;\n}(ASTNodeImpl));\n\nvar ArrayASTNodeImpl = /** @class */ (function (_super) {\n    __extends(ArrayASTNodeImpl, _super);\n    function ArrayASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'array';\n        _this.items = [];\n        return _this;\n    }\n    Object.defineProperty(ArrayASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return this.items;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ArrayASTNodeImpl;\n}(ASTNodeImpl));\n\nvar NumberASTNodeImpl = /** @class */ (function (_super) {\n    __extends(NumberASTNodeImpl, _super);\n    function NumberASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'number';\n        _this.isInteger = true;\n        _this.value = Number.NaN;\n        return _this;\n    }\n    return NumberASTNodeImpl;\n}(ASTNodeImpl));\n\nvar StringASTNodeImpl = /** @class */ (function (_super) {\n    __extends(StringASTNodeImpl, _super);\n    function StringASTNodeImpl(parent, offset, length) {\n        var _this = _super.call(this, parent, offset, length) || this;\n        _this.type = 'string';\n        _this.value = '';\n        return _this;\n    }\n    return StringASTNodeImpl;\n}(ASTNodeImpl));\n\nvar PropertyASTNodeImpl = /** @class */ (function (_super) {\n    __extends(PropertyASTNodeImpl, _super);\n    function PropertyASTNodeImpl(parent, offset, keyNode) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'property';\n        _this.colonOffset = -1;\n        _this.keyNode = keyNode;\n        return _this;\n    }\n    Object.defineProperty(PropertyASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return PropertyASTNodeImpl;\n}(ASTNodeImpl));\n\nvar ObjectASTNodeImpl = /** @class */ (function (_super) {\n    __extends(ObjectASTNodeImpl, _super);\n    function ObjectASTNodeImpl(parent, offset) {\n        var _this = _super.call(this, parent, offset) || this;\n        _this.type = 'object';\n        _this.properties = [];\n        return _this;\n    }\n    Object.defineProperty(ObjectASTNodeImpl.prototype, \"children\", {\n        get: function () {\n            return this.properties;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ObjectASTNodeImpl;\n}(ASTNodeImpl));\n\nfunction asSchema(schema) {\n    if (objects_isBoolean(schema)) {\n        return schema ? {} : { \"not\": {} };\n    }\n    return schema;\n}\nvar EnumMatch;\n(function (EnumMatch) {\n    EnumMatch[EnumMatch[\"Key\"] = 0] = \"Key\";\n    EnumMatch[EnumMatch[\"Enum\"] = 1] = \"Enum\";\n})(EnumMatch || (EnumMatch = {}));\nvar SchemaCollector = /** @class */ (function () {\n    function SchemaCollector(focusOffset, exclude) {\n        if (focusOffset === void 0) { focusOffset = -1; }\n        this.focusOffset = focusOffset;\n        this.exclude = exclude;\n        this.schemas = [];\n    }\n    SchemaCollector.prototype.add = function (schema) {\n        this.schemas.push(schema);\n    };\n    SchemaCollector.prototype.merge = function (other) {\n        Array.prototype.push.apply(this.schemas, other.schemas);\n    };\n    SchemaCollector.prototype.include = function (node) {\n        return (this.focusOffset === -1 || jsonParser_contains(node, this.focusOffset)) && (node !== this.exclude);\n    };\n    SchemaCollector.prototype.newSub = function () {\n        return new SchemaCollector(-1, this.exclude);\n    };\n    return SchemaCollector;\n}());\nvar NoOpSchemaCollector = /** @class */ (function () {\n    function NoOpSchemaCollector() {\n    }\n    Object.defineProperty(NoOpSchemaCollector.prototype, \"schemas\", {\n        get: function () { return []; },\n        enumerable: false,\n        configurable: true\n    });\n    NoOpSchemaCollector.prototype.add = function (schema) { };\n    NoOpSchemaCollector.prototype.merge = function (other) { };\n    NoOpSchemaCollector.prototype.include = function (node) { return true; };\n    NoOpSchemaCollector.prototype.newSub = function () { return this; };\n    NoOpSchemaCollector.instance = new NoOpSchemaCollector();\n    return NoOpSchemaCollector;\n}());\nvar ValidationResult = /** @class */ (function () {\n    function ValidationResult() {\n        this.problems = [];\n        this.propertiesMatches = 0;\n        this.propertiesValueMatches = 0;\n        this.primaryValueMatches = 0;\n        this.enumValueMatch = false;\n        this.enumValues = undefined;\n    }\n    ValidationResult.prototype.hasProblems = function () {\n        return !!this.problems.length;\n    };\n    ValidationResult.prototype.mergeAll = function (validationResults) {\n        for (var _i = 0, validationResults_1 = validationResults; _i < validationResults_1.length; _i++) {\n            var validationResult = validationResults_1[_i];\n            this.merge(validationResult);\n        }\n    };\n    ValidationResult.prototype.merge = function (validationResult) {\n        this.problems = this.problems.concat(validationResult.problems);\n    };\n    ValidationResult.prototype.mergeEnumValues = function (validationResult) {\n        if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {\n            this.enumValues = this.enumValues.concat(validationResult.enumValues);\n            for (var _i = 0, _a = this.problems; _i < _a.length; _i++) {\n                var error = _a[_i];\n                if (error.code === ErrorCode.EnumValueMismatch) {\n                    error.message = jsonParser_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', this.enumValues.map(function (v) { return JSON.stringify(v); }).join(', '));\n                }\n            }\n        }\n    };\n    ValidationResult.prototype.mergePropertyMatch = function (propertyValidationResult) {\n        this.merge(propertyValidationResult);\n        this.propertiesMatches++;\n        if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {\n            this.propertiesValueMatches++;\n        }\n        if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {\n            this.primaryValueMatches++;\n        }\n    };\n    ValidationResult.prototype.compare = function (other) {\n        var hasProblems = this.hasProblems();\n        if (hasProblems !== other.hasProblems()) {\n            return hasProblems ? -1 : 1;\n        }\n        if (this.enumValueMatch !== other.enumValueMatch) {\n            return other.enumValueMatch ? -1 : 1;\n        }\n        if (this.primaryValueMatches !== other.primaryValueMatches) {\n            return this.primaryValueMatches - other.primaryValueMatches;\n        }\n        if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n            return this.propertiesValueMatches - other.propertiesValueMatches;\n        }\n        return this.propertiesMatches - other.propertiesMatches;\n    };\n    return ValidationResult;\n}());\n\nfunction newJSONDocument(root, diagnostics) {\n    if (diagnostics === void 0) { diagnostics = []; }\n    return new JSONDocument(root, diagnostics, []);\n}\nfunction jsonParser_getNodeValue(node) {\n    return main_getNodeValue(node);\n}\nfunction jsonParser_getNodePath(node) {\n    return main_getNodePath(node);\n}\nfunction jsonParser_contains(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) { includeRightBound = false; }\n    return offset >= node.offset && offset < (node.offset + node.length) || includeRightBound && offset === (node.offset + node.length);\n}\nvar JSONDocument = /** @class */ (function () {\n    function JSONDocument(root, syntaxErrors, comments) {\n        if (syntaxErrors === void 0) { syntaxErrors = []; }\n        if (comments === void 0) { comments = []; }\n        this.root = root;\n        this.syntaxErrors = syntaxErrors;\n        this.comments = comments;\n    }\n    JSONDocument.prototype.getNodeFromOffset = function (offset, includeRightBound) {\n        if (includeRightBound === void 0) { includeRightBound = false; }\n        if (this.root) {\n            return main_findNodeAtOffset(this.root, offset, includeRightBound);\n        }\n        return undefined;\n    };\n    JSONDocument.prototype.visit = function (visitor) {\n        if (this.root) {\n            var doVisit_1 = function (node) {\n                var ctn = visitor(node);\n                var children = node.children;\n                if (Array.isArray(children)) {\n                    for (var i = 0; i < children.length && ctn; i++) {\n                        ctn = doVisit_1(children[i]);\n                    }\n                }\n                return ctn;\n            };\n            doVisit_1(this.root);\n        }\n    };\n    JSONDocument.prototype.validate = function (textDocument, schema, severity) {\n        if (severity === void 0) { severity = DiagnosticSeverity.Warning; }\n        if (this.root && schema) {\n            var validationResult = new ValidationResult();\n            validate(this.root, schema, validationResult, NoOpSchemaCollector.instance);\n            return validationResult.problems.map(function (p) {\n                var _a;\n                var range = main_Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\n                return Diagnostic.create(range, p.message, (_a = p.severity) !== null && _a !== void 0 ? _a : severity, p.code);\n            });\n        }\n        return undefined;\n    };\n    JSONDocument.prototype.getMatchingSchemas = function (schema, focusOffset, exclude) {\n        if (focusOffset === void 0) { focusOffset = -1; }\n        var matchingSchemas = new SchemaCollector(focusOffset, exclude);\n        if (this.root && schema) {\n            validate(this.root, schema, new ValidationResult(), matchingSchemas);\n        }\n        return matchingSchemas.schemas;\n    };\n    return JSONDocument;\n}());\n\nfunction validate(n, schema, validationResult, matchingSchemas) {\n    if (!n || !matchingSchemas.include(n)) {\n        return;\n    }\n    var node = n;\n    switch (node.type) {\n        case 'object':\n            _validateObjectNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'array':\n            _validateArrayNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'string':\n            _validateStringNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'number':\n            _validateNumberNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'property':\n            return validate(node.valueNode, schema, validationResult, matchingSchemas);\n    }\n    _validateNode();\n    matchingSchemas.add({ node: node, schema: schema });\n    function _validateNode() {\n        function matchesType(type) {\n            return node.type === type || (type === 'integer' && node.type === 'number' && node.isInteger);\n        }\n        if (Array.isArray(schema.type)) {\n            if (!schema.type.some(matchesType)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || jsonParser_localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', '))\n                });\n            }\n        }\n        else if (schema.type) {\n            if (!matchesType(schema.type)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || jsonParser_localize('typeMismatchWarning', 'Incorrect type. Expected \"{0}\".', schema.type)\n                });\n            }\n        }\n        if (Array.isArray(schema.allOf)) {\n            for (var _i = 0, _a = schema.allOf; _i < _a.length; _i++) {\n                var subSchemaRef = _a[_i];\n                validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);\n            }\n        }\n        var notSchema = asSchema(schema.not);\n        if (notSchema) {\n            var subValidationResult = new ValidationResult();\n            var subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, notSchema, subValidationResult, subMatchingSchemas);\n            if (!subValidationResult.hasProblems()) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('notSchemaWarning', \"Matches a schema that is not allowed.\")\n                });\n            }\n            for (var _b = 0, _c = subMatchingSchemas.schemas; _b < _c.length; _b++) {\n                var ms = _c[_b];\n                ms.inverted = !ms.inverted;\n                matchingSchemas.add(ms);\n            }\n        }\n        var testAlternatives = function (alternatives, maxOneMatch) {\n            var matches = [];\n            // remember the best match that is used for error messages\n            var bestMatch = undefined;\n            for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {\n                var subSchemaRef = alternatives_1[_i];\n                var subSchema = asSchema(subSchemaRef);\n                var subValidationResult = new ValidationResult();\n                var subMatchingSchemas = matchingSchemas.newSub();\n                validate(node, subSchema, subValidationResult, subMatchingSchemas);\n                if (!subValidationResult.hasProblems()) {\n                    matches.push(subSchema);\n                }\n                if (!bestMatch) {\n                    bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\n                }\n                else {\n                    if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {\n                        // no errors, both are equally good matches\n                        bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                        bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n                        bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n                    }\n                    else {\n                        var compareResult = subValidationResult.compare(bestMatch.validationResult);\n                        if (compareResult > 0) {\n                            // our node is the best matching so far\n                            bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };\n                        }\n                        else if (compareResult === 0) {\n                            // there's already a best matching but we are as good\n                            bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                            bestMatch.validationResult.mergeEnumValues(subValidationResult);\n                        }\n                    }\n                }\n            }\n            if (matches.length > 1 && maxOneMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: 1 },\n                    message: jsonParser_localize('oneOfWarning', \"Matches multiple schemas when only one must validate.\")\n                });\n            }\n            if (bestMatch) {\n                validationResult.merge(bestMatch.validationResult);\n                validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;\n                validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;\n                matchingSchemas.merge(bestMatch.matchingSchemas);\n            }\n            return matches.length;\n        };\n        if (Array.isArray(schema.anyOf)) {\n            testAlternatives(schema.anyOf, false);\n        }\n        if (Array.isArray(schema.oneOf)) {\n            testAlternatives(schema.oneOf, true);\n        }\n        var testBranch = function (schema) {\n            var subValidationResult = new ValidationResult();\n            var subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, asSchema(schema), subValidationResult, subMatchingSchemas);\n            validationResult.merge(subValidationResult);\n            validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n            validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n            matchingSchemas.merge(subMatchingSchemas);\n        };\n        var testCondition = function (ifSchema, thenSchema, elseSchema) {\n            var subSchema = asSchema(ifSchema);\n            var subValidationResult = new ValidationResult();\n            var subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, subSchema, subValidationResult, subMatchingSchemas);\n            matchingSchemas.merge(subMatchingSchemas);\n            if (!subValidationResult.hasProblems()) {\n                if (thenSchema) {\n                    testBranch(thenSchema);\n                }\n            }\n            else if (elseSchema) {\n                testBranch(elseSchema);\n            }\n        };\n        var ifSchema = asSchema(schema.if);\n        if (ifSchema) {\n            testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));\n        }\n        if (Array.isArray(schema.enum)) {\n            var val = jsonParser_getNodeValue(node);\n            var enumValueMatch = false;\n            for (var _d = 0, _e = schema.enum; _d < _e.length; _d++) {\n                var e = _e[_d];\n                if (equals(val, e)) {\n                    enumValueMatch = true;\n                    break;\n                }\n            }\n            validationResult.enumValues = schema.enum;\n            validationResult.enumValueMatch = enumValueMatch;\n            if (!enumValueMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    code: ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage || jsonParser_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum.map(function (v) { return JSON.stringify(v); }).join(', '))\n                });\n            }\n        }\n        if (isDefined(schema.const)) {\n            var val = jsonParser_getNodeValue(node);\n            if (!equals(val, schema.const)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    code: ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage || jsonParser_localize('constWarning', 'Value must be {0}.', JSON.stringify(schema.const))\n                });\n                validationResult.enumValueMatch = false;\n            }\n            else {\n                validationResult.enumValueMatch = true;\n            }\n            validationResult.enumValues = [schema.const];\n        }\n        if (schema.deprecationMessage && node.parent) {\n            validationResult.problems.push({\n                location: { offset: node.parent.offset, length: node.parent.length },\n                severity: DiagnosticSeverity.Warning,\n                message: schema.deprecationMessage,\n                code: ErrorCode.Deprecated\n            });\n        }\n    }\n    function _validateNumberNode(node, schema, validationResult, matchingSchemas) {\n        var val = node.value;\n        function normalizeFloats(float) {\n            var _a;\n            var parts = /^(-?\\d+)(?:\\.(\\d+))?(?:e([-+]\\d+))?$/.exec(float.toString());\n            return parts && {\n                value: Number(parts[1] + (parts[2] || '')),\n                multiplier: (((_a = parts[2]) === null || _a === void 0 ? void 0 : _a.length) || 0) - (parseInt(parts[3]) || 0)\n            };\n        }\n        ;\n        if (objects_isNumber(schema.multipleOf)) {\n            var remainder = -1;\n            if (Number.isInteger(schema.multipleOf)) {\n                remainder = val % schema.multipleOf;\n            }\n            else {\n                var normMultipleOf = normalizeFloats(schema.multipleOf);\n                var normValue = normalizeFloats(val);\n                if (normMultipleOf && normValue) {\n                    var multiplier = Math.pow(10, Math.abs(normValue.multiplier - normMultipleOf.multiplier));\n                    if (normValue.multiplier < normMultipleOf.multiplier) {\n                        normValue.value *= multiplier;\n                    }\n                    else {\n                        normMultipleOf.value *= multiplier;\n                    }\n                    remainder = normValue.value % normMultipleOf.value;\n                }\n            }\n            if (remainder !== 0) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf)\n                });\n            }\n        }\n        function getExclusiveLimit(limit, exclusive) {\n            if (objects_isNumber(exclusive)) {\n                return exclusive;\n            }\n            if (objects_isBoolean(exclusive) && exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        function getLimit(limit, exclusive) {\n            if (!objects_isBoolean(exclusive) || !exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        var exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);\n        if (objects_isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', exclusiveMinimum)\n            });\n        }\n        var exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);\n        if (objects_isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', exclusiveMaximum)\n            });\n        }\n        var minimum = getLimit(schema.minimum, schema.exclusiveMinimum);\n        if (objects_isNumber(minimum) && val < minimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('minimumWarning', 'Value is below the minimum of {0}.', minimum)\n            });\n        }\n        var maximum = getLimit(schema.maximum, schema.exclusiveMaximum);\n        if (objects_isNumber(maximum) && val > maximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('maximumWarning', 'Value is above the maximum of {0}.', maximum)\n            });\n        }\n    }\n    function _validateStringNode(node, schema, validationResult, matchingSchemas) {\n        if (objects_isNumber(schema.minLength) && node.value.length < schema.minLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength)\n            });\n        }\n        if (objects_isNumber(schema.maxLength) && node.value.length > schema.maxLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength)\n            });\n        }\n        if (objects_isString(schema.pattern)) {\n            var regex = extendedRegExp(schema.pattern);\n            if (!regex.test(node.value)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.patternErrorMessage || schema.errorMessage || jsonParser_localize('patternWarning', 'String does not match the pattern of \"{0}\".', schema.pattern)\n                });\n            }\n        }\n        if (schema.format) {\n            switch (schema.format) {\n                case 'uri':\n                case 'uri-reference':\n                    {\n                        var errorMessage = void 0;\n                        if (!node.value) {\n                            errorMessage = jsonParser_localize('uriEmpty', 'URI expected.');\n                        }\n                        else {\n                            var match = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(node.value);\n                            if (!match) {\n                                errorMessage = jsonParser_localize('uriMissing', 'URI is expected.');\n                            }\n                            else if (!match[2] && schema.format === 'uri') {\n                                errorMessage = jsonParser_localize('uriSchemeMissing', 'URI with a scheme is expected.');\n                            }\n                        }\n                        if (errorMessage) {\n                            validationResult.problems.push({\n                                location: { offset: node.offset, length: node.length },\n                                message: schema.patternErrorMessage || schema.errorMessage || jsonParser_localize('uriFormatWarning', 'String is not a URI: {0}', errorMessage)\n                            });\n                        }\n                    }\n                    break;\n                case 'color-hex':\n                case 'date-time':\n                case 'date':\n                case 'time':\n                case 'email':\n                    var format = formats[schema.format];\n                    if (!node.value || !format.pattern.exec(node.value)) {\n                        validationResult.problems.push({\n                            location: { offset: node.offset, length: node.length },\n                            message: schema.patternErrorMessage || schema.errorMessage || format.errorMessage\n                        });\n                    }\n                default:\n            }\n        }\n    }\n    function _validateArrayNode(node, schema, validationResult, matchingSchemas) {\n        if (Array.isArray(schema.items)) {\n            var subSchemas = schema.items;\n            for (var index = 0; index < subSchemas.length; index++) {\n                var subSchemaRef = subSchemas[index];\n                var subSchema = asSchema(subSchemaRef);\n                var itemValidationResult = new ValidationResult();\n                var item = node.items[index];\n                if (item) {\n                    validate(item, subSchema, itemValidationResult, matchingSchemas);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                }\n                else if (node.items.length >= subSchemas.length) {\n                    validationResult.propertiesValueMatches++;\n                }\n            }\n            if (node.items.length > subSchemas.length) {\n                if (typeof schema.additionalItems === 'object') {\n                    for (var i = subSchemas.length; i < node.items.length; i++) {\n                        var itemValidationResult = new ValidationResult();\n                        validate(node.items[i], schema.additionalItems, itemValidationResult, matchingSchemas);\n                        validationResult.mergePropertyMatch(itemValidationResult);\n                    }\n                }\n                else if (schema.additionalItems === false) {\n                    validationResult.problems.push({\n                        location: { offset: node.offset, length: node.length },\n                        message: jsonParser_localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas.length)\n                    });\n                }\n            }\n        }\n        else {\n            var itemSchema = asSchema(schema.items);\n            if (itemSchema) {\n                for (var _i = 0, _a = node.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    var itemValidationResult = new ValidationResult();\n                    validate(item, itemSchema, itemValidationResult, matchingSchemas);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                }\n            }\n        }\n        var containsSchema = asSchema(schema.contains);\n        if (containsSchema) {\n            var doesContain = node.items.some(function (item) {\n                var itemValidationResult = new ValidationResult();\n                validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance);\n                return !itemValidationResult.hasProblems();\n            });\n            if (!doesContain) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: schema.errorMessage || jsonParser_localize('requiredItemMissingWarning', 'Array does not contain required item.')\n                });\n            }\n        }\n        if (objects_isNumber(schema.minItems) && node.items.length < schema.minItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems)\n            });\n        }\n        if (objects_isNumber(schema.maxItems) && node.items.length > schema.maxItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                message: jsonParser_localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.maxItems)\n            });\n        }\n        if (schema.uniqueItems === true) {\n            var values_1 = jsonParser_getNodeValue(node);\n            var duplicates = values_1.some(function (value, index) {\n                return index !== values_1.lastIndexOf(value);\n            });\n            if (duplicates) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('uniqueItemsWarning', 'Array has duplicate items.')\n                });\n            }\n        }\n    }\n    function _validateObjectNode(node, schema, validationResult, matchingSchemas) {\n        var seenKeys = Object.create(null);\n        var unprocessedProperties = [];\n        for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {\n            var propertyNode = _a[_i];\n            var key = propertyNode.keyNode.value;\n            seenKeys[key] = propertyNode.valueNode;\n            unprocessedProperties.push(key);\n        }\n        if (Array.isArray(schema.required)) {\n            for (var _b = 0, _c = schema.required; _b < _c.length; _b++) {\n                var propertyName = _c[_b];\n                if (!seenKeys[propertyName]) {\n                    var keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;\n                    var location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node.offset, length: 1 };\n                    validationResult.problems.push({\n                        location: location,\n                        message: jsonParser_localize('MissingRequiredPropWarning', 'Missing property \"{0}\".', propertyName)\n                    });\n                }\n            }\n        }\n        var propertyProcessed = function (prop) {\n            var index = unprocessedProperties.indexOf(prop);\n            while (index >= 0) {\n                unprocessedProperties.splice(index, 1);\n                index = unprocessedProperties.indexOf(prop);\n            }\n        };\n        if (schema.properties) {\n            for (var _d = 0, _e = Object.keys(schema.properties); _d < _e.length; _d++) {\n                var propertyName = _e[_d];\n                propertyProcessed(propertyName);\n                var propertySchema = schema.properties[propertyName];\n                var child = seenKeys[propertyName];\n                if (child) {\n                    if (objects_isBoolean(propertySchema)) {\n                        if (!propertySchema) {\n                            var propertyNode = child.parent;\n                            validationResult.problems.push({\n                                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                            });\n                        }\n                        else {\n                            validationResult.propertiesMatches++;\n                            validationResult.propertiesValueMatches++;\n                        }\n                    }\n                    else {\n                        var propertyValidationResult = new ValidationResult();\n                        validate(child, propertySchema, propertyValidationResult, matchingSchemas);\n                        validationResult.mergePropertyMatch(propertyValidationResult);\n                    }\n                }\n            }\n        }\n        if (schema.patternProperties) {\n            for (var _f = 0, _g = Object.keys(schema.patternProperties); _f < _g.length; _f++) {\n                var propertyPattern = _g[_f];\n                var regex = extendedRegExp(propertyPattern);\n                for (var _h = 0, _j = unprocessedProperties.slice(0); _h < _j.length; _h++) {\n                    var propertyName = _j[_h];\n                    if (regex.test(propertyName)) {\n                        propertyProcessed(propertyName);\n                        var child = seenKeys[propertyName];\n                        if (child) {\n                            var propertySchema = schema.patternProperties[propertyPattern];\n                            if (objects_isBoolean(propertySchema)) {\n                                if (!propertySchema) {\n                                    var propertyNode = child.parent;\n                                    validationResult.problems.push({\n                                        location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                                        message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                                    });\n                                }\n                                else {\n                                    validationResult.propertiesMatches++;\n                                    validationResult.propertiesValueMatches++;\n                                }\n                            }\n                            else {\n                                var propertyValidationResult = new ValidationResult();\n                                validate(child, propertySchema, propertyValidationResult, matchingSchemas);\n                                validationResult.mergePropertyMatch(propertyValidationResult);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k < unprocessedProperties_1.length; _k++) {\n                var propertyName = unprocessedProperties_1[_k];\n                var child = seenKeys[propertyName];\n                if (child) {\n                    var propertyValidationResult = new ValidationResult();\n                    validate(child, schema.additionalProperties, propertyValidationResult, matchingSchemas);\n                    validationResult.mergePropertyMatch(propertyValidationResult);\n                }\n            }\n        }\n        else if (schema.additionalProperties === false) {\n            if (unprocessedProperties.length > 0) {\n                for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l < unprocessedProperties_2.length; _l++) {\n                    var propertyName = unprocessedProperties_2[_l];\n                    var child = seenKeys[propertyName];\n                    if (child) {\n                        var propertyNode = child.parent;\n                        validationResult.problems.push({\n                            location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },\n                            message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)\n                        });\n                    }\n                }\n            }\n        }\n        if (objects_isNumber(schema.maxProperties)) {\n            if (node.properties.length > schema.maxProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties)\n                });\n            }\n        }\n        if (objects_isNumber(schema.minProperties)) {\n            if (node.properties.length < schema.minProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    message: jsonParser_localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties)\n                });\n            }\n        }\n        if (schema.dependencies) {\n            for (var _m = 0, _o = Object.keys(schema.dependencies); _m < _o.length; _m++) {\n                var key = _o[_m];\n                var prop = seenKeys[key];\n                if (prop) {\n                    var propertyDep = schema.dependencies[key];\n                    if (Array.isArray(propertyDep)) {\n                        for (var _p = 0, propertyDep_1 = propertyDep; _p < propertyDep_1.length; _p++) {\n                            var requiredProp = propertyDep_1[_p];\n                            if (!seenKeys[requiredProp]) {\n                                validationResult.problems.push({\n                                    location: { offset: node.offset, length: node.length },\n                                    message: jsonParser_localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key)\n                                });\n                            }\n                            else {\n                                validationResult.propertiesValueMatches++;\n                            }\n                        }\n                    }\n                    else {\n                        var propertySchema = asSchema(propertyDep);\n                        if (propertySchema) {\n                            var propertyValidationResult = new ValidationResult();\n                            validate(node, propertySchema, propertyValidationResult, matchingSchemas);\n                            validationResult.mergePropertyMatch(propertyValidationResult);\n                        }\n                    }\n                }\n            }\n        }\n        var propertyNames = asSchema(schema.propertyNames);\n        if (propertyNames) {\n            for (var _q = 0, _r = node.properties; _q < _r.length; _q++) {\n                var f = _r[_q];\n                var key = f.keyNode;\n                if (key) {\n                    validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance);\n                }\n            }\n        }\n    }\n}\nfunction jsonParser_parse(textDocument, config) {\n    var problems = [];\n    var lastProblemOffset = -1;\n    var text = textDocument.getText();\n    var scanner = main_createScanner(text, false);\n    var commentRanges = config && config.collectComments ? [] : undefined;\n    function _scanNext() {\n        while (true) {\n            var token_1 = scanner.scan();\n            _checkScanError();\n            switch (token_1) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                    if (Array.isArray(commentRanges)) {\n                        commentRanges.push(main_Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));\n                    }\n                    break;\n                case 15 /* Trivia */:\n                case 14 /* LineBreakTrivia */:\n                    break;\n                default:\n                    return token_1;\n            }\n        }\n    }\n    function _accept(token) {\n        if (scanner.getToken() === token) {\n            _scanNext();\n            return true;\n        }\n        return false;\n    }\n    function _errorAtRange(message, code, startOffset, endOffset, severity) {\n        if (severity === void 0) { severity = DiagnosticSeverity.Error; }\n        if (problems.length === 0 || startOffset !== lastProblemOffset) {\n            var range = main_Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));\n            problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));\n            lastProblemOffset = startOffset;\n        }\n    }\n    function _error(message, code, node, skipUntilAfter, skipUntil) {\n        if (node === void 0) { node = undefined; }\n        if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n        if (skipUntil === void 0) { skipUntil = []; }\n        var start = scanner.getTokenOffset();\n        var end = scanner.getTokenOffset() + scanner.getTokenLength();\n        if (start === end && start > 0) {\n            start--;\n            while (start > 0 && /\\s/.test(text.charAt(start))) {\n                start--;\n            }\n            end = start + 1;\n        }\n        _errorAtRange(message, code, start, end);\n        if (node) {\n            _finalize(node, false);\n        }\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            var token_2 = scanner.getToken();\n            while (token_2 !== 17 /* EOF */) {\n                if (skipUntilAfter.indexOf(token_2) !== -1) {\n                    _scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token_2) !== -1) {\n                    break;\n                }\n                token_2 = _scanNext();\n            }\n        }\n        return node;\n    }\n    function _checkScanError() {\n        switch (scanner.getTokenError()) {\n            case 4 /* InvalidUnicode */:\n                _error(jsonParser_localize('InvalidUnicode', 'Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);\n                return true;\n            case 5 /* InvalidEscapeCharacter */:\n                _error(jsonParser_localize('InvalidEscapeCharacter', 'Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);\n                return true;\n            case 3 /* UnexpectedEndOfNumber */:\n                _error(jsonParser_localize('UnexpectedEndOfNumber', 'Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);\n                return true;\n            case 1 /* UnexpectedEndOfComment */:\n                _error(jsonParser_localize('UnexpectedEndOfComment', 'Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);\n                return true;\n            case 2 /* UnexpectedEndOfString */:\n                _error(jsonParser_localize('UnexpectedEndOfString', 'Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);\n                return true;\n            case 6 /* InvalidCharacter */:\n                _error(jsonParser_localize('InvalidCharacter', 'Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);\n                return true;\n        }\n        return false;\n    }\n    function _finalize(node, scanNext) {\n        node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;\n        if (scanNext) {\n            _scanNext();\n        }\n        return node;\n    }\n    function _parseArray(parent) {\n        if (scanner.getToken() !== 3 /* OpenBracketToken */) {\n            return undefined;\n        }\n        var node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());\n        _scanNext(); // consume OpenBracketToken\n        var count = 0;\n        var needsComma = false;\n        while (scanner.getToken() !== 4 /* CloseBracketToken */ && scanner.getToken() !== 17 /* EOF */) {\n            if (scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    _error(jsonParser_localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected);\n                }\n                var commaOffset = scanner.getTokenOffset();\n                _scanNext(); // consume comma\n                if (scanner.getToken() === 4 /* CloseBracketToken */) {\n                    if (needsComma) {\n                        _errorAtRange(jsonParser_localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n                    }\n                    continue;\n                }\n            }\n            else if (needsComma) {\n                _error(jsonParser_localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);\n            }\n            var item = _parseValue(node);\n            if (!item) {\n                _error(jsonParser_localize('PropertyExpected', 'Value expected'), ErrorCode.ValueExpected, undefined, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n            }\n            else {\n                node.items.push(item);\n            }\n            needsComma = true;\n        }\n        if (scanner.getToken() !== 4 /* CloseBracketToken */) {\n            return _error(jsonParser_localize('ExpectedCloseBracket', 'Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);\n        }\n        return _finalize(node, true);\n    }\n    var keyPlaceholder = new StringASTNodeImpl(undefined, 0, 0);\n    function _parseProperty(parent, keysSeen) {\n        var node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);\n        var key = _parseString(node);\n        if (!key) {\n            if (scanner.getToken() === 16 /* Unknown */) {\n                // give a more helpful error message\n                _error(jsonParser_localize('DoubleQuotesExpected', 'Property keys must be doublequoted'), ErrorCode.Undefined);\n                var keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());\n                keyNode.value = scanner.getTokenValue();\n                key = keyNode;\n                _scanNext(); // consume Unknown\n            }\n            else {\n                return undefined;\n            }\n        }\n        node.keyNode = key;\n        var seen = keysSeen[key.value];\n        if (seen) {\n            _errorAtRange(jsonParser_localize('DuplicateKeyWarning', \"Duplicate object key\"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);\n            if (typeof seen === 'object') {\n                _errorAtRange(jsonParser_localize('DuplicateKeyWarning', \"Duplicate object key\"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);\n            }\n            keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting\n        }\n        else {\n            keysSeen[key.value] = node;\n        }\n        if (scanner.getToken() === 6 /* ColonToken */) {\n            node.colonOffset = scanner.getTokenOffset();\n            _scanNext(); // consume ColonToken\n        }\n        else {\n            _error(jsonParser_localize('ColonExpected', 'Colon expected'), ErrorCode.ColonExpected);\n            if (scanner.getToken() === 10 /* StringLiteral */ && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {\n                node.length = key.length;\n                return node;\n            }\n        }\n        var value = _parseValue(node);\n        if (!value) {\n            return _error(jsonParser_localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected, node, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n        }\n        node.valueNode = value;\n        node.length = value.offset + value.length - node.offset;\n        return node;\n    }\n    function _parseObject(parent) {\n        if (scanner.getToken() !== 1 /* OpenBraceToken */) {\n            return undefined;\n        }\n        var node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());\n        var keysSeen = Object.create(null);\n        _scanNext(); // consume OpenBraceToken\n        var needsComma = false;\n        while (scanner.getToken() !== 2 /* CloseBraceToken */ && scanner.getToken() !== 17 /* EOF */) {\n            if (scanner.getToken() === 5 /* CommaToken */) {\n                if (!needsComma) {\n                    _error(jsonParser_localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected);\n                }\n                var commaOffset = scanner.getTokenOffset();\n                _scanNext(); // consume comma\n                if (scanner.getToken() === 2 /* CloseBraceToken */) {\n                    if (needsComma) {\n                        _errorAtRange(jsonParser_localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);\n                    }\n                    continue;\n                }\n            }\n            else if (needsComma) {\n                _error(jsonParser_localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);\n            }\n            var property = _parseProperty(node, keysSeen);\n            if (!property) {\n                _error(jsonParser_localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected, undefined, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            else {\n                node.properties.push(property);\n            }\n            needsComma = true;\n        }\n        if (scanner.getToken() !== 2 /* CloseBraceToken */) {\n            return _error(jsonParser_localize('ExpectedCloseBrace', 'Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);\n        }\n        return _finalize(node, true);\n    }\n    function _parseString(parent) {\n        if (scanner.getToken() !== 10 /* StringLiteral */) {\n            return undefined;\n        }\n        var node = new StringASTNodeImpl(parent, scanner.getTokenOffset());\n        node.value = scanner.getTokenValue();\n        return _finalize(node, true);\n    }\n    function _parseNumber(parent) {\n        if (scanner.getToken() !== 11 /* NumericLiteral */) {\n            return undefined;\n        }\n        var node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());\n        if (scanner.getTokenError() === 0 /* None */) {\n            var tokenValue = scanner.getTokenValue();\n            try {\n                var numberValue = JSON.parse(tokenValue);\n                if (!objects_isNumber(numberValue)) {\n                    return _error(jsonParser_localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);\n                }\n                node.value = numberValue;\n            }\n            catch (e) {\n                return _error(jsonParser_localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);\n            }\n            node.isInteger = tokenValue.indexOf('.') === -1;\n        }\n        return _finalize(node, true);\n    }\n    function _parseLiteral(parent) {\n        var node;\n        switch (scanner.getToken()) {\n            case 7 /* NullKeyword */:\n                return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);\n            case 8 /* TrueKeyword */:\n                return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);\n            case 9 /* FalseKeyword */:\n                return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);\n            default:\n                return undefined;\n        }\n    }\n    function _parseValue(parent) {\n        return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);\n    }\n    var _root = undefined;\n    var token = _scanNext();\n    if (token !== 17 /* EOF */) {\n        _root = _parseValue(_root);\n        if (!_root) {\n            _error(jsonParser_localize('Invalid symbol', 'Expected a JSON object, array or literal.'), ErrorCode.Undefined);\n        }\n        else if (scanner.getToken() !== 17 /* EOF */) {\n            _error(jsonParser_localize('End of file expected', 'End of file expected.'), ErrorCode.Undefined);\n        }\n    }\n    return new JSONDocument(_root, problems, commentRanges);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/json.js\n/*---------------------------------------------------------------------------------------------\n*  Copyright (c) Microsoft Corporation. All rights reserved.\n*  Licensed under the MIT License. See License.txt in the project root for license information.\n*--------------------------------------------------------------------------------------------*/\nfunction stringifyObject(obj, indent, stringifyLiteral) {\n    if (obj !== null && typeof obj === 'object') {\n        var newIndent = indent + '\\t';\n        if (Array.isArray(obj)) {\n            if (obj.length === 0) {\n                return '[]';\n            }\n            var result = '[\\n';\n            for (var i = 0; i < obj.length; i++) {\n                result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);\n                if (i < obj.length - 1) {\n                    result += ',';\n                }\n                result += '\\n';\n            }\n            result += indent + ']';\n            return result;\n        }\n        else {\n            var keys = Object.keys(obj);\n            if (keys.length === 0) {\n                return '{}';\n            }\n            var result = '{\\n';\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);\n                if (i < keys.length - 1) {\n                    result += ',';\n                }\n                result += '\\n';\n            }\n            result += indent + '}';\n            return result;\n        }\n    }\n    return stringifyLiteral(obj);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonCompletion.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nvar jsonCompletion_localize = loadMessageBundle();\nvar valueCommitCharacters = [',', '}', ']'];\nvar propertyCommitCharacters = [':'];\nvar JSONCompletion = /** @class */ (function () {\n    function JSONCompletion(schemaService, contributions, promiseConstructor, clientCapabilities) {\n        if (contributions === void 0) { contributions = []; }\n        if (promiseConstructor === void 0) { promiseConstructor = Promise; }\n        if (clientCapabilities === void 0) { clientCapabilities = {}; }\n        this.schemaService = schemaService;\n        this.contributions = contributions;\n        this.promiseConstructor = promiseConstructor;\n        this.clientCapabilities = clientCapabilities;\n    }\n    JSONCompletion.prototype.doResolve = function (item) {\n        for (var i = this.contributions.length - 1; i >= 0; i--) {\n            var resolveCompletion = this.contributions[i].resolveCompletion;\n            if (resolveCompletion) {\n                var resolver = resolveCompletion(item);\n                if (resolver) {\n                    return resolver;\n                }\n            }\n        }\n        return this.promiseConstructor.resolve(item);\n    };\n    JSONCompletion.prototype.doComplete = function (document, position, doc) {\n        var _this = this;\n        var result = {\n            items: [],\n            isIncomplete: false\n        };\n        var text = document.getText();\n        var offset = document.offsetAt(position);\n        var node = doc.getNodeFromOffset(offset, true);\n        if (this.isInComment(document, node ? node.offset : 0, offset)) {\n            return Promise.resolve(result);\n        }\n        if (node && (offset === node.offset + node.length) && offset > 0) {\n            var ch = text[offset - 1];\n            if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {\n                // after ] or }\n                node = node.parent;\n            }\n        }\n        var currentWord = this.getCurrentWord(document, offset);\n        var overwriteRange;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            overwriteRange = main_Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n        }\n        else {\n            var overwriteStart = offset - currentWord.length;\n            if (overwriteStart > 0 && text[overwriteStart - 1] === '\"') {\n                overwriteStart--;\n            }\n            overwriteRange = main_Range.create(document.positionAt(overwriteStart), position);\n        }\n        var supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544\n        var proposed = {};\n        var collector = {\n            add: function (suggestion) {\n                var label = suggestion.label;\n                var existing = proposed[label];\n                if (!existing) {\n                    label = label.replace(/[\\n]/g, '↵');\n                    if (label.length > 60) {\n                        var shortendedLabel = label.substr(0, 57).trim() + '...';\n                        if (!proposed[shortendedLabel]) {\n                            label = shortendedLabel;\n                        }\n                    }\n                    if (overwriteRange && suggestion.insertText !== undefined) {\n                        suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);\n                    }\n                    if (supportsCommitCharacters) {\n                        suggestion.commitCharacters = suggestion.kind === main_CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;\n                    }\n                    suggestion.label = label;\n                    proposed[label] = suggestion;\n                    result.items.push(suggestion);\n                }\n                else {\n                    if (!existing.documentation) {\n                        existing.documentation = suggestion.documentation;\n                    }\n                    if (!existing.detail) {\n                        existing.detail = suggestion.detail;\n                    }\n                }\n            },\n            setAsIncomplete: function () {\n                result.isIncomplete = true;\n            },\n            error: function (message) {\n                console.error(message);\n            },\n            log: function (message) {\n                console.log(message);\n            },\n            getNumberOfProposals: function () {\n                return result.items.length;\n            }\n        };\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n            var collectionPromises = [];\n            var addValue = true;\n            var currentKey = '';\n            var currentProperty = undefined;\n            if (node) {\n                if (node.type === 'string') {\n                    var parent = node.parent;\n                    if (parent && parent.type === 'property' && parent.keyNode === node) {\n                        addValue = !parent.valueNode;\n                        currentProperty = parent;\n                        currentKey = text.substr(node.offset + 1, node.length - 2);\n                        if (parent) {\n                            node = parent.parent;\n                        }\n                    }\n                }\n            }\n            // proposals for properties\n            if (node && node.type === 'object') {\n                // don't suggest keys when the cursor is just before the opening curly brace\n                if (node.offset === offset) {\n                    return result;\n                }\n                // don't suggest properties that are already present\n                var properties = node.properties;\n                properties.forEach(function (p) {\n                    if (!currentProperty || currentProperty !== p) {\n                        proposed[p.keyNode.value] = CompletionItem.create('__');\n                    }\n                });\n                var separatorAfter_1 = '';\n                if (addValue) {\n                    separatorAfter_1 = _this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));\n                }\n                if (schema) {\n                    // property proposals with schema\n                    _this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter_1, collector);\n                }\n                else {\n                    // property proposals without schema\n                    _this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);\n                }\n                var location_1 = jsonParser_getNodePath(node);\n                _this.contributions.forEach(function (contribution) {\n                    var collectPromise = contribution.collectPropertyCompletions(document.uri, location_1, currentWord, addValue, separatorAfter_1 === '', collector);\n                    if (collectPromise) {\n                        collectionPromises.push(collectPromise);\n                    }\n                });\n                if ((!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '\"')) {\n                    collector.add({\n                        kind: main_CompletionItemKind.Property,\n                        label: _this.getLabelForValue(currentWord),\n                        insertText: _this.getInsertTextForProperty(currentWord, undefined, false, separatorAfter_1),\n                        insertTextFormat: InsertTextFormat.Snippet, documentation: '',\n                    });\n                    collector.setAsIncomplete();\n                }\n            }\n            // proposals for values\n            var types = {};\n            if (schema) {\n                // value proposals with schema\n                _this.getValueCompletions(schema, doc, node, offset, document, collector, types);\n            }\n            else {\n                // value proposals without schema\n                _this.getSchemaLessValueCompletions(doc, node, offset, document, collector);\n            }\n            if (_this.contributions.length > 0) {\n                _this.getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises);\n            }\n            return _this.promiseConstructor.all(collectionPromises).then(function () {\n                if (collector.getNumberOfProposals() === 0) {\n                    var offsetForSeparator = offset;\n                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n                        offsetForSeparator = node.offset + node.length;\n                    }\n                    var separatorAfter = _this.evaluateSeparatorAfter(document, offsetForSeparator);\n                    _this.addFillerValueCompletions(types, separatorAfter, collector);\n                }\n                return result;\n            });\n        });\n    };\n    JSONCompletion.prototype.getPropertyCompletions = function (schema, doc, node, addValue, separatorAfter, collector) {\n        var _this = this;\n        var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n        matchingSchemas.forEach(function (s) {\n            if (s.node === node && !s.inverted) {\n                var schemaProperties_1 = s.schema.properties;\n                if (schemaProperties_1) {\n                    Object.keys(schemaProperties_1).forEach(function (key) {\n                        var propertySchema = schemaProperties_1[key];\n                        if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {\n                            var proposal = {\n                                kind: main_CompletionItemKind.Property,\n                                label: key,\n                                insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),\n                                insertTextFormat: InsertTextFormat.Snippet,\n                                filterText: _this.getFilterTextForValue(key),\n                                documentation: _this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || '',\n                            };\n                            if (propertySchema.suggestSortText !== undefined) {\n                                proposal.sortText = propertySchema.suggestSortText;\n                            }\n                            if (proposal.insertText && endsWith(proposal.insertText, \"$1\" + separatorAfter)) {\n                                proposal.command = {\n                                    title: 'Suggest',\n                                    command: 'editor.action.triggerSuggest'\n                                };\n                            }\n                            collector.add(proposal);\n                        }\n                    });\n                }\n                var schemaPropertyNames_1 = s.schema.propertyNames;\n                if (typeof schemaPropertyNames_1 === 'object' && !schemaPropertyNames_1.deprecationMessage && !schemaPropertyNames_1.doNotSuggest) {\n                    var propertyNameCompletionItem = function (name, enumDescription) {\n                        if (enumDescription === void 0) { enumDescription = undefined; }\n                        var proposal = {\n                            kind: main_CompletionItemKind.Property,\n                            label: name,\n                            insertText: _this.getInsertTextForProperty(name, undefined, addValue, separatorAfter),\n                            insertTextFormat: InsertTextFormat.Snippet,\n                            filterText: _this.getFilterTextForValue(name),\n                            documentation: enumDescription || _this.fromMarkup(schemaPropertyNames_1.markdownDescription) || schemaPropertyNames_1.description || '',\n                        };\n                        if (schemaPropertyNames_1.suggestSortText !== undefined) {\n                            proposal.sortText = schemaPropertyNames_1.suggestSortText;\n                        }\n                        if (proposal.insertText && endsWith(proposal.insertText, \"$1\" + separatorAfter)) {\n                            proposal.command = {\n                                title: 'Suggest',\n                                command: 'editor.action.triggerSuggest'\n                            };\n                        }\n                        collector.add(proposal);\n                    };\n                    if (schemaPropertyNames_1.enum) {\n                        for (var i = 0; i < schemaPropertyNames_1.enum.length; i++) {\n                            var enumDescription = undefined;\n                            if (schemaPropertyNames_1.markdownEnumDescriptions && i < schemaPropertyNames_1.markdownEnumDescriptions.length) {\n                                enumDescription = _this.fromMarkup(schemaPropertyNames_1.markdownEnumDescriptions[i]);\n                            }\n                            else if (schemaPropertyNames_1.enumDescriptions && i < schemaPropertyNames_1.enumDescriptions.length) {\n                                enumDescription = schemaPropertyNames_1.enumDescriptions[i];\n                            }\n                            propertyNameCompletionItem(schemaPropertyNames_1.enum[i], enumDescription);\n                        }\n                    }\n                    if (schemaPropertyNames_1.const) {\n                        propertyNameCompletionItem(schemaPropertyNames_1.const);\n                    }\n                }\n            }\n        });\n    };\n    JSONCompletion.prototype.getSchemaLessPropertyCompletions = function (doc, node, currentKey, collector) {\n        var _this = this;\n        var collectCompletionsForSimilarObject = function (obj) {\n            obj.properties.forEach(function (p) {\n                var key = p.keyNode.value;\n                collector.add({\n                    kind: main_CompletionItemKind.Property,\n                    label: key,\n                    insertText: _this.getInsertTextForValue(key, ''),\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    filterText: _this.getFilterTextForValue(key),\n                    documentation: ''\n                });\n            });\n        };\n        if (node.parent) {\n            if (node.parent.type === 'property') {\n                // if the object is a property value, check the tree for other objects that hang under a property of the same name\n                var parentKey_1 = node.parent.keyNode.value;\n                doc.visit(function (n) {\n                    if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey_1 && n.valueNode && n.valueNode.type === 'object') {\n                        collectCompletionsForSimilarObject(n.valueNode);\n                    }\n                    return true;\n                });\n            }\n            else if (node.parent.type === 'array') {\n                // if the object is in an array, use all other array elements as similar objects\n                node.parent.items.forEach(function (n) {\n                    if (n.type === 'object' && n !== node) {\n                        collectCompletionsForSimilarObject(n);\n                    }\n                });\n            }\n        }\n        else if (node.type === 'object') {\n            collector.add({\n                kind: main_CompletionItemKind.Property,\n                label: '$schema',\n                insertText: this.getInsertTextForProperty('$schema', undefined, true, ''),\n                insertTextFormat: InsertTextFormat.Snippet, documentation: '',\n                filterText: this.getFilterTextForValue(\"$schema\")\n            });\n        }\n    };\n    JSONCompletion.prototype.getSchemaLessValueCompletions = function (doc, node, offset, document, collector) {\n        var _this = this;\n        var offsetForSeparator = offset;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n            node = node.parent;\n        }\n        if (!node) {\n            collector.add({\n                kind: this.getSuggestionKind('object'),\n                label: 'Empty object',\n                insertText: this.getInsertTextForValue({}, ''),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: ''\n            });\n            collector.add({\n                kind: this.getSuggestionKind('array'),\n                label: 'Empty array',\n                insertText: this.getInsertTextForValue([], ''),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: ''\n            });\n            return;\n        }\n        var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n        var collectSuggestionsForValues = function (value) {\n            if (value.parent && !jsonParser_contains(value.parent, offset, true)) {\n                collector.add({\n                    kind: _this.getSuggestionKind(value.type),\n                    label: _this.getLabelTextForMatchingNode(value, document),\n                    insertText: _this.getInsertTextForMatchingNode(value, document, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet, documentation: ''\n                });\n            }\n            if (value.type === 'boolean') {\n                _this.addBooleanValueCompletion(!value.value, separatorAfter, collector);\n            }\n        };\n        if (node.type === 'property') {\n            if (offset > (node.colonOffset || 0)) {\n                var valueNode = node.valueNode;\n                if (valueNode && (offset > (valueNode.offset + valueNode.length) || valueNode.type === 'object' || valueNode.type === 'array')) {\n                    return;\n                }\n                // suggest values at the same key\n                var parentKey_2 = node.keyNode.value;\n                doc.visit(function (n) {\n                    if (n.type === 'property' && n.keyNode.value === parentKey_2 && n.valueNode) {\n                        collectSuggestionsForValues(n.valueNode);\n                    }\n                    return true;\n                });\n                if (parentKey_2 === '$schema' && node.parent && !node.parent.parent) {\n                    this.addDollarSchemaCompletions(separatorAfter, collector);\n                }\n            }\n        }\n        if (node.type === 'array') {\n            if (node.parent && node.parent.type === 'property') {\n                // suggest items of an array at the same key\n                var parentKey_3 = node.parent.keyNode.value;\n                doc.visit(function (n) {\n                    if (n.type === 'property' && n.keyNode.value === parentKey_3 && n.valueNode && n.valueNode.type === 'array') {\n                        n.valueNode.items.forEach(collectSuggestionsForValues);\n                    }\n                    return true;\n                });\n            }\n            else {\n                // suggest items in the same array\n                node.items.forEach(collectSuggestionsForValues);\n            }\n        }\n    };\n    JSONCompletion.prototype.getValueCompletions = function (schema, doc, node, offset, document, collector, types) {\n        var offsetForSeparator = offset;\n        var parentKey = undefined;\n        var valueNode = undefined;\n        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {\n            offsetForSeparator = node.offset + node.length;\n            valueNode = node;\n            node = node.parent;\n        }\n        if (!node) {\n            this.addSchemaValueCompletions(schema.schema, '', collector, types);\n            return;\n        }\n        if ((node.type === 'property') && offset > (node.colonOffset || 0)) {\n            var valueNode_1 = node.valueNode;\n            if (valueNode_1 && offset > (valueNode_1.offset + valueNode_1.length)) {\n                return; // we are past the value node\n            }\n            parentKey = node.keyNode.value;\n            node = node.parent;\n        }\n        if (node && (parentKey !== undefined || node.type === 'array')) {\n            var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);\n            var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);\n            for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {\n                var s = matchingSchemas_1[_i];\n                if (s.node === node && !s.inverted && s.schema) {\n                    if (node.type === 'array' && s.schema.items) {\n                        if (Array.isArray(s.schema.items)) {\n                            var index = this.findItemAtOffset(node, document, offset);\n                            if (index < s.schema.items.length) {\n                                this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types);\n                            }\n                        }\n                        else {\n                            this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types);\n                        }\n                    }\n                    if (parentKey !== undefined) {\n                        var propertyMatched = false;\n                        if (s.schema.properties) {\n                            var propertySchema = s.schema.properties[parentKey];\n                            if (propertySchema) {\n                                propertyMatched = true;\n                                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                            }\n                        }\n                        if (s.schema.patternProperties && !propertyMatched) {\n                            for (var _a = 0, _b = Object.keys(s.schema.patternProperties); _a < _b.length; _a++) {\n                                var pattern = _b[_a];\n                                var regex = extendedRegExp(pattern);\n                                if (regex.test(parentKey)) {\n                                    propertyMatched = true;\n                                    var propertySchema = s.schema.patternProperties[pattern];\n                                    this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                                }\n                            }\n                        }\n                        if (s.schema.additionalProperties && !propertyMatched) {\n                            var propertySchema = s.schema.additionalProperties;\n                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);\n                        }\n                    }\n                }\n            }\n            if (parentKey === '$schema' && !node.parent) {\n                this.addDollarSchemaCompletions(separatorAfter, collector);\n            }\n            if (types['boolean']) {\n                this.addBooleanValueCompletion(true, separatorAfter, collector);\n                this.addBooleanValueCompletion(false, separatorAfter, collector);\n            }\n            if (types['null']) {\n                this.addNullValueCompletion(separatorAfter, collector);\n            }\n        }\n    };\n    JSONCompletion.prototype.getContributedValueCompletions = function (doc, node, offset, document, collector, collectionPromises) {\n        if (!node) {\n            this.contributions.forEach(function (contribution) {\n                var collectPromise = contribution.collectDefaultCompletions(document.uri, collector);\n                if (collectPromise) {\n                    collectionPromises.push(collectPromise);\n                }\n            });\n        }\n        else {\n            if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {\n                node = node.parent;\n            }\n            if (node && (node.type === 'property') && offset > (node.colonOffset || 0)) {\n                var parentKey_4 = node.keyNode.value;\n                var valueNode = node.valueNode;\n                if ((!valueNode || offset <= (valueNode.offset + valueNode.length)) && node.parent) {\n                    var location_2 = jsonParser_getNodePath(node.parent);\n                    this.contributions.forEach(function (contribution) {\n                        var collectPromise = contribution.collectValueCompletions(document.uri, location_2, parentKey_4, collector);\n                        if (collectPromise) {\n                            collectionPromises.push(collectPromise);\n                        }\n                    });\n                }\n            }\n        }\n    };\n    JSONCompletion.prototype.addSchemaValueCompletions = function (schema, separatorAfter, collector, types) {\n        var _this = this;\n        if (typeof schema === 'object') {\n            this.addEnumValueCompletions(schema, separatorAfter, collector);\n            this.addDefaultValueCompletions(schema, separatorAfter, collector);\n            this.collectTypes(schema, types);\n            if (Array.isArray(schema.allOf)) {\n                schema.allOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });\n            }\n            if (Array.isArray(schema.anyOf)) {\n                schema.anyOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });\n            }\n            if (Array.isArray(schema.oneOf)) {\n                schema.oneOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });\n            }\n        }\n    };\n    JSONCompletion.prototype.addDefaultValueCompletions = function (schema, separatorAfter, collector, arrayDepth) {\n        var _this = this;\n        if (arrayDepth === void 0) { arrayDepth = 0; }\n        var hasProposals = false;\n        if (isDefined(schema.default)) {\n            var type = schema.type;\n            var value = schema.default;\n            for (var i = arrayDepth; i > 0; i--) {\n                value = [value];\n                type = 'array';\n            }\n            collector.add({\n                kind: this.getSuggestionKind(type),\n                label: this.getLabelForValue(value),\n                insertText: this.getInsertTextForValue(value, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: jsonCompletion_localize('json.suggest.default', 'Default value')\n            });\n            hasProposals = true;\n        }\n        if (Array.isArray(schema.examples)) {\n            schema.examples.forEach(function (example) {\n                var type = schema.type;\n                var value = example;\n                for (var i = arrayDepth; i > 0; i--) {\n                    value = [value];\n                    type = 'array';\n                }\n                collector.add({\n                    kind: _this.getSuggestionKind(type),\n                    label: _this.getLabelForValue(value),\n                    insertText: _this.getInsertTextForValue(value, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet\n                });\n                hasProposals = true;\n            });\n        }\n        if (Array.isArray(schema.defaultSnippets)) {\n            schema.defaultSnippets.forEach(function (s) {\n                var type = schema.type;\n                var value = s.body;\n                var label = s.label;\n                var insertText;\n                var filterText;\n                if (isDefined(value)) {\n                    var type_1 = schema.type;\n                    for (var i = arrayDepth; i > 0; i--) {\n                        value = [value];\n                        type_1 = 'array';\n                    }\n                    insertText = _this.getInsertTextForSnippetValue(value, separatorAfter);\n                    filterText = _this.getFilterTextForSnippetValue(value);\n                    label = label || _this.getLabelForSnippetValue(value);\n                }\n                else if (typeof s.bodyText === 'string') {\n                    var prefix = '', suffix = '', indent = '';\n                    for (var i = arrayDepth; i > 0; i--) {\n                        prefix = prefix + indent + '[\\n';\n                        suffix = suffix + '\\n' + indent + ']';\n                        indent += '\\t';\n                        type = 'array';\n                    }\n                    insertText = prefix + indent + s.bodyText.split('\\n').join('\\n' + indent) + suffix + separatorAfter;\n                    label = label || insertText,\n                        filterText = insertText.replace(/[\\n]/g, ''); // remove new lines\n                }\n                else {\n                    return;\n                }\n                collector.add({\n                    kind: _this.getSuggestionKind(type),\n                    label: label,\n                    documentation: _this.fromMarkup(s.markdownDescription) || s.description,\n                    insertText: insertText,\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    filterText: filterText\n                });\n                hasProposals = true;\n            });\n        }\n        if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items) && arrayDepth < 5 /* beware of recursion */) {\n            this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);\n        }\n    };\n    JSONCompletion.prototype.addEnumValueCompletions = function (schema, separatorAfter, collector) {\n        if (isDefined(schema.const)) {\n            collector.add({\n                kind: this.getSuggestionKind(schema.type),\n                label: this.getLabelForValue(schema.const),\n                insertText: this.getInsertTextForValue(schema.const, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                documentation: this.fromMarkup(schema.markdownDescription) || schema.description\n            });\n        }\n        if (Array.isArray(schema.enum)) {\n            for (var i = 0, length = schema.enum.length; i < length; i++) {\n                var enm = schema.enum[i];\n                var documentation = this.fromMarkup(schema.markdownDescription) || schema.description;\n                if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {\n                    documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);\n                }\n                else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {\n                    documentation = schema.enumDescriptions[i];\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(schema.type),\n                    label: this.getLabelForValue(enm),\n                    insertText: this.getInsertTextForValue(enm, separatorAfter),\n                    insertTextFormat: InsertTextFormat.Snippet,\n                    documentation: documentation\n                });\n            }\n        }\n    };\n    JSONCompletion.prototype.collectTypes = function (schema, types) {\n        if (Array.isArray(schema.enum) || isDefined(schema.const)) {\n            return;\n        }\n        var type = schema.type;\n        if (Array.isArray(type)) {\n            type.forEach(function (t) { return types[t] = true; });\n        }\n        else if (type) {\n            types[type] = true;\n        }\n    };\n    JSONCompletion.prototype.addFillerValueCompletions = function (types, separatorAfter, collector) {\n        if (types['object']) {\n            collector.add({\n                kind: this.getSuggestionKind('object'),\n                label: '{}',\n                insertText: this.getInsertTextForGuessedValue({}, separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: jsonCompletion_localize('defaults.object', 'New object'),\n                documentation: ''\n            });\n        }\n        if (types['array']) {\n            collector.add({\n                kind: this.getSuggestionKind('array'),\n                label: '[]',\n                insertText: this.getInsertTextForGuessedValue([], separatorAfter),\n                insertTextFormat: InsertTextFormat.Snippet,\n                detail: jsonCompletion_localize('defaults.array', 'New array'),\n                documentation: ''\n            });\n        }\n    };\n    JSONCompletion.prototype.addBooleanValueCompletion = function (value, separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('boolean'),\n            label: value ? 'true' : 'false',\n            insertText: this.getInsertTextForValue(value, separatorAfter),\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n        });\n    };\n    JSONCompletion.prototype.addNullValueCompletion = function (separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('null'),\n            label: 'null',\n            insertText: 'null' + separatorAfter,\n            insertTextFormat: InsertTextFormat.Snippet,\n            documentation: ''\n        });\n    };\n    JSONCompletion.prototype.addDollarSchemaCompletions = function (separatorAfter, collector) {\n        var _this = this;\n        var schemaIds = this.schemaService.getRegisteredSchemaIds(function (schema) { return schema === 'http' || schema === 'https'; });\n        schemaIds.forEach(function (schemaId) { return collector.add({\n            kind: main_CompletionItemKind.Module,\n            label: _this.getLabelForValue(schemaId),\n            filterText: _this.getFilterTextForValue(schemaId),\n            insertText: _this.getInsertTextForValue(schemaId, separatorAfter),\n            insertTextFormat: InsertTextFormat.Snippet, documentation: ''\n        }); });\n    };\n    JSONCompletion.prototype.getLabelForValue = function (value) {\n        return JSON.stringify(value);\n    };\n    JSONCompletion.prototype.getFilterTextForValue = function (value) {\n        return JSON.stringify(value);\n    };\n    JSONCompletion.prototype.getFilterTextForSnippetValue = function (value) {\n        return JSON.stringify(value).replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    };\n    JSONCompletion.prototype.getLabelForSnippetValue = function (value) {\n        var label = JSON.stringify(value);\n        return label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    };\n    JSONCompletion.prototype.getInsertTextForPlainText = function (text) {\n        return text.replace(/[\\\\\\$\\}]/g, '\\\\$&'); // escape $, \\ and } \n    };\n    JSONCompletion.prototype.getInsertTextForValue = function (value, separatorAfter) {\n        var text = JSON.stringify(value, null, '\\t');\n        if (text === '{}') {\n            return '{$1}' + separatorAfter;\n        }\n        else if (text === '[]') {\n            return '[$1]' + separatorAfter;\n        }\n        return this.getInsertTextForPlainText(text + separatorAfter);\n    };\n    JSONCompletion.prototype.getInsertTextForSnippetValue = function (value, separatorAfter) {\n        var replacer = function (value) {\n            if (typeof value === 'string') {\n                if (value[0] === '^') {\n                    return value.substr(1);\n                }\n            }\n            return JSON.stringify(value);\n        };\n        return stringifyObject(value, '', replacer) + separatorAfter;\n    };\n    JSONCompletion.prototype.getInsertTextForGuessedValue = function (value, separatorAfter) {\n        switch (typeof value) {\n            case 'object':\n                if (value === null) {\n                    return '${1:null}' + separatorAfter;\n                }\n                return this.getInsertTextForValue(value, separatorAfter);\n            case 'string':\n                var snippetValue = JSON.stringify(value);\n                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes\n                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \\ and }\n                return '\"${1:' + snippetValue + '}\"' + separatorAfter;\n            case 'number':\n            case 'boolean':\n                return '${1:' + JSON.stringify(value) + '}' + separatorAfter;\n        }\n        return this.getInsertTextForValue(value, separatorAfter);\n    };\n    JSONCompletion.prototype.getSuggestionKind = function (type) {\n        if (Array.isArray(type)) {\n            var array = type;\n            type = array.length > 0 ? array[0] : undefined;\n        }\n        if (!type) {\n            return main_CompletionItemKind.Value;\n        }\n        switch (type) {\n            case 'string': return main_CompletionItemKind.Value;\n            case 'object': return main_CompletionItemKind.Module;\n            case 'property': return main_CompletionItemKind.Property;\n            default: return main_CompletionItemKind.Value;\n        }\n    };\n    JSONCompletion.prototype.getLabelTextForMatchingNode = function (node, document) {\n        switch (node.type) {\n            case 'array':\n                return '[]';\n            case 'object':\n                return '{}';\n            default:\n                var content = document.getText().substr(node.offset, node.length);\n                return content;\n        }\n    };\n    JSONCompletion.prototype.getInsertTextForMatchingNode = function (node, document, separatorAfter) {\n        switch (node.type) {\n            case 'array':\n                return this.getInsertTextForValue([], separatorAfter);\n            case 'object':\n                return this.getInsertTextForValue({}, separatorAfter);\n            default:\n                var content = document.getText().substr(node.offset, node.length) + separatorAfter;\n                return this.getInsertTextForPlainText(content);\n        }\n    };\n    JSONCompletion.prototype.getInsertTextForProperty = function (key, propertySchema, addValue, separatorAfter) {\n        var propertyText = this.getInsertTextForValue(key, '');\n        if (!addValue) {\n            return propertyText;\n        }\n        var resultText = propertyText + ': ';\n        var value;\n        var nValueProposals = 0;\n        if (propertySchema) {\n            if (Array.isArray(propertySchema.defaultSnippets)) {\n                if (propertySchema.defaultSnippets.length === 1) {\n                    var body = propertySchema.defaultSnippets[0].body;\n                    if (isDefined(body)) {\n                        value = this.getInsertTextForSnippetValue(body, '');\n                    }\n                }\n                nValueProposals += propertySchema.defaultSnippets.length;\n            }\n            if (propertySchema.enum) {\n                if (!value && propertySchema.enum.length === 1) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');\n                }\n                nValueProposals += propertySchema.enum.length;\n            }\n            if (isDefined(propertySchema.default)) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.default, '');\n                }\n                nValueProposals++;\n            }\n            if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');\n                }\n                nValueProposals += propertySchema.examples.length;\n            }\n            if (nValueProposals === 0) {\n                var type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n                if (!type) {\n                    if (propertySchema.properties) {\n                        type = 'object';\n                    }\n                    else if (propertySchema.items) {\n                        type = 'array';\n                    }\n                }\n                switch (type) {\n                    case 'boolean':\n                        value = '$1';\n                        break;\n                    case 'string':\n                        value = '\"$1\"';\n                        break;\n                    case 'object':\n                        value = '{$1}';\n                        break;\n                    case 'array':\n                        value = '[$1]';\n                        break;\n                    case 'number':\n                    case 'integer':\n                        value = '${1:0}';\n                        break;\n                    case 'null':\n                        value = '${1:null}';\n                        break;\n                    default:\n                        return propertyText;\n                }\n            }\n        }\n        if (!value || nValueProposals > 1) {\n            value = '$1';\n        }\n        return resultText + value + separatorAfter;\n    };\n    JSONCompletion.prototype.getCurrentWord = function (document, offset) {\n        var i = offset - 1;\n        var text = document.getText();\n        while (i >= 0 && ' \\t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\n            i--;\n        }\n        return text.substring(i + 1, offset);\n    };\n    JSONCompletion.prototype.evaluateSeparatorAfter = function (document, offset) {\n        var scanner = main_createScanner(document.getText(), true);\n        scanner.setPosition(offset);\n        var token = scanner.scan();\n        switch (token) {\n            case 5 /* CommaToken */:\n            case 2 /* CloseBraceToken */:\n            case 4 /* CloseBracketToken */:\n            case 17 /* EOF */:\n                return '';\n            default:\n                return ',';\n        }\n    };\n    JSONCompletion.prototype.findItemAtOffset = function (node, document, offset) {\n        var scanner = main_createScanner(document.getText(), true);\n        var children = node.items;\n        for (var i = children.length - 1; i >= 0; i--) {\n            var child = children[i];\n            if (offset > child.offset + child.length) {\n                scanner.setPosition(child.offset + child.length);\n                var token = scanner.scan();\n                if (token === 5 /* CommaToken */ && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {\n                    return i + 1;\n                }\n                return i;\n            }\n            else if (offset >= child.offset) {\n                return i;\n            }\n        }\n        return 0;\n    };\n    JSONCompletion.prototype.isInComment = function (document, start, offset) {\n        var scanner = main_createScanner(document.getText(), false);\n        scanner.setPosition(start);\n        var token = scanner.scan();\n        while (token !== 17 /* EOF */ && (scanner.getTokenOffset() + scanner.getTokenLength() < offset)) {\n            token = scanner.scan();\n        }\n        return (token === 12 /* LineCommentTrivia */ || token === 13 /* BlockCommentTrivia */) && scanner.getTokenOffset() <= offset;\n    };\n    JSONCompletion.prototype.fromMarkup = function (markupString) {\n        if (markupString && this.doesSupportMarkdown()) {\n            return {\n                kind: MarkupKind.Markdown,\n                value: markupString\n            };\n        }\n        return undefined;\n    };\n    JSONCompletion.prototype.doesSupportMarkdown = function () {\n        if (!isDefined(this.supportsMarkdown)) {\n            var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;\n            this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    };\n    JSONCompletion.prototype.doesSupportsCommitCharacters = function () {\n        if (!isDefined(this.supportsCommitCharacters)) {\n            var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;\n            this.supportsCommitCharacters = completion && completion.completionItem && !!completion.completionItem.commitCharactersSupport;\n        }\n        return this.supportsCommitCharacters;\n    };\n    return JSONCompletion;\n}());\n\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonHover.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nvar JSONHover = /** @class */ (function () {\n    function JSONHover(schemaService, contributions, promiseConstructor) {\n        if (contributions === void 0) { contributions = []; }\n        this.schemaService = schemaService;\n        this.contributions = contributions;\n        this.promise = promiseConstructor || Promise;\n    }\n    JSONHover.prototype.doHover = function (document, position, doc) {\n        var offset = document.offsetAt(position);\n        var node = doc.getNodeFromOffset(offset);\n        if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {\n            return this.promise.resolve(null);\n        }\n        var hoverRangeNode = node;\n        // use the property description when hovering over an object key\n        if (node.type === 'string') {\n            var parent = node.parent;\n            if (parent && parent.type === 'property' && parent.keyNode === node) {\n                node = parent.valueNode;\n                if (!node) {\n                    return this.promise.resolve(null);\n                }\n            }\n        }\n        var hoverRange = main_Range.create(document.positionAt(hoverRangeNode.offset), document.positionAt(hoverRangeNode.offset + hoverRangeNode.length));\n        var createHover = function (contents) {\n            var result = {\n                contents: contents,\n                range: hoverRange\n            };\n            return result;\n        };\n        var location = jsonParser_getNodePath(node);\n        for (var i = this.contributions.length - 1; i >= 0; i--) {\n            var contribution = this.contributions[i];\n            var promise = contribution.getInfoContribution(document.uri, location);\n            if (promise) {\n                return promise.then(function (htmlContent) { return createHover(htmlContent); });\n            }\n        }\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n            if (schema && node) {\n                var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n                var title_1 = undefined;\n                var markdownDescription_1 = undefined;\n                var markdownEnumValueDescription_1 = undefined, enumValue_1 = undefined;\n                matchingSchemas.every(function (s) {\n                    if (s.node === node && !s.inverted && s.schema) {\n                        title_1 = title_1 || s.schema.title;\n                        markdownDescription_1 = markdownDescription_1 || s.schema.markdownDescription || toMarkdown(s.schema.description);\n                        if (s.schema.enum) {\n                            var idx = s.schema.enum.indexOf(jsonParser_getNodeValue(node));\n                            if (s.schema.markdownEnumDescriptions) {\n                                markdownEnumValueDescription_1 = s.schema.markdownEnumDescriptions[idx];\n                            }\n                            else if (s.schema.enumDescriptions) {\n                                markdownEnumValueDescription_1 = toMarkdown(s.schema.enumDescriptions[idx]);\n                            }\n                            if (markdownEnumValueDescription_1) {\n                                enumValue_1 = s.schema.enum[idx];\n                                if (typeof enumValue_1 !== 'string') {\n                                    enumValue_1 = JSON.stringify(enumValue_1);\n                                }\n                            }\n                        }\n                    }\n                    return true;\n                });\n                var result = '';\n                if (title_1) {\n                    result = toMarkdown(title_1);\n                }\n                if (markdownDescription_1) {\n                    if (result.length > 0) {\n                        result += \"\\n\\n\";\n                    }\n                    result += markdownDescription_1;\n                }\n                if (markdownEnumValueDescription_1) {\n                    if (result.length > 0) {\n                        result += \"\\n\\n\";\n                    }\n                    result += \"`\" + toMarkdownCodeBlock(enumValue_1) + \"`: \" + markdownEnumValueDescription_1;\n                }\n                return createHover([result]);\n            }\n            return null;\n        });\n    };\n    return JSONHover;\n}());\n\nfunction toMarkdown(plain) {\n    if (plain) {\n        var res = plain.replace(/([^\\n\\r])(\\r?\\n)([^\\n\\r])/gm, '$1\\n\\n$3'); // single new lines to \\n\\n (Markdown paragraph)\n        return res.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    return undefined;\n}\nfunction toMarkdownCodeBlock(content) {\n    // see https://daringfireball.net/projects/markdown/syntax#precode\n    if (content.indexOf('`') !== -1) {\n        return '`` ' + content + ' ``';\n    }\n    return content;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-uri/index.js\nvar LIB;LIB=(()=>{\"use strict\";var t={470:t=>{function e(t){if(\"string\"!=typeof t)throw new TypeError(\"Path must be a string. Received \"+JSON.stringify(t))}function r(t,e){for(var r,n=\"\",o=0,i=-1,a=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(i===h-1||1===a);else if(i!==h-1&&2===a){if(n.length<2||2!==o||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var s=n.lastIndexOf(\"/\");if(s!==n.length-1){-1===s?(n=\"\",o=0):o=(n=n.slice(0,s)).length-1-n.lastIndexOf(\"/\"),i=h,a=0;continue}}else if(2===n.length||1===n.length){n=\"\",o=0,i=h,a=0;continue}e&&(n.length>0?n+=\"/..\":n=\"..\",o=2)}else n.length>0?n+=\"/\"+t.slice(i+1,h):n=t.slice(i+1,h),o=h-i-1;i=h,a=0}else 46===r&&-1!==a?++a:a=-1}return n}var n={resolve:function(){for(var t,n=\"\",o=!1,i=arguments.length-1;i>=-1&&!o;i--){var a;i>=0?a=arguments[i]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(n=a+\"/\"+n,o=47===a.charCodeAt(0))}return n=r(n,!o),o?n.length>0?\"/\"+n:\"/\":n.length>0?n:\".\"},normalize:function(t){if(e(t),0===t.length)return\".\";var n=47===t.charCodeAt(0),o=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=\".\"),t.length>0&&o&&(t+=\"/\"),n?\"/\"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return\".\";for(var t,r=0;r<arguments.length;++r){var o=arguments[r];e(o),o.length>0&&(void 0===t?t=o:t+=\"/\"+o)}return void 0===t?\".\":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return\"\";if((t=n.resolve(t))===(r=n.resolve(r)))return\"\";for(var o=1;o<t.length&&47===t.charCodeAt(o);++o);for(var i=t.length,a=i-o,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var s=r.length-h,f=a<s?a:s,u=-1,c=0;c<=f;++c){if(c===f){if(s>f){if(47===r.charCodeAt(h+c))return r.slice(h+c+1);if(0===c)return r.slice(h+c)}else a>f&&(47===t.charCodeAt(o+c)?u=c:0===c&&(u=0));break}var l=t.charCodeAt(o+c);if(l!==r.charCodeAt(h+c))break;47===l&&(u=c)}var p=\"\";for(c=o+u+1;c<=i;++c)c!==i&&47!==t.charCodeAt(c)||(0===p.length?p+=\"..\":p+=\"/..\");return p.length>0?p+r.slice(h+u):(h+=u,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return\".\";for(var r=t.charCodeAt(0),n=47===r,o=-1,i=!0,a=t.length-1;a>=1;--a)if(47===(r=t.charCodeAt(a))){if(!i){o=a;break}}else i=!1;return-1===o?n?\"/\":\".\":n&&1===o?\"//\":t.slice(0,o)},basename:function(t,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError('\"ext\" argument must be a string');e(t);var n,o=0,i=-1,a=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return\"\";var h=r.length-1,s=-1;for(n=t.length-1;n>=0;--n){var f=t.charCodeAt(n);if(47===f){if(!a){o=n+1;break}}else-1===s&&(a=!1,s=n+1),h>=0&&(f===r.charCodeAt(h)?-1==--h&&(i=n):(h=-1,i=s))}return o===i?i=s:-1===i&&(i=t.length),t.slice(o,i)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!a){o=n+1;break}}else-1===i&&(a=!1,i=n+1);return-1===i?\"\":t.slice(o,i)},extname:function(t){e(t);for(var r=-1,n=0,o=-1,i=!0,a=0,h=t.length-1;h>=0;--h){var s=t.charCodeAt(h);if(47!==s)-1===o&&(i=!1,o=h+1),46===s?-1===r?r=h:1!==a&&(a=1):-1!==r&&(a=-1);else if(!i){n=h+1;break}}return-1===r||-1===o||0===a||1===a&&r===o-1&&r===n+1?\"\":t.slice(r,o)},format:function(t){if(null===t||\"object\"!=typeof t)throw new TypeError('The \"pathObject\" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||\"\")+(e.ext||\"\");return r?r===e.root?r+n:r+\"/\"+n:n}(0,t)},parse:function(t){e(t);var r={root:\"\",dir:\"\",base:\"\",ext:\"\",name:\"\"};if(0===t.length)return r;var n,o=t.charCodeAt(0),i=47===o;i?(r.root=\"/\",n=1):n=0;for(var a=-1,h=0,s=-1,f=!0,u=t.length-1,c=0;u>=n;--u)if(47!==(o=t.charCodeAt(u)))-1===s&&(f=!1,s=u+1),46===o?-1===a?a=u:1!==c&&(c=1):-1!==a&&(c=-1);else if(!f){h=u+1;break}return-1===a||-1===s||0===c||1===c&&a===s-1&&a===h+1?-1!==s&&(r.base=r.name=0===h&&i?t.slice(1,s):t.slice(h,s)):(0===h&&i?(r.name=t.slice(1,a),r.base=t.slice(1,s)):(r.name=t.slice(h,a),r.base=t.slice(h,s)),r.ext=t.slice(a,s)),h>0?r.dir=t.slice(0,h-1):i&&(r.dir=\"/\"),r},sep:\"/\",delimiter:\":\",win32:null,posix:null};n.posix=n,t.exports=n},447:(t,e,r)=>{var n;if(r.r(e),r.d(e,{URI:()=>g,Utils:()=>O}),\"object\"==typeof process)n=\"win32\"===process.platform;else if(\"object\"==typeof navigator){var o=navigator.userAgent;n=o.indexOf(\"Windows\")>=0}var i,a,h=(i=function(t,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(t,e)},function(t,e){function r(){this.constructor=t}i(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}),s=/^\\w[\\w\\d+.-]*$/,f=/^\\//,u=/^\\/\\//,c=\"\",l=\"/\",p=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/,g=function(){function t(t,e,r,n,o,i){void 0===i&&(i=!1),\"object\"==typeof t?(this.scheme=t.scheme||c,this.authority=t.authority||c,this.path=t.path||c,this.query=t.query||c,this.fragment=t.fragment||c):(this.scheme=function(t,e){return t||e?t:\"file\"}(t,i),this.authority=e||c,this.path=function(t,e){switch(t){case\"https\":case\"http\":case\"file\":e?e[0]!==l&&(e=l+e):e=l}return e}(this.scheme,r||c),this.query=n||c,this.fragment=o||c,function(t,e){if(!t.scheme&&e)throw new Error('[UriError]: Scheme is missing: {scheme: \"\", authority: \"'+t.authority+'\", path: \"'+t.path+'\", query: \"'+t.query+'\", fragment: \"'+t.fragment+'\"}');if(t.scheme&&!s.test(t.scheme))throw new Error(\"[UriError]: Scheme contains illegal characters.\");if(t.path)if(t.authority){if(!f.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character')}else if(u.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")')}(this,i))}return t.isUri=function(e){return e instanceof t||!!e&&\"string\"==typeof e.authority&&\"string\"==typeof e.fragment&&\"string\"==typeof e.path&&\"string\"==typeof e.query&&\"string\"==typeof e.scheme&&\"function\"==typeof e.fsPath&&\"function\"==typeof e.with&&\"function\"==typeof e.toString},Object.defineProperty(t.prototype,\"fsPath\",{get:function(){return C(this,!1)},enumerable:!1,configurable:!0}),t.prototype.with=function(t){if(!t)return this;var e=t.scheme,r=t.authority,n=t.path,o=t.query,i=t.fragment;return void 0===e?e=this.scheme:null===e&&(e=c),void 0===r?r=this.authority:null===r&&(r=c),void 0===n?n=this.path:null===n&&(n=c),void 0===o?o=this.query:null===o&&(o=c),void 0===i?i=this.fragment:null===i&&(i=c),e===this.scheme&&r===this.authority&&n===this.path&&o===this.query&&i===this.fragment?this:new v(e,r,n,o,i)},t.parse=function(t,e){void 0===e&&(e=!1);var r=p.exec(t);return r?new v(r[2]||c,x(r[4]||c),x(r[5]||c),x(r[7]||c),x(r[9]||c),e):new v(c,c,c,c,c)},t.file=function(t){var e=c;if(n&&(t=t.replace(/\\\\/g,l)),t[0]===l&&t[1]===l){var r=t.indexOf(l,2);-1===r?(e=t.substring(2),t=l):(e=t.substring(2,r),t=t.substring(r)||l)}return new v(\"file\",e,t,c,c)},t.from=function(t){return new v(t.scheme,t.authority,t.path,t.query,t.fragment)},t.prototype.toString=function(t){return void 0===t&&(t=!1),A(this,t)},t.prototype.toJSON=function(){return this},t.revive=function(e){if(e){if(e instanceof t)return e;var r=new v(e);return r._formatted=e.external,r._fsPath=e._sep===d?e.fsPath:null,r}return e},t}(),d=n?1:void 0,v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._formatted=null,e._fsPath=null,e}return h(e,t),Object.defineProperty(e.prototype,\"fsPath\",{get:function(){return this._fsPath||(this._fsPath=C(this,!1)),this._fsPath},enumerable:!1,configurable:!0}),e.prototype.toString=function(t){return void 0===t&&(t=!1),t?A(this,!0):(this._formatted||(this._formatted=A(this,!1)),this._formatted)},e.prototype.toJSON=function(){var t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=d),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t},e}(g),m=((a={})[58]=\"%3A\",a[47]=\"%2F\",a[63]=\"%3F\",a[35]=\"%23\",a[91]=\"%5B\",a[93]=\"%5D\",a[64]=\"%40\",a[33]=\"%21\",a[36]=\"%24\",a[38]=\"%26\",a[39]=\"%27\",a[40]=\"%28\",a[41]=\"%29\",a[42]=\"%2A\",a[43]=\"%2B\",a[44]=\"%2C\",a[59]=\"%3B\",a[61]=\"%3D\",a[32]=\"%20\",a);function y(t,e){for(var r=void 0,n=-1,o=0;o<t.length;o++){var i=t.charCodeAt(o);if(i>=97&&i<=122||i>=65&&i<=90||i>=48&&i<=57||45===i||46===i||95===i||126===i||e&&47===i)-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),void 0!==r&&(r+=t.charAt(o));else{void 0===r&&(r=t.substr(0,o));var a=m[i];void 0!==a?(-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),r+=a):-1===n&&(n=o)}}return-1!==n&&(r+=encodeURIComponent(t.substring(n))),void 0!==r?r:t}function b(t){for(var e=void 0,r=0;r<t.length;r++){var n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=m[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function C(t,e){var r;return r=t.authority&&t.path.length>1&&\"file\"===t.scheme?\"//\"+t.authority+t.path:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n&&(r=r.replace(/\\//g,\"\\\\\")),r}function A(t,e){var r=e?b:y,n=\"\",o=t.scheme,i=t.authority,a=t.path,h=t.query,s=t.fragment;if(o&&(n+=o,n+=\":\"),(i||\"file\"===o)&&(n+=l,n+=l),i){var f=i.indexOf(\"@\");if(-1!==f){var u=i.substr(0,f);i=i.substr(f+1),-1===(f=u.indexOf(\":\"))?n+=r(u,!1):(n+=r(u.substr(0,f),!1),n+=\":\",n+=r(u.substr(f+1),!1)),n+=\"@\"}-1===(f=(i=i.toLowerCase()).indexOf(\":\"))?n+=r(i,!1):(n+=r(i.substr(0,f),!1),n+=i.substr(f))}if(a){if(a.length>=3&&47===a.charCodeAt(0)&&58===a.charCodeAt(2))(c=a.charCodeAt(1))>=65&&c<=90&&(a=\"/\"+String.fromCharCode(c+32)+\":\"+a.substr(3));else if(a.length>=2&&58===a.charCodeAt(1)){var c;(c=a.charCodeAt(0))>=65&&c<=90&&(a=String.fromCharCode(c+32)+\":\"+a.substr(2))}n+=r(a,!0)}return h&&(n+=\"?\",n+=r(h,!1)),s&&(n+=\"#\",n+=e?s:y(s,!1)),n}function w(t){try{return decodeURIComponent(t)}catch(e){return t.length>3?t.substr(0,3)+w(t.substr(3)):t}}var _=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function x(t){return t.match(_)?t.replace(_,(function(t){return w(t)})):t}var O,P=r(470),j=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),o=0;for(e=0;e<r;e++)for(var i=arguments[e],a=0,h=i.length;a<h;a++,o++)n[o]=i[a];return n},U=P.posix||P;!function(t){t.joinPath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return t.with({path:U.join.apply(U,j([t.path],e))})},t.resolvePath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var n=t.path||\"/\";return t.with({path:U.resolve.apply(U,j([n],e))})},t.dirname=function(t){var e=U.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)?t:t.with({path:e})},t.basename=function(t){return U.basename(t.path)},t.extname=function(t){return U.extname(t.path)}}(O||(O={}))}},e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}return r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},r(447)})();const{URI: vscode_uri_URI,Utils}=LIB;\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/glob.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Copyright (c) 2013, Nick Fitzgerald\n *  Licensed under the MIT License. See LICENCE.md in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction createRegex(glob, opts) {\n    if (typeof glob !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    var str = String(glob);\n    // The regexp we are building, as a string.\n    var reStr = \"\";\n    // Whether we are matching so called \"extended\" globs (like bash) and should\n    // support single character matching, matching ranges of characters, group\n    // matching, etc.\n    var extended = opts ? !!opts.extended : false;\n    // When globstar is _false_ (default), '/foo/*' is translated a regexp like\n    // '^\\/foo\\/.*$' which will match any string beginning with '/foo/'\n    // When globstar is _true_, '/foo/*' is translated to regexp like\n    // '^\\/foo\\/[^/]*$' which will match any string beginning with '/foo/' BUT\n    // which does not have a '/' to the right of it.\n    // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but\n    // these will not '/foo/bar/baz', '/foo/bar/baz.txt'\n    // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when\n    // globstar is _false_\n    var globstar = opts ? !!opts.globstar : false;\n    // If we are doing extended matching, this boolean is true when we are inside\n    // a group (eg {*.html,*.js}), and false otherwise.\n    var inGroup = false;\n    // RegExp flags (eg \"i\" ) to pass in to RegExp constructor.\n    var flags = opts && typeof (opts.flags) === \"string\" ? opts.flags : \"\";\n    var c;\n    for (var i = 0, len = str.length; i < len; i++) {\n        c = str[i];\n        switch (c) {\n            case \"/\":\n            case \"$\":\n            case \"^\":\n            case \"+\":\n            case \".\":\n            case \"(\":\n            case \")\":\n            case \"=\":\n            case \"!\":\n            case \"|\":\n                reStr += \"\\\\\" + c;\n                break;\n            case \"?\":\n                if (extended) {\n                    reStr += \".\";\n                    break;\n                }\n            case \"[\":\n            case \"]\":\n                if (extended) {\n                    reStr += c;\n                    break;\n                }\n            case \"{\":\n                if (extended) {\n                    inGroup = true;\n                    reStr += \"(\";\n                    break;\n                }\n            case \"}\":\n                if (extended) {\n                    inGroup = false;\n                    reStr += \")\";\n                    break;\n                }\n            case \",\":\n                if (inGroup) {\n                    reStr += \"|\";\n                    break;\n                }\n                reStr += \"\\\\\" + c;\n                break;\n            case \"*\":\n                // Move over all consecutive \"*\"'s.\n                // Also store the previous and next characters\n                var prevChar = str[i - 1];\n                var starCount = 1;\n                while (str[i + 1] === \"*\") {\n                    starCount++;\n                    i++;\n                }\n                var nextChar = str[i + 1];\n                if (!globstar) {\n                    // globstar is disabled, so treat any number of \"*\" as one\n                    reStr += \".*\";\n                }\n                else {\n                    // globstar is enabled, so determine if this is a globstar segment\n                    var isGlobstar = starCount > 1 // multiple \"*\"'s\n                        && (prevChar === \"/\" || prevChar === undefined || prevChar === '{' || prevChar === ',') // from the start of the segment\n                        && (nextChar === \"/\" || nextChar === undefined || nextChar === ',' || nextChar === '}'); // to the end of the segment\n                    if (isGlobstar) {\n                        if (nextChar === \"/\") {\n                            i++; // move over the \"/\"\n                        }\n                        else if (prevChar === '/' && reStr.endsWith('\\\\/')) {\n                            reStr = reStr.substr(0, reStr.length - 2);\n                        }\n                        // it's a globstar, so match zero or more path segments\n                        reStr += \"((?:[^/]*(?:\\/|$))*)\";\n                    }\n                    else {\n                        // it's not a globstar, so only match one path segment\n                        reStr += \"([^/]*)\";\n                    }\n                }\n                break;\n            default:\n                reStr += c;\n        }\n    }\n    // When regexp 'g' flag is specified don't\n    // constrain the regular expression with ^ & $\n    if (!flags || !~flags.indexOf('g')) {\n        reStr = \"^\" + reStr + \"$\";\n    }\n    return new RegExp(reStr, flags);\n}\n;\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonSchemaService.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nvar jsonSchemaService_localize = loadMessageBundle();\nvar BANG = '!';\nvar PATH_SEP = '/';\nvar FilePatternAssociation = /** @class */ (function () {\n    function FilePatternAssociation(pattern, uris) {\n        this.globWrappers = [];\n        try {\n            for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n                var patternString = pattern_1[_i];\n                var include = patternString[0] !== BANG;\n                if (!include) {\n                    patternString = patternString.substring(1);\n                }\n                if (patternString.length > 0) {\n                    if (patternString[0] === PATH_SEP) {\n                        patternString = patternString.substring(1);\n                    }\n                    this.globWrappers.push({\n                        regexp: createRegex('**/' + patternString, { extended: true, globstar: true }),\n                        include: include,\n                    });\n                }\n            }\n            ;\n            this.uris = uris;\n        }\n        catch (e) {\n            this.globWrappers.length = 0;\n            this.uris = [];\n        }\n    }\n    FilePatternAssociation.prototype.matchesPattern = function (fileName) {\n        var match = false;\n        for (var _i = 0, _a = this.globWrappers; _i < _a.length; _i++) {\n            var _b = _a[_i], regexp = _b.regexp, include = _b.include;\n            if (regexp.test(fileName)) {\n                match = include;\n            }\n        }\n        return match;\n    };\n    FilePatternAssociation.prototype.getURIs = function () {\n        return this.uris;\n    };\n    return FilePatternAssociation;\n}());\nvar SchemaHandle = /** @class */ (function () {\n    function SchemaHandle(service, url, unresolvedSchemaContent) {\n        this.service = service;\n        this.url = url;\n        this.dependencies = {};\n        if (unresolvedSchemaContent) {\n            this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\n        }\n    }\n    SchemaHandle.prototype.getUnresolvedSchema = function () {\n        if (!this.unresolvedSchema) {\n            this.unresolvedSchema = this.service.loadSchema(this.url);\n        }\n        return this.unresolvedSchema;\n    };\n    SchemaHandle.prototype.getResolvedSchema = function () {\n        var _this = this;\n        if (!this.resolvedSchema) {\n            this.resolvedSchema = this.getUnresolvedSchema().then(function (unresolved) {\n                return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);\n            });\n        }\n        return this.resolvedSchema;\n    };\n    SchemaHandle.prototype.clearSchema = function () {\n        this.resolvedSchema = undefined;\n        this.unresolvedSchema = undefined;\n        this.dependencies = {};\n    };\n    return SchemaHandle;\n}());\nvar UnresolvedSchema = /** @class */ (function () {\n    function UnresolvedSchema(schema, errors) {\n        if (errors === void 0) { errors = []; }\n        this.schema = schema;\n        this.errors = errors;\n    }\n    return UnresolvedSchema;\n}());\n\nvar ResolvedSchema = /** @class */ (function () {\n    function ResolvedSchema(schema, errors) {\n        if (errors === void 0) { errors = []; }\n        this.schema = schema;\n        this.errors = errors;\n    }\n    ResolvedSchema.prototype.getSection = function (path) {\n        var schemaRef = this.getSectionRecursive(path, this.schema);\n        if (schemaRef) {\n            return asSchema(schemaRef);\n        }\n        return undefined;\n    };\n    ResolvedSchema.prototype.getSectionRecursive = function (path, schema) {\n        if (!schema || typeof schema === 'boolean' || path.length === 0) {\n            return schema;\n        }\n        var next = path.shift();\n        if (schema.properties && typeof schema.properties[next]) {\n            return this.getSectionRecursive(path, schema.properties[next]);\n        }\n        else if (schema.patternProperties) {\n            for (var _i = 0, _a = Object.keys(schema.patternProperties); _i < _a.length; _i++) {\n                var pattern = _a[_i];\n                var regex = extendedRegExp(pattern);\n                if (regex.test(next)) {\n                    return this.getSectionRecursive(path, schema.patternProperties[pattern]);\n                }\n            }\n        }\n        else if (typeof schema.additionalProperties === 'object') {\n            return this.getSectionRecursive(path, schema.additionalProperties);\n        }\n        else if (next.match('[0-9]+')) {\n            if (Array.isArray(schema.items)) {\n                var index = parseInt(next, 10);\n                if (!isNaN(index) && schema.items[index]) {\n                    return this.getSectionRecursive(path, schema.items[index]);\n                }\n            }\n            else if (schema.items) {\n                return this.getSectionRecursive(path, schema.items);\n            }\n        }\n        return undefined;\n    };\n    return ResolvedSchema;\n}());\n\nvar JSONSchemaService = /** @class */ (function () {\n    function JSONSchemaService(requestService, contextService, promiseConstructor) {\n        this.contextService = contextService;\n        this.requestService = requestService;\n        this.promiseConstructor = promiseConstructor || Promise;\n        this.callOnDispose = [];\n        this.contributionSchemas = {};\n        this.contributionAssociations = [];\n        this.schemasById = {};\n        this.filePatternAssociations = [];\n        this.registeredSchemasIds = {};\n    }\n    JSONSchemaService.prototype.getRegisteredSchemaIds = function (filter) {\n        return Object.keys(this.registeredSchemasIds).filter(function (id) {\n            var scheme = vscode_uri_URI.parse(id).scheme;\n            return scheme !== 'schemaservice' && (!filter || filter(scheme));\n        });\n    };\n    Object.defineProperty(JSONSchemaService.prototype, \"promise\", {\n        get: function () {\n            return this.promiseConstructor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    JSONSchemaService.prototype.dispose = function () {\n        while (this.callOnDispose.length > 0) {\n            this.callOnDispose.pop()();\n        }\n    };\n    JSONSchemaService.prototype.onResourceChange = function (uri) {\n        var _this = this;\n        var hasChanges = false;\n        uri = normalizeId(uri);\n        var toWalk = [uri];\n        var all = Object.keys(this.schemasById).map(function (key) { return _this.schemasById[key]; });\n        while (toWalk.length) {\n            var curr = toWalk.pop();\n            for (var i = 0; i < all.length; i++) {\n                var handle = all[i];\n                if (handle && (handle.url === curr || handle.dependencies[curr])) {\n                    if (handle.url !== curr) {\n                        toWalk.push(handle.url);\n                    }\n                    handle.clearSchema();\n                    all[i] = undefined;\n                    hasChanges = true;\n                }\n            }\n        }\n        return hasChanges;\n    };\n    JSONSchemaService.prototype.setSchemaContributions = function (schemaContributions) {\n        if (schemaContributions.schemas) {\n            var schemas = schemaContributions.schemas;\n            for (var id in schemas) {\n                var normalizedId = normalizeId(id);\n                this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\n            }\n        }\n        if (Array.isArray(schemaContributions.schemaAssociations)) {\n            var schemaAssociations = schemaContributions.schemaAssociations;\n            for (var _i = 0, schemaAssociations_1 = schemaAssociations; _i < schemaAssociations_1.length; _i++) {\n                var schemaAssociation = schemaAssociations_1[_i];\n                var uris = schemaAssociation.uris.map(normalizeId);\n                var association = this.addFilePatternAssociation(schemaAssociation.pattern, uris);\n                this.contributionAssociations.push(association);\n            }\n        }\n    };\n    JSONSchemaService.prototype.addSchemaHandle = function (id, unresolvedSchemaContent) {\n        var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\n        this.schemasById[id] = schemaHandle;\n        return schemaHandle;\n    };\n    JSONSchemaService.prototype.getOrAddSchemaHandle = function (id, unresolvedSchemaContent) {\n        return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\n    };\n    JSONSchemaService.prototype.addFilePatternAssociation = function (pattern, uris) {\n        var fpa = new FilePatternAssociation(pattern, uris);\n        this.filePatternAssociations.push(fpa);\n        return fpa;\n    };\n    JSONSchemaService.prototype.registerExternalSchema = function (uri, filePatterns, unresolvedSchemaContent) {\n        var id = normalizeId(uri);\n        this.registeredSchemasIds[id] = true;\n        this.cachedSchemaForResource = undefined;\n        if (filePatterns) {\n            this.addFilePatternAssociation(filePatterns, [uri]);\n        }\n        return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);\n    };\n    JSONSchemaService.prototype.clearExternalSchemas = function () {\n        this.schemasById = {};\n        this.filePatternAssociations = [];\n        this.registeredSchemasIds = {};\n        this.cachedSchemaForResource = undefined;\n        for (var id in this.contributionSchemas) {\n            this.schemasById[id] = this.contributionSchemas[id];\n            this.registeredSchemasIds[id] = true;\n        }\n        for (var _i = 0, _a = this.contributionAssociations; _i < _a.length; _i++) {\n            var contributionAssociation = _a[_i];\n            this.filePatternAssociations.push(contributionAssociation);\n        }\n    };\n    JSONSchemaService.prototype.getResolvedSchema = function (schemaId) {\n        var id = normalizeId(schemaId);\n        var schemaHandle = this.schemasById[id];\n        if (schemaHandle) {\n            return schemaHandle.getResolvedSchema();\n        }\n        return this.promise.resolve(undefined);\n    };\n    JSONSchemaService.prototype.loadSchema = function (url) {\n        if (!this.requestService) {\n            var errorMessage = jsonSchemaService_localize('json.schema.norequestservice', 'Unable to load schema from \\'{0}\\'. No schema request service available', toDisplayString(url));\n            return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\n        }\n        return this.requestService(url).then(function (content) {\n            if (!content) {\n                var errorMessage = jsonSchemaService_localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': No content.', toDisplayString(url));\n                return new UnresolvedSchema({}, [errorMessage]);\n            }\n            var schemaContent = {};\n            var jsonErrors = [];\n            schemaContent = main_parse(content, jsonErrors);\n            var errors = jsonErrors.length ? [jsonSchemaService_localize('json.schema.invalidFormat', 'Unable to parse content from \\'{0}\\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset)] : [];\n            return new UnresolvedSchema(schemaContent, errors);\n        }, function (error) {\n            var errorMessage = error.toString();\n            var errorSplit = error.toString().split('Error: ');\n            if (errorSplit.length > 1) {\n                // more concise error message, URL and context are attached by caller anyways\n                errorMessage = errorSplit[1];\n            }\n            if (endsWith(errorMessage, '.')) {\n                errorMessage = errorMessage.substr(0, errorMessage.length - 1);\n            }\n            return new UnresolvedSchema({}, [jsonSchemaService_localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': {1}.', toDisplayString(url), errorMessage)]);\n        });\n    };\n    JSONSchemaService.prototype.resolveSchemaContent = function (schemaToResolve, schemaURL, dependencies) {\n        var _this = this;\n        var resolveErrors = schemaToResolve.errors.slice(0);\n        var schema = schemaToResolve.schema;\n        if (schema.$schema) {\n            var id = normalizeId(schema.$schema);\n            if (id === 'http://json-schema.org/draft-03/schema') {\n                return this.promise.resolve(new ResolvedSchema({}, [jsonSchemaService_localize('json.schema.draft03.notsupported', \"Draft-03 schemas are not supported.\")]));\n            }\n            else if (id === 'https://json-schema.org/draft/2019-09/schema') {\n                resolveErrors.push(jsonSchemaService_localize('json.schema.draft201909.notsupported', \"Draft 2019-09 schemas are not yet fully supported.\"));\n            }\n        }\n        var contextService = this.contextService;\n        var findSection = function (schema, path) {\n            if (!path) {\n                return schema;\n            }\n            var current = schema;\n            if (path[0] === '/') {\n                path = path.substr(1);\n            }\n            path.split('/').some(function (part) {\n                part = part.replace(/~1/g, '/').replace(/~0/g, '~');\n                current = current[part];\n                return !current;\n            });\n            return current;\n        };\n        var merge = function (target, sourceRoot, sourceURI, refSegment) {\n            var path = refSegment ? decodeURIComponent(refSegment) : undefined;\n            var section = findSection(sourceRoot, path);\n            if (section) {\n                for (var key in section) {\n                    if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n                        target[key] = section[key];\n                    }\n                }\n            }\n            else {\n                resolveErrors.push(jsonSchemaService_localize('json.schema.invalidref', '$ref \\'{0}\\' in \\'{1}\\' can not be resolved.', path, sourceURI));\n            }\n        };\n        var resolveExternalLink = function (node, uri, refSegment, parentSchemaURL, parentSchemaDependencies) {\n            if (contextService && !/^[A-Za-z][A-Za-z0-9+\\-.+]*:\\/\\/.*/.test(uri)) {\n                uri = contextService.resolveRelativePath(uri, parentSchemaURL);\n            }\n            uri = normalizeId(uri);\n            var referencedHandle = _this.getOrAddSchemaHandle(uri);\n            return referencedHandle.getUnresolvedSchema().then(function (unresolvedSchema) {\n                parentSchemaDependencies[uri] = true;\n                if (unresolvedSchema.errors.length) {\n                    var loc = refSegment ? uri + '#' + refSegment : uri;\n                    resolveErrors.push(jsonSchemaService_localize('json.schema.problemloadingref', 'Problems loading reference \\'{0}\\': {1}', loc, unresolvedSchema.errors[0]));\n                }\n                merge(node, unresolvedSchema.schema, uri, refSegment);\n                return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);\n            });\n        };\n        var resolveRefs = function (node, parentSchema, parentSchemaURL, parentSchemaDependencies) {\n            if (!node || typeof node !== 'object') {\n                return Promise.resolve(null);\n            }\n            var toWalk = [node];\n            var seen = [];\n            var openPromises = [];\n            var collectEntries = function () {\n                var entries = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    entries[_i] = arguments[_i];\n                }\n                for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {\n                    var entry = entries_1[_a];\n                    if (typeof entry === 'object') {\n                        toWalk.push(entry);\n                    }\n                }\n            };\n            var collectMapEntries = function () {\n                var maps = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    maps[_i] = arguments[_i];\n                }\n                for (var _a = 0, maps_1 = maps; _a < maps_1.length; _a++) {\n                    var map = maps_1[_a];\n                    if (typeof map === 'object') {\n                        for (var k in map) {\n                            var key = k;\n                            var entry = map[key];\n                            if (typeof entry === 'object') {\n                                toWalk.push(entry);\n                            }\n                        }\n                    }\n                }\n            };\n            var collectArrayEntries = function () {\n                var arrays = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    arrays[_i] = arguments[_i];\n                }\n                for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {\n                    var array = arrays_1[_a];\n                    if (Array.isArray(array)) {\n                        for (var _b = 0, array_1 = array; _b < array_1.length; _b++) {\n                            var entry = array_1[_b];\n                            if (typeof entry === 'object') {\n                                toWalk.push(entry);\n                            }\n                        }\n                    }\n                }\n            };\n            var handleRef = function (next) {\n                var seenRefs = [];\n                while (next.$ref) {\n                    var ref = next.$ref;\n                    var segments = ref.split('#', 2);\n                    delete next.$ref;\n                    if (segments[0].length > 0) {\n                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));\n                        return;\n                    }\n                    else {\n                        if (seenRefs.indexOf(ref) === -1) {\n                            merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle\n                            seenRefs.push(ref);\n                        }\n                    }\n                }\n                collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);\n                collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);\n                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);\n            };\n            while (toWalk.length) {\n                var next = toWalk.pop();\n                if (seen.indexOf(next) >= 0) {\n                    continue;\n                }\n                seen.push(next);\n                handleRef(next);\n            }\n            return _this.promise.all(openPromises);\n        };\n        return resolveRefs(schema, schema, schemaURL, dependencies).then(function (_) { return new ResolvedSchema(schema, resolveErrors); });\n    };\n    JSONSchemaService.prototype.getSchemaForResource = function (resource, document) {\n        // first use $schema if present\n        if (document && document.root && document.root.type === 'object') {\n            var schemaProperties = document.root.properties.filter(function (p) { return (p.keyNode.value === '$schema') && p.valueNode && p.valueNode.type === 'string'; });\n            if (schemaProperties.length > 0) {\n                var valueNode = schemaProperties[0].valueNode;\n                if (valueNode && valueNode.type === 'string') {\n                    var schemeId = jsonParser_getNodeValue(valueNode);\n                    if (schemeId && startsWith(schemeId, '.') && this.contextService) {\n                        schemeId = this.contextService.resolveRelativePath(schemeId, resource);\n                    }\n                    if (schemeId) {\n                        var id = normalizeId(schemeId);\n                        return this.getOrAddSchemaHandle(id).getResolvedSchema();\n                    }\n                }\n            }\n        }\n        if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {\n            return this.cachedSchemaForResource.resolvedSchema;\n        }\n        var seen = Object.create(null);\n        var schemas = [];\n        var normalizedResource = normalizeResourceForMatching(resource);\n        for (var _i = 0, _a = this.filePatternAssociations; _i < _a.length; _i++) {\n            var entry = _a[_i];\n            if (entry.matchesPattern(normalizedResource)) {\n                for (var _b = 0, _c = entry.getURIs(); _b < _c.length; _b++) {\n                    var schemaId = _c[_b];\n                    if (!seen[schemaId]) {\n                        schemas.push(schemaId);\n                        seen[schemaId] = true;\n                    }\n                }\n            }\n        }\n        var resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);\n        this.cachedSchemaForResource = { resource: resource, resolvedSchema: resolvedSchema };\n        return resolvedSchema;\n    };\n    JSONSchemaService.prototype.createCombinedSchema = function (resource, schemaIds) {\n        if (schemaIds.length === 1) {\n            return this.getOrAddSchemaHandle(schemaIds[0]);\n        }\n        else {\n            var combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);\n            var combinedSchema = {\n                allOf: schemaIds.map(function (schemaId) { return ({ $ref: schemaId }); })\n            };\n            return this.addSchemaHandle(combinedSchemaId, combinedSchema);\n        }\n    };\n    JSONSchemaService.prototype.getMatchingSchemas = function (document, jsonDocument, schema) {\n        if (schema) {\n            var id = schema.id || ('schemaservice://untitled/matchingSchemas/' + idCounter++);\n            return this.resolveSchemaContent(new UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {\n                return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(function (s) { return !s.inverted; });\n            });\n        }\n        return this.getSchemaForResource(document.uri, jsonDocument).then(function (schema) {\n            if (schema) {\n                return jsonDocument.getMatchingSchemas(schema.schema).filter(function (s) { return !s.inverted; });\n            }\n            return [];\n        });\n    };\n    return JSONSchemaService;\n}());\n\nvar idCounter = 0;\nfunction normalizeId(id) {\n    // remove trailing '#', normalize drive capitalization\n    try {\n        return vscode_uri_URI.parse(id).toString();\n    }\n    catch (e) {\n        return id;\n    }\n}\nfunction normalizeResourceForMatching(resource) {\n    // remove queries and fragments, normalize drive capitalization\n    try {\n        return vscode_uri_URI.parse(resource).with({ fragment: null, query: null }).toString();\n    }\n    catch (e) {\n        return resource;\n    }\n}\nfunction toDisplayString(url) {\n    try {\n        var uri = vscode_uri_URI.parse(url);\n        if (uri.scheme === 'file') {\n            return uri.fsPath;\n        }\n    }\n    catch (e) {\n        // ignore\n    }\n    return url;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonValidation.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\nvar jsonValidation_localize = loadMessageBundle();\nvar JSONValidation = /** @class */ (function () {\n    function JSONValidation(jsonSchemaService, promiseConstructor) {\n        this.jsonSchemaService = jsonSchemaService;\n        this.promise = promiseConstructor;\n        this.validationEnabled = true;\n    }\n    JSONValidation.prototype.configure = function (raw) {\n        if (raw) {\n            this.validationEnabled = raw.validate !== false;\n            this.commentSeverity = raw.allowComments ? undefined : DiagnosticSeverity.Error;\n        }\n    };\n    JSONValidation.prototype.doValidation = function (textDocument, jsonDocument, documentSettings, schema) {\n        var _this = this;\n        if (!this.validationEnabled) {\n            return this.promise.resolve([]);\n        }\n        var diagnostics = [];\n        var added = {};\n        var addProblem = function (problem) {\n            // remove duplicated messages\n            var signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;\n            if (!added[signature]) {\n                added[signature] = true;\n                diagnostics.push(problem);\n            }\n        };\n        var getDiagnostics = function (schema) {\n            var trailingCommaSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;\n            var commentSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.comments) ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;\n            var schemaValidation = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;\n            var schemaRequest = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;\n            if (schema) {\n                if (schema.errors.length && jsonDocument.root && schemaRequest) {\n                    var astRoot = jsonDocument.root;\n                    var property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;\n                    if (property && property.keyNode.value === '$schema') {\n                        var node = property.valueNode || property;\n                        var range = main_Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));\n                        addProblem(Diagnostic.create(range, schema.errors[0], schemaRequest, ErrorCode.SchemaResolveError));\n                    }\n                    else {\n                        var range = main_Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));\n                        addProblem(Diagnostic.create(range, schema.errors[0], schemaRequest, ErrorCode.SchemaResolveError));\n                    }\n                }\n                else if (schemaValidation) {\n                    var semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation);\n                    if (semanticErrors) {\n                        semanticErrors.forEach(addProblem);\n                    }\n                }\n                if (schemaAllowsComments(schema.schema)) {\n                    commentSeverity = undefined;\n                }\n                if (schemaAllowsTrailingCommas(schema.schema)) {\n                    trailingCommaSeverity = undefined;\n                }\n            }\n            for (var _i = 0, _a = jsonDocument.syntaxErrors; _i < _a.length; _i++) {\n                var p = _a[_i];\n                if (p.code === ErrorCode.TrailingComma) {\n                    if (typeof trailingCommaSeverity !== 'number') {\n                        continue;\n                    }\n                    p.severity = trailingCommaSeverity;\n                }\n                addProblem(p);\n            }\n            if (typeof commentSeverity === 'number') {\n                var message_1 = jsonValidation_localize('InvalidCommentToken', 'Comments are not permitted in JSON.');\n                jsonDocument.comments.forEach(function (c) {\n                    addProblem(Diagnostic.create(c, message_1, commentSeverity, ErrorCode.CommentNotPermitted));\n                });\n            }\n            return diagnostics;\n        };\n        if (schema) {\n            var id = schema.id || ('schemaservice://untitled/' + jsonValidation_idCounter++);\n            return this.jsonSchemaService.resolveSchemaContent(new UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {\n                return getDiagnostics(resolvedSchema);\n            });\n        }\n        return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function (schema) {\n            return getDiagnostics(schema);\n        });\n    };\n    return JSONValidation;\n}());\n\nvar jsonValidation_idCounter = 0;\nfunction schemaAllowsComments(schemaRef) {\n    if (schemaRef && typeof schemaRef === 'object') {\n        if (objects_isBoolean(schemaRef.allowComments)) {\n            return schemaRef.allowComments;\n        }\n        if (schemaRef.allOf) {\n            for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {\n                var schema = _a[_i];\n                var allow = schemaAllowsComments(schema);\n                if (objects_isBoolean(allow)) {\n                    return allow;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction schemaAllowsTrailingCommas(schemaRef) {\n    if (schemaRef && typeof schemaRef === 'object') {\n        if (objects_isBoolean(schemaRef.allowTrailingCommas)) {\n            return schemaRef.allowTrailingCommas;\n        }\n        var deprSchemaRef = schemaRef;\n        if (objects_isBoolean(deprSchemaRef['allowsTrailingCommas'])) { // deprecated\n            return deprSchemaRef['allowsTrailingCommas'];\n        }\n        if (schemaRef.allOf) {\n            for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {\n                var schema = _a[_i];\n                var allow = schemaAllowsTrailingCommas(schema);\n                if (objects_isBoolean(allow)) {\n                    return allow;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction toDiagnosticSeverity(severityLevel) {\n    switch (severityLevel) {\n        case 'error': return DiagnosticSeverity.Error;\n        case 'warning': return DiagnosticSeverity.Warning;\n        case 'ignore': return undefined;\n    }\n    return undefined;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/utils/colors.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar Digit0 = 48;\nvar Digit9 = 57;\nvar A = 65;\nvar a = 97;\nvar f = 102;\nfunction hexDigit(charCode) {\n    if (charCode < Digit0) {\n        return 0;\n    }\n    if (charCode <= Digit9) {\n        return charCode - Digit0;\n    }\n    if (charCode < a) {\n        charCode += (a - A);\n    }\n    if (charCode >= a && charCode <= f) {\n        return charCode - a + 10;\n    }\n    return 0;\n}\nfunction colorFromHex(text) {\n    if (text[0] !== '#') {\n        return undefined;\n    }\n    switch (text.length) {\n        case 4:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,\n                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,\n                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,\n                alpha: 1\n            };\n        case 5:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,\n                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,\n                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,\n                alpha: (hexDigit(text.charCodeAt(4)) * 0x11) / 255.0,\n            };\n        case 7:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,\n                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,\n                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,\n                alpha: 1\n            };\n        case 9:\n            return {\n                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,\n                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,\n                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,\n                alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0\n            };\n    }\n    return undefined;\n}\nfunction colorFrom256RGB(red, green, blue, alpha) {\n    if (alpha === void 0) { alpha = 1.0; }\n    return {\n        red: red / 255.0,\n        green: green / 255.0,\n        blue: blue / 255.0,\n        alpha: alpha\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonDocumentSymbols.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\nvar JSONDocumentSymbols = /** @class */ (function () {\n    function JSONDocumentSymbols(schemaService) {\n        this.schemaService = schemaService;\n    }\n    JSONDocumentSymbols.prototype.findDocumentSymbols = function (document, doc, context) {\n        var _this = this;\n        if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }\n        var root = doc.root;\n        if (!root) {\n            return [];\n        }\n        var limit = context.resultLimit || Number.MAX_VALUE;\n        // special handling for key bindings\n        var resourceString = document.uri;\n        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n            if (root.type === 'array') {\n                var result_1 = [];\n                for (var _i = 0, _a = root.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.type === 'object') {\n                        for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {\n                            var property = _c[_b];\n                            if (property.keyNode.value === 'key' && property.valueNode) {\n                                var location = Location.create(document.uri, getRange(document, item));\n                                result_1.push({ name: jsonParser_getNodeValue(property.valueNode), kind: main_SymbolKind.Function, location: location });\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(resourceString);\n                                    }\n                                    return result_1;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result_1;\n            }\n        }\n        var toVisit = [\n            { node: root, containerName: '' }\n        ];\n        var nextToVisit = 0;\n        var limitExceeded = false;\n        var result = [];\n        var collectOutlineEntries = function (node, containerName) {\n            if (node.type === 'array') {\n                node.items.forEach(function (node) {\n                    if (node) {\n                        toVisit.push({ node: node, containerName: containerName });\n                    }\n                });\n            }\n            else if (node.type === 'object') {\n                node.properties.forEach(function (property) {\n                    var valueNode = property.valueNode;\n                    if (valueNode) {\n                        if (limit > 0) {\n                            limit--;\n                            var location = Location.create(document.uri, getRange(document, property));\n                            var childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;\n                            result.push({ name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), location: location, containerName: containerName });\n                            toVisit.push({ node: valueNode, containerName: childContainerName });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n        };\n        // breath first traversal\n        while (nextToVisit < toVisit.length) {\n            var next = toVisit[nextToVisit++];\n            collectOutlineEntries(next.node, next.containerName);\n        }\n        if (limitExceeded && context && context.onResultLimitExceeded) {\n            context.onResultLimitExceeded(resourceString);\n        }\n        return result;\n    };\n    JSONDocumentSymbols.prototype.findDocumentSymbols2 = function (document, doc, context) {\n        var _this = this;\n        if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }\n        var root = doc.root;\n        if (!root) {\n            return [];\n        }\n        var limit = context.resultLimit || Number.MAX_VALUE;\n        // special handling for key bindings\n        var resourceString = document.uri;\n        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n            if (root.type === 'array') {\n                var result_2 = [];\n                for (var _i = 0, _a = root.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.type === 'object') {\n                        for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {\n                            var property = _c[_b];\n                            if (property.keyNode.value === 'key' && property.valueNode) {\n                                var range = getRange(document, item);\n                                var selectionRange = getRange(document, property.keyNode);\n                                result_2.push({ name: jsonParser_getNodeValue(property.valueNode), kind: main_SymbolKind.Function, range: range, selectionRange: selectionRange });\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(resourceString);\n                                    }\n                                    return result_2;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result_2;\n            }\n        }\n        var result = [];\n        var toVisit = [\n            { node: root, result: result }\n        ];\n        var nextToVisit = 0;\n        var limitExceeded = false;\n        var collectOutlineEntries = function (node, result) {\n            if (node.type === 'array') {\n                node.items.forEach(function (node, index) {\n                    if (node) {\n                        if (limit > 0) {\n                            limit--;\n                            var range = getRange(document, node);\n                            var selectionRange = range;\n                            var name = String(index);\n                            var symbol = { name: name, kind: _this.getSymbolKind(node.type), range: range, selectionRange: selectionRange, children: [] };\n                            result.push(symbol);\n                            toVisit.push({ result: symbol.children, node: node });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n            else if (node.type === 'object') {\n                node.properties.forEach(function (property) {\n                    var valueNode = property.valueNode;\n                    if (valueNode) {\n                        if (limit > 0) {\n                            limit--;\n                            var range = getRange(document, property);\n                            var selectionRange = getRange(document, property.keyNode);\n                            var children = [];\n                            var symbol = { name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), range: range, selectionRange: selectionRange, children: children, detail: _this.getDetail(valueNode) };\n                            result.push(symbol);\n                            toVisit.push({ result: children, node: valueNode });\n                        }\n                        else {\n                            limitExceeded = true;\n                        }\n                    }\n                });\n            }\n        };\n        // breath first traversal\n        while (nextToVisit < toVisit.length) {\n            var next = toVisit[nextToVisit++];\n            collectOutlineEntries(next.node, next.result);\n        }\n        if (limitExceeded && context && context.onResultLimitExceeded) {\n            context.onResultLimitExceeded(resourceString);\n        }\n        return result;\n    };\n    JSONDocumentSymbols.prototype.getSymbolKind = function (nodeType) {\n        switch (nodeType) {\n            case 'object':\n                return main_SymbolKind.Module;\n            case 'string':\n                return main_SymbolKind.String;\n            case 'number':\n                return main_SymbolKind.Number;\n            case 'array':\n                return main_SymbolKind.Array;\n            case 'boolean':\n                return main_SymbolKind.Boolean;\n            default: // 'null'\n                return main_SymbolKind.Variable;\n        }\n    };\n    JSONDocumentSymbols.prototype.getKeyLabel = function (property) {\n        var name = property.keyNode.value;\n        if (name) {\n            name = name.replace(/[\\n]/g, '↵');\n        }\n        if (name && name.trim()) {\n            return name;\n        }\n        return \"\\\"\" + name + \"\\\"\";\n    };\n    JSONDocumentSymbols.prototype.getDetail = function (node) {\n        if (!node) {\n            return undefined;\n        }\n        if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {\n            return String(node.value);\n        }\n        else {\n            if (node.type === 'array') {\n                return node.children.length ? undefined : '[]';\n            }\n            else if (node.type === 'object') {\n                return node.children.length ? undefined : '{}';\n            }\n        }\n        return undefined;\n    };\n    JSONDocumentSymbols.prototype.findDocumentColors = function (document, doc, context) {\n        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n            var result = [];\n            if (schema) {\n                var limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;\n                var matchingSchemas = doc.getMatchingSchemas(schema.schema);\n                var visitedNode = {};\n                for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {\n                    var s = matchingSchemas_1[_i];\n                    if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {\n                        var nodeId = String(s.node.offset);\n                        if (!visitedNode[nodeId]) {\n                            var color = colorFromHex(jsonParser_getNodeValue(s.node));\n                            if (color) {\n                                var range = getRange(document, s.node);\n                                result.push({ color: color, range: range });\n                            }\n                            visitedNode[nodeId] = true;\n                            limit--;\n                            if (limit <= 0) {\n                                if (context && context.onResultLimitExceeded) {\n                                    context.onResultLimitExceeded(document.uri);\n                                }\n                                return result;\n                            }\n                        }\n                    }\n                }\n            }\n            return result;\n        });\n    };\n    JSONDocumentSymbols.prototype.getColorPresentations = function (document, doc, color, range) {\n        var result = [];\n        var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);\n        function toTwoDigitHex(n) {\n            var r = n.toString(16);\n            return r.length !== 2 ? '0' + r : r;\n        }\n        var label;\n        if (color.alpha === 1) {\n            label = \"#\" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256);\n        }\n        else {\n            label = \"#\" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256) + toTwoDigitHex(Math.round(color.alpha * 255));\n        }\n        result.push({ label: label, textEdit: TextEdit.replace(range, JSON.stringify(label)) });\n        return result;\n    };\n    return JSONDocumentSymbols;\n}());\n\nfunction getRange(document, node) {\n    return main_Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/configuration.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar configuration_localize = loadMessageBundle();\nvar schemaContributions = {\n    schemaAssociations: [],\n    schemas: {\n        // refer to the latest schema\n        'http://json-schema.org/schema#': {\n            $ref: 'http://json-schema.org/draft-07/schema#'\n        },\n        // bundle the schema-schema to include (localized) descriptions\n        'http://json-schema.org/draft-04/schema#': {\n            'title': configuration_localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),\n            '$schema': 'http://json-schema.org/draft-04/schema#',\n            'definitions': {\n                'schemaArray': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'items': {\n                        '$ref': '#'\n                    }\n                },\n                'positiveInteger': {\n                    'type': 'integer',\n                    'minimum': 0\n                },\n                'positiveIntegerDefault0': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        },\n                        {\n                            'default': 0\n                        }\n                    ]\n                },\n                'simpleTypes': {\n                    'type': 'string',\n                    'enum': [\n                        'array',\n                        'boolean',\n                        'integer',\n                        'null',\n                        'number',\n                        'object',\n                        'string'\n                    ]\n                },\n                'stringArray': {\n                    'type': 'array',\n                    'items': {\n                        'type': 'string'\n                    },\n                    'minItems': 1,\n                    'uniqueItems': true\n                }\n            },\n            'type': 'object',\n            'properties': {\n                'id': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                '$schema': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                'title': {\n                    'type': 'string'\n                },\n                'description': {\n                    'type': 'string'\n                },\n                'default': {},\n                'multipleOf': {\n                    'type': 'number',\n                    'minimum': 0,\n                    'exclusiveMinimum': true\n                },\n                'maximum': {\n                    'type': 'number'\n                },\n                'exclusiveMaximum': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'minimum': {\n                    'type': 'number'\n                },\n                'exclusiveMinimum': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'maxLength': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minLength': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'pattern': {\n                    'type': 'string',\n                    'format': 'regex'\n                },\n                'additionalItems': {\n                    'anyOf': [\n                        {\n                            'type': 'boolean'\n                        },\n                        {\n                            '$ref': '#'\n                        }\n                    ],\n                    'default': {}\n                },\n                'items': {\n                    'anyOf': [\n                        {\n                            '$ref': '#'\n                        },\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ],\n                    'default': {}\n                },\n                'maxItems': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minItems': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'uniqueItems': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'maxProperties': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveInteger'\n                        }\n                    ]\n                },\n                'minProperties': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/positiveIntegerDefault0'\n                        }\n                    ]\n                },\n                'required': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/stringArray'\n                        }\n                    ]\n                },\n                'additionalProperties': {\n                    'anyOf': [\n                        {\n                            'type': 'boolean'\n                        },\n                        {\n                            '$ref': '#'\n                        }\n                    ],\n                    'default': {}\n                },\n                'definitions': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'properties': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'patternProperties': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        '$ref': '#'\n                    },\n                    'default': {}\n                },\n                'dependencies': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        'anyOf': [\n                            {\n                                '$ref': '#'\n                            },\n                            {\n                                '$ref': '#/definitions/stringArray'\n                            }\n                        ]\n                    }\n                },\n                'enum': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'uniqueItems': true\n                },\n                'type': {\n                    'anyOf': [\n                        {\n                            '$ref': '#/definitions/simpleTypes'\n                        },\n                        {\n                            'type': 'array',\n                            'items': {\n                                '$ref': '#/definitions/simpleTypes'\n                            },\n                            'minItems': 1,\n                            'uniqueItems': true\n                        }\n                    ]\n                },\n                'format': {\n                    'anyOf': [\n                        {\n                            'type': 'string',\n                            'enum': [\n                                'date-time',\n                                'uri',\n                                'email',\n                                'hostname',\n                                'ipv4',\n                                'ipv6',\n                                'regex'\n                            ]\n                        },\n                        {\n                            'type': 'string'\n                        }\n                    ]\n                },\n                'allOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'anyOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'oneOf': {\n                    'allOf': [\n                        {\n                            '$ref': '#/definitions/schemaArray'\n                        }\n                    ]\n                },\n                'not': {\n                    'allOf': [\n                        {\n                            '$ref': '#'\n                        }\n                    ]\n                }\n            },\n            'dependencies': {\n                'exclusiveMaximum': [\n                    'maximum'\n                ],\n                'exclusiveMinimum': [\n                    'minimum'\n                ]\n            },\n            'default': {}\n        },\n        'http://json-schema.org/draft-07/schema#': {\n            'title': configuration_localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),\n            'definitions': {\n                'schemaArray': {\n                    'type': 'array',\n                    'minItems': 1,\n                    'items': { '$ref': '#' }\n                },\n                'nonNegativeInteger': {\n                    'type': 'integer',\n                    'minimum': 0\n                },\n                'nonNegativeIntegerDefault0': {\n                    'allOf': [\n                        { '$ref': '#/definitions/nonNegativeInteger' },\n                        { 'default': 0 }\n                    ]\n                },\n                'simpleTypes': {\n                    'enum': [\n                        'array',\n                        'boolean',\n                        'integer',\n                        'null',\n                        'number',\n                        'object',\n                        'string'\n                    ]\n                },\n                'stringArray': {\n                    'type': 'array',\n                    'items': { 'type': 'string' },\n                    'uniqueItems': true,\n                    'default': []\n                }\n            },\n            'type': ['object', 'boolean'],\n            'properties': {\n                '$id': {\n                    'type': 'string',\n                    'format': 'uri-reference'\n                },\n                '$schema': {\n                    'type': 'string',\n                    'format': 'uri'\n                },\n                '$ref': {\n                    'type': 'string',\n                    'format': 'uri-reference'\n                },\n                '$comment': {\n                    'type': 'string'\n                },\n                'title': {\n                    'type': 'string'\n                },\n                'description': {\n                    'type': 'string'\n                },\n                'default': true,\n                'readOnly': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'examples': {\n                    'type': 'array',\n                    'items': true\n                },\n                'multipleOf': {\n                    'type': 'number',\n                    'exclusiveMinimum': 0\n                },\n                'maximum': {\n                    'type': 'number'\n                },\n                'exclusiveMaximum': {\n                    'type': 'number'\n                },\n                'minimum': {\n                    'type': 'number'\n                },\n                'exclusiveMinimum': {\n                    'type': 'number'\n                },\n                'maxLength': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minLength': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'pattern': {\n                    'type': 'string',\n                    'format': 'regex'\n                },\n                'additionalItems': { '$ref': '#' },\n                'items': {\n                    'anyOf': [\n                        { '$ref': '#' },\n                        { '$ref': '#/definitions/schemaArray' }\n                    ],\n                    'default': true\n                },\n                'maxItems': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minItems': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'uniqueItems': {\n                    'type': 'boolean',\n                    'default': false\n                },\n                'contains': { '$ref': '#' },\n                'maxProperties': { '$ref': '#/definitions/nonNegativeInteger' },\n                'minProperties': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },\n                'required': { '$ref': '#/definitions/stringArray' },\n                'additionalProperties': { '$ref': '#' },\n                'definitions': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'default': {}\n                },\n                'properties': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'default': {}\n                },\n                'patternProperties': {\n                    'type': 'object',\n                    'additionalProperties': { '$ref': '#' },\n                    'propertyNames': { 'format': 'regex' },\n                    'default': {}\n                },\n                'dependencies': {\n                    'type': 'object',\n                    'additionalProperties': {\n                        'anyOf': [\n                            { '$ref': '#' },\n                            { '$ref': '#/definitions/stringArray' }\n                        ]\n                    }\n                },\n                'propertyNames': { '$ref': '#' },\n                'const': true,\n                'enum': {\n                    'type': 'array',\n                    'items': true,\n                    'minItems': 1,\n                    'uniqueItems': true\n                },\n                'type': {\n                    'anyOf': [\n                        { '$ref': '#/definitions/simpleTypes' },\n                        {\n                            'type': 'array',\n                            'items': { '$ref': '#/definitions/simpleTypes' },\n                            'minItems': 1,\n                            'uniqueItems': true\n                        }\n                    ]\n                },\n                'format': { 'type': 'string' },\n                'contentMediaType': { 'type': 'string' },\n                'contentEncoding': { 'type': 'string' },\n                'if': { '$ref': '#' },\n                'then': { '$ref': '#' },\n                'else': { '$ref': '#' },\n                'allOf': { '$ref': '#/definitions/schemaArray' },\n                'anyOf': { '$ref': '#/definitions/schemaArray' },\n                'oneOf': { '$ref': '#/definitions/schemaArray' },\n                'not': { '$ref': '#' }\n            },\n            'default': true\n        }\n    }\n};\nvar descriptions = {\n    id: configuration_localize('schema.json.id', \"A unique identifier for the schema.\"),\n    $schema: configuration_localize('schema.json.$schema', \"The schema to verify this document against.\"),\n    title: configuration_localize('schema.json.title', \"A descriptive title of the element.\"),\n    description: configuration_localize('schema.json.description', \"A long description of the element. Used in hover menus and suggestions.\"),\n    default: configuration_localize('schema.json.default', \"A default value. Used by suggestions.\"),\n    multipleOf: configuration_localize('schema.json.multipleOf', \"A number that should cleanly divide the current value (i.e. have no remainder).\"),\n    maximum: configuration_localize('schema.json.maximum', \"The maximum numerical value, inclusive by default.\"),\n    exclusiveMaximum: configuration_localize('schema.json.exclusiveMaximum', \"Makes the maximum property exclusive.\"),\n    minimum: configuration_localize('schema.json.minimum', \"The minimum numerical value, inclusive by default.\"),\n    exclusiveMinimum: configuration_localize('schema.json.exclusiveMininum', \"Makes the minimum property exclusive.\"),\n    maxLength: configuration_localize('schema.json.maxLength', \"The maximum length of a string.\"),\n    minLength: configuration_localize('schema.json.minLength', \"The minimum length of a string.\"),\n    pattern: configuration_localize('schema.json.pattern', \"A regular expression to match the string against. It is not implicitly anchored.\"),\n    additionalItems: configuration_localize('schema.json.additionalItems', \"For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail.\"),\n    items: configuration_localize('schema.json.items', \"For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on.\"),\n    maxItems: configuration_localize('schema.json.maxItems', \"The maximum number of items that can be inside an array. Inclusive.\"),\n    minItems: configuration_localize('schema.json.minItems', \"The minimum number of items that can be inside an array. Inclusive.\"),\n    uniqueItems: configuration_localize('schema.json.uniqueItems', \"If all of the items in the array must be unique. Defaults to false.\"),\n    maxProperties: configuration_localize('schema.json.maxProperties', \"The maximum number of properties an object can have. Inclusive.\"),\n    minProperties: configuration_localize('schema.json.minProperties', \"The minimum number of properties an object can have. Inclusive.\"),\n    required: configuration_localize('schema.json.required', \"An array of strings that lists the names of all properties required on this object.\"),\n    additionalProperties: configuration_localize('schema.json.additionalProperties', \"Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail.\"),\n    definitions: configuration_localize('schema.json.definitions', \"Not used for validation. Place subschemas here that you wish to reference inline with $ref.\"),\n    properties: configuration_localize('schema.json.properties', \"A map of property names to schemas for each property.\"),\n    patternProperties: configuration_localize('schema.json.patternProperties', \"A map of regular expressions on property names to schemas for matching properties.\"),\n    dependencies: configuration_localize('schema.json.dependencies', \"A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object.\"),\n    enum: configuration_localize('schema.json.enum', \"The set of literal values that are valid.\"),\n    type: configuration_localize('schema.json.type', \"Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types.\"),\n    format: configuration_localize('schema.json.format', \"Describes the format expected for the value.\"),\n    allOf: configuration_localize('schema.json.allOf', \"An array of schemas, all of which must match.\"),\n    anyOf: configuration_localize('schema.json.anyOf', \"An array of schemas, where at least one must match.\"),\n    oneOf: configuration_localize('schema.json.oneOf', \"An array of schemas, exactly one of which must match.\"),\n    not: configuration_localize('schema.json.not', \"A schema which must not match.\"),\n    $id: configuration_localize('schema.json.$id', \"A unique identifier for the schema.\"),\n    $ref: configuration_localize('schema.json.$ref', \"Reference a definition hosted on any location.\"),\n    $comment: configuration_localize('schema.json.$comment', \"Comments from schema authors to readers or maintainers of the schema.\"),\n    readOnly: configuration_localize('schema.json.readOnly', \"Indicates that the value of the instance is managed exclusively by the owning authority.\"),\n    examples: configuration_localize('schema.json.examples', \"Sample JSON values associated with a particular schema, for the purpose of illustrating usage.\"),\n    contains: configuration_localize('schema.json.contains', \"An array instance is valid against \\\"contains\\\" if at least one of its elements is valid against the given schema.\"),\n    propertyNames: configuration_localize('schema.json.propertyNames', \"If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema.\"),\n    const: configuration_localize('schema.json.const', \"An instance validates successfully against this keyword if its value is equal to the value of the keyword.\"),\n    contentMediaType: configuration_localize('schema.json.contentMediaType', \"Describes the media type of a string property.\"),\n    contentEncoding: configuration_localize('schema.json.contentEncoding', \"Describes the content encoding of a string property.\"),\n    if: configuration_localize('schema.json.if', \"The validation outcome of the \\\"if\\\" subschema controls which of the \\\"then\\\" or \\\"else\\\" keywords are evaluated.\"),\n    then: configuration_localize('schema.json.then', \"The \\\"if\\\" subschema is used for validation when the \\\"if\\\" subschema succeeds.\"),\n    else: configuration_localize('schema.json.else', \"The \\\"else\\\" subschema is used for validation when the \\\"if\\\" subschema fails.\")\n};\nfor (var schemaName in schemaContributions.schemas) {\n    var schema = schemaContributions.schemas[schemaName];\n    for (var property in schema.properties) {\n        var propertyObject = schema.properties[property];\n        if (typeof propertyObject === 'boolean') {\n            propertyObject = schema.properties[property] = {};\n        }\n        var description = descriptions[property];\n        if (description) {\n            propertyObject['description'] = description;\n        }\n        else {\n            console.log(property + \": localize('schema.json.\" + property + \"', \\\"\\\")\");\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonFolding.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction getFoldingRanges(document, context) {\n    var ranges = [];\n    var nestingLevels = [];\n    var stack = [];\n    var prevStart = -1;\n    var scanner = main_createScanner(document.getText(), false);\n    var token = scanner.scan();\n    function addRange(range) {\n        ranges.push(range);\n        nestingLevels.push(stack.length);\n    }\n    while (token !== 17 /* EOF */) {\n        switch (token) {\n            case 1 /* OpenBraceToken */:\n            case 3 /* OpenBracketToken */: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var range = { startLine: startLine, endLine: startLine, kind: token === 1 /* OpenBraceToken */ ? 'object' : 'array' };\n                stack.push(range);\n                break;\n            }\n            case 2 /* CloseBraceToken */:\n            case 4 /* CloseBracketToken */: {\n                var kind = token === 2 /* CloseBraceToken */ ? 'object' : 'array';\n                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {\n                    var range = stack.pop();\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {\n                        range.endLine = line - 1;\n                        addRange(range);\n                        prevStart = range.startLine;\n                    }\n                }\n                break;\n            }\n            case 13 /* BlockCommentTrivia */: {\n                var startLine = document.positionAt(scanner.getTokenOffset()).line;\n                var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;\n                if (scanner.getTokenError() === 1 /* UnexpectedEndOfComment */ && startLine + 1 < document.lineCount) {\n                    scanner.setPosition(document.offsetAt(main_Position.create(startLine + 1, 0)));\n                }\n                else {\n                    if (startLine < endLine) {\n                        addRange({ startLine: startLine, endLine: endLine, kind: FoldingRangeKind.Comment });\n                        prevStart = startLine;\n                    }\n                }\n                break;\n            }\n            case 12 /* LineCommentTrivia */: {\n                var text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());\n                var m = text.match(/^\\/\\/\\s*#(region\\b)|(endregion\\b)/);\n                if (m) {\n                    var line = document.positionAt(scanner.getTokenOffset()).line;\n                    if (m[1]) { // start pattern match\n                        var range = { startLine: line, endLine: line, kind: FoldingRangeKind.Region };\n                        stack.push(range);\n                    }\n                    else {\n                        var i = stack.length - 1;\n                        while (i >= 0 && stack[i].kind !== FoldingRangeKind.Region) {\n                            i--;\n                        }\n                        if (i >= 0) {\n                            var range = stack[i];\n                            stack.length = i;\n                            if (line > range.startLine && prevStart !== range.startLine) {\n                                range.endLine = line;\n                                addRange(range);\n                                prevStart = range.startLine;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        token = scanner.scan();\n    }\n    var rangeLimit = context && context.rangeLimit;\n    if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {\n        return ranges;\n    }\n    if (context && context.onRangeLimitExceeded) {\n        context.onRangeLimitExceeded(document.uri);\n    }\n    var counts = [];\n    for (var _i = 0, nestingLevels_1 = nestingLevels; _i < nestingLevels_1.length; _i++) {\n        var level = nestingLevels_1[_i];\n        if (level < 30) {\n            counts[level] = (counts[level] || 0) + 1;\n        }\n    }\n    var entries = 0;\n    var maxLevel = 0;\n    for (var i = 0; i < counts.length; i++) {\n        var n = counts[i];\n        if (n) {\n            if (n + entries > rangeLimit) {\n                maxLevel = i;\n                break;\n            }\n            entries += n;\n        }\n    }\n    var result = [];\n    for (var i = 0; i < ranges.length; i++) {\n        var level = nestingLevels[i];\n        if (typeof level === 'number') {\n            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {\n                result.push(ranges[i]);\n            }\n        }\n    }\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonSelectionRanges.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nfunction getSelectionRanges(document, positions, doc) {\n    function getSelectionRange(position) {\n        var offset = document.offsetAt(position);\n        var node = doc.getNodeFromOffset(offset, true);\n        var result = [];\n        while (node) {\n            switch (node.type) {\n                case 'string':\n                case 'object':\n                case 'array':\n                    // range without \", [ or {\n                    var cStart = node.offset + 1, cEnd = node.offset + node.length - 1;\n                    if (cStart < cEnd && offset >= cStart && offset <= cEnd) {\n                        result.push(newRange(cStart, cEnd));\n                    }\n                    result.push(newRange(node.offset, node.offset + node.length));\n                    break;\n                case 'number':\n                case 'boolean':\n                case 'null':\n                case 'property':\n                    result.push(newRange(node.offset, node.offset + node.length));\n                    break;\n            }\n            if (node.type === 'property' || node.parent && node.parent.type === 'array') {\n                var afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* CommaToken */);\n                if (afterCommaOffset !== -1) {\n                    result.push(newRange(node.offset, afterCommaOffset));\n                }\n            }\n            node = node.parent;\n        }\n        var current = undefined;\n        for (var index = result.length - 1; index >= 0; index--) {\n            current = SelectionRange.create(result[index], current);\n        }\n        if (!current) {\n            current = SelectionRange.create(main_Range.create(position, position));\n        }\n        return current;\n    }\n    function newRange(start, end) {\n        return main_Range.create(document.positionAt(start), document.positionAt(end));\n    }\n    var scanner = main_createScanner(document.getText(), true);\n    function getOffsetAfterNextToken(offset, expectedToken) {\n        scanner.setPosition(offset);\n        var token = scanner.scan();\n        if (token === expectedToken) {\n            return scanner.getTokenOffset() + scanner.getTokenLength();\n        }\n        return -1;\n    }\n    return positions.map(getSelectionRange);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/services/jsonLinks.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nfunction findLinks(document, doc) {\n    var links = [];\n    doc.visit(function (node) {\n        var _a;\n        if (node.type === \"property\" && node.keyNode.value === \"$ref\" && ((_a = node.valueNode) === null || _a === void 0 ? void 0 : _a.type) === 'string') {\n            var path = node.valueNode.value;\n            var targetNode = findTargetNode(doc, path);\n            if (targetNode) {\n                var targetPos = document.positionAt(targetNode.offset);\n                links.push({\n                    target: document.uri + \"#\" + (targetPos.line + 1) + \",\" + (targetPos.character + 1),\n                    range: createRange(document, node.valueNode)\n                });\n            }\n        }\n        return true;\n    });\n    return Promise.resolve(links);\n}\nfunction createRange(document, node) {\n    return main_Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + node.length - 1));\n}\nfunction findTargetNode(doc, path) {\n    var tokens = parseJSONPointer(path);\n    if (!tokens) {\n        return null;\n    }\n    return findNode(tokens, doc.root);\n}\nfunction findNode(pointer, node) {\n    if (!node) {\n        return null;\n    }\n    if (pointer.length === 0) {\n        return node;\n    }\n    var token = pointer.shift();\n    if (node && node.type === 'object') {\n        var propertyNode = node.properties.find(function (propertyNode) { return propertyNode.keyNode.value === token; });\n        if (!propertyNode) {\n            return null;\n        }\n        return findNode(pointer, propertyNode.valueNode);\n    }\n    else if (node && node.type === 'array') {\n        if (token.match(/^(0|[1-9][0-9]*)$/)) {\n            var index = Number.parseInt(token);\n            var arrayItem = node.items[index];\n            if (!arrayItem) {\n                return null;\n            }\n            return findNode(pointer, arrayItem);\n        }\n    }\n    return null;\n}\nfunction parseJSONPointer(path) {\n    if (path === \"#\") {\n        return [];\n    }\n    if (path[0] !== '#' || path[1] !== '/') {\n        return null;\n    }\n    return path.substring(2).split(/\\//).map(jsonLinks_unescape);\n}\nfunction jsonLinks_unescape(str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-json-languageservice/jsonLanguageService.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getLanguageService(params) {\n    var promise = params.promiseConstructor || Promise;\n    var jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);\n    jsonSchemaService.setSchemaContributions(schemaContributions);\n    var jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);\n    var jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);\n    var jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);\n    var jsonValidation = new JSONValidation(jsonSchemaService, promise);\n    return {\n        configure: function (settings) {\n            jsonSchemaService.clearExternalSchemas();\n            if (settings.schemas) {\n                settings.schemas.forEach(function (settings) {\n                    jsonSchemaService.registerExternalSchema(settings.uri, settings.fileMatch, settings.schema);\n                });\n            }\n            jsonValidation.configure(settings);\n        },\n        resetSchema: function (uri) { return jsonSchemaService.onResourceChange(uri); },\n        doValidation: jsonValidation.doValidation.bind(jsonValidation),\n        parseJSONDocument: function (document) { return jsonParser_parse(document, { collectComments: true }); },\n        newJSONDocument: function (root, diagnostics) { return newJSONDocument(root, diagnostics); },\n        getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),\n        doResolve: jsonCompletion.doResolve.bind(jsonCompletion),\n        doComplete: jsonCompletion.doComplete.bind(jsonCompletion),\n        findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),\n        findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),\n        findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),\n        getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),\n        doHover: jsonHover.doHover.bind(jsonHover),\n        getFoldingRanges: getFoldingRanges,\n        getSelectionRanges: getSelectionRanges,\n        findDefinition: function () { return Promise.resolve([]); },\n        findLinks: findLinks,\n        format: function (d, r, o) {\n            var range = undefined;\n            if (r) {\n                var offset = d.offsetAt(r.start);\n                var length = d.offsetAt(r.end) - offset;\n                range = { offset: offset, length: length };\n            }\n            var options = { tabSize: o ? o.tabSize : 4, insertSpaces: (o === null || o === void 0 ? void 0 : o.insertSpaces) === true, insertFinalNewline: (o === null || o === void 0 ? void 0 : o.insertFinalNewline) === true, eol: '\\n' };\n            return main_format(d.getText(), range, options).map(function (e) {\n                return TextEdit.replace(main_Range.create(d.positionAt(e.offset), d.positionAt(e.offset + e.length)), e.content);\n            });\n        }\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/jsonWorker.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar jsonWorker_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n\r\n\r\nvar defaultSchemaRequestService;\r\nif (typeof fetch !== 'undefined') {\r\n    defaultSchemaRequestService = function (url) {\r\n        return fetch(url).then(function (response) { return response.text(); });\r\n    };\r\n}\r\nvar JSONWorker = /** @class */ (function () {\r\n    function JSONWorker(ctx, createData) {\r\n        this._ctx = ctx;\r\n        this._languageSettings = createData.languageSettings;\r\n        this._languageId = createData.languageId;\r\n        this._languageService = getLanguageService({\r\n            workspaceContext: {\r\n                resolveRelativePath: function (relativePath, resource) {\r\n                    var base = resource.substr(0, resource.lastIndexOf('/') + 1);\r\n                    return resolvePath(base, relativePath);\r\n                }\r\n            },\r\n            schemaRequestService: createData.enableSchemaRequest && defaultSchemaRequestService\r\n        });\r\n        this._languageService.configure(this._languageSettings);\r\n    }\r\n    JSONWorker.prototype.doValidation = function (uri) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                if (document) {\r\n                    jsonDocument = this._languageService.parseJSONDocument(document);\r\n                    return [2 /*return*/, this._languageService.doValidation(document, jsonDocument, this._languageSettings)];\r\n                }\r\n                return [2 /*return*/, Promise.resolve([])];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.doComplete = function (uri, position) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                jsonDocument = this._languageService.parseJSONDocument(document);\r\n                return [2 /*return*/, this._languageService.doComplete(document, position, jsonDocument)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.doResolve = function (item) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, this._languageService.doResolve(item)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.doHover = function (uri, position) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                jsonDocument = this._languageService.parseJSONDocument(document);\r\n                return [2 /*return*/, this._languageService.doHover(document, position, jsonDocument)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.format = function (uri, range, options) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, textEdits;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                textEdits = this._languageService.format(document, range, options);\r\n                return [2 /*return*/, Promise.resolve(textEdits)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.resetSchema = function (uri) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, Promise.resolve(this._languageService.resetSchema(uri))];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.findDocumentSymbols = function (uri) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument, symbols;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                jsonDocument = this._languageService.parseJSONDocument(document);\r\n                symbols = this._languageService.findDocumentSymbols(document, jsonDocument);\r\n                return [2 /*return*/, Promise.resolve(symbols)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.findDocumentColors = function (uri) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument, colorSymbols;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                jsonDocument = this._languageService.parseJSONDocument(document);\r\n                colorSymbols = this._languageService.findDocumentColors(document, jsonDocument);\r\n                return [2 /*return*/, Promise.resolve(colorSymbols)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.getColorPresentations = function (uri, color, range) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument, colorPresentations;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                jsonDocument = this._languageService.parseJSONDocument(document);\r\n                colorPresentations = this._languageService.getColorPresentations(document, jsonDocument, color, range);\r\n                return [2 /*return*/, Promise.resolve(colorPresentations)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.getFoldingRanges = function (uri, context) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, ranges;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                ranges = this._languageService.getFoldingRanges(document, context);\r\n                return [2 /*return*/, Promise.resolve(ranges)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype.getSelectionRanges = function (uri, positions) {\r\n        return jsonWorker_awaiter(this, void 0, void 0, function () {\r\n            var document, jsonDocument, ranges;\r\n            return __generator(this, function (_a) {\r\n                document = this._getTextDocument(uri);\r\n                jsonDocument = this._languageService.parseJSONDocument(document);\r\n                ranges = this._languageService.getSelectionRanges(document, positions, jsonDocument);\r\n                return [2 /*return*/, Promise.resolve(ranges)];\r\n            });\r\n        });\r\n    };\r\n    JSONWorker.prototype._getTextDocument = function (uri) {\r\n        var models = this._ctx.getMirrorModels();\r\n        for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {\r\n            var model = models_1[_i];\r\n            if (model.uri.toString() === uri) {\r\n                return main_TextDocument.create(uri, this._languageId, model.version, model.getValue());\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    return JSONWorker;\r\n}());\r\n\r\n// URI path utilities, will (hopefully) move to vscode-uri\r\nvar Slash = '/'.charCodeAt(0);\r\nvar Dot = '.'.charCodeAt(0);\r\nfunction isAbsolutePath(path) {\r\n    return path.charCodeAt(0) === Slash;\r\n}\r\nfunction resolvePath(uriString, path) {\r\n    if (isAbsolutePath(path)) {\r\n        var uri = vscode_uri_URI.parse(uriString);\r\n        var parts = path.split('/');\r\n        return uri.with({ path: normalizePath(parts) }).toString();\r\n    }\r\n    return joinPath(uriString, path);\r\n}\r\nfunction normalizePath(parts) {\r\n    var newParts = [];\r\n    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\r\n        var part = parts_1[_i];\r\n        if (part.length === 0 || (part.length === 1 && part.charCodeAt(0) === Dot)) {\r\n            // ignore\r\n        }\r\n        else if (part.length === 2 && part.charCodeAt(0) === Dot && part.charCodeAt(1) === Dot) {\r\n            newParts.pop();\r\n        }\r\n        else {\r\n            newParts.push(part);\r\n        }\r\n    }\r\n    if (parts.length > 1 && parts[parts.length - 1].length === 0) {\r\n        newParts.push('');\r\n    }\r\n    var res = newParts.join('/');\r\n    if (parts[0].length === 0) {\r\n        res = '/' + res;\r\n    }\r\n    return res;\r\n}\r\nfunction joinPath(uriString) {\r\n    var paths = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        paths[_i - 1] = arguments[_i];\r\n    }\r\n    var uri = vscode_uri_URI.parse(uriString);\r\n    var parts = uri.path.split('/');\r\n    for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {\r\n        var path = paths_1[_a];\r\n        parts.push.apply(parts, path.split('/'));\r\n    }\r\n    return uri.with({ path: normalizePath(parts) }).toString();\r\n}\r\nfunction jsonWorker_create(ctx, createData) {\r\n    return new JSONWorker(ctx, createData);\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/language/json/json.worker.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nself.onmessage = function () {\r\n    // ignore the first message\r\n    initialize(function (ctx, createData) {\r\n        return new JSONWorker(ctx, createData);\r\n    });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25KQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSw2REFBNkQsS0FBSztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQzhEO0FBQ2pCO0FB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Z0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ08sbURBQW1EO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1Asc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUIsaUJBQWlCO0FBQzFEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNXZCQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUF1QjtBQUN2QztBQUNBO0FBQ0Esd0JBQXdCLGNBQXNCO0FBQzlDO0FBQ0Esb0NBQW9DLGdCQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOzs7QUNqUTdEO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ0w7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RCw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQ0FBZ0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEVBQUUsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQixRQUFnQjtBQUNuQyxpQkFBaUIsUUFBZ0I7QUFDakMsa0JBQWtCLFFBQWdCO0FBQ2xDLGlCQUFpQixRQUFnQjtBQUNqQyxrQkFBa0IsUUFBZ0I7QUFDbEMsaUJBQWlCLFFBQWdCO0FBQ2pDLGFBQWEsUUFBZ0I7OztBQ2wyQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQzBDO0FBQ1A7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBCQUEwQixjQUFjLFlBQVksU0FBUyxhQUFhLFVBQVUsZ0JBQWdCLGFBQWEsRUFBRTtBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsK0JBQStCLFVBQWdCO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IsVUFBZ0I7QUFDdEM7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWMsRUFBRSxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0IsR0FBRyxlQUFlLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQkFBK0IsR0FBRyxlQUFlLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUN6QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFDRDtBQUMzRDtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0o7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBOEI7QUFDNUM7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHFCQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLHVEQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIsZ0VBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDOUI7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ047QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0VBQW9FO0FBQzlEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQzFDO0FBQ1A7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwRUFBMEU7QUFDM0U7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUN0RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQSxXQUFXLDREQUE0RDtBQUN2RTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0VBQWtFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0VBQW9FO0FBQ3JFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBd0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwRUFBMEU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7OztBQ24zRGpCO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixJQUFJLHFCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csU0FBUztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxJQUFJLGlCQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0RBQXNELDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGlCQUFZLEtBQUssaUJBQVksS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dZO0FBQ3pTO0FBQ3VRO0FBQzlWO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQ3hCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUIsRUFBRSxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEOzs7QUM1Q2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxXQUFXLGlCQUFNO0FBQ2pCO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0I7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNvRDtBQUNrQztBQUNsQztBQUNzQztBQUNuQztBQUN4RCxJQUFJLG1CQUFRLEdBQUcsaUJBQXFCO0FBQ3BDO0FBQ0EsbUJBQW1CLGNBQWMsbUJBQVEsb0hBQW9ILElBQUksY0FBYyxFQUFFLEVBQUUsSUFBSSxLQUFLO0FBQzVMLG1CQUFtQixjQUFjLG1CQUFRLGdGQUFnRixFQUFFLG1KQUFtSjtBQUM5USxjQUFjLGNBQWMsbUJBQVEsdUVBQXVFLEVBQUUsK0NBQStDO0FBQzVKLGNBQWMsY0FBYyxtQkFBUSwyS0FBMks7QUFDL00sZUFBZSxjQUFjLG1CQUFRLHdGQUF3Rix5QkFBeUIsNkJBQTZCLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksZ0NBQWdDLEdBQUc7QUFDOVA7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrR0FBK0csK0JBQStCO0FBQzlJO0FBQ0E7QUFDQSxDQUFDO0FBQ3NCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM2QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQzJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUM4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQzRCO0FBQ3RCO0FBQ1AsUUFBUSxpQkFBUztBQUNqQiwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtQkFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOERBQThEO0FBQzlELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlDQUFpQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakU7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlELG9DQUFvQyxtQkFBUSx1REFBdUQsRUFBRSx1Q0FBdUMsMkJBQTJCO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMyQjtBQUNyQjtBQUNQLGtDQUFrQztBQUNsQztBQUNBO0FBQ08sU0FBUyx1QkFBWTtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNPLFNBQVMsc0JBQVc7QUFDM0IsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDTyxTQUFTLG1CQUFRO0FBQ3hCLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBWTtBQUN4Qyx1QkFBdUIsaUJBQWlCO0FBQ3hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRSxvREFBb0QsbUJBQVEsK0RBQStELEVBQUU7QUFDN0gsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFLG9EQUFvRCxtQkFBUSxvREFBb0QsRUFBRTtBQUNsSCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRSw2QkFBNkIsbUJBQVE7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEUsNkJBQTZCLG1CQUFRO0FBQ3JDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUFZO0FBQ2xDO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFLDBCQUEwQiwyQkFBMkI7QUFDckQsb0RBQW9ELG1CQUFRLHVEQUF1RCxFQUFFLG1DQUFtQywyQkFBMkI7QUFDbkwsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsc0JBQXNCLHVCQUFZO0FBQ2xDLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRSwwQkFBMEIsMkJBQTJCO0FBQ3JELG9EQUFvRCxtQkFBUSxpQ0FBaUMsRUFBRTtBQUMvRixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdEQUF3RDtBQUNwRiwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFLDZCQUE2QixtQkFBUSxrREFBa0QsRUFBRTtBQUN6RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFRO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBUTtBQUNwQjtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEUseUJBQXlCLG1CQUFRLHNFQUFzRSxFQUFFO0FBQ3pHLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxnQkFBUTtBQUNwQjtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEUseUJBQXlCLG1CQUFRLHNFQUFzRSxFQUFFO0FBQ3pHLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxnQkFBUTtBQUNwQjtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEUseUJBQXlCLG1CQUFRLG1EQUFtRCxFQUFFO0FBQ3RGLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxnQkFBUTtBQUNwQjtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEUseUJBQXlCLG1CQUFRLG1EQUFtRCxFQUFFO0FBQ3RGLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFRO0FBQ3BCO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RSx5QkFBeUIsbUJBQVEsb0VBQW9FLEVBQUU7QUFDdkcsYUFBYTtBQUNiO0FBQ0EsWUFBWSxnQkFBUTtBQUNwQjtBQUNBLDRCQUE0QiwwQ0FBMEM7QUFDdEUseUJBQXlCLG1CQUFRLG1FQUFtRSxFQUFFO0FBQ3RHLGFBQWE7QUFDYjtBQUNBLFlBQVksZ0JBQVE7QUFDcEIsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEM7QUFDMUUsa0ZBQWtGLG1CQUFRLDJEQUEyRCxFQUFFO0FBQ3ZKLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQVE7QUFDdkQ7QUFDQTtBQUNBLCtDQUErQyxtQkFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQ0FBMEM7QUFDdEYsOEZBQThGLG1CQUFRLDRDQUE0QyxFQUFFO0FBQ3BKLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBDQUEwQztBQUNsRjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVCQUF1QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBMEM7QUFDOUUsaUNBQWlDLG1CQUFRLG9GQUFvRixHQUFHO0FBQ2hJLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFLG9EQUFvRCxtQkFBUTtBQUM1RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFlBQVksZ0JBQVE7QUFDcEI7QUFDQSw0QkFBNEIsMENBQTBDO0FBQ3RFLHlCQUF5QixtQkFBUSx3REFBd0QsR0FBRztBQUM1RixhQUFhO0FBQ2I7QUFDQSxZQUFZLGdCQUFRO0FBQ3BCO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RSx5QkFBeUIsbUJBQVEseURBQXlELEdBQUc7QUFDN0YsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQVk7QUFDdkM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRSw2QkFBNkIsbUJBQVE7QUFDckMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaURBQWlELElBQUk7QUFDcEc7QUFDQTtBQUNBLGlDQUFpQyxtQkFBUSxtREFBbUQsRUFBRTtBQUM5RixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMEVBQTBFO0FBQ3RILGdFQUFnRSxtQkFBUSwwQ0FBMEMsR0FBRztBQUNySCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdCQUFnQjtBQUN6RjtBQUNBLDRCQUE0QixjQUFjO0FBQzFDLHNFQUFzRSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwRUFBMEU7QUFDOUgsd0VBQXdFLG1CQUFRLDBDQUEwQyxHQUFHO0FBQzdILHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHFDQUFxQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHFDQUFxQztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBFQUEwRTtBQUNsSCw0REFBNEQsbUJBQVEsMENBQTBDLEdBQUc7QUFDakgseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBUTtBQUNwQjtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRSw2QkFBNkIsbUJBQVEsOERBQThELEVBQUU7QUFDckcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxZQUFZLGdCQUFRO0FBQ3BCO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFLDZCQUE2QixtQkFBUSw2RUFBNkUsRUFBRTtBQUNwSCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdCQUFnQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDJCQUEyQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMENBQTBDO0FBQzFGLDZDQUE2QyxtQkFBUSw4REFBOEQsR0FBRyxzQkFBc0IsRUFBRTtBQUM5SSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVMsZ0JBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsd0JBQXdCO0FBQ3RFO0FBQ0Esd0JBQXdCLGlCQUFZO0FBQ3BDLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IseUNBQXlDO0FBQ3pDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBUSwyREFBMkQsd0JBQXdCO0FBQ2xIO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVEsbUVBQW1FLGdDQUFnQztBQUNsSTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFRLHdEQUF3RCwrQkFBK0I7QUFDdEg7QUFDQTtBQUNBLHVCQUF1QixtQkFBUSwwREFBMEQsZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVEsd0RBQXdELCtCQUErQjtBQUN0SDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFRLDJGQUEyRiwwQkFBMEI7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBUSxxQ0FBcUMsdUJBQXVCO0FBQy9GO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNDQUFzQyxtQkFBUSxxQ0FBcUMsdUJBQXVCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVEscUNBQXFDLHVCQUF1QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVEsd0NBQXdDLHVCQUF1QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBUSwrREFBK0Qsb0NBQW9DO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFRLGdFQUFnRSxtQkFBbUI7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQVEsaURBQWlELHNCQUFzQixrRUFBa0UsMEJBQTBCO0FBQ3JNO0FBQ0EsOEJBQThCLG1CQUFRLGlEQUFpRCxzQkFBc0Isa0VBQWtFLDBCQUEwQjtBQUN6TTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG1CQUFtQixtQkFBUSxxQ0FBcUMsdUJBQXVCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFRLHFDQUFxQyx1QkFBdUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBUSwyQ0FBMkMsMEJBQTBCO0FBQ3hHO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNDQUFzQyxtQkFBUSxxQ0FBcUMsdUJBQXVCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVEscUNBQXFDLHVCQUF1QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQVEsMkNBQTJDLDBCQUEwQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBUSwyREFBMkQsbUNBQW1DO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQVE7QUFDN0Isa0NBQWtDLG1CQUFRLG1EQUFtRCxtQkFBbUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQVEsbURBQW1ELG1CQUFtQjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFRLGlFQUFpRSxtQkFBbUI7QUFDL0c7QUFDQTtBQUNBLG1CQUFtQixtQkFBUSxtREFBbUQsbUJBQW1CO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBOzs7QUMzckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tEO0FBQ0c7QUFDRjtBQUNZO0FBQ2Y7QUFDNEU7QUFDcEU7QUFDeEQsSUFBSSx1QkFBUSxHQUFHLGlCQUFxQjtBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBWTtBQUN6QztBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBLDBFQUEwRSxnQ0FBMkI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4QkFBOEIsZ0NBQTJCO0FBQ3pEO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0NBQTJCO0FBQ2pFO0FBQ0E7QUFDQSxrREFBa0Qsd0JBQXdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0Esa0NBQWtDLGdDQUEyQjtBQUM3RDtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVDQUF1QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQTJCO0FBQ3JEO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUEyQjtBQUNqRDtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0I7QUFDOUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsZ0JBQWdCO0FBQzNHO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDhFQUE4RTtBQUNsSTtBQUNBO0FBQ0Esb0RBQW9ELDhFQUE4RTtBQUNsSTtBQUNBO0FBQ0Esb0RBQW9ELDhFQUE4RTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsd0JBQXdCLHVCQUFRO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0I7QUFDOUQsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0VBQWdFO0FBQ2hFLGtDQUFrQyx3QkFBd0I7QUFDMUQsd0JBQXdCLHVCQUFRO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQsd0JBQXdCLHVCQUFRO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpREFBaUQ7QUFDdkksZ0RBQWdEO0FBQ2hELGtCQUFrQiw4QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RCxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSxLQUFLO0FBQy9DO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRiw2RUFBNkU7QUFDN0UsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQXdCO0FBQzNDO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQXdCO0FBQzFELGtDQUFrQyw4QkFBeUI7QUFDM0Qsb0NBQW9DLGdDQUEyQjtBQUMvRCw0QkFBNEIsNkJBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxHQUFHO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxxTUFBcU0sbUJBQW1CO0FBQ3hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDeUI7OztBQ3I2QjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ2tEO0FBQ0Y7QUFDaEQ7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQWtCO0FBQ3pDLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQ0FBa0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsdUJBQW1CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNvQjtBQUNyQjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9HQSxRQUFRLFVBQVUsYUFBYSxPQUFPLFFBQVEsY0FBYyxnR0FBZ0csZ0JBQWdCLGdDQUFnQyxZQUFZLEtBQUssZ0NBQWdDLEtBQUssZ0JBQWdCLEtBQUssV0FBVyxtQkFBbUIsd0JBQXdCLGtHQUFrRyx5QkFBeUIsbUJBQW1CLHlFQUF5RSxVQUFVLG9DQUFvQyxpQkFBaUIsU0FBUyxvQ0FBb0MsK0RBQStELFFBQVEsNkJBQTZCLFNBQVMsT0FBTyxtQkFBbUIseUNBQXlDLFVBQVUsS0FBSyxNQUFNLDhHQUE4Ryx5REFBeUQsdUJBQXVCLCtCQUErQiwyREFBMkQsNEVBQTRFLHdCQUF3Qiw2Q0FBNkMsaUJBQWlCLGtDQUFrQyxjQUFjLG1CQUFtQixLQUFLLG1CQUFtQiwyQ0FBMkMscUNBQXFDLHdCQUF3Qiw0QkFBNEIsZ0RBQWdELFlBQVksaUNBQWlDLEtBQUssNkJBQTZCLGlDQUFpQyxLQUFLLHdDQUF3QyxLQUFLLEtBQUssVUFBVSxRQUFRLGdEQUFnRCw2QkFBNkIsb0RBQW9ELE1BQU0sd0JBQXdCLCtCQUErQixjQUFjLFNBQVMsWUFBWSxLQUFLLGlFQUFpRSw2RUFBNkUsdUJBQXVCLFNBQVMscUJBQXFCLCtCQUErQiwwREFBMEQsS0FBSyxpQ0FBaUMsT0FBTyxJQUFJLE9BQU8sVUFBVSxrREFBa0Qsd0JBQXdCLHlGQUF5RixLQUFLLG9CQUFvQiwrQ0FBK0MsdUNBQXVDLHNCQUFzQixpQkFBaUIsS0FBSyxLQUFLLHNCQUFzQixXQUFXLE9BQU8sTUFBTSxPQUFPLCtFQUErRSxtREFBbUQsaUJBQWlCLEtBQUssNkJBQTZCLE9BQU8sTUFBTSxPQUFPLHlCQUF5Qiw2QkFBNkIscUJBQXFCLEtBQUssNENBQTRDLEtBQUssS0FBSyxzQkFBc0IsNkVBQTZFLFlBQVksTUFBTSxPQUFPLHFFQUFxRSxvQkFBb0IsaUlBQWlJLHFCQUFxQix1REFBdUQsa0NBQWtDLE1BQU0sbUJBQW1CLEtBQUssT0FBTyx1Q0FBdUMseUJBQXlCLGlDQUFpQyx1QkFBdUIsNENBQTRDLEtBQUssbUdBQW1HLFlBQVksTUFBTSxNQUFNLDRRQUE0USw4Q0FBOEMsc0JBQXNCLGVBQWUsTUFBTSxpQkFBaUIsc0JBQXNCLHdEQUF3RCxvQ0FBb0MsMEJBQTBCLDBCQUEwQiwyQkFBMkIsaUNBQWlDLGFBQWEsZ0NBQWdDLGNBQWMsZ0JBQWdCLHNFQUFzRSxPQUFPLGVBQWUsYUFBYSxtQkFBbUIsNkVBQTZFLGdJQUFnSSx3QkFBd0IsK0xBQStMLHFCQUFxQixrREFBa0QsVUFBVSwwREFBMEQsU0FBUyxvRUFBb0UsaUVBQWlFLCtHQUErRyxHQUFHLGtHQUFrRywwQkFBMEIsK0tBQStLLG9LQUFvSyxVQUFVLDJCQUEyQiwyUEFBMlAsNkNBQTZDLGVBQWUsa0JBQWtCLCtCQUErQiwrQkFBK0Isa0JBQWtCLDZEQUE2RCxrVUFBa1UsdUJBQXVCLG1CQUFtQixnQkFBZ0IsdUZBQXVGLG9CQUFvQixRQUFRLGlEQUFpRCxxQkFBcUIsdUVBQXVFLDZCQUE2QixvQkFBb0IsNkRBQTZELGtDQUFrQyxvQ0FBb0MsK0JBQStCLFlBQVksc0JBQXNCLE1BQU0sMkJBQTJCLGVBQWUsb0VBQW9FLFNBQVMsR0FBRyw4QkFBOEIsYUFBYSw4Q0FBOEMsMENBQTBDLDBEQUEwRCxlQUFlLDREQUE0RCwrQkFBK0IsbUNBQW1DLHVHQUF1RywrQkFBK0IsT0FBTyxRQUFRLGdTQUFnUyxHQUFHLFlBQVksdU9BQXVPLGdCQUFnQiwwQkFBMEIsV0FBVyxLQUFLLHNCQUFzQiw2S0FBNkssS0FBSyw4QkFBOEIsV0FBVyx3RkFBd0YscUVBQXFFLGNBQWMscUJBQXFCLFdBQVcsS0FBSyxzQkFBc0IsNkVBQTZFLHNCQUFzQixnQkFBZ0IsTUFBTSxtVkFBbVYsZ0JBQWdCLDBFQUEwRSxvREFBb0QscUJBQXFCLFdBQVcsb0JBQW9CLGlIQUFpSCw2RkFBNkYsTUFBTSw2SUFBNkksMkNBQTJDLE1BQU0sOEVBQThFLFdBQVcsMkRBQTJELGNBQWMsSUFBSSw2QkFBNkIsU0FBUyxrREFBa0Qsb0NBQW9DLGNBQWMsMkNBQTJDLFlBQVksS0FBSyw0QkFBNEIsbUNBQW1DLElBQUksMkJBQTJCLG1CQUFtQixRQUFRLElBQUksMENBQTBDLElBQUksa0JBQWtCLFNBQVMsY0FBYyxhQUFhLHVCQUF1QixpQkFBaUIsbUJBQW1CLHdCQUF3QixlQUFlLG1DQUFtQyxFQUFFLDJCQUEyQixpQkFBaUIsbUJBQW1CLHdCQUF3QixrQkFBa0IsZUFBZSxpQ0FBaUMsRUFBRSx1QkFBdUIsd0JBQXdCLG9EQUFvRCxPQUFPLEVBQUUsd0JBQXdCLDBCQUEwQix1QkFBdUIsMEJBQTBCLFNBQVMsSUFBSSxNQUFNLGNBQWMsNEJBQTRCLFlBQVksWUFBWSxxQ0FBcUMsbUJBQW1CLCtEQUErRCx1QkFBdUIsRUFBRSw4REFBOEQsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxRQUFRLElBQVcsTUFBTSxHQUFHLHVCQUFPOzs7QUNBaDBXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLDZHQUE2RyxJQUFJO0FBQ2pIO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRDtBQUNIO0FBQ0g7QUFDRztBQUNNO0FBQ1Q7QUFDL0MsSUFBSSwwQkFBUSxHQUFHLGlCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsMEJBQTBCLGdDQUFnQztBQUNyRztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMkI7QUFDNUI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0EsNEJBQTRCLGNBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN5QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFTO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZ0NBQWdDO0FBQ3JHO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usa0NBQWtDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEJBQVEsZ0VBQWdFLEVBQUU7QUFDekcsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBUSx5REFBeUQsRUFBRTtBQUN0Ryw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsOENBQThDLDBCQUFRLCtEQUErRCxFQUFFLDJCQUEyQixFQUFFO0FBQ3BKO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFnQjtBQUNoQztBQUNBO0FBQ0EsMENBQTBDLEdBQUcsMEJBQVEseURBQXlELEVBQUUsS0FBSyxFQUFFO0FBQ3ZILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUcsMEJBQVE7QUFDNUU7QUFDQTtBQUNBLG1DQUFtQywwQkFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQVEsb0NBQW9DLEVBQUUsU0FBUyxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBUSxpRUFBaUUsRUFBRSxLQUFLLEVBQUU7QUFDekg7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0Esc0RBQXNELHVCQUF1QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0Esb0RBQW9ELHNCQUFzQjtBQUMxRTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixtREFBbUQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YseUZBQXlGO0FBQzNLO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1QkFBbUI7QUFDdEQsb0NBQW9DLFVBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxVQUFVLGdCQUFnQixJQUFJO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGLG9HQUFvRyxxQkFBcUI7QUFDekgsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixxQkFBcUI7QUFDakg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQVMsa0JBQWtCLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDaUM7QUFDbkM7QUFDUjtBQUNoRCxJQUFJLHVCQUFRLEdBQUcsaUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx3QkFBd0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd01BQXdNLHdCQUF3QjtBQUNoTztBQUNBLHVNQUF1TSwwQkFBMEI7QUFDak8sOExBQThMLDBCQUEwQjtBQUN4TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQVk7QUFDaEQsbUNBQW1DLGlCQUFpQix5Q0FBeUMsNEJBQTRCO0FBQ3pIO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQVk7QUFDaEQsbUNBQW1DLGlCQUFpQix5Q0FBeUMsNEJBQTRCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQVE7QUFDeEM7QUFDQSwrQkFBK0IsaUJBQWlCLGdDQUFnQyw2QkFBNkI7QUFDN0csaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdCQUFTO0FBQzFFLG1FQUFtRSxnQkFBZ0IsZ0JBQWdCO0FBQ25HO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUN5QjtBQUMxQixJQUFJLHdCQUFTO0FBQ2I7QUFDQTtBQUNBLFlBQVksaUJBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBUywyQ0FBMkM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3QkFBd0I7QUFDckQsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDa0Q7QUFDSDtBQUNHO0FBQzhCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFFBQWdCO0FBQ2hHO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSwrREFBK0QsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RCxnREFBZ0QsTUFBTSx1QkFBbUIsNEJBQTRCLHdCQUFtQixzQkFBc0I7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMENBQTBDO0FBQ2pGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQSwwQ0FBMEMsZ0lBQWdJO0FBQzFLLDJDQUEyQyxvREFBb0Q7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsUUFBZ0I7QUFDaEc7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTSx1QkFBbUIsNEJBQTRCLHdCQUFtQixnREFBZ0Q7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkNBQTJDLHFDQUFxQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkNBQTJDLG1DQUFtQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBaUI7QUFDeEM7QUFDQSx1QkFBdUIsc0JBQWlCO0FBQ3hDO0FBQ0EsdUJBQXVCLHNCQUFpQjtBQUN4QztBQUNBLHVCQUF1QixxQkFBZ0I7QUFDdkM7QUFDQSx1QkFBdUIsdUJBQWtCO0FBQ3pDO0FBQ0EsdUJBQXVCLHdCQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwrQkFBK0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxDQUFDLHVCQUFtQjtBQUN4RTtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0IsZ0JBQWdCLGdDQUFnQztBQUM5RjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQy9CO0FBQ0EsV0FBVyxpQkFBWTtBQUN2Qjs7O0FDclJBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dEO0FBQ3hELElBQUksc0JBQVEsR0FBRyxpQkFBcUI7QUFDN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7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QTtBQUNBO0FBQ0E7QUFDd0Q7QUFDWDtBQUM3QztBQUNBO0FBQ0EsSUFBSSxVQUFpQjtBQUNyQixtQkFBbUIsVUFBVTtBQUM3QixLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXJyb3JzLmpzP2ZkY2MiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2Z1bmN0aW9uYWwuanM/MGJmYiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaXRlcmF0b3IuanM/MjU4YSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlmZWN5Y2xlLmpzP2E2NjYiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3BsYXRmb3JtLmpzPzMwZGIiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3R5cGVzLmpzP2VmOGUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanM/MWIxZiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmQ2hhbmdlLmpzPzE1ZjEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3N0cmluZ3MuanM/Mzc0MiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaGFzaC5qcz9lZGE3Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanM/MWIwZSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vcHJvY2Vzcy5qcz9jMzE3Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wYXRoLmpzPzMyYjgiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VyaS5qcz82ZDhlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvcG9zaXRpb24uanM/NzA2MSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3JhbmdlLmpzPzZhODkiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kaWZmQ29tcHV0ZXIuanM/MjJlOSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vdWludC5qcz8wOTlkIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3ZpZXdNb2RlbC9wcmVmaXhTdW1Db21wdXRlci5qcz8yZGU1Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL21pcnJvclRleHRNb2RlbC5qcz9hNDExIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL21vZGVsL3dvcmRIZWxwZXIuanM/ZDA5MyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanM/MzE3MCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9saW5rQ29tcHV0ZXIuanM/MzgzMiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2Rlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanM/MmUwYyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcz9kYjg4Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9zdG9wd2F0Y2guanM/ZTU4ZSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZXZlbnQuanM/MzA4ZiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzPzI1MDQiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2tleUNvZGVzLmpzP2ZlNDUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9zZWxlY3Rpb24uanM/ODAyNSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Rva2VuLmpzPzRkYzciLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc3RhbmRhbG9uZS9zdGFuZGFsb25lRW51bXMuanM/Njg4MSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zdGFuZGFsb25lL3N0YW5kYWxvbmVCYXNlLmpzPzZlYWIiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yU2ltcGxlV29ya2VyLmpzP2NjZjYiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9lZGl0b3Iud29ya2VyLmpzP2U1MDAiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvanNvbmMtcGFyc2VyL2ltcGwvc2Nhbm5lci5qcz80NTRlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL2pzb25jLXBhcnNlci9pbXBsL2Zvcm1hdC5qcz9mZjg2Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL2pzb25jLXBhcnNlci9pbXBsL3BhcnNlci5qcz8yODU2Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL2pzb25jLXBhcnNlci9pbXBsL2VkaXQuanM/NzA5ZSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy9qc29uYy1wYXJzZXIvbWFpbi5qcz9jMmZjIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS91dGlscy9vYmplY3RzLmpzP2UzMTUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3V0aWxzL3N0cmluZ3MuanM/MDM5NSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbWFpbi5qcz9lNjk3Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQvbGliL2VzbS9tYWluLmpzP2VjYzkiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2pzb25MYW5ndWFnZVR5cGVzLmpzPzJjOTEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vZmlsbGVycy92c2NvZGUtbmxzLmpzPzAwMmUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3BhcnNlci9qc29uUGFyc2VyLmpzPzZhMWIiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3V0aWxzL2pzb24uanM/NWJlYiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvbkNvbXBsZXRpb24uanM/MzA4ZCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvbkhvdmVyLmpzPzBiNjMiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLXVyaS9pbmRleC5qcz9jNjIzIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS91dGlscy9nbG9iLmpzPzkxM2MiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3NlcnZpY2VzL2pzb25TY2hlbWFTZXJ2aWNlLmpzP2JhMjMiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3NlcnZpY2VzL2pzb25WYWxpZGF0aW9uLmpzP2IyZjciLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3V0aWxzL2NvbG9ycy5qcz9iNzdlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9zZXJ2aWNlcy9qc29uRG9jdW1lbnRTeW1ib2xzLmpzP2QxOWQiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2xhbmd1YWdlL2pzb24vX2RlcHMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL3NlcnZpY2VzL2NvbmZpZ3VyYXRpb24uanM/OWU0ZCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvbkZvbGRpbmcuanM/YjdkMSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2Uvc2VydmljZXMvanNvblNlbGVjdGlvblJhbmdlcy5qcz9iMWE2Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL19kZXBzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9zZXJ2aWNlcy9qc29uTGlua3MuanM/NTU2MSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvanNvbkxhbmd1YWdlU2VydmljZS5qcz81MmJjIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9sYW5ndWFnZS9qc29uL2pzb25Xb3JrZXIuanM/NTE3YiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvanNvbi9qc29uLndvcmtlci5qcz9mMTlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgb24gRXZlbnRFbWl0dGVyIGJ5IGltcGxlbWVudGluZyBhIHN1YnNldCBvZiB0aGUgaW50ZXJmYWNlLlxyXG5leHBvcnQgY2xhc3MgRXJyb3JIYW5kbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdGFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UgKyAnXFxuXFxuJyArIGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVtaXQoZSkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25VbmV4cGVjdGVkRXJyb3IoZSkge1xyXG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlcihlKTtcclxuICAgICAgICB0aGlzLmVtaXQoZSk7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgZXh0ZXJuYWwgZXJyb3JzLCB3ZSBkb24ndCB3YW50IHRoZSBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkXHJcbiAgICBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcclxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWRFcnJvckhhbmRsZXIoZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNvbnN0IGVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXIoKTtcclxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcclxuICAgIC8vIGlnbm9yZSBlcnJvcnMgZnJvbSBjYW5jZWxsZWQgcHJvbWlzZXNcclxuICAgIGlmICghaXNQcm9taXNlQ2FuY2VsZWRFcnJvcihlKSkge1xyXG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFcnJvcihlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEV4dGVybmFsRXJyb3IoZSkge1xyXG4gICAgLy8gaWdub3JlIGVycm9ycyBmcm9tIGNhbmNlbGxlZCBwcm9taXNlc1xyXG4gICAgaWYgKCFpc1Byb21pc2VDYW5jZWxlZEVycm9yKGUpKSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyLm9uVW5leHBlY3RlZEV4dGVybmFsRXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24oZXJyb3IpIHtcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgbGV0IHsgbmFtZSwgbWVzc2FnZSB9ID0gZXJyb3I7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBlcnJvci5zdGFja3RyYWNlIHx8IGVycm9yLnN0YWNrO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICRpc0Vycm9yOiB0cnVlLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICBzdGFja1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gYXMgaXNcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG5jb25zdCBjYW5jZWxlZE5hbWUgPSAnQ2FuY2VsZWQnO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhIHByb21pc2UgaW4gY2FuY2VsZWQgc3RhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2VDYW5jZWxlZEVycm9yKGVycm9yKSB7XHJcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBjYW5jZWxlZE5hbWUgJiYgZXJyb3IubWVzc2FnZSA9PT0gY2FuY2VsZWROYW1lO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGVycm9yIHRoYXQgc2lnbmFscyBjYW5jZWxsYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsZWQoKSB7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjYW5jZWxlZE5hbWUpO1xyXG4gICAgZXJyb3IubmFtZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlsbGVnYWxBcmd1bWVudChuYW1lKSB7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYElsbGVnYWwgYXJndW1lbnQ6ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgYXJndW1lbnQnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaWxsZWdhbFN0YXRlKG5hbWUpIHtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSWxsZWdhbCBzdGF0ZTogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSWxsZWdhbCBzdGF0ZScpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xyXG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xyXG4gICAgbGV0IGRpZENhbGwgPSBmYWxzZTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChkaWRDYWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xyXG4gICAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgdmFyIEl0ZXJhYmxlO1xyXG4oZnVuY3Rpb24gKEl0ZXJhYmxlKSB7XHJcbiAgICBmdW5jdGlvbiBpcyh0aGluZykge1xyXG4gICAgICAgIHJldHVybiB0aGluZyAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuaXMgPSBpcztcclxuICAgIGNvbnN0IF9lbXB0eSA9IE9iamVjdC5mcmVlemUoW10pO1xyXG4gICAgZnVuY3Rpb24gZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9lbXB0eTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmVtcHR5ID0gZW1wdHk7XHJcbiAgICBmdW5jdGlvbiogc2luZ2xlKGVsZW1lbnQpIHtcclxuICAgICAgICB5aWVsZCBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuc2luZ2xlID0gc2luZ2xlO1xyXG4gICAgZnVuY3Rpb24gZnJvbShpdGVyYWJsZSkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYWJsZSB8fCBfZW1wdHk7XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5mcm9tID0gZnJvbTtcclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkoaXRlcmFibGUpIHtcclxuICAgICAgICByZXR1cm4gIWl0ZXJhYmxlIHx8IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSA9PT0gdHJ1ZTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmlzRW1wdHkgPSBpc0VtcHR5O1xyXG4gICAgZnVuY3Rpb24gZmlyc3QoaXRlcmFibGUpIHtcclxuICAgICAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS52YWx1ZTtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmZpcnN0ID0gZmlyc3Q7XHJcbiAgICBmdW5jdGlvbiBzb21lKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuc29tZSA9IHNvbWU7XHJcbiAgICBmdW5jdGlvbiBmaW5kKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLmZpbmQgPSBmaW5kO1xyXG4gICAgZnVuY3Rpb24qIGZpbHRlcihpdGVyYWJsZSwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICBmdW5jdGlvbiogbWFwKGl0ZXJhYmxlLCBmbikge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGZuKGVsZW1lbnQsIGluZGV4KyspO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEl0ZXJhYmxlLm1hcCA9IG1hcDtcclxuICAgIGZ1bmN0aW9uKiBjb25jYXQoLi4uaXRlcmFibGVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuY29uY2F0ID0gY29uY2F0O1xyXG4gICAgZnVuY3Rpb24qIGNvbmNhdE5lc3RlZChpdGVyYWJsZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZXJhYmxlIG9mIGl0ZXJhYmxlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5jb25jYXROZXN0ZWQgPSBjb25jYXROZXN0ZWQ7XHJcbiAgICBmdW5jdGlvbiByZWR1Y2UoaXRlcmFibGUsIHJlZHVjZXIsIGluaXRpYWxWYWx1ZSkge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSByZWR1Y2VyKHZhbHVlLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgSXRlcmFibGUucmVkdWNlID0gcmVkdWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhYmxlIHNsaWNlIG9mIHRoZSBhcnJheSwgd2l0aCB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgYGFycmF5LnNsaWNlKClgLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiogc2xpY2UoYXJyLCBmcm9tLCB0byA9IGFyci5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcclxuICAgICAgICAgICAgZnJvbSArPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG8gPCAwKSB7XHJcbiAgICAgICAgICAgIHRvICs9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRvID4gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0byA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBmcm9tIDwgdG87IGZyb20rKykge1xyXG4gICAgICAgICAgICB5aWVsZCBhcnJbZnJvbV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSXRlcmFibGUuc2xpY2UgPSBzbGljZTtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3VtZXMgYGF0TW9zdGAgZWxlbWVudHMgZnJvbSBpdGVyYWJsZSBhbmQgcmV0dXJucyB0aGUgY29uc3VtZWQgZWxlbWVudHMsXHJcbiAgICAgKiBhbmQgYW4gaXRlcmFibGUgZm9yIHRoZSByZXN0IG9mIHRoZSBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29uc3VtZShpdGVyYWJsZSwgYXRNb3N0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XHJcbiAgICAgICAgY29uc3QgY29uc3VtZWQgPSBbXTtcclxuICAgICAgICBpZiAoYXRNb3N0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29uc3VtZWQsIGl0ZXJhYmxlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdE1vc3Q7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCBJdGVyYWJsZS5lbXB0eSgpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdW1lZC5wdXNoKG5leHQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCB7IFtTeW1ib2wuaXRlcmF0b3JdKCkgeyByZXR1cm4gaXRlcmF0b3I7IH0gfV07XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5jb25zdW1lID0gY29uc3VtZTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVyYWJsZXMgYXJlIHRoZSBzYW1lIGxlbmd0aCBhbmQgYWxsIGl0ZW1zIGFyZVxyXG4gICAgICogZXF1YWwgdXNpbmcgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiLCBjb21wYXJhdG9yID0gKGF0LCBidCkgPT4gYXQgPT09IGJ0KSB7XHJcbiAgICAgICAgY29uc3QgYWkgPSBhW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICBjb25zdCBiaSA9IGJbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuID0gYWkubmV4dCgpO1xyXG4gICAgICAgICAgICBjb25zdCBibiA9IGJpLm5leHQoKTtcclxuICAgICAgICAgICAgaWYgKGFuLmRvbmUgIT09IGJuLmRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhbi5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghY29tcGFyYXRvcihhbi52YWx1ZSwgYm4udmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJdGVyYWJsZS5lcXVhbHMgPSBlcXVhbHM7XHJcbn0pKEl0ZXJhYmxlIHx8IChJdGVyYWJsZSA9IHt9KSk7XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBvbmNlIH0gZnJvbSAnLi9mdW5jdGlvbmFsLmpzJztcclxuaW1wb3J0IHsgSXRlcmFibGUgfSBmcm9tICcuL2l0ZXJhdG9yLmpzJztcclxuLyoqXHJcbiAqIEVuYWJsZXMgbG9nZ2luZyBvZiBwb3RlbnRpYWxseSBsZWFrZWQgZGlzcG9zYWJsZXMuXHJcbiAqXHJcbiAqIEEgZGlzcG9zYWJsZSBpcyBjb25zaWRlcmVkIGxlYWtlZCBpZiBpdCBpcyBub3QgZGlzcG9zZWQgb3Igbm90IHJlZ2lzdGVyZWQgYXMgdGhlIGNoaWxkIG9mXHJcbiAqIGFub3RoZXIgZGlzcG9zYWJsZS4gVGhpcyB0cmFja2luZyBpcyB2ZXJ5IHNpbXBsZSBhbiBvbmx5IHdvcmtzIGZvciBjbGFzc2VzIHRoYXQgZWl0aGVyXHJcbiAqIGV4dGVuZCBEaXNwb3NhYmxlIG9yIHVzZSBhIERpc3Bvc2FibGVTdG9yZS4gVGhpcyBtZWFucyB0aGVyZSBhcmUgYSBsb3Qgb2YgZmFsc2UgcG9zaXRpdmVzLlxyXG4gKi9cclxuY29uc3QgVFJBQ0tfRElTUE9TQUJMRVMgPSBmYWxzZTtcclxubGV0IGRpc3Bvc2FibGVUcmFja2VyID0gbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHNldERpc3Bvc2FibGVUcmFja2VyKHRyYWNrZXIpIHtcclxuICAgIGRpc3Bvc2FibGVUcmFja2VyID0gdHJhY2tlcjtcclxufVxyXG5pZiAoVFJBQ0tfRElTUE9TQUJMRVMpIHtcclxuICAgIGNvbnN0IF9faXNfZGlzcG9zYWJsZV90cmFja2VkX18gPSAnX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfXyc7XHJcbiAgICBzZXREaXNwb3NhYmxlVHJhY2tlcihuZXcgY2xhc3Mge1xyXG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCdQb3RlbnRpYWxseSBsZWFrZWQgZGlzcG9zYWJsZScpLnN0YWNrO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgheFtfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMzAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFBhcmVudChjaGlsZCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gRGlzcG9zYWJsZS5Ob25lKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwb3NhYmxlICYmIGRpc3Bvc2FibGUgIT09IERpc3Bvc2FibGUuTm9uZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlW19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrQXNTaW5nbGV0b24oZGlzcG9zYWJsZSkgeyB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB0cmFja0Rpc3Bvc2FibGUoeCkge1xyXG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLnRyYWNrRGlzcG9zYWJsZSh4KTtcclxuICAgIHJldHVybiB4O1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtBc0Rpc3Bvc2VkKGRpc3Bvc2FibGUpIHtcclxuICAgIGRpc3Bvc2FibGVUcmFja2VyID09PSBudWxsIHx8IGRpc3Bvc2FibGVUcmFja2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXNwb3NhYmxlVHJhY2tlci5tYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKTtcclxufVxyXG5mdW5jdGlvbiBzZXRQYXJlbnRPZkRpc3Bvc2FibGUoY2hpbGQsIHBhcmVudCkge1xyXG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLnNldFBhcmVudChjaGlsZCwgcGFyZW50KTtcclxufVxyXG5mdW5jdGlvbiBzZXRQYXJlbnRPZkRpc3Bvc2FibGVzKGNoaWxkcmVuLCBwYXJlbnQpIHtcclxuICAgIGlmICghZGlzcG9zYWJsZVRyYWNrZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgZGlzcG9zYWJsZVRyYWNrZXIuc2V0UGFyZW50KGNoaWxkLCBwYXJlbnQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgc2luZ2xldG9uIHdoaWNoIGRvZXMgbm90IG5lZWQgdG8gYmUgZGlzcG9zZWQuXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNTaW5nbGV0b24oc2luZ2xldG9uKSB7XHJcbiAgICBkaXNwb3NhYmxlVHJhY2tlciA9PT0gbnVsbCB8fCBkaXNwb3NhYmxlVHJhY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZVRyYWNrZXIubWFya0FzU2luZ2xldG9uKHNpbmdsZXRvbik7XHJcbiAgICByZXR1cm4gc2luZ2xldG9uO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBNdWx0aURpc3Bvc2VFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xyXG4gICAgICAgIHN1cGVyKGBFbmNvdW50ZXJlZCBlcnJvcnMgd2hpbGUgZGlzcG9zaW5nIG9mIHN0b3JlLiBFcnJvcnM6IFske2Vycm9ycy5qb2luKCcsICcpfV1gKTtcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNEaXNwb3NhYmxlKHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcuZGlzcG9zZS5sZW5ndGggPT09IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2UoYXJnKSB7XHJcbiAgICBpZiAoSXRlcmFibGUuaXMoYXJnKSkge1xyXG4gICAgICAgIGxldCBlcnJvcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGQgb2YgYXJnKSB7XHJcbiAgICAgICAgICAgIGlmIChkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVycm9ycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBNdWx0aURpc3Bvc2VFcnJvcihlcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpID8gW10gOiBhcmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhcmcpIHtcclxuICAgICAgICBhcmcuZGlzcG9zZSgpO1xyXG4gICAgICAgIHJldHVybiBhcmc7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVkRGlzcG9zYWJsZSguLi5kaXNwb3NhYmxlcykge1xyXG4gICAgY29uc3QgcGFyZW50ID0gdG9EaXNwb3NhYmxlKCgpID0+IGRpc3Bvc2UoZGlzcG9zYWJsZXMpKTtcclxuICAgIHNldFBhcmVudE9mRGlzcG9zYWJsZXMoZGlzcG9zYWJsZXMsIHBhcmVudCk7XHJcbiAgICByZXR1cm4gcGFyZW50O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Rpc3Bvc2FibGUoZm4pIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0cmFja0Rpc3Bvc2FibGUoe1xyXG4gICAgICAgIGRpc3Bvc2U6IG9uY2UoKCkgPT4ge1xyXG4gICAgICAgICAgICBtYXJrQXNEaXNwb3NlZChzZWxmKTtcclxuICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc2VsZjtcclxufVxyXG5leHBvcnQgY2xhc3MgRGlzcG9zYWJsZVN0b3JlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3RvRGlzcG9zZSA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlIG9mIGFsbCByZWdpc3RlcmVkIGRpc3Bvc2FibGVzIGFuZCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEFueSBmdXR1cmUgZGlzcG9zYWJsZXMgYWRkZWQgdG8gdGhpcyBvYmplY3Qgd2lsbCBiZSBkaXNwb3NlZCBvZiBvbiBgYWRkYC5cclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtBc0Rpc3Bvc2VkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZSBvZiBhbGwgcmVnaXN0ZXJlZCBkaXNwb3NhYmxlcyBidXQgZG8gbm90IG1hcmsgdGhpcyBvYmplY3QgYXMgZGlzcG9zZWQuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRpc3Bvc2UodGhpcy5fdG9EaXNwb3NlLnZhbHVlcygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvRGlzcG9zZS5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZChvKSB7XHJcbiAgICAgICAgaWYgKCFvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobyA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIGRpc3Bvc2FibGUgb24gaXRzZWxmIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUobywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFEaXNwb3NhYmxlU3RvcmUuRElTQUJMRV9ESVNQT1NFRF9XQVJOSU5HKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCdUcnlpbmcgdG8gYWRkIGEgZGlzcG9zYWJsZSB0byBhIERpc3Bvc2FibGVTdG9yZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgb2YuIFRoZSBhZGRlZCBvYmplY3Qgd2lsbCBiZSBsZWFrZWQhJykuc3RhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuYWRkKG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxufVxyXG5EaXNwb3NhYmxlU3RvcmUuRElTQUJMRV9ESVNQT1NFRF9XQVJOSU5HID0gZmFsc2U7XHJcbmV4cG9ydCBjbGFzcyBEaXNwb3NhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3JlID0gbmV3IERpc3Bvc2FibGVTdG9yZSgpO1xyXG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcclxuICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUodGhpcy5fc3RvcmUsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9zdG9yZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBfcmVnaXN0ZXIobykge1xyXG4gICAgICAgIGlmIChvID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyIGEgZGlzcG9zYWJsZSBvbiBpdHNlbGYhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5hZGQobyk7XHJcbiAgICB9XHJcbn1cclxuRGlzcG9zYWJsZS5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7IGRpc3Bvc2UoKSB7IH0gfSk7XHJcbi8qKlxyXG4gKiBNYW5hZ2VzIHRoZSBsaWZlY3ljbGUgb2YgYSBkaXNwb3NhYmxlIHZhbHVlIHRoYXQgbWF5IGJlIGNoYW5nZWQuXHJcbiAqXHJcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gdGhlIGRpc3Bvc2FibGUgdmFsdWUgaXMgY2hhbmdlZCwgdGhlIHByZXZpb3VzbHkgaGVsZCBkaXNwb3NhYmxlIGlzIGRpc3Bvc2VkIG9mLiBZb3UgY2FuXHJcbiAqIGFsc28gcmVnaXN0ZXIgYSBgTXV0YWJsZURpc3Bvc2FibGVgIG9uIGEgYERpc3Bvc2FibGVgIHRvIGVuc3VyZSBpdCBpcyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTXV0YWJsZURpc3Bvc2FibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZCA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkIHx8IHZhbHVlID09PSB0aGlzLl92YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYSA9IHRoaXMuX3ZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUodmFsdWUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIG1hcmtBc0Rpc3Bvc2VkKHRoaXMpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX3ZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIHZhbHVlLCBidXQgZG9lcyBub3QgZGlzcG9zZSBpdC5cclxuICAgICAqIFRoZSBvbGQgdmFsdWUgaXMgcmV0dXJuZWQuXHJcbiAgICAqL1xyXG4gICAgY2xlYXJBbmRMZWFrKCkge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHNldFBhcmVudE9mRGlzcG9zYWJsZShvbGRWYWx1ZSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvbGRWYWx1ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSW1tb3J0YWxSZWZlcmVuY2Uge1xyXG4gICAgY29uc3RydWN0b3Iob2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkgeyB9XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBfYTtcclxuY29uc3QgTEFOR1VBR0VfREVGQVVMVCA9ICdlbic7XHJcbmxldCBfaXNXaW5kb3dzID0gZmFsc2U7XHJcbmxldCBfaXNNYWNpbnRvc2ggPSBmYWxzZTtcclxubGV0IF9pc0xpbnV4ID0gZmFsc2U7XHJcbmxldCBfaXNMaW51eFNuYXAgPSBmYWxzZTtcclxubGV0IF9pc05hdGl2ZSA9IGZhbHNlO1xyXG5sZXQgX2lzV2ViID0gZmFsc2U7XHJcbmxldCBfaXNJT1MgPSBmYWxzZTtcclxubGV0IF9sb2NhbGUgPSB1bmRlZmluZWQ7XHJcbmxldCBfbGFuZ3VhZ2UgPSBMQU5HVUFHRV9ERUZBVUxUO1xyXG5sZXQgX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGUgPSB1bmRlZmluZWQ7XHJcbmxldCBfdXNlckFnZW50ID0gdW5kZWZpbmVkO1xyXG5leHBvcnQgY29uc3QgZ2xvYmFscyA9ICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDogdHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgPyBnbG9iYWwgOiB7fSk7XHJcbmxldCBub2RlUHJvY2VzcyA9IHVuZGVmaW5lZDtcclxuaWYgKHR5cGVvZiBnbG9iYWxzLnZzY29kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbHMudnNjb2RlLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBOYXRpdmUgZW52aXJvbm1lbnQgKHNhbmRib3hlZClcclxuICAgIG5vZGVQcm9jZXNzID0gZ2xvYmFscy52c2NvZGUucHJvY2VzcztcclxufVxyXG5lbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vIE5hdGl2ZSBlbnZpcm9ubWVudCAobm9uLXNhbmRib3hlZClcclxuICAgIG5vZGVQcm9jZXNzID0gcHJvY2VzcztcclxufVxyXG5jb25zdCBpc0VsZWN0cm9uUmVuZGVyZXIgPSB0eXBlb2YgKChfYSA9IG5vZGVQcm9jZXNzID09PSBudWxsIHx8IG5vZGVQcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZWN0cm9uKSA9PT0gJ3N0cmluZycgJiYgbm9kZVByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJztcclxuZXhwb3J0IGNvbnN0IGlzRWxlY3Ryb25TYW5kYm94ZWQgPSBpc0VsZWN0cm9uUmVuZGVyZXIgJiYgKG5vZGVQcm9jZXNzID09PSBudWxsIHx8IG5vZGVQcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvY2Vzcy5zYW5kYm94ZWQpO1xyXG5leHBvcnQgY29uc3QgYnJvd3NlckNvZGVMb2FkaW5nQ2FjaGVTdHJhdGVneSA9ICgoKSA9PiB7XHJcbiAgICAvLyBBbHdheXMgZW5hYmxlZCB3aGVuIHNhbmRib3ggaXMgZW5hYmxlZFxyXG4gICAgaWYgKGlzRWxlY3Ryb25TYW5kYm94ZWQpIHtcclxuICAgICAgICByZXR1cm4gJ2J5cGFzc0hlYXRDaGVjayc7XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlcndpc2UsIG9ubHkgZW5hYmxlZCBjb25kaXRpb25hbGx5XHJcbiAgICBjb25zdCBlbnYgPSBub2RlUHJvY2VzcyA9PT0gbnVsbCB8fCBub2RlUHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2Nlc3MuZW52WydWU0NPREVfQlJPV1NFUl9DT0RFX0xPQURJTkcnXTtcclxuICAgIGlmICh0eXBlb2YgZW52ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChlbnYgPT09ICdub25lJyB8fCBlbnYgPT09ICdjb2RlJyB8fCBlbnYgPT09ICdieXBhc3NIZWF0Q2hlY2snIHx8IGVudiA9PT0gJ2J5cGFzc0hlYXRDaGVja0FuZEVhZ2VyQ29tcGlsZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdieXBhc3NIZWF0Q2hlY2snO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufSkoKTtcclxuZXhwb3J0IGNvbnN0IGlzUHJlZmVycmluZ0Jyb3dzZXJDb2RlTG9hZCA9IHR5cGVvZiBicm93c2VyQ29kZUxvYWRpbmdDYWNoZVN0cmF0ZWd5ID09PSAnc3RyaW5nJztcclxuLy8gV2ViIGVudmlyb25tZW50XHJcbmlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiAhaXNFbGVjdHJvblJlbmRlcmVyKSB7XHJcbiAgICBfdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgIF9pc1dpbmRvd3MgPSBfdXNlckFnZW50LmluZGV4T2YoJ1dpbmRvd3MnKSA+PSAwO1xyXG4gICAgX2lzTWFjaW50b3NoID0gX3VzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwO1xyXG4gICAgX2lzSU9TID0gKF91c2VyQWdlbnQuaW5kZXhPZignTWFjaW50b3NoJykgPj0gMCB8fCBfdXNlckFnZW50LmluZGV4T2YoJ2lQYWQnKSA+PSAwIHx8IF91c2VyQWdlbnQuaW5kZXhPZignaVBob25lJykgPj0gMCkgJiYgISFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcclxuICAgIF9pc0xpbnV4ID0gX3VzZXJBZ2VudC5pbmRleE9mKCdMaW51eCcpID49IDA7XHJcbiAgICBfaXNXZWIgPSB0cnVlO1xyXG4gICAgX2xvY2FsZSA9IG5hdmlnYXRvci5sYW5ndWFnZTtcclxuICAgIF9sYW5ndWFnZSA9IF9sb2NhbGU7XHJcbn1cclxuLy8gTmF0aXZlIGVudmlyb25tZW50XHJcbmVsc2UgaWYgKHR5cGVvZiBub2RlUHJvY2VzcyA9PT0gJ29iamVjdCcpIHtcclxuICAgIF9pc1dpbmRvd3MgPSAobm9kZVByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpO1xyXG4gICAgX2lzTWFjaW50b3NoID0gKG5vZGVQcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyk7XHJcbiAgICBfaXNMaW51eCA9IChub2RlUHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jyk7XHJcbiAgICBfaXNMaW51eFNuYXAgPSBfaXNMaW51eCAmJiAhIW5vZGVQcm9jZXNzLmVudlsnU05BUCddICYmICEhbm9kZVByb2Nlc3MuZW52WydTTkFQX1JFVklTSU9OJ107XHJcbiAgICBfbG9jYWxlID0gTEFOR1VBR0VfREVGQVVMVDtcclxuICAgIF9sYW5ndWFnZSA9IExBTkdVQUdFX0RFRkFVTFQ7XHJcbiAgICBjb25zdCByYXdObHNDb25maWcgPSBub2RlUHJvY2Vzcy5lbnZbJ1ZTQ09ERV9OTFNfQ09ORklHJ107XHJcbiAgICBpZiAocmF3TmxzQ29uZmlnKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgbmxzQ29uZmlnID0gSlNPTi5wYXJzZShyYXdObHNDb25maWcpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IG5sc0NvbmZpZy5hdmFpbGFibGVMYW5ndWFnZXNbJyonXTtcclxuICAgICAgICAgICAgX2xvY2FsZSA9IG5sc0NvbmZpZy5sb2NhbGU7XHJcbiAgICAgICAgICAgIC8vIFZTQ29kZSdzIGRlZmF1bHQgbGFuZ3VhZ2UgaXMgJ2VuJ1xyXG4gICAgICAgICAgICBfbGFuZ3VhZ2UgPSByZXNvbHZlZCA/IHJlc29sdmVkIDogTEFOR1VBR0VfREVGQVVMVDtcclxuICAgICAgICAgICAgX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGUgPSBubHNDb25maWcuX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2lzTmF0aXZlID0gdHJ1ZTtcclxufVxyXG4vLyBVbmtub3duIGVudmlyb25tZW50XHJcbmVsc2Uge1xyXG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJlc29sdmUgcGxhdGZvcm0uJyk7XHJcbn1cclxubGV0IF9wbGF0Zm9ybSA9IDAgLyogV2ViICovO1xyXG5pZiAoX2lzTWFjaW50b3NoKSB7XHJcbiAgICBfcGxhdGZvcm0gPSAxIC8qIE1hYyAqLztcclxufVxyXG5lbHNlIGlmIChfaXNXaW5kb3dzKSB7XHJcbiAgICBfcGxhdGZvcm0gPSAzIC8qIFdpbmRvd3MgKi87XHJcbn1cclxuZWxzZSBpZiAoX2lzTGludXgpIHtcclxuICAgIF9wbGF0Zm9ybSA9IDIgLyogTGludXggKi87XHJcbn1cclxuZXhwb3J0IGNvbnN0IGlzV2luZG93cyA9IF9pc1dpbmRvd3M7XHJcbmV4cG9ydCBjb25zdCBpc01hY2ludG9zaCA9IF9pc01hY2ludG9zaDtcclxuZXhwb3J0IGNvbnN0IGlzTGludXggPSBfaXNMaW51eDtcclxuZXhwb3J0IGNvbnN0IGlzTmF0aXZlID0gX2lzTmF0aXZlO1xyXG5leHBvcnQgY29uc3QgaXNXZWIgPSBfaXNXZWI7XHJcbmV4cG9ydCBjb25zdCBpc0lPUyA9IF9pc0lPUztcclxuZXhwb3J0IGNvbnN0IHVzZXJBZ2VudCA9IF91c2VyQWdlbnQ7XHJcbmV4cG9ydCBjb25zdCBzZXRJbW1lZGlhdGUgPSAoZnVuY3Rpb24gZGVmaW5lU2V0SW1tZWRpYXRlKCkge1xyXG4gICAgaWYgKGdsb2JhbHMuc2V0SW1tZWRpYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbHMuc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFscyk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbHMucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgJiYgIWdsb2JhbHMuaW1wb3J0U2NyaXB0cykge1xyXG4gICAgICAgIGxldCBwZW5kaW5nID0gW107XHJcbiAgICAgICAgZ2xvYmFscy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUuZGF0YSAmJiBlLmRhdGEudnNjb2RlU2V0SW1tZWRpYXRlSWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwZW5kaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gcGVuZGluZ1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmlkID09PSBlLmRhdGEudnNjb2RlU2V0SW1tZWRpYXRlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZS5jYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGxhc3RJZCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBteUlkID0gKytsYXN0SWQ7XHJcbiAgICAgICAgICAgIHBlbmRpbmcucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBpZDogbXlJZCxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZ2xvYmFscy5wb3N0TWVzc2FnZSh7IHZzY29kZVNldEltbWVkaWF0ZUlkOiBteUlkIH0sICcqJyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgKG5vZGVQcm9jZXNzID09PSBudWxsIHx8IG5vZGVQcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvY2Vzcy5uZXh0VGljaykgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gbm9kZVByb2Nlc3MubmV4dFRpY2suYmluZChub2RlUHJvY2Vzcyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4gX3Byb21pc2UudGhlbihjYWxsYmFjayk7XHJcbn0pKCk7XHJcbmV4cG9ydCBjb25zdCBPUyA9IChfaXNNYWNpbnRvc2ggfHwgX2lzSU9TID8gMiAvKiBNYWNpbnRvc2ggKi8gOiAoX2lzV2luZG93cyA/IDEgLyogV2luZG93cyAqLyA6IDMgLyogTGludXggKi8pKTtcclxubGV0IF9pc0xpdHRsZUVuZGlhbiA9IHRydWU7XHJcbmxldCBfaXNMaXR0bGVFbmRpYW5Db21wdXRlZCA9IGZhbHNlO1xyXG5leHBvcnQgZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XHJcbiAgICBpZiAoIV9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkKSB7XHJcbiAgICAgICAgX2lzTGl0dGxlRW5kaWFuQ29tcHV0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHRlc3QgPSBuZXcgVWludDhBcnJheSgyKTtcclxuICAgICAgICB0ZXN0WzBdID0gMTtcclxuICAgICAgICB0ZXN0WzFdID0gMjtcclxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KHRlc3QuYnVmZmVyKTtcclxuICAgICAgICBfaXNMaXR0bGVFbmRpYW4gPSAodmlld1swXSA9PT0gKDIgPDwgOCkgKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaXNMaXR0bGVFbmRpYW47XHJcbn1cclxuIiwiLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgQXJyYXkgb3Igbm90LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkoYXJyYXkpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5KTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBTdHJpbmcgb3Igbm90LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xyXG4gICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBvZiB0eXBlIGBvYmplY3RgIGJ1dCAqKm5vdCoqXHJcbiAqXHRgbnVsbGAsIGFuIGBhcnJheWAsIGEgYHJlZ2V4cGAsIG5vciBhIGBkYXRlYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcclxuICAgIC8vIFRoZSBtZXRob2QgY2FuJ3QgZG8gYSB0eXBlIGNhc3Qgc2luY2UgdGhlcmUgYXJlIHR5cGUgKGxpa2Ugc3RyaW5ncykgd2hpY2hcclxuICAgIC8vIGFyZSBzdWJjbGFzc2VzIG9mIGFueSBwdXQgbm90IHBvc2l0dmVseSBtYXRjaGVkIGJ5IHRoZSBmdW5jdGlvbi4gSGVuY2UgdHlwZVxyXG4gICAgLy8gbmFycm93aW5nIHJlc3VsdHMgaW4gd3JvbmcgcmVzdWx0cy5cclxuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xyXG4gICAgICAgICYmIG9iaiAhPT0gbnVsbFxyXG4gICAgICAgICYmICFBcnJheS5pc0FycmF5KG9iailcclxuICAgICAgICAmJiAhKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cClcclxuICAgICAgICAmJiAhKG9iaiBpbnN0YW5jZW9mIERhdGUpO1xyXG59XHJcbi8qKlxyXG4gKiBJbiAqKmNvbnRyYXN0KiogdG8ganVzdCBjaGVja2luZyBgdHlwZW9mYCB0aGlzIHdpbGwgcmV0dXJuIGBmYWxzZWAgZm9yIGBOYU5gLlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IE51bWJlciBvciBub3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdudW1iZXInICYmICFpc05hTihvYmopKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBCb29sZWFuIG9yIG5vdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcclxuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwob2JqKSB7XHJcbiAgICByZXR1cm4gKGlzVW5kZWZpbmVkKG9iaikgfHwgb2JqID09PSBudWxsKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VHlwZShjb25kaXRpb24sIHR5cGUpIHtcclxuICAgIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgPyBgVW5leHBlY3RlZCB0eXBlLCBleHBlY3RlZCAnJHt0eXBlfSdgIDogJ1VuZXhwZWN0ZWQgdHlwZScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGFyZ3VtZW50IHBhc3NlZCBpbiBpcyBuZWl0aGVyIHVuZGVmaW5lZCBub3IgbnVsbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJc0RlZmluZWQoYXJnKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWRPck51bGwoYXJnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIEZhaWxlZDogYXJndW1lbnQgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmc7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgRnVuY3Rpb24gb3Igbm90LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnRzKGFyZ3MsIGNvbnN0cmFpbnRzKSB7XHJcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhcmdzLmxlbmd0aCwgY29uc3RyYWludHMubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICB2YWxpZGF0ZUNvbnN0cmFpbnQoYXJnc1tpXSwgY29uc3RyYWludHNbaV0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnQoYXJnLCBjb25zdHJhaW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29uc3RyYWludCkpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gY29uc3RyYWludCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIGNvbnN0cmFpbnQ6IHR5cGVvZiAke2NvbnN0cmFpbnR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjb25zdHJhaW50KSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkT3JOdWxsKGFyZykgJiYgYXJnLmNvbnN0cnVjdG9yID09PSBjb25zdHJhaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVuZ3RoID09PSAxICYmIGNvbnN0cmFpbnQuY2FsbCh1bmRlZmluZWQsIGFyZykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIG9uZSBvZiB0aGVzZSBjb25zdHJhaW50czogYXJnIGluc3RhbmNlb2YgY29uc3RyYWludCwgYXJnLmNvbnN0cnVjdG9yID09PSBjb25zdHJhaW50LCBub3IgY29uc3RyYWludChhcmcpID09PSB0cnVlYCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFByb3BlcnR5TmFtZXMob2JqKSB7XHJcbiAgICBsZXQgcmVzID0gW107XHJcbiAgICBsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcclxuICAgIHdoaWxlIChPYmplY3QucHJvdG90eXBlICE9PSBwcm90bykge1xyXG4gICAgICAgIHJlcyA9IHJlcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pKTtcclxuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxNZXRob2ROYW1lcyhvYmopIHtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBnZXRBbGxQcm9wZXJ0eU5hbWVzKG9iaikpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9ialtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBtZXRob2RzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1ldGhvZHM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3h5T2JqZWN0KG1ldGhvZE5hbWVzLCBpbnZva2UpIHtcclxuICAgIGNvbnN0IGNyZWF0ZVByb3h5TWV0aG9kID0gKG1ldGhvZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlKG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBsZXQgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgbWV0aG9kTmFtZXMpIHtcclxuICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eU1ldGhvZChtZXRob2ROYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIG51bGwgdG8gdW5kZWZpbmVkLCBwYXNzZXMgYWxsIG90aGVyIHZhbHVlcyB0aHJvdWdoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhOdWxsQXNVbmRlZmluZWQoeCkge1xyXG4gICAgcmV0dXJuIHggPT09IG51bGwgPyB1bmRlZmluZWQgOiB4O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZSwgbWVzc2FnZSA9ICdVbnJlYWNoYWJsZScpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcclxuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL2xpZmVjeWNsZS5qcyc7XHJcbmltcG9ydCB7IGlzV2ViIH0gZnJvbSAnLi4vcGxhdGZvcm0uanMnO1xyXG5pbXBvcnQgKiBhcyB0eXBlcyBmcm9tICcuLi90eXBlcy5qcyc7XHJcbmNvbnN0IElOSVRJQUxJWkUgPSAnJGluaXRpYWxpemUnO1xyXG5sZXQgd2ViV29ya2VyV2FybmluZ0xvZ2dlZCA9IGZhbHNlO1xyXG5leHBvcnQgZnVuY3Rpb24gbG9nT25jZVdlYldvcmtlcldhcm5pbmcoZXJyKSB7XHJcbiAgICBpZiAoIWlzV2ViKSB7XHJcbiAgICAgICAgLy8gcnVubmluZyB0ZXN0c1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghd2ViV29ya2VyV2FybmluZ0xvZ2dlZCkge1xyXG4gICAgICAgIHdlYldvcmtlcldhcm5pbmdMb2dnZWQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGNyZWF0ZSB3ZWIgd29ya2VyKHMpLiBGYWxsaW5nIGJhY2sgdG8gbG9hZGluZyB3ZWIgd29ya2VyIGNvZGUgaW4gbWFpbiB0aHJlYWQsIHdoaWNoIG1pZ2h0IGNhdXNlIFVJIGZyZWV6ZXMuIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9tb25hY28tZWRpdG9yI2ZhcScpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS53YXJuKGVyci5tZXNzYWdlKTtcclxufVxyXG5jbGFzcyBTaW1wbGVXb3JrZXJQcm90b2NvbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VySWQgPSAtMTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICB0aGlzLl9sYXN0U2VudFJlcSA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcGxpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgc2V0V29ya2VySWQod29ya2VySWQpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXJJZCA9IHdvcmtlcklkO1xyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2UobWV0aG9kLCBhcmdzKSB7XHJcbiAgICAgICAgbGV0IHJlcSA9IFN0cmluZygrK3RoaXMuX2xhc3RTZW50UmVxKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXFdID0ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbmQoe1xyXG4gICAgICAgICAgICAgICAgdnNXb3JrZXI6IHRoaXMuX3dvcmtlcklkLFxyXG4gICAgICAgICAgICAgICAgcmVxOiByZXEsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIW1lc3NhZ2UgfHwgIW1lc3NhZ2UudnNXb3JrZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fd29ya2VySWQgIT09IC0xICYmIG1lc3NhZ2UudnNXb3JrZXIgIT09IHRoaXMuX3dvcmtlcklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVNZXNzYWdlKG1zZykge1xyXG4gICAgICAgIGlmIChtc2cuc2VxKSB7XHJcbiAgICAgICAgICAgIGxldCByZXBseU1lc3NhZ2UgPSBtc2c7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignR290IHJlcGx5IHRvIHVua25vd24gc2VxJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHJlcGx5ID0gdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXBseU1lc3NhZ2Uuc2VxXTtcclxuICAgICAgICAgICAgaWYgKHJlcGx5TWVzc2FnZS5lcnIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBlcnIgPSByZXBseU1lc3NhZ2UuZXJyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGx5TWVzc2FnZS5lcnIuJGlzRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9IHJlcGx5TWVzc2FnZS5lcnIubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IHJlcGx5TWVzc2FnZS5lcnIubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgPSByZXBseU1lc3NhZ2UuZXJyLnN0YWNrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVwbHkucmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVwbHkucmVzb2x2ZShyZXBseU1lc3NhZ2UucmVzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVxdWVzdE1lc3NhZ2UgPSBtc2c7XHJcbiAgICAgICAgbGV0IHJlcSA9IHJlcXVlc3RNZXNzYWdlLnJlcTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5faGFuZGxlci5oYW5kbGVNZXNzYWdlKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UuYXJncyk7XHJcbiAgICAgICAgcmVzdWx0LnRoZW4oKHIpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc2VuZCh7XHJcbiAgICAgICAgICAgICAgICB2c1dvcmtlcjogdGhpcy5fd29ya2VySWQsXHJcbiAgICAgICAgICAgICAgICBzZXE6IHJlcSxcclxuICAgICAgICAgICAgICAgIHJlczogcixcclxuICAgICAgICAgICAgICAgIGVycjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLmRldGFpbCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkaW5nIGVycm9ycyBoYXZlIGEgZGV0YWlsIHByb3BlcnR5IHRoYXQgcG9pbnRzIHRvIHRoZSBhY3R1YWwgZXJyb3JcclxuICAgICAgICAgICAgICAgIGUuZGV0YWlsID0gdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uKGUuZGV0YWlsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZW5kKHtcclxuICAgICAgICAgICAgICAgIHZzV29ya2VyOiB0aGlzLl93b3JrZXJJZCxcclxuICAgICAgICAgICAgICAgIHNlcTogcmVxLFxyXG4gICAgICAgICAgICAgICAgcmVzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBlcnI6IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9zZW5kKG1zZykge1xyXG4gICAgICAgIGxldCB0cmFuc2ZlciA9IFtdO1xyXG4gICAgICAgIGlmIChtc2cucmVxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtc2c7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobS5hcmdzW2ldIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zlci5wdXNoKG0uYXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtc2c7XHJcbiAgICAgICAgICAgIGlmIChtLnJlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zlci5wdXNoKG0ucmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYW5kbGVyLnNlbmRNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNYWluIHRocmVhZCBzaWRlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2ltcGxlV29ya2VyQ2xpZW50IGV4dGVuZHMgRGlzcG9zYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXJGYWN0b3J5LCBtb2R1bGVJZCwgaG9zdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgbGV0IGxhenlQcm94eVJlamVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gdGhpcy5fcmVnaXN0ZXIod29ya2VyRmFjdG9yeS5jcmVhdGUoJ3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXInLCAobXNnKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcclxuICAgICAgICB9LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGluIEZpcmVmb3gsIHdlYiB3b3JrZXJzIGZhaWwgbGF6aWx5IDooXHJcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVqZWN0IHRoZSBwcm94eVxyXG4gICAgICAgICAgICBpZiAobGF6eVByb3h5UmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBsYXp5UHJveHlSZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbCA9IG5ldyBTaW1wbGVXb3JrZXJQcm90b2NvbCh7XHJcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAobXNnLCB0cmFuc2ZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYW5kbGVNZXNzYWdlOiAobWV0aG9kLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhvc3RbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ01pc3NpbmcgbWV0aG9kICcgKyBtZXRob2QgKyAnIG9uIG1haW4gdGhyZWFkIGhvc3QuJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvc3RbbWV0aG9kXS5hcHBseShob3N0LCBhcmdzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sLnNldFdvcmtlcklkKHRoaXMuX3dvcmtlci5nZXRJZCgpKTtcclxuICAgICAgICAvLyBHYXRoZXIgbG9hZGVyIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICBsZXQgbG9hZGVyQ29uZmlndXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzZWxmLnJlcXVpcmUuZ2V0Q29uZmlnID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHRoZSBNb25hY28gQU1EIExvYWRlclxyXG4gICAgICAgICAgICBsb2FkZXJDb25maWd1cmF0aW9uID0gc2VsZi5yZXF1aXJlLmdldENvbmZpZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZi5yZXF1aXJlanMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHJlcXVpcmVqc1xyXG4gICAgICAgICAgICBsb2FkZXJDb25maWd1cmF0aW9uID0gc2VsZi5yZXF1aXJlanMucy5jb250ZXh0cy5fLmNvbmZpZztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaG9zdE1ldGhvZHMgPSB0eXBlcy5nZXRBbGxNZXRob2ROYW1lcyhob3N0KTtcclxuICAgICAgICAvLyBTZW5kIGluaXRpYWxpemUgbWVzc2FnZVxyXG4gICAgICAgIHRoaXMuX29uTW9kdWxlTG9hZGVkID0gdGhpcy5fcHJvdG9jb2wuc2VuZE1lc3NhZ2UoSU5JVElBTElaRSwgW1xyXG4gICAgICAgICAgICB0aGlzLl93b3JrZXIuZ2V0SWQoKSxcclxuICAgICAgICAgICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsb2FkZXJDb25maWd1cmF0aW9uKSksXHJcbiAgICAgICAgICAgIG1vZHVsZUlkLFxyXG4gICAgICAgICAgICBob3N0TWV0aG9kcyxcclxuICAgICAgICBdKTtcclxuICAgICAgICAvLyBDcmVhdGUgcHJveHkgdG8gbG9hZGVkIGNvZGVcclxuICAgICAgICBjb25zdCBwcm94eU1ldGhvZFJlcXVlc3QgPSAobWV0aG9kLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0KG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9sYXp5UHJveHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxhenlQcm94eVJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgdGhpcy5fb25Nb2R1bGVMb2FkZWQudGhlbigoYXZhaWxhYmxlTWV0aG9kcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlcy5jcmVhdGVQcm94eU9iamVjdChhdmFpbGFibGVNZXRob2RzLCBwcm94eU1ldGhvZFJlcXVlc3QpKTtcclxuICAgICAgICAgICAgfSwgKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoJ1dvcmtlciBmYWlsZWQgdG8gbG9hZCAnICsgbW9kdWxlSWQsIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFByb3h5T2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXp5UHJveHk7XHJcbiAgICB9XHJcbiAgICBfcmVxdWVzdChtZXRob2QsIGFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9vbk1vZHVsZUxvYWRlZC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLnNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncykudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdvcmtlciBzaWRlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2ltcGxlV29ya2VyU2VydmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvc3RNZXNzYWdlLCByZXF1ZXN0SGFuZGxlckZhY3RvcnkpIHtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlckZhY3RvcnkgPSByZXF1ZXN0SGFuZGxlckZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gbmV3IFNpbXBsZVdvcmtlclByb3RvY29sKHtcclxuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZTogKG1ldGhvZCwgYXJncykgPT4gdGhpcy5faGFuZGxlTWVzc2FnZShtZXRob2QsIGFyZ3MpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvbm1lc3NhZ2UobXNnKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wuaGFuZGxlTWVzc2FnZShtc2cpO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZU1lc3NhZ2UobWV0aG9kLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gSU5JVElBTElaRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RIYW5kbGVyIHx8IHR5cGVvZiB0aGlzLl9yZXF1ZXN0SGFuZGxlclttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWVzdEhhbmRsZXIgb3IgbWV0aG9kOiAnICsgbWV0aG9kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcmVxdWVzdEhhbmRsZXJbbWV0aG9kXS5hcHBseSh0aGlzLl9yZXF1ZXN0SGFuZGxlciwgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZSh3b3JrZXJJZCwgbG9hZGVyQ29uZmlnLCBtb2R1bGVJZCwgaG9zdE1ldGhvZHMpIHtcclxuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh3b3JrZXJJZCk7XHJcbiAgICAgICAgY29uc3QgcHJveHlNZXRob2RSZXF1ZXN0ID0gKG1ldGhvZCwgYXJncykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2wuc2VuZE1lc3NhZ2UobWV0aG9kLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGhvc3RQcm94eSA9IHR5cGVzLmNyZWF0ZVByb3h5T2JqZWN0KGhvc3RNZXRob2RzLCBwcm94eU1ldGhvZFJlcXVlc3QpO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SGFuZGxlckZhY3RvcnkpIHtcclxuICAgICAgICAgICAgLy8gc3RhdGljIHJlcXVlc3QgaGFuZGxlclxyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeShob3N0UHJveHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR5cGVzLmdldEFsbE1ldGhvZE5hbWVzKHRoaXMuX3JlcXVlc3RIYW5kbGVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2FkZXJDb25maWcpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlICdiYXNlVXJsJywgaGFuZGxpbmcgaXQgaXMgYmV5b25kIHNjb3BlIGZvciBub3dcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcuYmFzZVVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWdbJ2Jhc2VVcmwnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5wYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyQ29uZmlnLnBhdGhzLnZzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWcucGF0aHNbJ3ZzJ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcudHJ1c3RlZFR5cGVzUG9saWN5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHVzZSwgaXQgaGFzIGJlZW4gZGVzdHJveWVkIGR1cmluZyBzZXJpYWxpemVcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWdbJ3RydXN0ZWRUeXBlc1BvbGljeSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgaW4gYSB3ZWIgd29ya2VyLCBlbmFibGUgY2F0Y2hpbmcgZXJyb3JzXHJcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZy5jYXRjaEVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5yZXF1aXJlLmNvbmZpZyhsb2FkZXJDb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGdsb2JhbCByZXF1aXJlIHRvIGJlIHN1cmUgdG8gZ2V0IHRoZSBnbG9iYWwgY29uZmlnXHJcbiAgICAgICAgICAgIHNlbGYucmVxdWlyZShbbW9kdWxlSWRdLCAobW9kdWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlciA9IG1vZHVsZS5jcmVhdGUoaG9zdFByb3h5KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBObyBSZXF1ZXN0SGFuZGxlciFgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0eXBlcy5nZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9yZXF1ZXN0SGFuZGxlcikpO1xyXG4gICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgb24gdGhlIHdvcmtlciBzaWRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHBvc3RNZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IFNpbXBsZVdvcmtlclNlcnZlcihwb3N0TWVzc2FnZSwgbnVsbCk7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBzZXF1ZW5jZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGlmZkNoYW5nZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZSB3aXRoIHRoZSBnaXZlbiBzZXF1ZW5jZSBpbmZvcm1hdGlvblxyXG4gICAgICogYW5kIGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkge1xyXG4gICAgICAgIC8vRGVidWcuQXNzZXJ0KG9yaWdpbmFsTGVuZ3RoID4gMCB8fCBtb2RpZmllZExlbmd0aCA+IDAsIFwib3JpZ2luYWxMZW5ndGggYW5kIG1vZGlmaWVkTGVuZ3RoIGNhbm5vdCBib3RoIGJlIDw9IDBcIik7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0ID0gb3JpZ2luYWxTdGFydDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsTGVuZ3RoID0gb3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0ID0gbW9kaWZpZWRTdGFydDtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkTGVuZ3RoID0gbW9kaWZpZWRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSkgb2YgdGhlIGNoYW5nZSBpbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldE9yaWdpbmFsRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsU3RhcnQgKyB0aGlzLm9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5kIHBvaW50IChleGNsdXNpdmUpIG9mIHRoZSBjaGFuZ2UgaW4gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXRNb2RpZmllZEVuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2RpZmllZFN0YXJ0ICsgdGhpcy5tb2RpZmllZExlbmd0aDtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPcldoaXRlc3BhY2Uoc3RyKSB7XHJcbiAgICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0ci50cmltKCkubGVuZ3RoID09PSAwO1xyXG59XHJcbmNvbnN0IF9mb3JtYXRSZWdleHAgPSAveyhcXGQrKX0vZztcclxuLyoqXHJcbiAqIEhlbHBlciB0byBwcm9kdWNlIGEgc3RyaW5nIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLiBJbnNlcnQgdmFyaWFibGUgc2VnbWVudHNcclxuICogaW50byB0aGUgc3RyaW5nIHVzaW5nIHRoZSB7bn0gbm90YXRpb24gd2hlcmUgTiBpcyB0aGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IGZvbGxvd2luZyB0aGUgc3RyaW5nLlxyXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHRvIHdoaWNoIGZvcm1hdHRpbmcgaXMgYXBwbGllZFxyXG4gKiBAcGFyYW0gYXJncyByZXBsYWNlbWVudHMgZm9yIHtufS1lbnRyaWVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShfZm9ybWF0UmVnZXhwLCBmdW5jdGlvbiAobWF0Y2gsIGdyb3VwKSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcclxuICAgICAgICByZXR1cm4gaXNOYU4oaWR4KSB8fCBpZHggPCAwIHx8IGlkeCA+PSBhcmdzLmxlbmd0aCA/XHJcbiAgICAgICAgICAgIG1hdGNoIDpcclxuICAgICAgICAgICAgYXJnc1tpZHhdO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIEhUTUwgY2hhcmFjdGVycyBpbnNpZGUgdGhlIHN0cmluZyB0byB1c2UgZW50aXRpZXMgaW5zdGVhZC4gTWFrZXMgdGhlIHN0cmluZyBzYWZlIGZyb21cclxuICogYmVpbmcgdXNlZCBlLmcuIGluIEhUTUxFbGVtZW50LmlubmVySFRNTC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUoaHRtbCkge1xyXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvWzw+Jl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgc3dpdGNoIChtYXRjaCkge1xyXG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcclxuICAgICAgICAgICAgY2FzZSAnPic6IHJldHVybiAnJmd0Oyc7XHJcbiAgICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBFc2NhcGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGFyYWN0ZXJzIGluIGEgZ2l2ZW4gc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXFxcXFx7XFx9XFwqXFwrXFw/XFx8XFxeXFwkXFwuXFxbXFxdXFwoXFwpXS9nLCAnXFxcXCQmJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBoYXlzdGFjay5cclxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXHJcbiAqIEBwYXJhbSBuZWVkbGUgdGhlIHRoaW5nIHRvIHRyaW0gKGRlZmF1bHQgaXMgYSBibGFuaylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKGhheXN0YWNrLCBuZWVkbGUgPSAnICcpIHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsdHJpbShoYXlzdGFjaywgbmVlZGxlKTtcclxuICAgIHJldHVybiBydHJpbSh0cmltbWVkLCBuZWVkbGUpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGhheXN0YWNrLlxyXG4gKiBAcGFyYW0gaGF5c3RhY2sgc3RyaW5nIHRvIHRyaW1cclxuICogQHBhcmFtIG5lZWRsZSB0aGUgdGhpbmcgdG8gdHJpbVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGx0cmltKGhheXN0YWNrLCBuZWVkbGUpIHtcclxuICAgIGlmICghaGF5c3RhY2sgfHwgIW5lZWRsZSkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcclxuICAgIH1cclxuICAgIGNvbnN0IG5lZWRsZUxlbiA9IG5lZWRsZS5sZW5ndGg7XHJcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcclxuICAgIH1cclxuICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgd2hpbGUgKGhheXN0YWNrLmluZGV4T2YobmVlZGxlLCBvZmZzZXQpID09PSBvZmZzZXQpIHtcclxuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBuZWVkbGVMZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGF5c3RhY2suc3Vic3RyaW5nKG9mZnNldCk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBlbmQgb2YgaGF5c3RhY2suXHJcbiAqIEBwYXJhbSBoYXlzdGFjayBzdHJpbmcgdG8gdHJpbVxyXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcnRyaW0oaGF5c3RhY2ssIG5lZWRsZSkge1xyXG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmVlZGxlTGVuID0gbmVlZGxlLmxlbmd0aCwgaGF5c3RhY2tMZW4gPSBoYXlzdGFjay5sZW5ndGg7XHJcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrTGVuID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrO1xyXG4gICAgfVxyXG4gICAgbGV0IG9mZnNldCA9IGhheXN0YWNrTGVuLCBpZHggPSAtMTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgaWR4ID0gaGF5c3RhY2subGFzdEluZGV4T2YobmVlZGxlLCBvZmZzZXQgLSAxKTtcclxuICAgICAgICBpZiAoaWR4ID09PSAtMSB8fCBpZHggKyBuZWVkbGVMZW4gIT09IG9mZnNldCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCA9IGlkeDtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXlzdGFjay5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFNpbXBsZTJSZWdFeHBQYXR0ZXJuKHBhdHRlcm4pIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1tcXC1cXFxcXFx7XFx9XFwrXFw/XFx8XFxeXFwkXFwuXFwsXFxbXFxdXFwoXFwpXFwjXFxzXS9nLCAnXFxcXCQmJykucmVwbGFjZSgvW1xcKl0vZywgJy4qJyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwV2lsZGNhcmRzKHBhdHRlcm4pIHtcclxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1xcKi9nLCAnJyk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZ0V4cChzZWFyY2hTdHJpbmcsIGlzUmVnZXgsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKCFzZWFyY2hTdHJpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcmVnZXggZnJvbSBlbXB0eSBzdHJpbmcnKTtcclxuICAgIH1cclxuICAgIGlmICghaXNSZWdleCkge1xyXG4gICAgICAgIHNlYXJjaFN0cmluZyA9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoc2VhcmNoU3RyaW5nKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLndob2xlV29yZCkge1xyXG4gICAgICAgIGlmICghL1xcQi8udGVzdChzZWFyY2hTdHJpbmcuY2hhckF0KDApKSkge1xyXG4gICAgICAgICAgICBzZWFyY2hTdHJpbmcgPSAnXFxcXGInICsgc2VhcmNoU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdChzZWFyY2hTdHJpbmcubGVuZ3RoIC0gMSkpKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaFN0cmluZyA9IHNlYXJjaFN0cmluZyArICdcXFxcYic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG1vZGlmaWVycyA9ICcnO1xyXG4gICAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XHJcbiAgICAgICAgbW9kaWZpZXJzICs9ICdnJztcclxuICAgIH1cclxuICAgIGlmICghb3B0aW9ucy5tYXRjaENhc2UpIHtcclxuICAgICAgICBtb2RpZmllcnMgKz0gJ2knO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgbW9kaWZpZXJzICs9ICdtJztcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLnVuaWNvZGUpIHtcclxuICAgICAgICBtb2RpZmllcnMgKz0gJ3UnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoU3RyaW5nLCBtb2RpZmllcnMpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZWdFeHBMZWFkc1RvRW5kbGVzc0xvb3AocmVnZXhwKSB7XHJcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGl0J3Mgb25lIG9mIHRoZXNlIHNwZWNpYWwgY2FzZXMgd2hpY2ggYXJlIG1lYW50IHRvIG1hdGNoXHJcbiAgICAvLyBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgaWYgKHJlZ2V4cC5zb3VyY2UgPT09ICdeJyB8fCByZWdleHAuc291cmNlID09PSAnXiQnIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICckJyB8fCByZWdleHAuc291cmNlID09PSAnXlxcXFxzKiQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCBhbiBlbXB0eSBzdHJpbmcuIElmIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZG9lc24ndCBhZHZhbmNlXHJcbiAgICAvLyAoZS5nLiBlbmRzIGluIGFuIGVuZGxlc3MgbG9vcCkgaXQgd2lsbCBtYXRjaCBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICBjb25zdCBtYXRjaCA9IHJlZ2V4cC5leGVjKCcnKTtcclxuICAgIHJldHVybiAhIShtYXRjaCAmJiByZWdleHAubGFzdEluZGV4ID09PSAwKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVnRXhwRmxhZ3MocmVnZXhwKSB7XHJcbiAgICByZXR1cm4gKHJlZ2V4cC5nbG9iYWwgPyAnZycgOiAnJylcclxuICAgICAgICArIChyZWdleHAuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKVxyXG4gICAgICAgICsgKHJlZ2V4cC5tdWx0aWxpbmUgPyAnbScgOiAnJylcclxuICAgICAgICArIChyZWdleHAgLyogc3RhbmRhbG9uZSBlZGl0b3IgY29tcGlsYXRpb24gKi8udW5pY29kZSA/ICd1JyA6ICcnKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRMaW5lcyhzdHIpIHtcclxuICAgIHJldHVybiBzdHIuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgZmlyc3QgaW5kZXggb2YgdGhlIHN0cmluZyB0aGF0IGlzIG5vdCB3aGl0ZXNwYWNlLlxyXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KHN0cikge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjaENvZGUgIT09IDMyIC8qIFNwYWNlICovICYmIGNoQ29kZSAhPT0gOSAvKiBUYWIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIHN0cmluZy5cclxuICogSWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VzLCByZXR1cm5zIGVudGlyZSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWFkaW5nV2hpdGVzcGFjZShzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyLmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBTcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogVGFiICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBsYXN0IGluZGV4IG9mIHRoZSBzdHJpbmcgdGhhdCBpcyBub3Qgd2hpdGVzcGFjZS5cclxuICogSWYgc3RyaW5nIGlzIGVtcHR5IG9yIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZXMsIHJldHVybnMgLTFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsYXN0Tm9uV2hpdGVzcGFjZUluZGV4KHN0ciwgc3RhcnRJbmRleCA9IHN0ci5sZW5ndGggLSAxKSB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBTcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogVGFiICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XHJcbiAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhID4gYikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmcoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcclxuICAgIGZvciAoOyBhU3RhcnQgPCBhRW5kICYmIGJTdGFydCA8IGJFbmQ7IGFTdGFydCsrLCBiU3RhcnQrKykge1xyXG4gICAgICAgIGxldCBjb2RlQSA9IGEuY2hhckNvZGVBdChhU3RhcnQpO1xyXG4gICAgICAgIGxldCBjb2RlQiA9IGIuY2hhckNvZGVBdChiU3RhcnQpO1xyXG4gICAgICAgIGlmIChjb2RlQSA8IGNvZGVCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZUEgPiBjb2RlQikge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcclxuICAgIGNvbnN0IGJMZW4gPSBiRW5kIC0gYlN0YXJ0O1xyXG4gICAgaWYgKGFMZW4gPCBiTGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYUxlbiA+IGJMZW4pIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlSWdub3JlQ2FzZShhLCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2UoYSwgYiwgMCwgYS5sZW5ndGgsIDAsIGIubGVuZ3RoKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2UoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcclxuICAgIGZvciAoOyBhU3RhcnQgPCBhRW5kICYmIGJTdGFydCA8IGJFbmQ7IGFTdGFydCsrLCBiU3RhcnQrKykge1xyXG4gICAgICAgIGxldCBjb2RlQSA9IGEuY2hhckNvZGVBdChhU3RhcnQpO1xyXG4gICAgICAgIGxldCBjb2RlQiA9IGIuY2hhckNvZGVBdChiU3RhcnQpO1xyXG4gICAgICAgIGlmIChjb2RlQSA9PT0gY29kZUIpIHtcclxuICAgICAgICAgICAgLy8gZXF1YWxcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRpZmYgPSBjb2RlQSAtIGNvZGVCO1xyXG4gICAgICAgIGlmIChkaWZmID09PSAzMiAmJiBpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZUIpKSB7IC8vY29kZUIgPVs2NS05MF0gJiYgY29kZUEgPVs5Ny0xMjJdXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaWZmID09PSAtMzIgJiYgaXNVcHBlckFzY2lpTGV0dGVyKGNvZGVBKSkgeyAvL2NvZGVCID1bOTctMTIyXSAmJiBjb2RlQSA9WzY1LTkwXVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTG93ZXJBc2NpaUxldHRlcihjb2RlQSkgJiYgaXNMb3dlckFzY2lpTGV0dGVyKGNvZGVCKSkge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlU3Vic3RyaW5nKGEudG9Mb3dlckNhc2UoKSwgYi50b0xvd2VyQ2FzZSgpLCBhU3RhcnQsIGFFbmQsIGJTdGFydCwgYkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgYUxlbiA9IGFFbmQgLSBhU3RhcnQ7XHJcbiAgICBjb25zdCBiTGVuID0gYkVuZCAtIGJTdGFydDtcclxuICAgIGlmIChhTGVuIDwgYkxlbikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFMZW4gPiBiTGVuKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNMb3dlckFzY2lpTGV0dGVyKGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlID49IDk3IC8qIGEgKi8gJiYgY29kZSA8PSAxMjIgLyogeiAqLztcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNVcHBlckFzY2lpTGV0dGVyKGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlID49IDY1IC8qIEEgKi8gJiYgY29kZSA8PSA5MCAvKiBaICovO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xyXG4gICAgcmV0dXJuIGlzTG93ZXJBc2NpaUxldHRlcihjb2RlKSB8fCBpc1VwcGVyQXNjaWlMZXR0ZXIoY29kZSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsc0lnbm9yZUNhc2UoYSwgYikge1xyXG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBkb0VxdWFsc0lnbm9yZUNhc2UoYSwgYik7XHJcbn1cclxuZnVuY3Rpb24gZG9FcXVhbHNJZ25vcmVDYXNlKGEsIGIsIHN0b3BBdCA9IGEubGVuZ3RoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BBdDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY29kZUEgPSBhLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgY29uc3QgY29kZUIgPSBiLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGNvZGVBID09PSBjb2RlQikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYS16IEEtWlxyXG4gICAgICAgIGlmIChpc0FzY2lpTGV0dGVyKGNvZGVBKSAmJiBpc0FzY2lpTGV0dGVyKGNvZGVCKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoY29kZUEgLSBjb2RlQik7XHJcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSAwICYmIGRpZmYgIT09IDMyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQW55IG90aGVyIGNoYXJjb2RlXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVBKS50b0xvd2VyQ2FzZSgpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVCKS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRzV2l0aElnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUpIHtcclxuICAgIGNvbnN0IGNhbmRpZGF0ZUxlbmd0aCA9IGNhbmRpZGF0ZS5sZW5ndGg7XHJcbiAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9FcXVhbHNJZ25vcmVDYXNlKHN0ciwgY2FuZGlkYXRlLCBjYW5kaWRhdGVMZW5ndGgpO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBjb21tb24gcHJlZml4IG9mIHRoZSB0d28gc3RyaW5ncy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21tb25QcmVmaXhMZW5ndGgoYSwgYikge1xyXG4gICAgbGV0IGksIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGkpICE9PSBiLmNoYXJDb2RlQXQoaSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0aGUgdHdvIHN0cmluZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4TGVuZ3RoKGEsIGIpIHtcclxuICAgIGxldCBpLCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgY29uc3QgYUxhc3RJbmRleCA9IGEubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IGJMYXN0SW5kZXggPSBiLmxlbmd0aCAtIDE7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGFMYXN0SW5kZXggLSBpKSAhPT0gYi5jaGFyQ29kZUF0KGJMYXN0SW5kZXggLSBpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59XHJcbi8qKlxyXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkge1xyXG4gICAgcmV0dXJuICgweEQ4MDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhEQkZGKTtcclxufVxyXG4vKipcclxuICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Vycm9nYXRlX3BhaXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkge1xyXG4gICAgcmV0dXJuICgweERDMDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhERkZGKTtcclxufVxyXG4vKipcclxuICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3Vycm9nYXRlX3BhaXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQ29kZVBvaW50KGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSkge1xyXG4gICAgcmV0dXJuICgoaGlnaFN1cnJvZ2F0ZSAtIDB4RDgwMCkgPDwgMTApICsgKGxvd1N1cnJvZ2F0ZSAtIDB4REMwMCkgKyAweDEwMDAwO1xyXG59XHJcbi8qKlxyXG4gKiBnZXQgdGhlIGNvZGUgcG9pbnQgdGhhdCBiZWdpbnMgYXQgb2Zmc2V0IGBvZmZzZXRgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dENvZGVQb2ludChzdHIsIGxlbiwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XHJcbiAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSAmJiBvZmZzZXQgKyAxIDwgbGVuKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSk7XHJcbiAgICAgICAgaWYgKGlzTG93U3Vycm9nYXRlKG5leHRDaGFyQ29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVDb2RlUG9pbnQoY2hhckNvZGUsIG5leHRDaGFyQ29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoYXJDb2RlO1xyXG59XHJcbi8qKlxyXG4gKiBnZXQgdGhlIGNvZGUgcG9pbnQgdGhhdCBlbmRzIHJpZ2h0IGJlZm9yZSBvZmZzZXQgYG9mZnNldGBcclxuICovXHJcbmZ1bmN0aW9uIGdldFByZXZDb2RlUG9pbnQoc3RyLCBvZmZzZXQpIHtcclxuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMSk7XHJcbiAgICBpZiAoaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpICYmIG9mZnNldCA+IDEpIHtcclxuICAgICAgICBjb25zdCBwcmV2Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgLSAyKTtcclxuICAgICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKHByZXZDaGFyQ29kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVDb2RlUG9pbnQocHJldkNoYXJDb2RlLCBjaGFyQ29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoYXJDb2RlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBuZXh0Q2hhckxlbmd0aChzdHIsIG9mZnNldCkge1xyXG4gICAgY29uc3QgZ3JhcGhlbWVCcmVha1RyZWUgPSBHcmFwaGVtZUJyZWFrVHJlZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgY29uc3QgaW5pdGlhbE9mZnNldCA9IG9mZnNldDtcclxuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICBjb25zdCBpbml0aWFsQ29kZVBvaW50ID0gZ2V0TmV4dENvZGVQb2ludChzdHIsIGxlbiwgb2Zmc2V0KTtcclxuICAgIG9mZnNldCArPSAoaW5pdGlhbENvZGVQb2ludCA+PSA2NTUzNiAvKiBVTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XHJcbiAgICBsZXQgZ3JhcGhlbWVCcmVha1R5cGUgPSBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShpbml0aWFsQ29kZVBvaW50KTtcclxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW4pIHtcclxuICAgICAgICBjb25zdCBuZXh0Q29kZVBvaW50ID0gZ2V0TmV4dENvZGVQb2ludChzdHIsIGxlbiwgb2Zmc2V0KTtcclxuICAgICAgICBjb25zdCBuZXh0R3JhcGhlbWVCcmVha1R5cGUgPSBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShuZXh0Q29kZVBvaW50KTtcclxuICAgICAgICBpZiAoYnJlYWtCZXR3ZWVuR3JhcGhlbWVCcmVha1R5cGUoZ3JhcGhlbWVCcmVha1R5cGUsIG5leHRHcmFwaGVtZUJyZWFrVHlwZSkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAobmV4dENvZGVQb2ludCA+PSA2NTUzNiAvKiBVTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XHJcbiAgICAgICAgZ3JhcGhlbWVCcmVha1R5cGUgPSBuZXh0R3JhcGhlbWVCcmVha1R5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKG9mZnNldCAtIGluaXRpYWxPZmZzZXQpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2Q2hhckxlbmd0aChzdHIsIG9mZnNldCkge1xyXG4gICAgY29uc3QgZ3JhcGhlbWVCcmVha1RyZWUgPSBHcmFwaGVtZUJyZWFrVHJlZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgY29uc3QgaW5pdGlhbE9mZnNldCA9IG9mZnNldDtcclxuICAgIGNvbnN0IGluaXRpYWxDb2RlUG9pbnQgPSBnZXRQcmV2Q29kZVBvaW50KHN0ciwgb2Zmc2V0KTtcclxuICAgIG9mZnNldCAtPSAoaW5pdGlhbENvZGVQb2ludCA+PSA2NTUzNiAvKiBVTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XHJcbiAgICBsZXQgZ3JhcGhlbWVCcmVha1R5cGUgPSBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShpbml0aWFsQ29kZVBvaW50KTtcclxuICAgIHdoaWxlIChvZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgY29uc3QgcHJldkNvZGVQb2ludCA9IGdldFByZXZDb2RlUG9pbnQoc3RyLCBvZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IHByZXZHcmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKHByZXZDb2RlUG9pbnQpO1xyXG4gICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShwcmV2R3JhcGhlbWVCcmVha1R5cGUsIGdyYXBoZW1lQnJlYWtUeXBlKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0IC09IChwcmV2Q29kZVBvaW50ID49IDY1NTM2IC8qIFVOSUNPREVfU1VQUExFTUVOVEFSWV9QTEFORV9CRUdJTiAqLyA/IDIgOiAxKTtcclxuICAgICAgICBncmFwaGVtZUJyZWFrVHlwZSA9IHByZXZHcmFwaGVtZUJyZWFrVHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoaW5pdGlhbE9mZnNldCAtIG9mZnNldCk7XHJcbn1cclxuLyoqXHJcbiAqIEEgbWFudWFsIGRlY29kaW5nIG9mIGEgVVRGOCBzdHJpbmcuXHJcbiAqIFVzZSBvbmx5IGluIGVudmlyb25tZW50cyB3aGljaCBkbyBub3Qgb2ZmZXIgbmF0aXZlIGNvbnZlcnNpb24gbWV0aG9kcyFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVVVEY4KGJ1ZmZlcikge1xyXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLThcclxuICAgIGNvbnN0IGxlbiA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW4pIHtcclxuICAgICAgICBjb25zdCB2MCA9IGJ1ZmZlcltvZmZzZXRdO1xyXG4gICAgICAgIGxldCBjb2RlUG9pbnQ7XHJcbiAgICAgICAgaWYgKHYwID49IDBiMTExMTAwMDAgJiYgb2Zmc2V0ICsgMyA8IGxlbikge1xyXG4gICAgICAgICAgICAvLyA0IGJ5dGVzXHJcbiAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDAwMDExMSkgPDwgMTgpID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDExMTExMSkgPDwgMTIpID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDExMTExMSkgPDwgNikgPj4+IDApXHJcbiAgICAgICAgICAgICAgICB8ICgoKGJ1ZmZlcltvZmZzZXQrK10gJiAwYjAwMTExMTExKSA8PCAwKSA+Pj4gMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2MCA+PSAwYjExMTAwMDAwICYmIG9mZnNldCArIDIgPCBsZW4pIHtcclxuICAgICAgICAgICAgLy8gMyBieXRlc1xyXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAoKCgoYnVmZmVyW29mZnNldCsrXSAmIDBiMDAwMDExMTEpIDw8IDEyKSA+Pj4gMClcclxuICAgICAgICAgICAgICAgIHwgKCgoYnVmZmVyW29mZnNldCsrXSAmIDBiMDAxMTExMTEpIDw8IDYpID4+PiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoKChidWZmZXJbb2Zmc2V0KytdICYgMGIwMDExMTExMSkgPDwgMCkgPj4+IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodjAgPj0gMGIxMTAwMDAwMCAmJiBvZmZzZXQgKyAxIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIC8vIDIgYnl0ZXNcclxuICAgICAgICAgICAgY29kZVBvaW50ID0gKCgoKGJ1ZmZlcltvZmZzZXQrK10gJiAwYjAwMDExMTExKSA8PCA2KSA+Pj4gMClcclxuICAgICAgICAgICAgICAgIHwgKCgoYnVmZmVyW29mZnNldCsrXSAmIDBiMDAxMTExMTEpIDw8IDApID4+PiAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAxIGJ5dGVcclxuICAgICAgICAgICAgY29kZVBvaW50ID0gYnVmZmVyW29mZnNldCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChjb2RlUG9pbnQgPj0gMCAmJiBjb2RlUG9pbnQgPD0gMHhEN0ZGKSB8fCAoY29kZVBvaW50ID49IDB4RTAwMCAmJiBjb2RlUG9pbnQgPD0gMHhGRkZGKSkge1xyXG4gICAgICAgICAgICAvLyBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmVcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xyXG4gICAgICAgICAgICAvLyBTdXBwbGVtZW50YXJ5IFBsYW5lc1xyXG4gICAgICAgICAgICBjb25zdCB1UHJpbWUgPSBjb2RlUG9pbnQgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjb25zdCB3MSA9IDB4RDgwMCArICgodVByaW1lICYgMGIxMTExMTExMTExMDAwMDAwMDAwMCkgPj4+IDEwKTtcclxuICAgICAgICAgICAgY29uc3QgdzIgPSAweERDMDAgKyAoKHVQcmltZSAmIDBiMDAwMDAwMDAwMDExMTExMTExMTEpID4+PiAwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh3MSkpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHcyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpbGxlZ2FsIGNvZGUgcG9pbnRcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYXN0ZXIvZ2VuZXJhdGUtcnRsLXRlc3QuanNcclxuICovXHJcbmNvbnN0IENPTlRBSU5TX1JUTCA9IC8oPzpbXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RDAtXFx1MDVGNFxcdTA2MDhcXHUwNjBCXFx1MDYwRFxcdTA2MUItXFx1MDY0QVxcdTA2NkQtXFx1MDY2RlxcdTA2NzEtXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkEtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4MzAtXFx1MDg1OFxcdTA4NUUtXFx1MDhCRFxcdTIwMEZcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGRDNEXFx1RkQ1MC1cXHVGREZDXFx1RkU3MC1cXHVGRUZDXXxcXHVEODAyW1xcdURDMDAtXFx1REQxQlxcdUREMjAtXFx1REUwMFxcdURFMTAtXFx1REUzM1xcdURFNDAtXFx1REVFNFxcdURFRUItXFx1REYzNVxcdURGNDAtXFx1REZGRl18XFx1RDgwM1tcXHVEQzAwLVxcdURDRkZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0NGXFx1REQwMC1cXHVERDQzXFx1REQ1MC1cXHVERkZGXXxcXHVEODNCW1xcdURDMDAtXFx1REVCQl0pLztcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBjb250YWlucyBhbnkgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBpcyBjbGFzc2lmaWVkIGFzIFwiUlwiIG9yIFwiQUxcIi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1JUTChzdHIpIHtcclxuICAgIHJldHVybiBDT05UQUlOU19SVEwudGVzdChzdHIpO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYXN0ZXIvZ2VuZXJhdGUtZW1vamktdGVzdC5qc1xyXG4gKi9cclxuY29uc3QgQ09OVEFJTlNfRU1PSkkgPSAvKD86W1xcdTIzMUFcXHUyMzFCXFx1MjNGMFxcdTIzRjNcXHUyNjAwLVxcdTI3QkZcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEREU2LVxcdURERkZcXHVERjAwLVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERTRGXFx1REU4MC1cXHVERUZDXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMDAtXFx1RERGRlxcdURFNzAtXFx1REVENl0pLztcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRW1vamkoc3RyKSB7XHJcbiAgICByZXR1cm4gQ09OVEFJTlNfRU1PSkkudGVzdChzdHIpO1xyXG59XHJcbmNvbnN0IElTX0JBU0lDX0FTQ0lJID0gL15bXFx0XFxuXFxyXFx4MjAtXFx4N0VdKiQvO1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIG9ubHkgYmFzaWMgQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgMzIgLSAxMjYgKGluY2x1ZGluZyAzMiBhbmQgMTI2KSBvciBcXG4sIFxcciwgXFx0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNCYXNpY0FTQ0lJKHN0cikge1xyXG4gICAgcmV0dXJuIElTX0JBU0lDX0FTQ0lJLnRlc3Qoc3RyKTtcclxufVxyXG5leHBvcnQgY29uc3QgVU5VU1VBTF9MSU5FX1RFUk1JTkFUT1JTID0gL1tcXHUyMDI4XFx1MjAyOV0vOyAvLyBMSU5FIFNFUEFSQVRPUiAoTFMpIG9yIFBBUkFHUkFQSCBTRVBBUkFUT1IgKFBTKVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIHVudXN1YWwgbGluZSB0ZXJtaW5hdG9ycywgbGlrZSBMUyBvciBQU1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycyhzdHIpIHtcclxuICAgIHJldHVybiBVTlVTVUFMX0xJTkVfVEVSTUlOQVRPUlMudGVzdChzdHIpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Z1bGxXaWR0aENoYXJhY3RlcihzdHIpIHtcclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNGdWxsV2lkdGhDaGFyYWN0ZXIoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaXNGdWxsV2lkdGhDaGFyYWN0ZXIoY2hhckNvZGUpIHtcclxuICAgIC8vIERvIGEgY2hlYXAgdHJpY2sgdG8gYmV0dGVyIHN1cHBvcnQgd3JhcHBpbmcgb2Ygd2lkZSBjaGFyYWN0ZXJzLCB0cmVhdCB0aGVtIGFzIDIgY29sdW1uc1xyXG4gICAgLy8gaHR0cDovL2pyZ3JhcGhpeC5uZXQvcmVzZWFyY2gvdW5pY29kZV9ibG9ja3MucGhwXHJcbiAgICAvLyAgICAgICAgICAyRTgwIOKAlCAyRUZGICAgQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcclxuICAgIC8vICAgICAgICAgIDJGMDAg4oCUIDJGREYgICBLYW5neGkgUmFkaWNhbHNcclxuICAgIC8vICAgICAgICAgIDJGRjAg4oCUIDJGRkYgICBJZGVvZ3JhcGhpYyBEZXNjcmlwdGlvbiBDaGFyYWN0ZXJzXHJcbiAgICAvLyAgICAgICAgICAzMDAwIOKAlCAzMDNGICAgQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXHJcbiAgICAvLyAgICAgICAgICAzMDQwIOKAlCAzMDlGICAgSGlyYWdhbmFcclxuICAgIC8vICAgICAgICAgIDMwQTAg4oCUIDMwRkYgICBLYXRha2FuYVxyXG4gICAgLy8gICAgICAgICAgMzEwMCDigJQgMzEyRiAgIEJvcG9tb2ZvXHJcbiAgICAvLyAgICAgICAgICAzMTMwIOKAlCAzMThGICAgSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xyXG4gICAgLy8gICAgICAgICAgMzE5MCDigJQgMzE5RiAgIEthbmJ1blxyXG4gICAgLy8gICAgICAgICAgMzFBMCDigJQgMzFCRiAgIEJvcG9tb2ZvIEV4dGVuZGVkXHJcbiAgICAvLyAgICAgICAgICAzMUYwIOKAlCAzMUZGICAgS2F0YWthbmEgUGhvbmV0aWMgRXh0ZW5zaW9uc1xyXG4gICAgLy8gICAgICAgICAgMzIwMCDigJQgMzJGRiAgIEVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHNcclxuICAgIC8vICAgICAgICAgIDMzMDAg4oCUIDMzRkYgICBDSksgQ29tcGF0aWJpbGl0eVxyXG4gICAgLy8gICAgICAgICAgMzQwMCDigJQgNERCRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcclxuICAgIC8vICAgICAgICAgIDREQzAg4oCUIDRERkYgICBZaWppbmcgSGV4YWdyYW0gU3ltYm9sc1xyXG4gICAgLy8gICAgICAgICAgNEUwMCDigJQgOUZGRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcclxuICAgIC8vICAgICAgICAgIEEwMDAg4oCUIEE0OEYgICBZaSBTeWxsYWJsZXNcclxuICAgIC8vICAgICAgICAgIEE0OTAg4oCUIEE0Q0YgICBZaSBSYWRpY2Fsc1xyXG4gICAgLy8gICAgICAgICAgQUMwMCDigJQgRDdBRiAgIEhhbmd1bCBTeWxsYWJsZXNcclxuICAgIC8vIFtJR05PUkVdIEQ4MDAg4oCUIERCN0YgICBIaWdoIFN1cnJvZ2F0ZXNcclxuICAgIC8vIFtJR05PUkVdIERCODAg4oCUIERCRkYgICBIaWdoIFByaXZhdGUgVXNlIFN1cnJvZ2F0ZXNcclxuICAgIC8vIFtJR05PUkVdIERDMDAg4oCUIERGRkYgICBMb3cgU3Vycm9nYXRlc1xyXG4gICAgLy8gW0lHTk9SRV0gRTAwMCDigJQgRjhGRiAgIFByaXZhdGUgVXNlIEFyZWFcclxuICAgIC8vICAgICAgICAgIEY5MDAg4oCUIEZBRkYgICBDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXHJcbiAgICAvLyBbSUdOT1JFXSBGQjAwIOKAlCBGQjRGICAgQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcclxuICAgIC8vIFtJR05PUkVdIEZCNTAg4oCUIEZERkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUFcclxuICAgIC8vIFtJR05PUkVdIEZFMDAg4oCUIEZFMEYgICBWYXJpYXRpb24gU2VsZWN0b3JzXHJcbiAgICAvLyBbSUdOT1JFXSBGRTIwIOKAlCBGRTJGICAgQ29tYmluaW5nIEhhbGYgTWFya3NcclxuICAgIC8vIFtJR05PUkVdIEZFMzAg4oCUIEZFNEYgICBDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1xyXG4gICAgLy8gW0lHTk9SRV0gRkU1MCDigJQgRkU2RiAgIFNtYWxsIEZvcm0gVmFyaWFudHNcclxuICAgIC8vIFtJR05PUkVdIEZFNzAg4oCUIEZFRkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcclxuICAgIC8vICAgICAgICAgIEZGMDAg4oCUIEZGRUYgICBIYWxmd2lkdGggYW5kIEZ1bGx3aWR0aCBGb3Jtc1xyXG4gICAgLy8gICAgICAgICAgICAgICBbaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFsZndpZHRoX2FuZF9mdWxsd2lkdGhfZm9ybXNdXHJcbiAgICAvLyAgICAgICAgICAgICAgIG9mIHdoaWNoIEZGMDEgLSBGRjVFIGZ1bGx3aWR0aCBBU0NJSSBvZiAyMSB0byA3RVxyXG4gICAgLy8gW0lHTk9SRV0gICAgYW5kIEZGNjUgLSBGRkRDIGhhbGZ3aWR0aCBvZiBLYXRha2FuYSBhbmQgSGFuZ3VsXHJcbiAgICAvLyBbSUdOT1JFXSBGRkYwIOKAlCBGRkZGICAgU3BlY2lhbHNcclxuICAgIGNoYXJDb2RlID0gK2NoYXJDb2RlOyAvLyBAcGVyZlxyXG4gICAgcmV0dXJuICgoY2hhckNvZGUgPj0gMHgyRTgwICYmIGNoYXJDb2RlIDw9IDB4RDdBRilcclxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGOTAwICYmIGNoYXJDb2RlIDw9IDB4RkFGRilcclxuICAgICAgICB8fCAoY2hhckNvZGUgPj0gMHhGRjAxICYmIGNoYXJDb2RlIDw9IDB4RkY1RSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGZhc3QgZnVuY3Rpb24gKHRoZXJlZm9yZSBpbXByZWNpc2UpIHRvIGNoZWNrIGlmIGNvZGUgcG9pbnRzIGFyZSBlbW9qaXMuXHJcbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGRpbWEvdW5pY29kZS11dGlscy9ibG9iL21hc3Rlci9nZW5lcmF0ZS1lbW9qaS10ZXN0LmpzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFbW9qaUltcHJlY2lzZSh4KSB7XHJcbiAgICByZXR1cm4gKCh4ID49IDB4MUYxRTYgJiYgeCA8PSAweDFGMUZGKSB8fCAoeCA9PT0gODk4NikgfHwgKHggPT09IDg5ODcpIHx8ICh4ID09PSA5MjAwKVxyXG4gICAgICAgIHx8ICh4ID09PSA5MjAzKSB8fCAoeCA+PSA5NzI4ICYmIHggPD0gMTAxNzUpIHx8ICh4ID09PSAxMTA4OCkgfHwgKHggPT09IDExMDkzKVxyXG4gICAgICAgIHx8ICh4ID49IDEyNzc0NCAmJiB4IDw9IDEyODU5MSkgfHwgKHggPj0gMTI4NjQwICYmIHggPD0gMTI4NzY0KVxyXG4gICAgICAgIHx8ICh4ID49IDEyODk5MiAmJiB4IDw9IDEyOTAwMykgfHwgKHggPj0gMTI5MjgwICYmIHggPD0gMTI5NTM1KVxyXG4gICAgICAgIHx8ICh4ID49IDEyOTY0OCAmJiB4IDw9IDEyOTc1MCkpO1xyXG59XHJcbi8vIC0tIFVURi04IEJPTVxyXG5leHBvcnQgY29uc3QgVVRGOF9CT01fQ0hBUkFDVEVSID0gU3RyaW5nLmZyb21DaGFyQ29kZSg2NTI3OSAvKiBVVEY4X0JPTSAqLyk7XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoVVRGOEJPTShzdHIpIHtcclxuICAgIHJldHVybiAhIShzdHIgJiYgc3RyLmxlbmd0aCA+IDAgJiYgc3RyLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5IC8qIFVURjhfQk9NICovKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIodGFyZ2V0LCBpZ25vcmVFc2NhcGVkQ2hhcnMgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaWdub3JlRXNjYXBlZENoYXJzKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnJlcGxhY2UoL1xcXFwuL2csICcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQudG9Mb3dlckNhc2UoKSAhPT0gdGFyZ2V0O1xyXG59XHJcbi8qKlxyXG4gKiBQcm9kdWNlcyAnYSctJ3onLCBmb2xsb3dlZCBieSAnQSctJ1onLi4uIGZvbGxvd2VkIGJ5ICdhJy0neicsIGV0Yy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVMZXR0ZXJIYXNoKG4pIHtcclxuICAgIGNvbnN0IExFVFRFUlNfQ05UID0gKDkwIC8qIFogKi8gLSA2NSAvKiBBICovICsgMSk7XHJcbiAgICBuID0gbiAlICgyICogTEVUVEVSU19DTlQpO1xyXG4gICAgaWYgKG4gPCBMRVRURVJTX0NOVCkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3IC8qIGEgKi8gKyBuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIEEgKi8gKyBuIC0gTEVUVEVSU19DTlQpO1xyXG59XHJcbi8vI3JlZ2lvbiBVbmljb2RlIEdyYXBoZW1lIEJyZWFrXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHcmFwaGVtZUJyZWFrVHlwZShjb2RlUG9pbnQpIHtcclxuICAgIGNvbnN0IGdyYXBoZW1lQnJlYWtUcmVlID0gR3JhcGhlbWVCcmVha1RyZWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHJldHVybiBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShjb2RlUG9pbnQpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShicmVha1R5cGVBLCBicmVha1R5cGVCKSB7XHJcbiAgICAvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIyOS8jR3JhcGhlbWVfQ2x1c3Rlcl9Cb3VuZGFyeV9SdWxlc1xyXG4gICAgLy8gISEhIExldCdzIG1ha2UgdGhlIGNvbW1vbiBjYXNlIGEgYml0IGZhc3RlclxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDAgLyogT3RoZXIgKi8pIHtcclxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljLzEzLjAuMC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LTEzLjAuMGQxMC5odG1sI3RhYmxlXHJcbiAgICAgICAgcmV0dXJuIChicmVha1R5cGVCICE9PSA1IC8qIEV4dGVuZCAqLyAmJiBicmVha1R5cGVCICE9PSA3IC8qIFNwYWNpbmdNYXJrICovKTtcclxuICAgIH1cclxuICAgIC8vIERvIG5vdCBicmVhayBiZXR3ZWVuIGEgQ1IgYW5kIExGLiBPdGhlcndpc2UsIGJyZWFrIGJlZm9yZSBhbmQgYWZ0ZXIgY29udHJvbHMuXHJcbiAgICAvLyBHQjMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1Igw5cgTEZcclxuICAgIC8vIEdCNCAgICAgICAgICAgICAgICAgICAgICAgKENvbnRyb2wgfCBDUiB8IExGKSDDt1xyXG4gICAgLy8gR0I1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIMO3IChDb250cm9sIHwgQ1IgfCBMRilcclxuICAgIGlmIChicmVha1R5cGVBID09PSAyIC8qIENSICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDMgLyogTEYgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjNcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNCAvKiBDb250cm9sICovIHx8IGJyZWFrVHlwZUEgPT09IDIgLyogQ1IgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMyAvKiBMRiAqLykge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBHQjRcclxuICAgIH1cclxuICAgIGlmIChicmVha1R5cGVCID09PSA0IC8qIENvbnRyb2wgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMiAvKiBDUiAqLyB8fCBicmVha1R5cGVCID09PSAzIC8qIExGICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEdCNVxyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGJyZWFrIEhhbmd1bCBzeWxsYWJsZSBzZXF1ZW5jZXMuXHJcbiAgICAvLyBHQjYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgw5cgKEwgfCBWIHwgTFYgfCBMVlQpXHJcbiAgICAvLyBHQjcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWIHwgVikgw5cgKFYgfCBUKVxyXG4gICAgLy8gR0I4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKExWVCB8IFQpIMOXIFRcclxuICAgIGlmIChicmVha1R5cGVBID09PSA4IC8qIEwgKi8pIHtcclxuICAgICAgICBpZiAoYnJlYWtUeXBlQiA9PT0gOCAvKiBMICovIHx8IGJyZWFrVHlwZUIgPT09IDkgLyogViAqLyB8fCBicmVha1R5cGVCID09PSAxMSAvKiBMViAqLyB8fCBicmVha1R5cGVCID09PSAxMiAvKiBMVlQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjZcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gMTEgLyogTFYgKi8gfHwgYnJlYWtUeXBlQSA9PT0gOSAvKiBWICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDkgLyogViAqLyB8fCBicmVha1R5cGVCID09PSAxMCAvKiBUICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I3XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEyIC8qIExWVCAqLyB8fCBicmVha1R5cGVBID09PSAxMCAvKiBUICovKSB7XHJcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDEwIC8qIFQgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjhcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBEbyBub3QgYnJlYWsgYmVmb3JlIGV4dGVuZGluZyBjaGFyYWN0ZXJzIG9yIFpXSi5cclxuICAgIC8vIEdCOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDlyAoRXh0ZW5kIHwgWldKKVxyXG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDUgLyogRXh0ZW5kICovIHx8IGJyZWFrVHlwZUIgPT09IDEzIC8qIFpXSiAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgR0I5YSBhbmQgR0I5YiBydWxlcyBvbmx5IGFwcGx5IHRvIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzOlxyXG4gICAgLy8gRG8gbm90IGJyZWFrIGJlZm9yZSBTcGFjaW5nTWFya3MsIG9yIGFmdGVyIFByZXBlbmQgY2hhcmFjdGVycy5cclxuICAgIC8vIEdCOWEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDlyBTcGFjaW5nTWFya1xyXG4gICAgLy8gR0I5YiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcmVwZW5kIMOXXHJcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNyAvKiBTcGFjaW5nTWFyayAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5YVxyXG4gICAgfVxyXG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEgLyogUHJlcGVuZCAqLykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5YlxyXG4gICAgfVxyXG4gICAgLy8gRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBtb2RpZmllciBzZXF1ZW5jZXMgb3IgZW1vamkgendqIHNlcXVlbmNlcy5cclxuICAgIC8vIEdCMTEgICAgXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY30gRXh0ZW5kKiBaV0ogw5cgXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY31cclxuICAgIGlmIChicmVha1R5cGVBID09PSAxMyAvKiBaV0ogKi8gJiYgYnJlYWtUeXBlQiA9PT0gMTQgLyogRXh0ZW5kZWRfUGljdG9ncmFwaGljICovKSB7XHJcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUgZW50aXJlbHkgaGVyZSB0byBhdm9pZCBpbnRyb2R1Y2luZyBzdGF0ZXNcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCMTFcclxuICAgIH1cclxuICAgIC8vIEdCMTIgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdCAoUkkgUkkpKiBSSSDDlyBSSVxyXG4gICAgLy8gR0IxMyAgICAgICAgICAgICAgICAgICAgICAgIFteUkldIChSSSBSSSkqIFJJIMOXIFJJXHJcbiAgICBpZiAoYnJlYWtUeXBlQSA9PT0gNiAvKiBSZWdpb25hbF9JbmRpY2F0b3IgKi8gJiYgYnJlYWtUeXBlQiA9PT0gNiAvKiBSZWdpb25hbF9JbmRpY2F0b3IgKi8pIHtcclxuICAgICAgICAvLyBOb3RlOiB3ZSBhcmUgbm90IGltcGxlbWVudGluZyB0aGUgcnVsZSBlbnRpcmVseSBoZXJlIHRvIGF2b2lkIGludHJvZHVjaW5nIHN0YXRlc1xyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0IxMiAmIEdCMTNcclxuICAgIH1cclxuICAgIC8vIEdCOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSDDtyBBbnlcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmNsYXNzIEdyYXBoZW1lQnJlYWtUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBnZXRHcmFwaGVtZUJyZWFrUmF3RGF0YSgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIGlmICghR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIEdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSA9IG5ldyBHcmFwaGVtZUJyZWFrVHJlZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFO1xyXG4gICAgfVxyXG4gICAgZ2V0R3JhcGhlbWVCcmVha1R5cGUoY29kZVBvaW50KSB7XHJcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDAuLjMxXHJcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDMyKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT09IDEwIC8qIExpbmVGZWVkICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBMRiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSAxMyAvKiBDYXJyaWFnZVJldHVybiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogQ1IgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDQgLyogQ29udHJvbCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDMyLi4xMjZcclxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMTI3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE90aGVyICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICBjb25zdCBub2RlQ291bnQgPSBkYXRhLmxlbmd0aCAvIDM7XHJcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKG5vZGVJbmRleCA8PSBub2RlQ291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IGRhdGFbMyAqIG5vZGVJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIGxlZnRcclxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IDIgKiBub2RlSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID4gZGF0YVszICogbm9kZUluZGV4ICsgMV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSAyICogbm9kZUluZGV4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGhpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMyAqIG5vZGVJbmRleCArIDJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwIC8qIE90aGVyICovO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldEdyYXBoZW1lQnJlYWtSYXdEYXRhKCkge1xyXG4gICAgLy8gZ2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFzdGVyL2dlbmVyYXRlLWdyYXBoZW1lLWJyZWFrLmpzXHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZSgnWzAsMCwwLDUxNTkyLDUxNTkyLDExLDQ0NDI0LDQ0NDI0LDExLDcyMjUxLDcyMjU0LDUsNzE1MCw3MTUwLDcsNDgwMDgsNDgwMDgsMTEsNTUxNzYsNTUxNzYsMTEsMTI4NDIwLDEyODQyMCwxNCwzMjc2LDMyNzcsNSw5OTc5LDk5ODAsMTQsNDYyMTYsNDYyMTYsMTEsNDk4MDAsNDk4MDAsMTEsNTMzODQsNTMzODQsMTEsNzA3MjYsNzA3MjYsNSwxMjI5MTUsMTIyOTE2LDUsMTI5MzIwLDEyOTMyNywxNCwyNTU4LDI1NTgsNSw1OTA2LDU5MDgsNSw5NzYyLDk3NjMsMTQsNDMzNjAsNDMzODgsOCw0NTMyMCw0NTMyMCwxMSw0NzExMiw0NzExMiwxMSw0ODkwNCw0ODkwNCwxMSw1MDY5Niw1MDY5NiwxMSw1MjQ4OCw1MjQ4OCwxMSw1NDI4MCw1NDI4MCwxMSw3MDA4Miw3MDA4MywxLDcxMzUwLDcxMzUwLDcsNzMxMTEsNzMxMTEsNSwxMjc4OTIsMTI3ODkzLDE0LDEyODcyNiwxMjg3MjcsMTQsMTI5NDczLDEyOTQ3NCwxNCwyMDI3LDIwMzUsNSwyOTAxLDI5MDIsNSwzNzg0LDM3ODksNSw2NzU0LDY3NTQsNSw4NDE4LDg0MjAsNSw5ODc3LDk4NzcsMTQsMTEwODgsMTEwODgsMTQsNDQwMDgsNDQwMDgsNSw0NDg3Miw0NDg3MiwxMSw0NTc2OCw0NTc2OCwxMSw0NjY2NCw0NjY2NCwxMSw0NzU2MCw0NzU2MCwxMSw0ODQ1Niw0ODQ1NiwxMSw0OTM1Miw0OTM1MiwxMSw1MDI0OCw1MDI0OCwxMSw1MTE0NCw1MTE0NCwxMSw1MjA0MCw1MjA0MCwxMSw1MjkzNiw1MjkzNiwxMSw1MzgzMiw1MzgzMiwxMSw1NDcyOCw1NDcyOCwxMSw2OTgxMSw2OTgxNCw1LDcwNDU5LDcwNDYwLDUsNzEwOTYsNzEwOTksNyw3MTk5OCw3MTk5OCw1LDcyODc0LDcyODgwLDUsMTE5MTQ5LDExOTE0OSw3LDEyNzM3NCwxMjczNzQsMTQsMTI4MzM1LDEyODMzNSwxNCwxMjg0ODIsMTI4NDgyLDE0LDEyODc2NSwxMjg3NjcsMTQsMTI5Mzk5LDEyOTQwMCwxNCwxMjk2ODAsMTI5Njg1LDE0LDE0NzYsMTQ3Nyw1LDIzNzcsMjM4MCw3LDI3NTksMjc2MCw1LDMxMzcsMzE0MCw3LDM0NTgsMzQ1OSw3LDQxNTMsNDE1NCw1LDY0MzIsNjQzNCw1LDY5NzgsNjk3OCw1LDc2NzUsNzY3OSw1LDk3MjMsOTcyNiwxNCw5ODIzLDk4MjMsMTQsOTkxOSw5OTIzLDE0LDEwMDM1LDEwMDM2LDE0LDQyNzM2LDQyNzM3LDUsNDM1OTYsNDM1OTYsNSw0NDIwMCw0NDIwMCwxMSw0NDY0OCw0NDY0OCwxMSw0NTA5Niw0NTA5NiwxMSw0NTU0NCw0NTU0NCwxMSw0NTk5Miw0NTk5MiwxMSw0NjQ0MCw0NjQ0MCwxMSw0Njg4OCw0Njg4OCwxMSw0NzMzNiw0NzMzNiwxMSw0Nzc4NCw0Nzc4NCwxMSw0ODIzMiw0ODIzMiwxMSw0ODY4MCw0ODY4MCwxMSw0OTEyOCw0OTEyOCwxMSw0OTU3Niw0OTU3NiwxMSw1MDAyNCw1MDAyNCwxMSw1MDQ3Miw1MDQ3MiwxMSw1MDkyMCw1MDkyMCwxMSw1MTM2OCw1MTM2OCwxMSw1MTgxNiw1MTgxNiwxMSw1MjI2NCw1MjI2NCwxMSw1MjcxMiw1MjcxMiwxMSw1MzE2MCw1MzE2MCwxMSw1MzYwOCw1MzYwOCwxMSw1NDA1Niw1NDA1NiwxMSw1NDUwNCw1NDUwNCwxMSw1NDk1Miw1NDk1MiwxMSw2ODEwOCw2ODExMSw1LDY5OTMzLDY5OTQwLDUsNzAxOTcsNzAxOTcsNyw3MDQ5OCw3MDQ5OSw3LDcwODQ1LDcwODQ1LDUsNzEyMjksNzEyMjksNSw3MTcyNyw3MTczNSw1LDcyMTU0LDcyMTU1LDUsNzIzNDQsNzIzNDUsNSw3MzAyMyw3MzAyOSw1LDk0MDk1LDk0MDk4LDUsMTIxNDAzLDEyMTQ1Miw1LDEyNjk4MSwxMjcxODIsMTQsMTI3NTM4LDEyNzU0NiwxNCwxMjc5OTAsMTI3OTkwLDE0LDEyODM5MSwxMjgzOTEsMTQsMTI4NDQ1LDEyODQ0OSwxNCwxMjg1MDAsMTI4NTA1LDE0LDEyODc1MiwxMjg3NTIsMTQsMTI5MTYwLDEyOTE2NywxNCwxMjkzNTYsMTI5MzU2LDE0LDEyOTQzMiwxMjk0NDIsMTQsMTI5NjQ4LDEyOTY1MSwxNCwxMjk3NTEsMTMxMDY5LDE0LDE3MywxNzMsNCwxNzU3LDE3NTcsMSwyMjc0LDIyNzQsMSwyNDk0LDI0OTQsNSwyNjQxLDI2NDEsNSwyODc2LDI4NzYsNSwzMDE0LDMwMTYsNywzMjYyLDMyNjIsNywzMzkzLDMzOTYsNSwzNTcwLDM1NzEsNywzOTY4LDM5NzIsNSw0MjI4LDQyMjgsNyw2MDg2LDYwODYsNSw2Njc5LDY2ODAsNSw2OTEyLDY5MTUsNSw3MDgwLDcwODEsNSw3MzgwLDczOTIsNSw4MjUyLDgyNTIsMTQsOTA5Niw5MDk2LDE0LDk3NDgsOTc0OSwxNCw5Nzg0LDk3ODYsMTQsOTgzMyw5ODUwLDE0LDk4OTAsOTg5NCwxNCw5OTM4LDk5MzgsMTQsOTk5OSw5OTk5LDE0LDEwMDg1LDEwMDg3LDE0LDEyMzQ5LDEyMzQ5LDE0LDQzMTM2LDQzMTM3LDcsNDM0NTQsNDM0NTYsNyw0Mzc1NSw0Mzc1NSw3LDQ0MDg4LDQ0MDg4LDExLDQ0MzEyLDQ0MzEyLDExLDQ0NTM2LDQ0NTM2LDExLDQ0NzYwLDQ0NzYwLDExLDQ0OTg0LDQ0OTg0LDExLDQ1MjA4LDQ1MjA4LDExLDQ1NDMyLDQ1NDMyLDExLDQ1NjU2LDQ1NjU2LDExLDQ1ODgwLDQ1ODgwLDExLDQ2MTA0LDQ2MTA0LDExLDQ2MzI4LDQ2MzI4LDExLDQ2NTUyLDQ2NTUyLDExLDQ2Nzc2LDQ2Nzc2LDExLDQ3MDAwLDQ3MDAwLDExLDQ3MjI0LDQ3MjI0LDExLDQ3NDQ4LDQ3NDQ4LDExLDQ3NjcyLDQ3NjcyLDExLDQ3ODk2LDQ3ODk2LDExLDQ4MTIwLDQ4MTIwLDExLDQ4MzQ0LDQ4MzQ0LDExLDQ4NTY4LDQ4NTY4LDExLDQ4NzkyLDQ4NzkyLDExLDQ5MDE2LDQ5MDE2LDExLDQ5MjQwLDQ5MjQwLDExLDQ5NDY0LDQ5NDY0LDExLDQ5Njg4LDQ5Njg4LDExLDQ5OTEyLDQ5OTEyLDExLDUwMTM2LDUwMTM2LDExLDUwMzYwLDUwMzYwLDExLDUwNTg0LDUwNTg0LDExLDUwODA4LDUwODA4LDExLDUxMDMyLDUxMDMyLDExLDUxMjU2LDUxMjU2LDExLDUxNDgwLDUxNDgwLDExLDUxNzA0LDUxNzA0LDExLDUxOTI4LDUxOTI4LDExLDUyMTUyLDUyMTUyLDExLDUyMzc2LDUyMzc2LDExLDUyNjAwLDUyNjAwLDExLDUyODI0LDUyODI0LDExLDUzMDQ4LDUzMDQ4LDExLDUzMjcyLDUzMjcyLDExLDUzNDk2LDUzNDk2LDExLDUzNzIwLDUzNzIwLDExLDUzOTQ0LDUzOTQ0LDExLDU0MTY4LDU0MTY4LDExLDU0MzkyLDU0MzkyLDExLDU0NjE2LDU0NjE2LDExLDU0ODQwLDU0ODQwLDExLDU1MDY0LDU1MDY0LDExLDY1NDM4LDY1NDM5LDUsNjk2MzMsNjk2MzMsNSw2OTgzNyw2OTgzNywxLDcwMDE4LDcwMDE4LDcsNzAxODgsNzAxOTAsNyw3MDM2OCw3MDM3MCw3LDcwNDY1LDcwNDY4LDcsNzA3MTIsNzA3MTksNSw3MDgzNSw3MDg0MCw1LDcwODUwLDcwODUxLDUsNzExMzIsNzExMzMsNSw3MTM0MCw3MTM0MCw3LDcxNDU4LDcxNDYxLDUsNzE5ODUsNzE5ODksNyw3MjAwMiw3MjAwMiw3LDcyMTkzLDcyMjAyLDUsNzIyODEsNzIyODMsNSw3Mjc2Niw3Mjc2Niw3LDcyODg1LDcyODg2LDUsNzMxMDQsNzMxMDUsNSw5MjkxMiw5MjkxNiw1LDExMzgyNCwxMTM4MjcsNCwxMTkxNzMsMTE5MTc5LDUsMTIxNTA1LDEyMTUxOSw1LDEyNTEzNiwxMjUxNDIsNSwxMjcyNzksMTI3Mjc5LDE0LDEyNzQ4OSwxMjc0OTAsMTQsMTI3NTcwLDEyNzc0MywxNCwxMjc5MDAsMTI3OTAxLDE0LDEyODI1NCwxMjgyNTQsMTQsMTI4MzY5LDEyODM3MCwxNCwxMjg0MDAsMTI4NDAwLDE0LDEyODQyNSwxMjg0MzIsMTQsMTI4NDY4LDEyODQ3NSwxNCwxMjg0ODksMTI4NDk0LDE0LDEyODcxNSwxMjg3MjAsMTQsMTI4NzQ1LDEyODc0NSwxNCwxMjg3NTksMTI4NzYwLDE0LDEyOTAwNCwxMjkwMjMsMTQsMTI5Mjk2LDEyOTMwNCwxNCwxMjkzNDAsMTI5MzQyLDE0LDEyOTM4OCwxMjkzOTIsMTQsMTI5NDA0LDEyOTQwNywxNCwxMjk0NTQsMTI5NDU1LDE0LDEyOTQ4NSwxMjk0ODcsMTQsMTI5NjU5LDEyOTY2MywxNCwxMjk3MTksMTI5NzI3LDE0LDkxNzUzNiw5MTc2MzEsNSwxMywxMywyLDExNjAsMTE2MSw1LDE1NjQsMTU2NCw0LDE4MDcsMTgwNywxLDIwODUsMjA4Nyw1LDIzNjMsMjM2Myw3LDI0MDIsMjQwMyw1LDI1MDcsMjUwOCw3LDI2MjIsMjYyNCw3LDI2OTEsMjY5MSw3LDI3ODYsMjc4Nyw1LDI4ODEsMjg4NCw1LDMwMDYsMzAwNiw1LDMwNzIsMzA3Miw1LDMxNzAsMzE3MSw1LDMyNjcsMzI2OCw3LDMzMzAsMzMzMSw3LDM0MDYsMzQwNiwxLDM1MzgsMzU0MCw1LDM2NTUsMzY2Miw1LDM4OTcsMzg5Nyw1LDQwMzgsNDAzOCw1LDQxODQsNDE4NSw1LDQzNTIsNDQ0Nyw4LDYwNjgsNjA2OSw1LDYxNTUsNjE1Nyw1LDY0NDgsNjQ0OSw3LDY3NDIsNjc0Miw1LDY3ODMsNjc4Myw1LDY5NjYsNjk3MCw1LDcwNDIsNzA0Miw3LDcxNDMsNzE0Myw3LDcyMTIsNzIxOSw1LDc0MTIsNzQxMiw1LDgyMDYsODIwNyw0LDgyOTQsODMwMyw0LDg1OTYsODYwMSwxNCw5NDEwLDk0MTAsMTQsOTc0Miw5NzQyLDE0LDk3NTcsOTc1NywxNCw5NzcwLDk3NzAsMTQsOTc5NCw5Nzk0LDE0LDk4MjgsOTgyOCwxNCw5ODU1LDk4NTUsMTQsOTg4Miw5ODgyLDE0LDk5MDAsOTkwMywxNCw5OTI5LDk5MzMsMTQsOTk2Myw5OTY3LDE0LDk5ODcsOTk4OCwxNCwxMDAwNiwxMDAwNiwxNCwxMDA2MiwxMDA2MiwxNCwxMDE3NSwxMDE3NSwxNCwxMTc0NCwxMTc3NSw1LDQyNjA3LDQyNjA3LDUsNDMwNDMsNDMwNDQsNyw0MzI2Myw0MzI2Myw1LDQzNDQ0LDQzNDQ1LDcsNDM1NjksNDM1NzAsNSw0MzY5OCw0MzcwMCw1LDQzNzY2LDQzNzY2LDUsNDQwMzIsNDQwMzIsMTEsNDQxNDQsNDQxNDQsMTEsNDQyNTYsNDQyNTYsMTEsNDQzNjgsNDQzNjgsMTEsNDQ0ODAsNDQ0ODAsMTEsNDQ1OTIsNDQ1OTIsMTEsNDQ3MDQsNDQ3MDQsMTEsNDQ4MTYsNDQ4MTYsMTEsNDQ5MjgsNDQ5MjgsMTEsNDUwNDAsNDUwNDAsMTEsNDUxNTIsNDUxNTIsMTEsNDUyNjQsNDUyNjQsMTEsNDUzNzYsNDUzNzYsMTEsNDU0ODgsNDU0ODgsMTEsNDU2MDAsNDU2MDAsMTEsNDU3MTIsNDU3MTIsMTEsNDU4MjQsNDU4MjQsMTEsNDU5MzYsNDU5MzYsMTEsNDYwNDgsNDYwNDgsMTEsNDYxNjAsNDYxNjAsMTEsNDYyNzIsNDYyNzIsMTEsNDYzODQsNDYzODQsMTEsNDY0OTYsNDY0OTYsMTEsNDY2MDgsNDY2MDgsMTEsNDY3MjAsNDY3MjAsMTEsNDY4MzIsNDY4MzIsMTEsNDY5NDQsNDY5NDQsMTEsNDcwNTYsNDcwNTYsMTEsNDcxNjgsNDcxNjgsMTEsNDcyODAsNDcyODAsMTEsNDczOTIsNDczOTIsMTEsNDc1MDQsNDc1MDQsMTEsNDc2MTYsNDc2MTYsMTEsNDc3MjgsNDc3MjgsMTEsNDc4NDAsNDc4NDAsMTEsNDc5NTIsNDc5NTIsMTEsNDgwNjQsNDgwNjQsMTEsNDgxNzYsNDgxNzYsMTEsNDgyODgsNDgyODgsMTEsNDg0MDAsNDg0MDAsMTEsNDg1MTIsNDg1MTIsMTEsNDg2MjQsNDg2MjQsMTEsNDg3MzYsNDg3MzYsMTEsNDg4NDgsNDg4NDgsMTEsNDg5NjAsNDg5NjAsMTEsNDkwNzIsNDkwNzIsMTEsNDkxODQsNDkxODQsMTEsNDkyOTYsNDkyOTYsMTEsNDk0MDgsNDk0MDgsMTEsNDk1MjAsNDk1MjAsMTEsNDk2MzIsNDk2MzIsMTEsNDk3NDQsNDk3NDQsMTEsNDk4NTYsNDk4NTYsMTEsNDk5NjgsNDk5NjgsMTEsNTAwODAsNTAwODAsMTEsNTAxOTIsNTAxOTIsMTEsNTAzMDQsNTAzMDQsMTEsNTA0MTYsNTA0MTYsMTEsNTA1MjgsNTA1MjgsMTEsNTA2NDAsNTA2NDAsMTEsNTA3NTIsNTA3NTIsMTEsNTA4NjQsNTA4NjQsMTEsNTA5NzYsNTA5NzYsMTEsNTEwODgsNTEwODgsMTEsNTEyMDAsNTEyMDAsMTEsNTEzMTIsNTEzMTIsMTEsNTE0MjQsNTE0MjQsMTEsNTE1MzYsNTE1MzYsMTEsNTE2NDgsNTE2NDgsMTEsNTE3NjAsNTE3NjAsMTEsNTE4NzIsNTE4NzIsMTEsNTE5ODQsNTE5ODQsMTEsNTIwOTYsNTIwOTYsMTEsNTIyMDgsNTIyMDgsMTEsNTIzMjAsNTIzMjAsMTEsNTI0MzIsNTI0MzIsMTEsNTI1NDQsNTI1NDQsMTEsNTI2NTYsNTI2NTYsMTEsNTI3NjgsNTI3NjgsMTEsNTI4ODAsNTI4ODAsMTEsNTI5OTIsNTI5OTIsMTEsNTMxMDQsNTMxMDQsMTEsNTMyMTYsNTMyMTYsMTEsNTMzMjgsNTMzMjgsMTEsNTM0NDAsNTM0NDAsMTEsNTM1NTIsNTM1NTIsMTEsNTM2NjQsNTM2NjQsMTEsNTM3NzYsNTM3NzYsMTEsNTM4ODgsNTM4ODgsMTEsNTQwMDAsNTQwMDAsMTEsNTQxMTIsNTQxMTIsMTEsNTQyMjQsNTQyMjQsMTEsNTQzMzYsNTQzMzYsMTEsNTQ0NDgsNTQ0NDgsMTEsNTQ1NjAsNTQ1NjAsMTEsNTQ2NzIsNTQ2NzIsMTEsNTQ3ODQsNTQ3ODQsMTEsNTQ4OTYsNTQ4OTYsMTEsNTUwMDgsNTUwMDgsMTEsNTUxMjAsNTUxMjAsMTEsNjQyODYsNjQyODYsNSw2NjI3Miw2NjI3Miw1LDY4OTAwLDY4OTAzLDUsNjk3NjIsNjk3NjIsNyw2OTgxNyw2OTgxOCw1LDY5OTI3LDY5OTMxLDUsNzAwMDMsNzAwMDMsNSw3MDA3MCw3MDA3OCw1LDcwMDk0LDcwMDk0LDcsNzAxOTQsNzAxOTUsNyw3MDIwNiw3MDIwNiw1LDcwNDAwLDcwNDAxLDUsNzA0NjMsNzA0NjMsNyw3MDQ3NSw3MDQ3Nyw3LDcwNTEyLDcwNTE2LDUsNzA3MjIsNzA3MjQsNSw3MDgzMiw3MDgzMiw1LDcwODQyLDcwODQyLDUsNzA4NDcsNzA4NDgsNSw3MTA4OCw3MTA4OSw3LDcxMTAyLDcxMTAyLDcsNzEyMTksNzEyMjYsNSw3MTIzMSw3MTIzMiw1LDcxMzQyLDcxMzQzLDcsNzE0NTMsNzE0NTUsNSw3MTQ2Myw3MTQ2Nyw1LDcxNzM3LDcxNzM4LDUsNzE5OTUsNzE5OTYsNSw3MjAwMCw3MjAwMCw3LDcyMTQ1LDcyMTQ3LDcsNzIxNjAsNzIxNjAsNSw3MjI0OSw3MjI0OSw3LDcyMjczLDcyMjc4LDUsNzIzMzAsNzIzNDIsNSw3Mjc1Miw3Mjc1OCw1LDcyODUwLDcyODcxLDUsNzI4ODIsNzI4ODMsNSw3MzAxOCw3MzAxOCw1LDczMDMxLDczMDMxLDUsNzMxMDksNzMxMDksNSw3MzQ2MSw3MzQ2Miw3LDk0MDMxLDk0MDMxLDUsOTQxOTIsOTQxOTMsNywxMTkxNDIsMTE5MTQyLDcsMTE5MTU1LDExOTE2Miw0LDExOTM2MiwxMTkzNjQsNSwxMjE0NzYsMTIxNDc2LDUsMTIyODg4LDEyMjkwNCw1LDEyMzE4NCwxMjMxOTAsNSwxMjY5NzYsMTI2OTc5LDE0LDEyNzE4NCwxMjcyMzEsMTQsMTI3MzQ0LDEyNzM0NSwxNCwxMjc0MDUsMTI3NDYxLDE0LDEyNzUxNCwxMjc1MTQsMTQsMTI3NTYxLDEyNzU2NywxNCwxMjc3NzgsMTI3Nzc5LDE0LDEyNzg5NiwxMjc4OTYsMTQsMTI3OTg1LDEyNzk4NiwxNCwxMjc5OTUsMTI3OTk5LDUsMTI4MzI2LDEyODMyOCwxNCwxMjgzNjAsMTI4MzY2LDE0LDEyODM3OCwxMjgzNzgsMTQsMTI4Mzk0LDEyODM5NywxNCwxMjg0MDUsMTI4NDA2LDE0LDEyODQyMiwxMjg0MjMsMTQsMTI4NDM1LDEyODQ0MywxNCwxMjg0NTMsMTI4NDY0LDE0LDEyODQ3OSwxMjg0ODAsMTQsMTI4NDg0LDEyODQ4NywxNCwxMjg0OTYsMTI4NDk4LDE0LDEyODY0MCwxMjg3MDksMTQsMTI4NzIzLDEyODcyNCwxNCwxMjg3MzYsMTI4NzQxLDE0LDEyODc0NywxMjg3NDgsMTQsMTI4NzU1LDEyODc1NSwxNCwxMjg3NjIsMTI4NzYyLDE0LDEyODk4MSwxMjg5OTEsMTQsMTI5MDk2LDEyOTEwMywxNCwxMjkyOTIsMTI5MjkyLDE0LDEyOTMxMSwxMjkzMTEsMTQsMTI5MzI5LDEyOTMzMCwxNCwxMjkzNDQsMTI5MzQ5LDE0LDEyOTM2MCwxMjkzNzQsMTQsMTI5Mzk0LDEyOTM5NCwxNCwxMjk0MDIsMTI5NDAyLDE0LDEyOTQxMywxMjk0MjUsMTQsMTI5NDQ1LDEyOTQ1MCwxNCwxMjk0NjYsMTI5NDcxLDE0LDEyOTQ4MywxMjk0ODMsMTQsMTI5NTExLDEyOTUzNSwxNCwxMjk2NTMsMTI5NjU1LDE0LDEyOTY2NywxMjk2NzAsMTQsMTI5NzA1LDEyOTcxMSwxNCwxMjk3MzEsMTI5NzQzLDE0LDkxNzUwNSw5MTc1MDUsNCw5MTc3NjAsOTE3OTk5LDUsMTAsMTAsMywxMjcsMTU5LDQsNzY4LDg3OSw1LDE0NzEsMTQ3MSw1LDE1MzYsMTU0MSwxLDE2NDgsMTY0OCw1LDE3NjcsMTc2OCw1LDE4NDAsMTg2Niw1LDIwNzAsMjA3Myw1LDIxMzcsMjEzOSw1LDIzMDcsMjMwNyw3LDIzNjYsMjM2OCw3LDIzODIsMjM4Myw3LDI0MzQsMjQzNSw3LDI0OTcsMjUwMCw1LDI1MTksMjUxOSw1LDI1NjMsMjU2Myw3LDI2MzEsMjYzMiw1LDI2NzcsMjY3Nyw1LDI3NTAsMjc1Miw3LDI3NjMsMjc2NCw3LDI4MTcsMjgxNyw1LDI4NzksMjg3OSw1LDI4OTEsMjg5Miw3LDI5MTQsMjkxNSw1LDMwMDgsMzAwOCw1LDMwMjEsMzAyMSw1LDMwNzYsMzA3Niw1LDMxNDYsMzE0OSw1LDMyMDIsMzIwMyw3LDMyNjQsMzI2NSw3LDMyNzEsMzI3Miw3LDMyOTgsMzI5OSw1LDMzOTAsMzM5MCw1LDM0MDIsMzQwNCw3LDM0MjYsMzQyNyw1LDM1MzUsMzUzNSw1LDM1NDQsMzU1MCw3LDM2MzUsMzYzNSw3LDM3NjMsMzc2Myw3LDM4OTMsMzg5Myw1LDM5NTMsMzk2Niw1LDM5ODEsMzk5MSw1LDQxNDUsNDE0NSw3LDQxNTcsNDE1OCw1LDQyMDksNDIxMiw1LDQyMzcsNDIzNyw1LDQ1MjAsNDYwNywxMCw1OTcwLDU5NzEsNSw2MDcxLDYwNzcsNSw2MDg5LDYwOTksNSw2Mjc3LDYyNzgsNSw2NDM5LDY0NDAsNSw2NDUxLDY0NTYsNyw2NjgzLDY2ODMsNSw2NzQ0LDY3NTAsNSw2NzY1LDY3NzAsNyw2ODQ2LDY4NDYsNSw2OTY0LDY5NjQsNSw2OTcyLDY5NzIsNSw3MDE5LDcwMjcsNSw3MDc0LDcwNzcsNSw3MDgzLDcwODUsNSw3MTQ2LDcxNDgsNyw3MTU0LDcxNTUsNyw3MjIyLDcyMjMsNSw3Mzk0LDc0MDAsNSw3NDE2LDc0MTcsNSw4MjA0LDgyMDQsNSw4MjMzLDgyMzMsNCw4Mjg4LDgyOTIsNCw4NDEzLDg0MTYsNSw4NDgyLDg0ODIsMTQsODk4Niw4OTg3LDE0LDkxOTMsOTIwMywxNCw5NjU0LDk2NTQsMTQsOTczMyw5NzMzLDE0LDk3NDUsOTc0NSwxNCw5NzUyLDk3NTIsMTQsOTc2MCw5NzYwLDE0LDk3NjYsOTc2NiwxNCw5Nzc0LDk3NzUsMTQsOTc5Miw5NzkyLDE0LDk4MDAsOTgxMSwxNCw5ODI1LDk4MjYsMTQsOTgzMSw5ODMxLDE0LDk4NTIsOTg1MywxNCw5ODcyLDk4NzMsMTQsOTg4MCw5ODgwLDE0LDk4ODUsOTg4NywxNCw5ODk2LDk4OTcsMTQsOTkwNiw5OTE2LDE0LDk5MjYsOTkyNywxNCw5OTM2LDk5MzYsMTQsOTk0MSw5OTYwLDE0LDk5NzQsOTk3NCwxNCw5OTgyLDk5ODUsMTQsOTk5Miw5OTk3LDE0LDEwMDAyLDEwMDAyLDE0LDEwMDE3LDEwMDE3LDE0LDEwMDU1LDEwMDU1LDE0LDEwMDcxLDEwMDcxLDE0LDEwMTQ1LDEwMTQ1LDE0LDExMDEzLDExMDE1LDE0LDExNTAzLDExNTA1LDUsMTIzMzQsMTIzMzUsNSwxMjk1MSwxMjk1MSwxNCw0MjYxMiw0MjYyMSw1LDQzMDE0LDQzMDE0LDUsNDMwNDcsNDMwNDcsNyw0MzIwNCw0MzIwNSw1LDQzMzM1LDQzMzQ1LDUsNDMzOTUsNDMzOTUsNyw0MzQ1MCw0MzQ1MSw3LDQzNTYxLDQzNTY2LDUsNDM1NzMsNDM1NzQsNSw0MzY0NCw0MzY0NCw1LDQzNzEwLDQzNzExLDUsNDM3NTgsNDM3NTksNyw0NDAwNSw0NDAwNSw1LDQ0MDEyLDQ0MDEyLDcsNDQwNjAsNDQwNjAsMTEsNDQxMTYsNDQxMTYsMTEsNDQxNzIsNDQxNzIsMTEsNDQyMjgsNDQyMjgsMTEsNDQyODQsNDQyODQsMTEsNDQzNDAsNDQzNDAsMTEsNDQzOTYsNDQzOTYsMTEsNDQ0NTIsNDQ0NTIsMTEsNDQ1MDgsNDQ1MDgsMTEsNDQ1NjQsNDQ1NjQsMTEsNDQ2MjAsNDQ2MjAsMTEsNDQ2NzYsNDQ2NzYsMTEsNDQ3MzIsNDQ3MzIsMTEsNDQ3ODgsNDQ3ODgsMTEsNDQ4NDQsNDQ4NDQsMTEsNDQ5MDAsNDQ5MDAsMTEsNDQ5NTYsNDQ5NTYsMTEsNDUwMTIsNDUwMTIsMTEsNDUwNjgsNDUwNjgsMTEsNDUxMjQsNDUxMjQsMTEsNDUxODAsNDUxODAsMTEsNDUyMzYsNDUyMzYsMTEsNDUyOTIsNDUyOTIsMTEsNDUzNDgsNDUzNDgsMTEsNDU0MDQsNDU0MDQsMTEsNDU0NjAsNDU0NjAsMTEsNDU1MTYsNDU1MTYsMTEsNDU1NzIsNDU1NzIsMTEsNDU2MjgsNDU2MjgsMTEsNDU2ODQsNDU2ODQsMTEsNDU3NDAsNDU3NDAsMTEsNDU3OTYsNDU3OTYsMTEsNDU4NTIsNDU4NTIsMTEsNDU5MDgsNDU5MDgsMTEsNDU5NjQsNDU5NjQsMTEsNDYwMjAsNDYwMjAsMTEsNDYwNzYsNDYwNzYsMTEsNDYxMzIsNDYxMzIsMTEsNDYxODgsNDYxODgsMTEsNDYyNDQsNDYyNDQsMTEsNDYzMDAsNDYzMDAsMTEsNDYzNTYsNDYzNTYsMTEsNDY0MTIsNDY0MTIsMTEsNDY0NjgsNDY0NjgsMTEsNDY1MjQsNDY1MjQsMTEsNDY1ODAsNDY1ODAsMTEsNDY2MzYsNDY2MzYsMTEsNDY2OTIsNDY2OTIsMTEsNDY3NDgsNDY3NDgsMTEsNDY4MDQsNDY4MDQsMTEsNDY4NjAsNDY4NjAsMTEsNDY5MTYsNDY5MTYsMTEsNDY5NzIsNDY5NzIsMTEsNDcwMjgsNDcwMjgsMTEsNDcwODQsNDcwODQsMTEsNDcxNDAsNDcxNDAsMTEsNDcxOTYsNDcxOTYsMTEsNDcyNTIsNDcyNTIsMTEsNDczMDgsNDczMDgsMTEsNDczNjQsNDczNjQsMTEsNDc0MjAsNDc0MjAsMTEsNDc0NzYsNDc0NzYsMTEsNDc1MzIsNDc1MzIsMTEsNDc1ODgsNDc1ODgsMTEsNDc2NDQsNDc2NDQsMTEsNDc3MDAsNDc3MDAsMTEsNDc3NTYsNDc3NTYsMTEsNDc4MTIsNDc4MTIsMTEsNDc4NjgsNDc4NjgsMTEsNDc5MjQsNDc5MjQsMTEsNDc5ODAsNDc5ODAsMTEsNDgwMzYsNDgwMzYsMTEsNDgwOTIsNDgwOTIsMTEsNDgxNDgsNDgxNDgsMTEsNDgyMDQsNDgyMDQsMTEsNDgyNjAsNDgyNjAsMTEsNDgzMTYsNDgzMTYsMTEsNDgzNzIsNDgzNzIsMTEsNDg0MjgsNDg0MjgsMTEsNDg0ODQsNDg0ODQsMTEsNDg1NDAsNDg1NDAsMTEsNDg1OTYsNDg1OTYsMTEsNDg2NTIsNDg2NTIsMTEsNDg3MDgsNDg3MDgsMTEsNDg3NjQsNDg3NjQsMTEsNDg4MjAsNDg4MjAsMTEsNDg4NzYsNDg4NzYsMTEsNDg5MzIsNDg5MzIsMTEsNDg5ODgsNDg5ODgsMTEsNDkwNDQsNDkwNDQsMTEsNDkxMDAsNDkxMDAsMTEsNDkxNTYsNDkxNTYsMTEsNDkyMTIsNDkyMTIsMTEsNDkyNjgsNDkyNjgsMTEsNDkzMjQsNDkzMjQsMTEsNDkzODAsNDkzODAsMTEsNDk0MzYsNDk0MzYsMTEsNDk0OTIsNDk0OTIsMTEsNDk1NDgsNDk1NDgsMTEsNDk2MDQsNDk2MDQsMTEsNDk2NjAsNDk2NjAsMTEsNDk3MTYsNDk3MTYsMTEsNDk3NzIsNDk3NzIsMTEsNDk4MjgsNDk4MjgsMTEsNDk4ODQsNDk4ODQsMTEsNDk5NDAsNDk5NDAsMTEsNDk5OTYsNDk5OTYsMTEsNTAwNTIsNTAwNTIsMTEsNTAxMDgsNTAxMDgsMTEsNTAxNjQsNTAxNjQsMTEsNTAyMjAsNTAyMjAsMTEsNTAyNzYsNTAyNzYsMTEsNTAzMzIsNTAzMzIsMTEsNTAzODgsNTAzODgsMTEsNTA0NDQsNTA0NDQsMTEsNTA1MDAsNTA1MDAsMTEsNTA1NTYsNTA1NTYsMTEsNTA2MTIsNTA2MTIsMTEsNTA2NjgsNTA2NjgsMTEsNTA3MjQsNTA3MjQsMTEsNTA3ODAsNTA3ODAsMTEsNTA4MzYsNTA4MzYsMTEsNTA4OTIsNTA4OTIsMTEsNTA5NDgsNTA5NDgsMTEsNTEwMDQsNTEwMDQsMTEsNTEwNjAsNTEwNjAsMTEsNTExMTYsNTExMTYsMTEsNTExNzIsNTExNzIsMTEsNTEyMjgsNTEyMjgsMTEsNTEyODQsNTEyODQsMTEsNTEzNDAsNTEzNDAsMTEsNTEzOTYsNTEzOTYsMTEsNTE0NTIsNTE0NTIsMTEsNTE1MDgsNTE1MDgsMTEsNTE1NjQsNTE1NjQsMTEsNTE2MjAsNTE2MjAsMTEsNTE2NzYsNTE2NzYsMTEsNTE3MzIsNTE3MzIsMTEsNTE3ODgsNTE3ODgsMTEsNTE4NDQsNTE4NDQsMTEsNTE5MDAsNTE5MDAsMTEsNTE5NTYsNTE5NTYsMTEsNTIwMTIsNTIwMTIsMTEsNTIwNjgsNTIwNjgsMTEsNTIxMjQsNTIxMjQsMTEsNTIxODAsNTIxODAsMTEsNTIyMzYsNTIyMzYsMTEsNTIyOTIsNTIyOTIsMTEsNTIzNDgsNTIzNDgsMTEsNTI0MDQsNTI0MDQsMTEsNTI0NjAsNTI0NjAsMTEsNTI1MTYsNTI1MTYsMTEsNTI1NzIsNTI1NzIsMTEsNTI2MjgsNTI2MjgsMTEsNTI2ODQsNTI2ODQsMTEsNTI3NDAsNTI3NDAsMTEsNTI3OTYsNTI3OTYsMTEsNTI4NTIsNTI4NTIsMTEsNTI5MDgsNTI5MDgsMTEsNTI5NjQsNTI5NjQsMTEsNTMwMjAsNTMwMjAsMTEsNTMwNzYsNTMwNzYsMTEsNTMxMzIsNTMxMzIsMTEsNTMxODgsNTMxODgsMTEsNTMyNDQsNTMyNDQsMTEsNTMzMDAsNTMzMDAsMTEsNTMzNTYsNTMzNTYsMTEsNTM0MTIsNTM0MTIsMTEsNTM0NjgsNTM0NjgsMTEsNTM1MjQsNTM1MjQsMTEsNTM1ODAsNTM1ODAsMTEsNTM2MzYsNTM2MzYsMTEsNTM2OTIsNTM2OTIsMTEsNTM3NDgsNTM3NDgsMTEsNTM4MDQsNTM4MDQsMTEsNTM4NjAsNTM4NjAsMTEsNTM5MTYsNTM5MTYsMTEsNTM5NzIsNTM5NzIsMTEsNTQwMjgsNTQwMjgsMTEsNTQwODQsNTQwODQsMTEsNTQxNDAsNTQxNDAsMTEsNTQxOTYsNTQxOTYsMTEsNTQyNTIsNTQyNTIsMTEsNTQzMDgsNTQzMDgsMTEsNTQzNjQsNTQzNjQsMTEsNTQ0MjAsNTQ0MjAsMTEsNTQ0NzYsNTQ0NzYsMTEsNTQ1MzIsNTQ1MzIsMTEsNTQ1ODgsNTQ1ODgsMTEsNTQ2NDQsNTQ2NDQsMTEsNTQ3MDAsNTQ3MDAsMTEsNTQ3NTYsNTQ3NTYsMTEsNTQ4MTIsNTQ4MTIsMTEsNTQ4NjgsNTQ4NjgsMTEsNTQ5MjQsNTQ5MjQsMTEsNTQ5ODAsNTQ5ODAsMTEsNTUwMzYsNTUwMzYsMTEsNTUwOTIsNTUwOTIsMTEsNTUxNDgsNTUxNDgsMTEsNTUyMTYsNTUyMzgsOSw2NTA1Niw2NTA3MSw1LDY1NTI5LDY1NTMxLDQsNjgwOTcsNjgwOTksNSw2ODE1OSw2ODE1OSw1LDY5NDQ2LDY5NDU2LDUsNjk2ODgsNjk3MDIsNSw2OTgwOCw2OTgxMCw3LDY5ODE1LDY5ODE2LDcsNjk4MjEsNjk4MjEsMSw2OTg4OCw2OTg5MCw1LDY5OTMyLDY5OTMyLDcsNjk5NTcsNjk5NTgsNyw3MDAxNiw3MDAxNyw1LDcwMDY3LDcwMDY5LDcsNzAwNzksNzAwODAsNyw3MDA4OSw3MDA5Miw1LDcwMDk1LDcwMDk1LDUsNzAxOTEsNzAxOTMsNSw3MDE5Niw3MDE5Niw1LDcwMTk4LDcwMTk5LDUsNzAzNjcsNzAzNjcsNSw3MDM3MSw3MDM3OCw1LDcwNDAyLDcwNDAzLDcsNzA0NjIsNzA0NjIsNSw3MDQ2NCw3MDQ2NCw1LDcwNDcxLDcwNDcyLDcsNzA0ODcsNzA0ODcsNSw3MDUwMiw3MDUwOCw1LDcwNzA5LDcwNzExLDcsNzA3MjAsNzA3MjEsNyw3MDcyNSw3MDcyNSw3LDcwNzUwLDcwNzUwLDUsNzA4MzMsNzA4MzQsNyw3MDg0MSw3MDg0MSw3LDcwODQzLDcwODQ0LDcsNzA4NDYsNzA4NDYsNyw3MDg0OSw3MDg0OSw3LDcxMDg3LDcxMDg3LDUsNzEwOTAsNzEwOTMsNSw3MTEwMCw3MTEwMSw1LDcxMTAzLDcxMTA0LDUsNzEyMTYsNzEyMTgsNyw3MTIyNyw3MTIyOCw3LDcxMjMwLDcxMjMwLDcsNzEzMzksNzEzMzksNSw3MTM0MSw3MTM0MSw1LDcxMzQ0LDcxMzQ5LDUsNzEzNTEsNzEzNTEsNSw3MTQ1Niw3MTQ1Nyw3LDcxNDYyLDcxNDYyLDcsNzE3MjQsNzE3MjYsNyw3MTczNiw3MTczNiw3LDcxOTg0LDcxOTg0LDUsNzE5OTEsNzE5OTIsNyw3MTk5Nyw3MTk5Nyw3LDcxOTk5LDcxOTk5LDEsNzIwMDEsNzIwMDEsMSw3MjAwMyw3MjAwMyw1LDcyMTQ4LDcyMTUxLDUsNzIxNTYsNzIxNTksNyw3MjE2NCw3MjE2NCw3LDcyMjQzLDcyMjQ4LDUsNzIyNTAsNzIyNTAsMSw3MjI2Myw3MjI2Myw1LDcyMjc5LDcyMjgwLDcsNzIzMjQsNzIzMjksMSw3MjM0Myw3MjM0Myw3LDcyNzUxLDcyNzUxLDcsNzI3NjAsNzI3NjUsNSw3Mjc2Nyw3Mjc2Nyw1LDcyODczLDcyODczLDcsNzI4ODEsNzI4ODEsNyw3Mjg4NCw3Mjg4NCw3LDczMDA5LDczMDE0LDUsNzMwMjAsNzMwMjEsNSw3MzAzMCw3MzAzMCwxLDczMDk4LDczMTAyLDcsNzMxMDcsNzMxMDgsNyw3MzExMCw3MzExMCw3LDczNDU5LDczNDYwLDUsNzg4OTYsNzg5MDQsNCw5Mjk3Niw5Mjk4Miw1LDk0MDMzLDk0MDg3LDcsOTQxODAsOTQxODAsNSwxMTM4MjEsMTEzODIyLDUsMTE5MTQxLDExOTE0MSw1LDExOTE0MywxMTkxNDUsNSwxMTkxNTAsMTE5MTU0LDUsMTE5MTYzLDExOTE3MCw1LDExOTIxMCwxMTkyMTMsNSwxMjEzNDQsMTIxMzk4LDUsMTIxNDYxLDEyMTQ2MSw1LDEyMTQ5OSwxMjE1MDMsNSwxMjI4ODAsMTIyODg2LDUsMTIyOTA3LDEyMjkxMyw1LDEyMjkxOCwxMjI5MjIsNSwxMjM2MjgsMTIzNjMxLDUsMTI1MjUyLDEyNTI1OCw1LDEyNjk4MCwxMjY5ODAsMTQsMTI3MTgzLDEyNzE4MywxNCwxMjcyNDUsMTI3MjQ3LDE0LDEyNzM0MCwxMjczNDMsMTQsMTI3MzU4LDEyNzM1OSwxNCwxMjczNzcsMTI3Mzg2LDE0LDEyNzQ2MiwxMjc0ODcsNiwxMjc0OTEsMTI3NTAzLDE0LDEyNzUzNSwxMjc1MzUsMTQsMTI3NTQ4LDEyNzU1MSwxNCwxMjc1NjgsMTI3NTY5LDE0LDEyNzc0NCwxMjc3NzcsMTQsMTI3NzgwLDEyNzg5MSwxNCwxMjc4OTQsMTI3ODk1LDE0LDEyNzg5NywxMjc4OTksMTQsMTI3OTAyLDEyNzk4NCwxNCwxMjc5ODcsMTI3OTg5LDE0LDEyNzk5MSwxMjc5OTQsMTQsMTI4MDAwLDEyODI1MywxNCwxMjgyNTUsMTI4MzE3LDE0LDEyODMyOSwxMjgzMzQsMTQsMTI4MzM2LDEyODM1OSwxNCwxMjgzNjcsMTI4MzY4LDE0LDEyODM3MSwxMjgzNzcsMTQsMTI4Mzc5LDEyODM5MCwxNCwxMjgzOTIsMTI4MzkzLDE0LDEyODM5OCwxMjgzOTksMTQsMTI4NDAxLDEyODQwNCwxNCwxMjg0MDcsMTI4NDE5LDE0LDEyODQyMSwxMjg0MjEsMTQsMTI4NDI0LDEyODQyNCwxNCwxMjg0MzMsMTI4NDM0LDE0LDEyODQ0NCwxMjg0NDQsMTQsMTI4NDUwLDEyODQ1MiwxNCwxMjg0NjUsMTI4NDY3LDE0LDEyODQ3NiwxMjg0NzgsMTQsMTI4NDgxLDEyODQ4MSwxNCwxMjg0ODMsMTI4NDgzLDE0LDEyODQ4OCwxMjg0ODgsMTQsMTI4NDk1LDEyODQ5NSwxNCwxMjg0OTksMTI4NDk5LDE0LDEyODUwNiwxMjg1OTEsMTQsMTI4NzEwLDEyODcxNCwxNCwxMjg3MjEsMTI4NzIyLDE0LDEyODcyNSwxMjg3MjUsMTQsMTI4NzI4LDEyODczNSwxNCwxMjg3NDIsMTI4NzQ0LDE0LDEyODc0NiwxMjg3NDYsMTQsMTI4NzQ5LDEyODc1MSwxNCwxMjg3NTMsMTI4NzU0LDE0LDEyODc1NiwxMjg3NTgsMTQsMTI4NzYxLDEyODc2MSwxNCwxMjg3NjMsMTI4NzY0LDE0LDEyODg4NCwxMjg4OTUsMTQsMTI4OTkyLDEyOTAwMywxNCwxMjkwMzYsMTI5MDM5LDE0LDEyOTExNCwxMjkxMTksMTQsMTI5MTk4LDEyOTI3OSwxNCwxMjkyOTMsMTI5Mjk1LDE0LDEyOTMwNSwxMjkzMTAsMTQsMTI5MzEyLDEyOTMxOSwxNCwxMjkzMjgsMTI5MzI4LDE0LDEyOTMzMSwxMjkzMzgsMTQsMTI5MzQzLDEyOTM0MywxNCwxMjkzNTEsMTI5MzU1LDE0LDEyOTM1NywxMjkzNTksMTQsMTI5Mzc1LDEyOTM4NywxNCwxMjkzOTMsMTI5MzkzLDE0LDEyOTM5NSwxMjkzOTgsMTQsMTI5NDAxLDEyOTQwMSwxNCwxMjk0MDMsMTI5NDAzLDE0LDEyOTQwOCwxMjk0MTIsMTQsMTI5NDI2LDEyOTQzMSwxNCwxMjk0NDMsMTI5NDQ0LDE0LDEyOTQ1MSwxMjk0NTMsMTQsMTI5NDU2LDEyOTQ2NSwxNCwxMjk0NzIsMTI5NDcyLDE0LDEyOTQ3NSwxMjk0ODIsMTQsMTI5NDg0LDEyOTQ4NCwxNCwxMjk0ODgsMTI5NTEwLDE0LDEyOTUzNiwxMjk2NDcsMTQsMTI5NjUyLDEyOTY1MiwxNCwxMjk2NTYsMTI5NjU4LDE0LDEyOTY2NCwxMjk2NjYsMTQsMTI5NjcxLDEyOTY3OSwxNCwxMjk2ODYsMTI5NzA0LDE0LDEyOTcxMiwxMjk3MTgsMTQsMTI5NzI4LDEyOTczMCwxNCwxMjk3NDQsMTI5NzUwLDE0LDkxNzUwNCw5MTc1MDQsNCw5MTc1MDYsOTE3NTM1LDQsOTE3NjMyLDkxNzc1OSw0LDkxODAwMCw5MjE1OTksNCwwLDksNCwxMSwxMiw0LDE0LDMxLDQsMTY5LDE2OSwxNCwxNzQsMTc0LDE0LDExNTUsMTE1OSw1LDE0MjUsMTQ2OSw1LDE0NzMsMTQ3NCw1LDE0NzksMTQ3OSw1LDE1NTIsMTU2Miw1LDE2MTEsMTYzMSw1LDE3NTAsMTc1Niw1LDE3NTksMTc2NCw1LDE3NzAsMTc3Myw1LDE4MDksMTgwOSw1LDE5NTgsMTk2OCw1LDIwNDUsMjA0NSw1LDIwNzUsMjA4Myw1LDIwODksMjA5Myw1LDIyNTksMjI3Myw1LDIyNzUsMjMwNiw1LDIzNjIsMjM2Miw1LDIzNjQsMjM2NCw1LDIzNjksMjM3Niw1LDIzODEsMjM4MSw1LDIzODUsMjM5MSw1LDI0MzMsMjQzMyw1LDI0OTIsMjQ5Miw1LDI0OTUsMjQ5Niw3LDI1MDMsMjUwNCw3LDI1MDksMjUwOSw1LDI1MzAsMjUzMSw1LDI1NjEsMjU2Miw1LDI2MjAsMjYyMCw1LDI2MjUsMjYyNiw1LDI2MzUsMjYzNyw1LDI2NzIsMjY3Myw1LDI2ODksMjY5MCw1LDI3NDgsMjc0OCw1LDI3NTMsMjc1Nyw1LDI3NjEsMjc2MSw3LDI3NjUsMjc2NSw1LDI4MTAsMjgxNSw1LDI4MTgsMjgxOSw3LDI4NzgsMjg3OCw1LDI4ODAsMjg4MCw3LDI4ODcsMjg4OCw3LDI4OTMsMjg5Myw1LDI5MDMsMjkwMyw1LDI5NDYsMjk0Niw1LDMwMDcsMzAwNyw3LDMwMDksMzAxMCw3LDMwMTgsMzAyMCw3LDMwMzEsMzAzMSw1LDMwNzMsMzA3NSw3LDMxMzQsMzEzNiw1LDMxNDIsMzE0NCw1LDMxNTcsMzE1OCw1LDMyMDEsMzIwMSw1LDMyNjAsMzI2MCw1LDMyNjMsMzI2Myw1LDMyNjYsMzI2Niw1LDMyNzAsMzI3MCw1LDMyNzQsMzI3NSw3LDMyODUsMzI4Niw1LDMzMjgsMzMyOSw1LDMzODcsMzM4OCw1LDMzOTEsMzM5Miw3LDMzOTgsMzQwMCw3LDM0MDUsMzQwNSw1LDM0MTUsMzQxNSw1LDM0NTcsMzQ1Nyw1LDM1MzAsMzUzMCw1LDM1MzYsMzUzNyw3LDM1NDIsMzU0Miw1LDM1NTEsMzU1MSw1LDM2MzMsMzYzMyw1LDM2MzYsMzY0Miw1LDM3NjEsMzc2MSw1LDM3NjQsMzc3Miw1LDM4NjQsMzg2NSw1LDM4OTUsMzg5NSw1LDM5MDIsMzkwMyw3LDM5NjcsMzk2Nyw3LDM5NzQsMzk3NSw1LDM5OTMsNDAyOCw1LDQxNDEsNDE0NCw1LDQxNDYsNDE1MSw1LDQxNTUsNDE1Niw3LDQxODIsNDE4Myw3LDQxOTAsNDE5Miw1LDQyMjYsNDIyNiw1LDQyMjksNDIzMCw1LDQyNTMsNDI1Myw1LDQ0NDgsNDUxOSw5LDQ5NTcsNDk1OSw1LDU5MzgsNTk0MCw1LDYwMDIsNjAwMyw1LDYwNzAsNjA3MCw3LDYwNzgsNjA4NSw3LDYwODcsNjA4OCw3LDYxMDksNjEwOSw1LDYxNTgsNjE1OCw0LDYzMTMsNjMxMyw1LDY0MzUsNjQzOCw3LDY0NDEsNjQ0Myw3LDY0NTAsNjQ1MCw1LDY0NTcsNjQ1OSw1LDY2ODEsNjY4Miw3LDY3NDEsNjc0MSw3LDY3NDMsNjc0Myw3LDY3NTIsNjc1Miw1LDY3NTcsNjc2NCw1LDY3NzEsNjc4MCw1LDY4MzIsNjg0NSw1LDY4NDcsNjg0OCw1LDY5MTYsNjkxNiw3LDY5NjUsNjk2NSw1LDY5NzEsNjk3MSw3LDY5NzMsNjk3Nyw3LDY5NzksNjk4MCw3LDcwNDAsNzA0MSw1LDcwNzMsNzA3Myw3LDcwNzgsNzA3OSw3LDcwODIsNzA4Miw3LDcxNDIsNzE0Miw1LDcxNDQsNzE0NSw1LDcxNDksNzE0OSw1LDcxNTEsNzE1Myw1LDcyMDQsNzIxMSw3LDcyMjAsNzIyMSw3LDczNzYsNzM3OCw1LDczOTMsNzM5Myw3LDc0MDUsNzQwNSw1LDc0MTUsNzQxNSw3LDc2MTYsNzY3Myw1LDgyMDMsODIwMyw0LDgyMDUsODIwNSwxMyw4MjMyLDgyMzIsNCw4MjM0LDgyMzgsNCw4MjY1LDgyNjUsMTQsODI5Myw4MjkzLDQsODQwMCw4NDEyLDUsODQxNyw4NDE3LDUsODQyMSw4NDMyLDUsODUwNSw4NTA1LDE0LDg2MTcsODYxOCwxNCw5MDAwLDkwMDAsMTQsOTE2Nyw5MTY3LDE0LDkyMDgsOTIxMCwxNCw5NjQyLDk2NDMsMTQsOTY2NCw5NjY0LDE0LDk3MjgsOTczMiwxNCw5NzM1LDk3NDEsMTQsOTc0Myw5NzQ0LDE0LDk3NDYsOTc0NiwxNCw5NzUwLDk3NTEsMTQsOTc1Myw5NzU2LDE0LDk3NTgsOTc1OSwxNCw5NzYxLDk3NjEsMTQsOTc2NCw5NzY1LDE0LDk3NjcsOTc2OSwxNCw5NzcxLDk3NzMsMTQsOTc3Niw5NzgzLDE0LDk3ODcsOTc5MSwxNCw5NzkzLDk3OTMsMTQsOTc5NSw5Nzk5LDE0LDk4MTIsOTgyMiwxNCw5ODI0LDk4MjQsMTQsOTgyNyw5ODI3LDE0LDk4MjksOTgzMCwxNCw5ODMyLDk4MzIsMTQsOTg1MSw5ODUxLDE0LDk4NTQsOTg1NCwxNCw5ODU2LDk4NjEsMTQsOTg3NCw5ODc2LDE0LDk4NzgsOTg3OSwxNCw5ODgxLDk4ODEsMTQsOTg4Myw5ODg0LDE0LDk4ODgsOTg4OSwxNCw5ODk1LDk4OTUsMTQsOTg5OCw5ODk5LDE0LDk5MDQsOTkwNSwxNCw5OTE3LDk5MTgsMTQsOTkyNCw5OTI1LDE0LDk5MjgsOTkyOCwxNCw5OTM0LDk5MzUsMTQsOTkzNyw5OTM3LDE0LDk5MzksOTk0MCwxNCw5OTYxLDk5NjIsMTQsOTk2OCw5OTczLDE0LDk5NzUsOTk3OCwxNCw5OTgxLDk5ODEsMTQsOTk4Niw5OTg2LDE0LDk5ODksOTk4OSwxNCw5OTk4LDk5OTgsMTQsMTAwMDAsMTAwMDEsMTQsMTAwMDQsMTAwMDQsMTQsMTAwMTMsMTAwMTMsMTQsMTAwMjQsMTAwMjQsMTQsMTAwNTIsMTAwNTIsMTQsMTAwNjAsMTAwNjAsMTQsMTAwNjcsMTAwNjksMTQsMTAwODMsMTAwODQsMTQsMTAxMzMsMTAxMzUsMTQsMTAxNjAsMTAxNjAsMTQsMTA1NDgsMTA1NDksMTQsMTEwMzUsMTEwMzYsMTQsMTEwOTMsMTEwOTMsMTQsMTE2NDcsMTE2NDcsNSwxMjMzMCwxMjMzMyw1LDEyMzM2LDEyMzM2LDE0LDEyNDQxLDEyNDQyLDUsMTI5NTMsMTI5NTMsMTQsNDI2MDgsNDI2MTAsNSw0MjY1NCw0MjY1NSw1LDQzMDEwLDQzMDEwLDUsNDMwMTksNDMwMTksNSw0MzA0NSw0MzA0Niw1LDQzMDUyLDQzMDUyLDUsNDMxODgsNDMyMDMsNyw0MzIzMiw0MzI0OSw1LDQzMzAyLDQzMzA5LDUsNDMzNDYsNDMzNDcsNyw0MzM5Miw0MzM5NCw1LDQzNDQzLDQzNDQzLDUsNDM0NDYsNDM0NDksNSw0MzQ1Miw0MzQ1Myw1LDQzNDkzLDQzNDkzLDUsNDM1NjcsNDM1NjgsNyw0MzU3MSw0MzU3Miw3LDQzNTg3LDQzNTg3LDUsNDM1OTcsNDM1OTcsNyw0MzY5Niw0MzY5Niw1LDQzNzAzLDQzNzA0LDUsNDM3MTMsNDM3MTMsNSw0Mzc1Niw0Mzc1Nyw1LDQzNzY1LDQzNzY1LDcsNDQwMDMsNDQwMDQsNyw0NDAwNiw0NDAwNyw3LDQ0MDA5LDQ0MDEwLDcsNDQwMTMsNDQwMTMsNSw0NDAzMyw0NDA1OSwxMiw0NDA2MSw0NDA4NywxMiw0NDA4OSw0NDExNSwxMiw0NDExNyw0NDE0MywxMiw0NDE0NSw0NDE3MSwxMiw0NDE3Myw0NDE5OSwxMiw0NDIwMSw0NDIyNywxMiw0NDIyOSw0NDI1NSwxMiw0NDI1Nyw0NDI4MywxMiw0NDI4NSw0NDMxMSwxMiw0NDMxMyw0NDMzOSwxMiw0NDM0MSw0NDM2NywxMiw0NDM2OSw0NDM5NSwxMiw0NDM5Nyw0NDQyMywxMiw0NDQyNSw0NDQ1MSwxMiw0NDQ1Myw0NDQ3OSwxMiw0NDQ4MSw0NDUwNywxMiw0NDUwOSw0NDUzNSwxMiw0NDUzNyw0NDU2MywxMiw0NDU2NSw0NDU5MSwxMiw0NDU5Myw0NDYxOSwxMiw0NDYyMSw0NDY0NywxMiw0NDY0OSw0NDY3NSwxMiw0NDY3Nyw0NDcwMywxMiw0NDcwNSw0NDczMSwxMiw0NDczMyw0NDc1OSwxMiw0NDc2MSw0NDc4NywxMiw0NDc4OSw0NDgxNSwxMiw0NDgxNyw0NDg0MywxMiw0NDg0NSw0NDg3MSwxMiw0NDg3Myw0NDg5OSwxMiw0NDkwMSw0NDkyNywxMiw0NDkyOSw0NDk1NSwxMiw0NDk1Nyw0NDk4MywxMiw0NDk4NSw0NTAxMSwxMiw0NTAxMyw0NTAzOSwxMiw0NTA0MSw0NTA2NywxMiw0NTA2OSw0NTA5NSwxMiw0NTA5Nyw0NTEyMywxMiw0NTEyNSw0NTE1MSwxMiw0NTE1Myw0NTE3OSwxMiw0NTE4MSw0NTIwNywxMiw0NTIwOSw0NTIzNSwxMiw0NTIzNyw0NTI2MywxMiw0NTI2NSw0NTI5MSwxMiw0NTI5Myw0NTMxOSwxMiw0NTMyMSw0NTM0NywxMiw0NTM0OSw0NTM3NSwxMiw0NTM3Nyw0NTQwMywxMiw0NTQwNSw0NTQzMSwxMiw0NTQzMyw0NTQ1OSwxMiw0NTQ2MSw0NTQ4NywxMiw0NTQ4OSw0NTUxNSwxMiw0NTUxNyw0NTU0MywxMiw0NTU0NSw0NTU3MSwxMiw0NTU3Myw0NTU5OSwxMiw0NTYwMSw0NTYyNywxMiw0NTYyOSw0NTY1NSwxMiw0NTY1Nyw0NTY4MywxMiw0NTY4NSw0NTcxMSwxMiw0NTcxMyw0NTczOSwxMiw0NTc0MSw0NTc2NywxMiw0NTc2OSw0NTc5NSwxMiw0NTc5Nyw0NTgyMywxMiw0NTgyNSw0NTg1MSwxMiw0NTg1Myw0NTg3OSwxMiw0NTg4MSw0NTkwNywxMiw0NTkwOSw0NTkzNSwxMiw0NTkzNyw0NTk2MywxMiw0NTk2NSw0NTk5MSwxMiw0NTk5Myw0NjAxOSwxMiw0NjAyMSw0NjA0NywxMiw0NjA0OSw0NjA3NSwxMiw0NjA3Nyw0NjEwMywxMiw0NjEwNSw0NjEzMSwxMiw0NjEzMyw0NjE1OSwxMiw0NjE2MSw0NjE4NywxMiw0NjE4OSw0NjIxNSwxMiw0NjIxNyw0NjI0MywxMiw0NjI0NSw0NjI3MSwxMiw0NjI3Myw0NjI5OSwxMiw0NjMwMSw0NjMyNywxMiw0NjMyOSw0NjM1NSwxMiw0NjM1Nyw0NjM4MywxMiw0NjM4NSw0NjQxMSwxMiw0NjQxMyw0NjQzOSwxMiw0NjQ0MSw0NjQ2NywxMiw0NjQ2OSw0NjQ5NSwxMiw0NjQ5Nyw0NjUyMywxMiw0NjUyNSw0NjU1MSwxMiw0NjU1Myw0NjU3OSwxMiw0NjU4MSw0NjYwNywxMiw0NjYwOSw0NjYzNSwxMiw0NjYzNyw0NjY2MywxMiw0NjY2NSw0NjY5MSwxMiw0NjY5Myw0NjcxOSwxMiw0NjcyMSw0Njc0NywxMiw0Njc0OSw0Njc3NSwxMiw0Njc3Nyw0NjgwMywxMiw0NjgwNSw0NjgzMSwxMiw0NjgzMyw0Njg1OSwxMiw0Njg2MSw0Njg4NywxMiw0Njg4OSw0NjkxNSwxMiw0NjkxNyw0Njk0MywxMiw0Njk0NSw0Njk3MSwxMiw0Njk3Myw0Njk5OSwxMiw0NzAwMSw0NzAyNywxMiw0NzAyOSw0NzA1NSwxMiw0NzA1Nyw0NzA4MywxMiw0NzA4NSw0NzExMSwxMiw0NzExMyw0NzEzOSwxMiw0NzE0MSw0NzE2NywxMiw0NzE2OSw0NzE5NSwxMiw0NzE5Nyw0NzIyMywxMiw0NzIyNSw0NzI1MSwxMiw0NzI1Myw0NzI3OSwxMiw0NzI4MSw0NzMwNywxMiw0NzMwOSw0NzMzNSwxMiw0NzMzNyw0NzM2MywxMiw0NzM2NSw0NzM5MSwxMiw0NzM5Myw0NzQxOSwxMiw0NzQyMSw0NzQ0NywxMiw0NzQ0OSw0NzQ3NSwxMiw0NzQ3Nyw0NzUwMywxMiw0NzUwNSw0NzUzMSwxMiw0NzUzMyw0NzU1OSwxMiw0NzU2MSw0NzU4NywxMiw0NzU4OSw0NzYxNSwxMiw0NzYxNyw0NzY0MywxMiw0NzY0NSw0NzY3MSwxMiw0NzY3Myw0NzY5OSwxMiw0NzcwMSw0NzcyNywxMiw0NzcyOSw0Nzc1NSwxMiw0Nzc1Nyw0Nzc4MywxMiw0Nzc4NSw0NzgxMSwxMiw0NzgxMyw0NzgzOSwxMiw0Nzg0MSw0Nzg2NywxMiw0Nzg2OSw0Nzg5NSwxMiw0Nzg5Nyw0NzkyMywxMiw0NzkyNSw0Nzk1MSwxMiw0Nzk1Myw0Nzk3OSwxMiw0Nzk4MSw0ODAwNywxMiw0ODAwOSw0ODAzNSwxMiw0ODAzNyw0ODA2MywxMiw0ODA2NSw0ODA5MSwxMiw0ODA5Myw0ODExOSwxMiw0ODEyMSw0ODE0NywxMiw0ODE0OSw0ODE3NSwxMiw0ODE3Nyw0ODIwMywxMiw0ODIwNSw0ODIzMSwxMiw0ODIzMyw0ODI1OSwxMiw0ODI2MSw0ODI4NywxMiw0ODI4OSw0ODMxNSwxMiw0ODMxNyw0ODM0MywxMiw0ODM0NSw0ODM3MSwxMiw0ODM3Myw0ODM5OSwxMiw0ODQwMSw0ODQyNywxMiw0ODQyOSw0ODQ1NSwxMiw0ODQ1Nyw0ODQ4MywxMiw0ODQ4NSw0ODUxMSwxMiw0ODUxMyw0ODUzOSwxMiw0ODU0MSw0ODU2NywxMiw0ODU2OSw0ODU5NSwxMiw0ODU5Nyw0ODYyMywxMiw0ODYyNSw0ODY1MSwxMiw0ODY1Myw0ODY3OSwxMiw0ODY4MSw0ODcwNywxMiw0ODcwOSw0ODczNSwxMiw0ODczNyw0ODc2MywxMiw0ODc2NSw0ODc5MSwxMiw0ODc5Myw0ODgxOSwxMiw0ODgyMSw0ODg0NywxMiw0ODg0OSw0ODg3NSwxMiw0ODg3Nyw0ODkwMywxMiw0ODkwNSw0ODkzMSwxMiw0ODkzMyw0ODk1OSwxMiw0ODk2MSw0ODk4NywxMiw0ODk4OSw0OTAxNSwxMiw0OTAxNyw0OTA0MywxMiw0OTA0NSw0OTA3MSwxMiw0OTA3Myw0OTA5OSwxMiw0OTEwMSw0OTEyNywxMiw0OTEyOSw0OTE1NSwxMiw0OTE1Nyw0OTE4MywxMiw0OTE4NSw0OTIxMSwxMiw0OTIxMyw0OTIzOSwxMiw0OTI0MSw0OTI2NywxMiw0OTI2OSw0OTI5NSwxMiw0OTI5Nyw0OTMyMywxMiw0OTMyNSw0OTM1MSwxMiw0OTM1Myw0OTM3OSwxMiw0OTM4MSw0OTQwNywxMiw0OTQwOSw0OTQzNSwxMiw0OTQzNyw0OTQ2MywxMiw0OTQ2NSw0OTQ5MSwxMiw0OTQ5Myw0OTUxOSwxMiw0OTUyMSw0OTU0NywxMiw0OTU0OSw0OTU3NSwxMiw0OTU3Nyw0OTYwMywxMiw0OTYwNSw0OTYzMSwxMiw0OTYzMyw0OTY1OSwxMiw0OTY2MSw0OTY4NywxMiw0OTY4OSw0OTcxNSwxMiw0OTcxNyw0OTc0MywxMiw0OTc0NSw0OTc3MSwxMiw0OTc3Myw0OTc5OSwxMiw0OTgwMSw0OTgyNywxMiw0OTgyOSw0OTg1NSwxMiw0OTg1Nyw0OTg4MywxMiw0OTg4NSw0OTkxMSwxMiw0OTkxMyw0OTkzOSwxMiw0OTk0MSw0OTk2NywxMiw0OTk2OSw0OTk5NSwxMiw0OTk5Nyw1MDAyMywxMiw1MDAyNSw1MDA1MSwxMiw1MDA1Myw1MDA3OSwxMiw1MDA4MSw1MDEwNywxMiw1MDEwOSw1MDEzNSwxMiw1MDEzNyw1MDE2MywxMiw1MDE2NSw1MDE5MSwxMiw1MDE5Myw1MDIxOSwxMiw1MDIyMSw1MDI0NywxMiw1MDI0OSw1MDI3NSwxMiw1MDI3Nyw1MDMwMywxMiw1MDMwNSw1MDMzMSwxMiw1MDMzMyw1MDM1OSwxMiw1MDM2MSw1MDM4NywxMiw1MDM4OSw1MDQxNSwxMiw1MDQxNyw1MDQ0MywxMiw1MDQ0NSw1MDQ3MSwxMiw1MDQ3Myw1MDQ5OSwxMiw1MDUwMSw1MDUyNywxMiw1MDUyOSw1MDU1NSwxMiw1MDU1Nyw1MDU4MywxMiw1MDU4NSw1MDYxMSwxMiw1MDYxMyw1MDYzOSwxMiw1MDY0MSw1MDY2NywxMiw1MDY2OSw1MDY5NSwxMiw1MDY5Nyw1MDcyMywxMiw1MDcyNSw1MDc1MSwxMiw1MDc1Myw1MDc3OSwxMiw1MDc4MSw1MDgwNywxMiw1MDgwOSw1MDgzNSwxMiw1MDgzNyw1MDg2MywxMiw1MDg2NSw1MDg5MSwxMiw1MDg5Myw1MDkxOSwxMiw1MDkyMSw1MDk0NywxMiw1MDk0OSw1MDk3NSwxMiw1MDk3Nyw1MTAwMywxMiw1MTAwNSw1MTAzMSwxMiw1MTAzMyw1MTA1OSwxMiw1MTA2MSw1MTA4NywxMiw1MTA4OSw1MTExNSwxMiw1MTExNyw1MTE0MywxMiw1MTE0NSw1MTE3MSwxMiw1MTE3Myw1MTE5OSwxMiw1MTIwMSw1MTIyNywxMiw1MTIyOSw1MTI1NSwxMiw1MTI1Nyw1MTI4MywxMiw1MTI4NSw1MTMxMSwxMiw1MTMxMyw1MTMzOSwxMiw1MTM0MSw1MTM2NywxMiw1MTM2OSw1MTM5NSwxMiw1MTM5Nyw1MTQyMywxMiw1MTQyNSw1MTQ1MSwxMiw1MTQ1Myw1MTQ3OSwxMiw1MTQ4MSw1MTUwNywxMiw1MTUwOSw1MTUzNSwxMiw1MTUzNyw1MTU2MywxMiw1MTU2NSw1MTU5MSwxMiw1MTU5Myw1MTYxOSwxMiw1MTYyMSw1MTY0NywxMiw1MTY0OSw1MTY3NSwxMiw1MTY3Nyw1MTcwMywxMiw1MTcwNSw1MTczMSwxMiw1MTczMyw1MTc1OSwxMiw1MTc2MSw1MTc4NywxMiw1MTc4OSw1MTgxNSwxMiw1MTgxNyw1MTg0MywxMiw1MTg0NSw1MTg3MSwxMiw1MTg3Myw1MTg5OSwxMiw1MTkwMSw1MTkyNywxMiw1MTkyOSw1MTk1NSwxMiw1MTk1Nyw1MTk4MywxMiw1MTk4NSw1MjAxMSwxMiw1MjAxMyw1MjAzOSwxMiw1MjA0MSw1MjA2NywxMiw1MjA2OSw1MjA5NSwxMiw1MjA5Nyw1MjEyMywxMiw1MjEyNSw1MjE1MSwxMiw1MjE1Myw1MjE3OSwxMiw1MjE4MSw1MjIwNywxMiw1MjIwOSw1MjIzNSwxMiw1MjIzNyw1MjI2MywxMiw1MjI2NSw1MjI5MSwxMiw1MjI5Myw1MjMxOSwxMiw1MjMyMSw1MjM0NywxMiw1MjM0OSw1MjM3NSwxMiw1MjM3Nyw1MjQwMywxMiw1MjQwNSw1MjQzMSwxMiw1MjQzMyw1MjQ1OSwxMiw1MjQ2MSw1MjQ4NywxMiw1MjQ4OSw1MjUxNSwxMiw1MjUxNyw1MjU0MywxMiw1MjU0NSw1MjU3MSwxMiw1MjU3Myw1MjU5OSwxMiw1MjYwMSw1MjYyNywxMiw1MjYyOSw1MjY1NSwxMiw1MjY1Nyw1MjY4MywxMiw1MjY4NSw1MjcxMSwxMiw1MjcxMyw1MjczOSwxMiw1Mjc0MSw1Mjc2NywxMiw1Mjc2OSw1Mjc5NSwxMiw1Mjc5Nyw1MjgyMywxMiw1MjgyNSw1Mjg1MSwxMiw1Mjg1Myw1Mjg3OSwxMiw1Mjg4MSw1MjkwNywxMiw1MjkwOSw1MjkzNSwxMiw1MjkzNyw1Mjk2MywxMiw1Mjk2NSw1Mjk5MSwxMiw1Mjk5Myw1MzAxOSwxMiw1MzAyMSw1MzA0NywxMiw1MzA0OSw1MzA3NSwxMiw1MzA3Nyw1MzEwMywxMiw1MzEwNSw1MzEzMSwxMiw1MzEzMyw1MzE1OSwxMiw1MzE2MSw1MzE4NywxMiw1MzE4OSw1MzIxNSwxMiw1MzIxNyw1MzI0MywxMiw1MzI0NSw1MzI3MSwxMiw1MzI3Myw1MzI5OSwxMiw1MzMwMSw1MzMyNywxMiw1MzMyOSw1MzM1NSwxMiw1MzM1Nyw1MzM4MywxMiw1MzM4NSw1MzQxMSwxMiw1MzQxMyw1MzQzOSwxMiw1MzQ0MSw1MzQ2NywxMiw1MzQ2OSw1MzQ5NSwxMiw1MzQ5Nyw1MzUyMywxMiw1MzUyNSw1MzU1MSwxMiw1MzU1Myw1MzU3OSwxMiw1MzU4MSw1MzYwNywxMiw1MzYwOSw1MzYzNSwxMiw1MzYzNyw1MzY2MywxMiw1MzY2NSw1MzY5MSwxMiw1MzY5Myw1MzcxOSwxMiw1MzcyMSw1Mzc0NywxMiw1Mzc0OSw1Mzc3NSwxMiw1Mzc3Nyw1MzgwMywxMiw1MzgwNSw1MzgzMSwxMiw1MzgzMyw1Mzg1OSwxMiw1Mzg2MSw1Mzg4NywxMiw1Mzg4OSw1MzkxNSwxMiw1MzkxNyw1Mzk0MywxMiw1Mzk0NSw1Mzk3MSwxMiw1Mzk3Myw1Mzk5OSwxMiw1NDAwMSw1NDAyNywxMiw1NDAyOSw1NDA1NSwxMiw1NDA1Nyw1NDA4MywxMiw1NDA4NSw1NDExMSwxMiw1NDExMyw1NDEzOSwxMiw1NDE0MSw1NDE2NywxMiw1NDE2OSw1NDE5NSwxMiw1NDE5Nyw1NDIyMywxMiw1NDIyNSw1NDI1MSwxMiw1NDI1Myw1NDI3OSwxMiw1NDI4MSw1NDMwNywxMiw1NDMwOSw1NDMzNSwxMiw1NDMzNyw1NDM2MywxMiw1NDM2NSw1NDM5MSwxMiw1NDM5Myw1NDQxOSwxMiw1NDQyMSw1NDQ0NywxMiw1NDQ0OSw1NDQ3NSwxMiw1NDQ3Nyw1NDUwMywxMiw1NDUwNSw1NDUzMSwxMiw1NDUzMyw1NDU1OSwxMiw1NDU2MSw1NDU4NywxMiw1NDU4OSw1NDYxNSwxMiw1NDYxNyw1NDY0MywxMiw1NDY0NSw1NDY3MSwxMiw1NDY3Myw1NDY5OSwxMiw1NDcwMSw1NDcyNywxMiw1NDcyOSw1NDc1NSwxMiw1NDc1Nyw1NDc4MywxMiw1NDc4NSw1NDgxMSwxMiw1NDgxMyw1NDgzOSwxMiw1NDg0MSw1NDg2NywxMiw1NDg2OSw1NDg5NSwxMiw1NDg5Nyw1NDkyMywxMiw1NDkyNSw1NDk1MSwxMiw1NDk1Myw1NDk3OSwxMiw1NDk4MSw1NTAwNywxMiw1NTAwOSw1NTAzNSwxMiw1NTAzNyw1NTA2MywxMiw1NTA2NSw1NTA5MSwxMiw1NTA5Myw1NTExOSwxMiw1NTEyMSw1NTE0NywxMiw1NTE0OSw1NTE3NSwxMiw1NTE3Nyw1NTIwMywxMiw1NTI0Myw1NTI5MSwxMCw2NTAyNCw2NTAzOSw1LDY1Mjc5LDY1Mjc5LDQsNjU1MjAsNjU1MjgsNCw2NjA0NSw2NjA0NSw1LDY2NDIyLDY2NDI2LDUsNjgxMDEsNjgxMDIsNSw2ODE1Miw2ODE1NCw1LDY4MzI1LDY4MzI2LDUsNjkyOTEsNjkyOTIsNSw2OTYzMiw2OTYzMiw3LDY5NjM0LDY5NjM0LDcsNjk3NTksNjk3NjEsNV0nKTtcclxufVxyXG4vLyNlbmRyZWdpb25cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBvZmZzZXQgYWZ0ZXIgcGVyZm9ybWluZyBhIGxlZnQgZGVsZXRlIG9uIHRoZSBnaXZlbiBzdHJpbmcsXHJcbiAqIHdoaWxlIGNvbnNpZGVyaW5nIHVuaWNvZGUgZ3JhcGhlbWUvZW1vamkgcnVsZXMuXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWZ0RGVsZXRlT2Zmc2V0KG9mZnNldCwgc3RyKSB7XHJcbiAgICBpZiAob2Zmc2V0ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gZGVsZXRlIGVtb2ppIHBhcnQuXHJcbiAgICBjb25zdCBlbW9qaU9mZnNldCA9IGdldE9mZnNldEJlZm9yZUxhc3RFbW9qaUNvbXBvbmVudChvZmZzZXQsIHN0cik7XHJcbiAgICBpZiAoZW1vamlPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBlbW9qaU9mZnNldDtcclxuICAgIH1cclxuICAgIC8vIE90aGVyd2lzZSwganVzdCBza2lwIGEgc2luZ2xlIGNvZGUgcG9pbnQuXHJcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBnZXRQcmV2Q29kZVBvaW50KHN0ciwgb2Zmc2V0KTtcclxuICAgIG9mZnNldCAtPSBnZXRVVEYxNkxlbmd0aChjb2RlUG9pbnQpO1xyXG4gICAgcmV0dXJuIG9mZnNldDtcclxufVxyXG5mdW5jdGlvbiBnZXRPZmZzZXRCZWZvcmVMYXN0RW1vamlDb21wb25lbnQob2Zmc2V0LCBzdHIpIHtcclxuICAgIC8vIFNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyNTEvdHI1MS0xNC5odG1sI0VCTkZfYW5kX1JlZ2V4IGZvciB0aGVcclxuICAgIC8vIHN0cnVjdHVyZSBvZiBlbW9qaXMuXHJcbiAgICBsZXQgY29kZVBvaW50ID0gZ2V0UHJldkNvZGVQb2ludChzdHIsIG9mZnNldCk7XHJcbiAgICBvZmZzZXQgLT0gZ2V0VVRGMTZMZW5ndGgoY29kZVBvaW50KTtcclxuICAgIC8vIFNraXAgbW9kaWZpZXJzXHJcbiAgICB3aGlsZSAoKGlzRW1vamlNb2RpZmllcihjb2RlUG9pbnQpIHx8IGNvZGVQb2ludCA9PT0gNjUwMzkgLyogZW1vamlWYXJpYW50U2VsZWN0b3IgKi8gfHwgY29kZVBvaW50ID09PSA4NDE5IC8qIGVuY2xvc2luZ0tleUNhcCAqLykpIHtcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIENhbm5vdCBza2lwIG1vZGlmaWVyLCBubyBwcmVjZWRpbmcgZW1vamkgYmFzZS5cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZVBvaW50ID0gZ2V0UHJldkNvZGVQb2ludChzdHIsIG9mZnNldCk7XHJcbiAgICAgICAgb2Zmc2V0IC09IGdldFVURjE2TGVuZ3RoKGNvZGVQb2ludCk7XHJcbiAgICB9XHJcbiAgICAvLyBFeHBlY3QgYmFzZSBlbW9qaVxyXG4gICAgaWYgKCFpc0Vtb2ppSW1wcmVjaXNlKGNvZGVQb2ludCkpIHtcclxuICAgICAgICAvLyBVbmV4cGVjdGVkIGNvZGUgcG9pbnQsIG5vdCBhIHZhbGlkIGVtb2ppLlxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAob2Zmc2V0ID49IDApIHtcclxuICAgICAgICAvLyBTa2lwIG9wdGlvbmFsIFpXSiBjb2RlIHBvaW50cyB0aGF0IGNvbWJpbmUgbXVsdGlwbGUgZW1vamlzLlxyXG4gICAgICAgIC8vIEluIHRoZW9yeSwgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoYXQgWldKIGFjdHVhbGx5IGNvbWJpbmVzIG11bHRpcGxlIGVtb2ppc1xyXG4gICAgICAgIC8vIHRvIHByZXZlbnQgZGVsZXRpbmcgWldKcyBpbiBzaXR1YXRpb25zIHdlIGRpZG4ndCBhY2NvdW50IGZvci5cclxuICAgICAgICBjb25zdCBvcHRpb25hbFp3akNvZGVQb2ludCA9IGdldFByZXZDb2RlUG9pbnQoc3RyLCBvZmZzZXQpO1xyXG4gICAgICAgIGlmIChvcHRpb25hbFp3akNvZGVQb2ludCA9PT0gODIwNSAvKiB6d2ogKi8pIHtcclxuICAgICAgICAgICAgb2Zmc2V0IC09IGdldFVURjE2TGVuZ3RoKG9wdGlvbmFsWndqQ29kZVBvaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0O1xyXG59XHJcbmZ1bmN0aW9uIGdldFVURjE2TGVuZ3RoKGNvZGVQb2ludCkge1xyXG4gICAgcmV0dXJuIGNvZGVQb2ludCA+PSA2NTUzNiAvKiBVTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMTtcclxufVxyXG5mdW5jdGlvbiBpc0Vtb2ppTW9kaWZpZXIoY29kZVBvaW50KSB7XHJcbiAgICByZXR1cm4gMHgxRjNGQiA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUYzRkY7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi9zdHJpbmdzLmpzJztcclxuLyoqXHJcbiAqIFJldHVybiBhIGhhc2ggdmFsdWUgZm9yIGFuIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNoKG9iaikge1xyXG4gICAgcmV0dXJuIGRvSGFzaChvYmosIDApO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBkb0hhc2gob2JqLCBoYXNoVmFsKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcclxuICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCgzNDksIGhhc2hWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5SGFzaChvYmosIGhhc2hWYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RIYXNoKG9iaiwgaGFzaFZhbCk7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0hhc2gob2JqLCBoYXNoVmFsKTtcclxuICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2xlYW5IYXNoKG9iaiwgaGFzaFZhbCk7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2gob2JqLCBoYXNoVmFsKTtcclxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCg5MzcsIGhhc2hWYWwpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKDYxNywgaGFzaFZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbnVtYmVySGFzaCh2YWwsIGluaXRpYWxIYXNoVmFsKSB7XHJcbiAgICByZXR1cm4gKCgoaW5pdGlhbEhhc2hWYWwgPDwgNSkgLSBpbml0aWFsSGFzaFZhbCkgKyB2YWwpIHwgMDsgLy8gaGFzaFZhbCAqIDMxICsgY2gsIGtlZXAgYXMgaW50MzJcclxufVxyXG5mdW5jdGlvbiBib29sZWFuSGFzaChiLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgcmV0dXJuIG51bWJlckhhc2goYiA/IDQzMyA6IDg2MywgaW5pdGlhbEhhc2hWYWwpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdIYXNoKHMsIGhhc2hWYWwpIHtcclxuICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKDE0OTQxNywgaGFzaFZhbCk7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKHMuY2hhckNvZGVBdChpKSwgaGFzaFZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaFZhbDtcclxufVxyXG5mdW5jdGlvbiBhcnJheUhhc2goYXJyLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgaW5pdGlhbEhhc2hWYWwgPSBudW1iZXJIYXNoKDEwNDU3OSwgaW5pdGlhbEhhc2hWYWwpO1xyXG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGhhc2hWYWwsIGl0ZW0pID0+IGRvSGFzaChpdGVtLCBoYXNoVmFsKSwgaW5pdGlhbEhhc2hWYWwpO1xyXG59XHJcbmZ1bmN0aW9uIG9iamVjdEhhc2gob2JqLCBpbml0aWFsSGFzaFZhbCkge1xyXG4gICAgaW5pdGlhbEhhc2hWYWwgPSBudW1iZXJIYXNoKDE4MTM4NywgaW5pdGlhbEhhc2hWYWwpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuc29ydCgpLnJlZHVjZSgoaGFzaFZhbCwga2V5KSA9PiB7XHJcbiAgICAgICAgaGFzaFZhbCA9IHN0cmluZ0hhc2goa2V5LCBoYXNoVmFsKTtcclxuICAgICAgICByZXR1cm4gZG9IYXNoKG9ialtrZXldLCBoYXNoVmFsKTtcclxuICAgIH0sIGluaXRpYWxIYXNoVmFsKTtcclxufVxyXG5mdW5jdGlvbiBsZWZ0Um90YXRlKHZhbHVlLCBiaXRzLCB0b3RhbEJpdHMgPSAzMikge1xyXG4gICAgLy8gZGVsdGEgKyBiaXRzID0gdG90YWxCaXRzXHJcbiAgICBjb25zdCBkZWx0YSA9IHRvdGFsQml0cyAtIGJpdHM7XHJcbiAgICAvLyBBbGwgb25lcywgZXhwZWN0IGBkZWx0YWAgemVyb3MgYWxpZ25lZCB0byB0aGUgcmlnaHRcclxuICAgIGNvbnN0IG1hc2sgPSB+KCgxIDw8IGRlbHRhKSAtIDEpO1xyXG4gICAgLy8gSm9pbiAodmFsdWUgbGVmdC1zaGlmdGVkIGBiaXRzYCBiaXRzKSB3aXRoIChtYXNrZWQgdmFsdWUgcmlnaHQtc2hpZnRlZCBgZGVsdGFgIGJpdHMpXHJcbiAgICByZXR1cm4gKCh2YWx1ZSA8PCBiaXRzKSB8ICgobWFzayAmIHZhbHVlKSA+Pj4gZGVsdGEpKSA+Pj4gMDtcclxufVxyXG5mdW5jdGlvbiBmaWxsKGRlc3QsIGluZGV4ID0gMCwgY291bnQgPSBkZXN0LmJ5dGVMZW5ndGgsIHZhbHVlID0gMCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgZGVzdFtpbmRleCArIGldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGVmdFBhZCh2YWx1ZSwgbGVuZ3RoLCBjaGFyID0gJzAnKSB7XHJcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgdmFsdWUgPSBjaGFyICsgdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ1ZmZlck9yVmFsdWUsIGJpdHNpemUgPSAzMikge1xyXG4gICAgaWYgKGJ1ZmZlck9yVmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlck9yVmFsdWUpKS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0UGFkKChidWZmZXJPclZhbHVlID4+PiAwKS50b1N0cmluZygxNiksIGJpdHNpemUgLyA0KTtcclxufVxyXG4vKipcclxuICogQSBTSEExIGltcGxlbWVudGF0aW9uIHRoYXQgd29ya3Mgd2l0aCBzdHJpbmdzIGFuZCBkb2VzIG5vdCBhbGxvY2F0ZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdTSEExIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2gwID0gMHg2NzQ1MjMwMTtcclxuICAgICAgICB0aGlzLl9oMSA9IDB4RUZDREFCODk7XHJcbiAgICAgICAgdGhpcy5faDIgPSAweDk4QkFEQ0ZFO1xyXG4gICAgICAgIHRoaXMuX2gzID0gMHgxMDMyNTQ3NjtcclxuICAgICAgICB0aGlzLl9oNCA9IDB4QzNEMkUxRjA7XHJcbiAgICAgICAgdGhpcy5fYnVmZiA9IG5ldyBVaW50OEFycmF5KDY0IC8qIEJMT0NLX1NJWkUgKi8gKyAzIC8qIHRvIGZpdCBhbnkgdXRmLTggKi8pO1xyXG4gICAgICAgIHRoaXMuX2J1ZmZEViA9IG5ldyBEYXRhVmlldyh0aGlzLl9idWZmLmJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fYnVmZkxlbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxMZW4gPSAwO1xyXG4gICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShzdHIpIHtcclxuICAgICAgICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzdHJMZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidWZmID0gdGhpcy5fYnVmZjtcclxuICAgICAgICBsZXQgYnVmZkxlbiA9IHRoaXMuX2J1ZmZMZW47XHJcbiAgICAgICAgbGV0IGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZTtcclxuICAgICAgICBsZXQgY2hhckNvZGU7XHJcbiAgICAgICAgbGV0IG9mZnNldDtcclxuICAgICAgICBpZiAobGVmdG92ZXJIaWdoU3Vycm9nYXRlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAtMTtcclxuICAgICAgICAgICAgbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBjaGFyQ29kZTtcclxuICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDEgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0xvd1N1cnJvZ2F0ZShuZXh0Q2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmdzLmNvbXB1dGVDb2RlUG9pbnQoY2hhckNvZGUsIG5leHRDaGFyQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IDY1NTMzIC8qIFVOSUNPREVfUkVQTEFDRU1FTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBjaGFyYWN0ZXIgaXMgYSBzdXJyb2dhdGUgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ3MuaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMyAvKiBVTklDT0RFX1JFUExBQ0VNRU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1ZmZMZW4gPSB0aGlzLl9wdXNoKGJ1ZmYsIGJ1ZmZMZW4sIGNvZGVQb2ludCk7XHJcbiAgICAgICAgICAgIG9mZnNldCsrO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9idWZmTGVuID0gYnVmZkxlbjtcclxuICAgICAgICB0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGU7XHJcbiAgICB9XHJcbiAgICBfcHVzaChidWZmLCBidWZmTGVuLCBjb2RlUG9pbnQpIHtcclxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgwMDgwKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IGNvZGVQb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDwgMHgwODAwKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTEwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTEwMDAwMDApID4+PiA2KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTExMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDExMTEwMDAwMDAwMDAwMDApID4+PiAxMik7XHJcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDApID4+PiA2KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMTExMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDExMTAwMDAwMDAwMDAwMDAwMDAwMCkgPj4+IDE4KTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMDAwMDAwMCkgPj4+IDEyKTtcclxuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMCkgPj4+IDYpO1xyXG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExKSA+Pj4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWZmTGVuID49IDY0IC8qIEJMT0NLX1NJWkUgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xyXG4gICAgICAgICAgICBidWZmTGVuIC09IDY0IC8qIEJMT0NLX1NJWkUgKi87XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IDY0IC8qIEJMT0NLX1NJWkUgKi87XHJcbiAgICAgICAgICAgIC8vIHRha2UgbGFzdCAzIGluIGNhc2Ugb2YgVVRGOCBvdmVyZmxvd1xyXG4gICAgICAgICAgICBidWZmWzBdID0gYnVmZls2NCAvKiBCTE9DS19TSVpFICovICsgMF07XHJcbiAgICAgICAgICAgIGJ1ZmZbMV0gPSBidWZmWzY0IC8qIEJMT0NLX1NJWkUgKi8gKyAxXTtcclxuICAgICAgICAgICAgYnVmZlsyXSA9IGJ1ZmZbNjQgLyogQkxPQ0tfU0laRSAqLyArIDJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVmZkxlbjtcclxuICAgIH1cclxuICAgIGRpZ2VzdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWxsZWdhbCA9PiB1bmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZMZW4gPSB0aGlzLl9wdXNoKHRoaXMuX2J1ZmYsIHRoaXMuX2J1ZmZMZW4sIDY1NTMzIC8qIFVOSUNPREVfUkVQTEFDRU1FTlQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuICs9IHRoaXMuX2J1ZmZMZW47XHJcbiAgICAgICAgICAgIHRoaXMuX3dyYXBVcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9IZXhTdHJpbmcodGhpcy5faDApICsgdG9IZXhTdHJpbmcodGhpcy5faDEpICsgdG9IZXhTdHJpbmcodGhpcy5faDIpICsgdG9IZXhTdHJpbmcodGhpcy5faDMpICsgdG9IZXhTdHJpbmcodGhpcy5faDQpO1xyXG4gICAgfVxyXG4gICAgX3dyYXBVcCgpIHtcclxuICAgICAgICB0aGlzLl9idWZmW3RoaXMuX2J1ZmZMZW4rK10gPSAweDgwO1xyXG4gICAgICAgIGZpbGwodGhpcy5fYnVmZiwgdGhpcy5fYnVmZkxlbik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZMZW4gPiA1Nikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGVwKCk7XHJcbiAgICAgICAgICAgIGZpbGwodGhpcy5fYnVmZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBmaXQgYmVjYXVzZSB0aGUgbWFudGlzc2EgY2FuIGNvdmVyIHVwIHRvIDUyIGJpdHNcclxuICAgICAgICBjb25zdCBtbCA9IDggKiB0aGlzLl90b3RhbExlbjtcclxuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDU2LCBNYXRoLmZsb29yKG1sIC8gNDI5NDk2NzI5NiksIGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDYwLCBtbCAlIDQyOTQ5NjcyOTYsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLl9zdGVwKCk7XHJcbiAgICB9XHJcbiAgICBfc3RlcCgpIHtcclxuICAgICAgICBjb25zdCBiaWdCbG9jazMyID0gU3RyaW5nU0hBMS5fYmlnQmxvY2szMjtcclxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fYnVmZkRWO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQgLyogMTYqNCAqLzsgaiArPSA0KSB7XHJcbiAgICAgICAgICAgIGJpZ0Jsb2NrMzIuc2V0VWludDMyKGosIGRhdGEuZ2V0VWludDMyKGosIGZhbHNlKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBqID0gNjQ7IGogPCAzMjAgLyogODAqNCAqLzsgaiArPSA0KSB7XHJcbiAgICAgICAgICAgIGJpZ0Jsb2NrMzIuc2V0VWludDMyKGosIGxlZnRSb3RhdGUoKGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSAxMiwgZmFsc2UpIF4gYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDMyLCBmYWxzZSkgXiBiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gNTYsIGZhbHNlKSBeIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSA2NCwgZmFsc2UpKSwgMSksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLl9oMDtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuX2gxO1xyXG4gICAgICAgIGxldCBjID0gdGhpcy5faDI7XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLl9oMztcclxuICAgICAgICBsZXQgZSA9IHRoaXMuX2g0O1xyXG4gICAgICAgIGxldCBmLCBrO1xyXG4gICAgICAgIGxldCB0ZW1wO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODA7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoaiA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8ICgofmIpICYgZCk7XHJcbiAgICAgICAgICAgICAgICBrID0gMHg1QTgyNzk5OTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgNDApIHtcclxuICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICBrID0gMHg2RUQ5RUJBMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChqIDwgNjApIHtcclxuICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XHJcbiAgICAgICAgICAgICAgICBrID0gMHg4RjFCQkNEQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICBrID0gMHhDQTYyQzFENjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZW1wID0gKGxlZnRSb3RhdGUoYSwgNSkgKyBmICsgZSArIGsgKyBiaWdCbG9jazMyLmdldFVpbnQzMihqICogNCwgZmFsc2UpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGUgPSBkO1xyXG4gICAgICAgICAgICBkID0gYztcclxuICAgICAgICAgICAgYyA9IGxlZnRSb3RhdGUoYiwgMzApO1xyXG4gICAgICAgICAgICBiID0gYTtcclxuICAgICAgICAgICAgYSA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2gwID0gKHRoaXMuX2gwICsgYSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2gxID0gKHRoaXMuX2gxICsgYikgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2gyID0gKHRoaXMuX2gyICsgYykgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2gzID0gKHRoaXMuX2gzICsgZCkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgIHRoaXMuX2g0ID0gKHRoaXMuX2g0ICsgZSkgJiAweGZmZmZmZmZmO1xyXG4gICAgfVxyXG59XHJcblN0cmluZ1NIQTEuX2JpZ0Jsb2NrMzIgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDMyMCkpOyAvLyA4MCAqIDQgPSAzMjBcclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IERpZmZDaGFuZ2UgfSBmcm9tICcuL2RpZmZDaGFuZ2UuanMnO1xyXG5pbXBvcnQgeyBzdHJpbmdIYXNoIH0gZnJvbSAnLi4vaGFzaC5qcyc7XHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdEaWZmU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBnZXRFbGVtZW50cygpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzID0gbmV3IEludDMyQXJyYXkoc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gc291cmNlLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdEaWZmKG9yaWdpbmFsLCBtb2RpZmllZCwgcHJldHR5KSB7XHJcbiAgICByZXR1cm4gbmV3IExjc0RpZmYobmV3IFN0cmluZ0RpZmZTZXF1ZW5jZShvcmlnaW5hbCksIG5ldyBTdHJpbmdEaWZmU2VxdWVuY2UobW9kaWZpZWQpKS5Db21wdXRlRGlmZihwcmV0dHkpLmNoYW5nZXM7XHJcbn1cclxuLy9cclxuLy8gVGhlIGNvZGUgYmVsb3cgaGFzIGJlZW4gcG9ydGVkIGZyb20gYSBDIyBpbXBsZW1lbnRhdGlvbiBpbiBWU1xyXG4vL1xyXG5leHBvcnQgY2xhc3MgRGVidWcge1xyXG4gICAgc3RhdGljIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBNeUFycmF5IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSBhbiBBcnJheSBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIHNvdXJjZSBpbmRleCBhbmQgcGFzdGVzXHJcbiAgICAgKiB0aGVtIHRvIGFub3RoZXIgQXJyYXkgc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBkZXN0aW5hdGlvbiBpbmRleC4gVGhlIGxlbmd0aCBhbmQgdGhlIGluZGV4ZXNcclxuICAgICAqIGFyZSBzcGVjaWZpZWQgYXMgNjQtYml0IGludGVnZXJzLlxyXG4gICAgICogc291cmNlQXJyYXk6XHJcbiAgICAgKlx0XHRUaGUgQXJyYXkgdGhhdCBjb250YWlucyB0aGUgZGF0YSB0byBjb3B5LlxyXG4gICAgICogc291cmNlSW5kZXg6XHJcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIHNvdXJjZUFycmF5IGF0IHdoaWNoIGNvcHlpbmcgYmVnaW5zLlxyXG4gICAgICogZGVzdGluYXRpb25BcnJheTpcclxuICAgICAqXHRcdFRoZSBBcnJheSB0aGF0IHJlY2VpdmVzIHRoZSBkYXRhLlxyXG4gICAgICogZGVzdGluYXRpb25JbmRleDpcclxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgZGVzdGluYXRpb25BcnJheSBhdCB3aGljaCBzdG9yaW5nIGJlZ2lucy5cclxuICAgICAqIGxlbmd0aDpcclxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY29weS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIENvcHkoc291cmNlQXJyYXksIHNvdXJjZUluZGV4LCBkZXN0aW5hdGlvbkFycmF5LCBkZXN0aW5hdGlvbkluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQXJyYXlbZGVzdGluYXRpb25JbmRleCArIGldID0gc291cmNlQXJyYXlbc291cmNlSW5kZXggKyBpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgQ29weTIoc291cmNlQXJyYXksIHNvdXJjZUluZGV4LCBkZXN0aW5hdGlvbkFycmF5LCBkZXN0aW5hdGlvbkluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQXJyYXlbZGVzdGluYXRpb25JbmRleCArIGldID0gc291cmNlQXJyYXlbc291cmNlSW5kZXggKyBpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyB3aGljaCBoZWxwcyB0byBjcmVhdGUgdGhlIHNldCBvZiBEaWZmQ2hhbmdlcyBmcm9tXHJcbiAqIGEgZGlmZmVyZW5jZSBvcGVyYXRpb24uIFRoaXMgY2xhc3MgYWNjZXB0cyBvcmlnaW5hbCBEaWZmRWxlbWVudHMgYW5kXHJcbiAqIG1vZGlmaWVkIERpZmZFbGVtZW50cyB0aGF0IGFyZSBpbnZvbHZlZCBpbiBhIHBhcnRpY3VsYXIgY2hhbmdlLiBUaGVcclxuICogTWFya3ROZXh0Q2hhbmdlKCkgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gbWFyayB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuXHJcbiAqIGRpc3RpbmN0IGNoYW5nZXMuIEF0IHRoZSBlbmQsIHRoZSBDaGFuZ2VzIHByb3BlcnR5IGNhbiBiZSBjYWxsZWQgdG8gcmV0cmlldmVcclxuICogdGhlIGNvbnN0cnVjdGVkIGNoYW5nZXMuXHJcbiAqL1xyXG5jbGFzcyBEaWZmQ2hhbmdlSGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBEaWZmQ2hhbmdlSGVscGVyIGZvciB0aGUgZ2l2ZW4gRGlmZlNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tX2NoYW5nZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IDEwNzM3NDE4MjQgLyogTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcclxuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IDEwNzM3NDE4MjQgLyogTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGNoYW5nZSBpbiB0aGUgc2V0IG9mIGRpZmZlcmVuY2VzLlxyXG4gICAgICovXHJcbiAgICBNYXJrTmV4dENoYW5nZSgpIHtcclxuICAgICAgICAvLyBPbmx5IGFkZCB0byB0aGUgbGlzdCBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdG8gYWRkXHJcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgY2hhbmdlIHRvIG91ciBsaXN0XHJcbiAgICAgICAgICAgIHRoaXMubV9jaGFuZ2VzLnB1c2gobmV3IERpZmZDaGFuZ2UodGhpcy5tX29yaWdpbmFsU3RhcnQsIHRoaXMubV9vcmlnaW5hbENvdW50LCB0aGlzLm1fbW9kaWZpZWRTdGFydCwgdGhpcy5tX21vZGlmaWVkQ291bnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGNoYW5nZVxyXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLm1fbW9kaWZpZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIE1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSAxMDczNzQxODI0IC8qIE1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIG9yaWdpbmFsIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50c1xyXG4gICAgICogYWZmZWN0ZWQgYnkgdGhlIGN1cnJlbnQgY2hhbmdlLiBUaGUgbW9kaWZpZWQgaW5kZXggZ2l2ZXMgY29udGV4dFxyXG4gICAgICogdG8gdGhlIGNoYW5nZSBwb3NpdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRvIGFkZC5cclxuICAgICAqIEBwYXJhbSBtb2RpZmllZEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbW9kaWZpZWQgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBBZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkge1xyXG4gICAgICAgIC8vIFRoZSAndHJ1ZScgc3RhcnQgaW5kZXggaXMgdGhlIHNtYWxsZXN0IG9mIHRoZSBvbmVzIHdlJ3ZlIHNlZW5cclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxTdGFydCA9IE1hdGgubWluKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEluZGV4KTtcclxuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IE1hdGgubWluKHRoaXMubV9tb2RpZmllZFN0YXJ0LCBtb2RpZmllZEluZGV4KTtcclxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBtb2RpZmllZCBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB0byB0aGUgZWxlbWVudHNcclxuICAgICAqIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IGNoYW5nZS4gVGhlIG9yaWdpbmFsIGluZGV4IGdpdmVzIGNvbnRleHRcclxuICAgICAqIHRvIHRoZSBjaGFuZ2UgcG9zaXRpb24gd2l0aCByZXNwZWN0IHRvIHRoZSBtb2RpZmllZCBzZXF1ZW5jZS5cclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEluZGV4IFRoZSBpbmRleCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIG1vZGlmaWVkSW5kZXggVGhlIGluZGV4IG9mIHRoZSBtb2RpZmllZCBlbGVtZW50IHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpIHtcclxuICAgICAgICAvLyBUaGUgJ3RydWUnIHN0YXJ0IGluZGV4IGlzIHRoZSBzbWFsbGVzdCBvZiB0aGUgb25lcyB3ZSd2ZSBzZWVuXHJcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fb3JpZ2luYWxTdGFydCwgb3JpZ2luYWxJbmRleCk7XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRJbmRleCk7XHJcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkQ291bnQrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY2hhbmdlcyBtYXJrZWQgYnkgdGhlIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBnZXRDaGFuZ2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1fb3JpZ2luYWxDb3VudCA+IDAgfHwgdGhpcy5tX21vZGlmaWVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmlzaCB1cCBvbiB3aGF0ZXZlciBpcyBsZWZ0XHJcbiAgICAgICAgICAgIHRoaXMuTWFya05leHRDaGFuZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIG1hcmtlZCBieSB0aGUgY2xhc3MgaW4gdGhlIHJldmVyc2Ugb3JkZXJcclxuICAgICAqL1xyXG4gICAgZ2V0UmV2ZXJzZUNoYW5nZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgLy8gRmluaXNoIHVwIG9uIHdoYXRldmVyIGlzIGxlZnRcclxuICAgICAgICAgICAgdGhpcy5NYXJrTmV4dENoYW5nZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1fY2hhbmdlcy5yZXZlcnNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jaGFuZ2VzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGlmZmVyZW5jZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluXHJcbiAqIFwiQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIGl0cyB2YXJpYXRpb25zXCIgYnkgRXVnZW5lIFcuIE15ZXJzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTGNzRGlmZiB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgdGhlIERpZmZGaW5kZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxTZXF1ZW5jZSwgbW9kaWZpZWRTZXF1ZW5jZSwgY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlID0gY29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsU2VxdWVuY2UgPSBvcmlnaW5hbFNlcXVlbmNlO1xyXG4gICAgICAgIHRoaXMuX21vZGlmaWVkU2VxdWVuY2UgPSBtb2RpZmllZFNlcXVlbmNlO1xyXG4gICAgICAgIGNvbnN0IFtvcmlnaW5hbFN0cmluZ0VsZW1lbnRzLCBvcmlnaW5hbEVsZW1lbnRzT3JIYXNoLCBvcmlnaW5hbEhhc1N0cmluZ3NdID0gTGNzRGlmZi5fZ2V0RWxlbWVudHMob3JpZ2luYWxTZXF1ZW5jZSk7XHJcbiAgICAgICAgY29uc3QgW21vZGlmaWVkU3RyaW5nRWxlbWVudHMsIG1vZGlmaWVkRWxlbWVudHNPckhhc2gsIG1vZGlmaWVkSGFzU3RyaW5nc10gPSBMY3NEaWZmLl9nZXRFbGVtZW50cyhtb2RpZmllZFNlcXVlbmNlKTtcclxuICAgICAgICB0aGlzLl9oYXNTdHJpbmdzID0gKG9yaWdpbmFsSGFzU3RyaW5ncyAmJiBtb2RpZmllZEhhc1N0cmluZ3MpO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHMgPSBvcmlnaW5hbFN0cmluZ0VsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2ggPSBvcmlnaW5hbEVsZW1lbnRzT3JIYXNoO1xyXG4gICAgICAgIHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHMgPSBtb2RpZmllZFN0cmluZ0VsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2ggPSBtb2RpZmllZEVsZW1lbnRzT3JIYXNoO1xyXG4gICAgICAgIHRoaXMubV9mb3J3YXJkSGlzdG9yeSA9IFtdO1xyXG4gICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeSA9IFtdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9pc1N0cmluZ0FycmF5KGFycikge1xyXG4gICAgICAgIHJldHVybiAoYXJyLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyclswXSA9PT0gJ3N0cmluZycpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9nZXRFbGVtZW50cyhzZXF1ZW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gc2VxdWVuY2UuZ2V0RWxlbWVudHMoKTtcclxuICAgICAgICBpZiAoTGNzRGlmZi5faXNTdHJpbmdBcnJheShlbGVtZW50cykpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFzaGVzID0gbmV3IEludDMyQXJyYXkoZWxlbWVudHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNoZXNbaV0gPSBzdHJpbmdIYXNoKGVsZW1lbnRzW2ldLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLCBoYXNoZXMsIHRydWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlbWVudHMgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbW10sIGVsZW1lbnRzLCBmYWxzZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbW10sIG5ldyBJbnQzMkFycmF5KGVsZW1lbnRzKSwgZmFsc2VdO1xyXG4gICAgfVxyXG4gICAgRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbEluZGV4LCBuZXdJbmRleCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoW29yaWdpbmFsSW5kZXhdICE9PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW25ld0luZGV4XSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxJbmRleF0gPT09IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbbmV3SW5kZXhdIDogdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBFbGVtZW50c0FyZVN0cmljdEVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbmV3SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbGVtZW50ID0gTGNzRGlmZi5fZ2V0U3RyaWN0RWxlbWVudCh0aGlzLl9vcmlnaW5hbFNlcXVlbmNlLCBvcmlnaW5hbEluZGV4KTtcclxuICAgICAgICBjb25zdCBtb2RpZmllZEVsZW1lbnQgPSBMY3NEaWZmLl9nZXRTdHJpY3RFbGVtZW50KHRoaXMuX21vZGlmaWVkU2VxdWVuY2UsIG5ld0luZGV4KTtcclxuICAgICAgICByZXR1cm4gKG9yaWdpbmFsRWxlbWVudCA9PT0gbW9kaWZpZWRFbGVtZW50KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBfZ2V0U3RyaWN0RWxlbWVudChzZXF1ZW5jZSwgaW5kZXgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNlcXVlbmNlLmdldFN0cmljdEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlLmdldFN0cmljdEVsZW1lbnQoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIE9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChpbmRleDEsIGluZGV4Mikge1xyXG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoW2luZGV4MV0gIT09IHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbaW5kZXgyXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbaW5kZXgxXSA9PT0gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleDJdIDogdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBNb2RpZmllZEVsZW1lbnRzQXJlRXF1YWwoaW5kZXgxLCBpbmRleDIpIHtcclxuICAgICAgICBpZiAodGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaFtpbmRleDFdICE9PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW2luZGV4Ml0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgPyB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzW2luZGV4MV0gPT09IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXgyXSA6IHRydWUpO1xyXG4gICAgfVxyXG4gICAgQ29tcHV0ZURpZmYocHJldHR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX0NvbXB1dGVEaWZmKDAsIHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSwgMCwgdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxLCBwcmV0dHkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgb3JpZ2luYWwgYW5kIG1vZGlmaWVkIGlucHV0XHJcbiAgICAgKiBzZXF1ZW5jZXMgb24gdGhlIGJvdW5kZWQgcmFuZ2UuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIGlucHV0IHNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgX0NvbXB1dGVEaWZmKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcHJldHR5KSB7XHJcbiAgICAgICAgY29uc3QgcXVpdEVhcmx5QXJyID0gW2ZhbHNlXTtcclxuICAgICAgICBsZXQgY2hhbmdlcyA9IHRoaXMuQ29tcHV0ZURpZmZSZWN1cnNpdmUob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgICAgIGlmIChwcmV0dHkpIHtcclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBjbGVhbiB1cCB0aGUgY29tcHV0ZWQgZGlmZiB0byBiZSBtb3JlIGludHVpdGl2ZVxyXG4gICAgICAgICAgICAvLyBidXQgaXQgdHVybnMgb3V0IHRoaXMgY2Fubm90IGJlIGRvbmUgY29ycmVjdGx5IHVudGlsIHRoZSBlbnRpcmUgc2V0XHJcbiAgICAgICAgICAgIC8vIG9mIGRpZmZzIGhhdmUgYmVlbiBjb21wdXRlZFxyXG4gICAgICAgICAgICBjaGFuZ2VzID0gdGhpcy5QcmV0dGlmeUNoYW5nZXMoY2hhbmdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1aXRFYXJseTogcXVpdEVhcmx5QXJyWzBdLFxyXG4gICAgICAgICAgICBjaGFuZ2VzOiBjaGFuZ2VzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHdoaWNoIGNvbXB1dGVzIHRoZSBkaWZmZXJlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZVxyXG4gICAgICogcmVjdXJzaXZlbHkuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIGlucHV0IHNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgQ29tcHV0ZURpZmZSZWN1cnNpdmUob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBxdWl0RWFybHlBcnIpIHtcclxuICAgICAgICBxdWl0RWFybHlBcnJbMF0gPSBmYWxzZTtcclxuICAgICAgICAvLyBGaW5kIHRoZSBzdGFydCBvZiB0aGUgZGlmZmVyZW5jZXNcclxuICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydCA8PSBvcmlnaW5hbEVuZCAmJiBtb2RpZmllZFN0YXJ0IDw9IG1vZGlmaWVkRW5kICYmIHRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KSkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Kys7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIHRoZSBkaWZmZXJlbmNlc1xyXG4gICAgICAgIHdoaWxlIChvcmlnaW5hbEVuZCA+PSBvcmlnaW5hbFN0YXJ0ICYmIG1vZGlmaWVkRW5kID49IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsRW5kLCBtb2RpZmllZEVuZCkpIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxFbmQtLTtcclxuICAgICAgICAgICAgbW9kaWZpZWRFbmQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW4gdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBlaXRoZXIgaGF2ZSBhbGwgaW5zZXJ0aW9ucyBvciBhbGwgZGVsZXRpb25zIG9yIHRoZSBzZXF1ZW5jZXMgYXJlIGlkZW50aWNhbFxyXG4gICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0ID4gb3JpZ2luYWxFbmQgfHwgbW9kaWZpZWRTdGFydCA+IG1vZGlmaWVkRW5kKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzO1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZWRTdGFydCA8PSBtb2RpZmllZEVuZCkge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsRW5kICsgMSwgJ29yaWdpbmFsU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBvcmlnaW5hbEVuZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gQWxsIGluc2VydGlvbnNcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgMCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxTdGFydCA8PSBvcmlnaW5hbEVuZCkge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gQWxsIGRlbGV0aW9uc1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQgKyAxLCBtb2RpZmllZFN0YXJ0LCAwKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChvcmlnaW5hbFN0YXJ0ID09PSBvcmlnaW5hbEVuZCArIDEsICdvcmlnaW5hbFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gb3JpZ2luYWxFbmQnKTtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZEVuZCArIDEsICdtb2RpZmllZFN0YXJ0IHNob3VsZCBvbmx5IGJlIG9uZSBtb3JlIHRoYW4gbW9kaWZpZWRFbmQnKTtcclxuICAgICAgICAgICAgICAgIC8vIElkZW50aWNhbCBzZXF1ZW5jZXMgLSBObyBkaWZmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGlzIHByb2JsZW0gY2FuIGJlIHNvbHZlZCB1c2luZyB0aGUgRGl2aWRlLUFuZC1Db25xdWVyIHRlY2huaXF1ZS5cclxuICAgICAgICBjb25zdCBtaWRPcmlnaW5hbEFyciA9IFswXTtcclxuICAgICAgICBjb25zdCBtaWRNb2RpZmllZEFyciA9IFswXTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLkNvbXB1dGVSZWN1cnNpb25Qb2ludChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIG1pZE9yaWdpbmFsQXJyLCBtaWRNb2RpZmllZEFyciwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICBjb25zdCBtaWRPcmlnaW5hbCA9IG1pZE9yaWdpbmFsQXJyWzBdO1xyXG4gICAgICAgIGNvbnN0IG1pZE1vZGlmaWVkID0gbWlkTW9kaWZpZWRBcnJbMF07XHJcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBSZXN1bHQgaXMgbm90LW51bGwgd2hlbiB0aGVyZSB3YXMgZW5vdWdoIG1lbW9yeSB0byBjb21wdXRlIHRoZSBjaGFuZ2VzIHdoaWxlXHJcbiAgICAgICAgICAgIC8vIHNlYXJjaGluZyBmb3IgdGhlIHJlY3Vyc2lvbiBwb2ludFxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghcXVpdEVhcmx5QXJyWzBdKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBicmVhayB0aGUgcHJvYmxlbSBkb3duIHJlY3Vyc2l2ZWx5IGJ5IGZpbmRpbmcgdGhlIGNoYW5nZXMgaW4gdGhlXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IEhhbGY6ICAgKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpIHRvIChtaWRPcmlnaW5hbCwgbWlkTW9kaWZpZWQpXHJcbiAgICAgICAgICAgIC8vIFNlY29uZCBIYWxmOiAgKG1pZE9yaWdpbmFsICsgMSwgbWluTW9kaWZpZWQgKyAxKSB0byAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxyXG4gICAgICAgICAgICAvLyBOT1RFOiBDb21wdXRlRGlmZigpIGlzIGluY2x1c2l2ZSwgdGhlcmVmb3JlIHRoZSBzZWNvbmQgcmFuZ2Ugc3RhcnRzIG9uIHRoZSBuZXh0IHBvaW50XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBtaWRPcmlnaW5hbCwgbW9kaWZpZWRTdGFydCwgbWlkTW9kaWZpZWQsIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgICAgIGxldCByaWdodENoYW5nZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCFxdWl0RWFybHlBcnJbMF0pIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhbmdlcyA9IHRoaXMuQ29tcHV0ZURpZmZSZWN1cnNpdmUobWlkT3JpZ2luYWwgKyAxLCBvcmlnaW5hbEVuZCwgbWlkTW9kaWZpZWQgKyAxLCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRpZCd0IGhhdmUgdGltZSB0byBmaW5pc2ggdGhlIGZpcnN0IGhhbGYsIHNvIHdlIGRvbid0IGhhdmUgdGltZSB0byBjb21wdXRlIHRoaXMgaGFsZi5cclxuICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIHRoZSBlbnRpcmUgcmVzdCBvZiB0aGUgc2VxdWVuY2UgZGlmZmVyZW50LlxyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG1pZE9yaWdpbmFsICsgMSwgb3JpZ2luYWxFbmQgLSAobWlkT3JpZ2luYWwgKyAxKSArIDEsIG1pZE1vZGlmaWVkICsgMSwgbW9kaWZpZWRFbmQgLSAobWlkTW9kaWZpZWQgKyAxKSArIDEpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhsZWZ0Q2hhbmdlcywgcmlnaHRDaGFuZ2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgaGl0IGhlcmUsIHdlIHF1aXQgZWFybHksIGFuZCBzbyBjYW4ndCByZXR1cm4gYW55dGhpbmcgbWVhbmluZ2Z1bFxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIFdBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpIHtcclxuICAgICAgICBsZXQgZm9yd2FyZENoYW5nZXMgPSBudWxsO1xyXG4gICAgICAgIGxldCByZXZlcnNlQ2hhbmdlcyA9IG51bGw7XHJcbiAgICAgICAgLy8gRmlyc3QsIHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgZm9yd2FyZCBkaWFnb25hbHMgaGlzdG9yeVxyXG4gICAgICAgIGxldCBjaGFuZ2VIZWxwZXIgPSBuZXcgRGlmZkNoYW5nZUhlbHBlcigpO1xyXG4gICAgICAgIGxldCBkaWFnb25hbE1pbiA9IGRpYWdvbmFsRm9yd2FyZFN0YXJ0O1xyXG4gICAgICAgIGxldCBkaWFnb25hbE1heCA9IGRpYWdvbmFsRm9yd2FyZEVuZDtcclxuICAgICAgICBsZXQgZGlhZ29uYWxSZWxhdGl2ZSA9IChtaWRPcmlnaW5hbEFyclswXSAtIG1pZE1vZGlmaWVkQXJyWzBdKSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcclxuICAgICAgICBsZXQgbGFzdE9yaWdpbmFsSW5kZXggPSAtMTA3Mzc0MTgyNCAvKiBNSU5fU0FGRV9TTUFMTF9JTlRFR0VSICovO1xyXG4gICAgICAgIGxldCBoaXN0b3J5SW5kZXggPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnkubGVuZ3RoIC0gMTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGlhZ29uYWwgaW5kZXggZnJvbSB0aGUgcmVsYXRpdmUgZGlhZ29uYWwgbnVtYmVyXHJcbiAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsRm9yd2FyZEJhc2U7XHJcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hlcmUgd2UgY2FtZSBmcm9tXHJcbiAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxNaW4gfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxNYXggJiYgZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdIDwgZm9yd2FyZFBvaW50c1tkaWFnb25hbCArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYW4gaW5zZXJ0KVxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGZvcndhcmRQb2ludHNbZGlhZ29uYWwgKyAxXTtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDwgbGFzdE9yaWdpbmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRNb2RpZmllZEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCArIDEpIC0gZGlhZ29uYWxGb3J3YXJkQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGEgZGVsZXRpb24pXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdICsgMTtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDwgbGFzdE9yaWdpbmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkT3JpZ2luYWxFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgLSAxKSAtIGRpYWdvbmFsRm9yd2FyZEJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yd2FyZFBvaW50cyA9IHRoaXMubV9mb3J3YXJkSGlzdG9yeVtoaXN0b3J5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgZGlhZ29uYWxGb3J3YXJkQmFzZSA9IGZvcndhcmRQb2ludHNbMF07IC8vV2Ugc3RvcmVkIHRoaXMgaW4gdGhlIGZpcnN0IHNwb3RcclxuICAgICAgICAgICAgICAgIGRpYWdvbmFsTWluID0gMTtcclxuICAgICAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gZm9yd2FyZFBvaW50cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpO1xyXG4gICAgICAgIC8vIElyb25pY2FsbHksIHdlIGdldCB0aGUgZm9yd2FyZCBjaGFuZ2VzIGFzIHRoZSByZXZlcnNlIG9mIHRoZVxyXG4gICAgICAgIC8vIG9yZGVyIHdlIGFkZGVkIHRoZW0gc2luY2Ugd2UgdGVjaG5pY2FsbHkgYWRkZWQgdGhlbSBiYWNrd2FyZHNcclxuICAgICAgICBmb3J3YXJkQ2hhbmdlcyA9IGNoYW5nZUhlbHBlci5nZXRSZXZlcnNlQ2hhbmdlcygpO1xyXG4gICAgICAgIGlmIChxdWl0RWFybHlBcnJbMF0pIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogQ2FsY3VsYXRlIGEgcGFydGlhbCBmcm9tIHRoZSByZXZlcnNlIGRpYWdvbmFscy5cclxuICAgICAgICAgICAgLy8gICAgICAgRm9yIG5vdywganVzdCBhc3N1bWUgZXZlcnl0aGluZyBhZnRlciB0aGUgbWlkT3JpZ2luYWwvbWlkTW9kaWZpZWQgcG9pbnQgaXMgYSBkaWZmXHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBtaWRPcmlnaW5hbEFyclswXSArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllZFN0YXJ0UG9pbnQgPSBtaWRNb2RpZmllZEFyclswXSArIDE7XHJcbiAgICAgICAgICAgIGlmIChmb3J3YXJkQ2hhbmdlcyAhPT0gbnVsbCAmJiBmb3J3YXJkQ2hhbmdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Rm9yd2FyZENoYW5nZSA9IGZvcndhcmRDaGFuZ2VzW2ZvcndhcmRDaGFuZ2VzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydFBvaW50ID0gTWF0aC5tYXgob3JpZ2luYWxTdGFydFBvaW50LCBsYXN0Rm9yd2FyZENoYW5nZS5nZXRPcmlnaW5hbEVuZCgpKTtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRQb2ludCA9IE1hdGgubWF4KG1vZGlmaWVkU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0TW9kaWZpZWRFbmQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV2ZXJzZUNoYW5nZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0UG9pbnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydFBvaW50ICsgMSwgbW9kaWZpZWRTdGFydFBvaW50LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnRQb2ludCArIDEpXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOb3cgd2FsayBiYWNrd2FyZCB0aHJvdWdoIHRoZSByZXZlcnNlIGRpYWdvbmFscyBoaXN0b3J5XHJcbiAgICAgICAgICAgIGNoYW5nZUhlbHBlciA9IG5ldyBEaWZmQ2hhbmdlSGVscGVyKCk7XHJcbiAgICAgICAgICAgIGRpYWdvbmFsTWluID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7XHJcbiAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gZGlhZ29uYWxSZXZlcnNlRW5kO1xyXG4gICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKG1pZE9yaWdpbmFsQXJyWzBdIC0gbWlkTW9kaWZpZWRBcnJbMF0pIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IDEwNzM3NDE4MjQgLyogTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcclxuICAgICAgICAgICAgaGlzdG9yeUluZGV4ID0gKGRlbHRhSXNFdmVuKSA/IHRoaXMubV9yZXZlcnNlSGlzdG9yeS5sZW5ndGggLSAxIDogdGhpcy5tX3JldmVyc2VIaXN0b3J5Lmxlbmd0aCAtIDI7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGlhZ29uYWwgaW5kZXggZnJvbSB0aGUgcmVsYXRpdmUgZGlhZ29uYWwgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaWFnb25hbCA9IGRpYWdvbmFsUmVsYXRpdmUgKyBkaWFnb25hbFJldmVyc2VCYXNlO1xyXG4gICAgICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGVyZSB3ZSBjYW1lIGZyb21cclxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxNaW4gfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxNYXggJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGEgZGVsZXRpb24pKVxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0gLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA+IGxhc3RPcmlnaW5hbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsICsgMSkgLSBkaWFnb25hbFJldmVyc2VCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGxpbmUgKHRoZSBlbGVtZW50IGlzIGFuIGluc2VydGlvbilcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCA+IGxhc3RPcmlnaW5hbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLkFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4ICsgMSwgbW9kaWZpZWRJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgLSAxKSAtIGRpYWdvbmFsUmV2ZXJzZUJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhpc3RvcnlJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZVBvaW50cyA9IHRoaXMubV9yZXZlcnNlSGlzdG9yeVtoaXN0b3J5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZUJhc2UgPSByZXZlcnNlUG9pbnRzWzBdOyAvL1dlIHN0b3JlZCB0aGlzIGluIHRoZSBmaXJzdCBzcG90XHJcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxNaW4gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gcmV2ZXJzZVBvaW50cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IHdoaWxlICgtLWhpc3RvcnlJbmRleCA+PSAtMSk7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgcmV2ZXJzZSBoaXN0b3J5IHdpbGwgZmluZCBkaWZmcyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGFyZSBjb3JyZWN0LCBidXQgbm90IGludHVpdGl2ZSwgc28gd2UgbmVlZCBzaGlmdCB0aGVtLlxyXG4gICAgICAgICAgICByZXZlcnNlQ2hhbmdlcyA9IGNoYW5nZUhlbHBlci5nZXRDaGFuZ2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLkNvbmNhdGVuYXRlQ2hhbmdlcyhmb3J3YXJkQ2hhbmdlcywgcmV2ZXJzZUNoYW5nZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiB0aGUgcmFuZ2UgdG8gY29tcHV0ZSB0aGUgZGlmZiBvbiwgdGhpcyBtZXRob2QgZmluZHMgdGhlIHBvaW50OlxyXG4gICAgICogKG1pZE9yaWdpbmFsLCBtaWRNb2RpZmllZClcclxuICAgICAqIHRoYXQgZXhpc3RzIGluIHRoZSBtaWRkbGUgb2YgdGhlIExDUyBvZiB0aGUgdHdvIHNlcXVlbmNlcyBhbmRcclxuICAgICAqIGlzIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgTENTIHByb2JsZW0gbWF5IGJlIGJyb2tlbiBkb3duIHJlY3Vyc2l2ZWx5LlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB0cnkgdG8ga2VlcCB0aGUgTENTIHRyYWNlIGluIG1lbW9yeS4gSWYgdGhlIExDUyByZWN1cnNpb25cclxuICAgICAqIHBvaW50IGlzIGNhbGN1bGF0ZWQgYW5kIHRoZSBmdWxsIHRyYWNlIGlzIGF2YWlsYWJsZSBpbiBtZW1vcnksIHRoZW4gdGhpcyBtZXRob2RcclxuICAgICAqIHdpbGwgcmV0dXJuIHRoZSBjaGFuZ2UgbGlzdC5cclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbFN0YXJ0IFRoZSBzdGFydCBib3VuZCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2VcclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEVuZCBUaGUgZW5kIGJvdW5kIG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHBhcmFtIG1vZGlmaWVkU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHBhcmFtIG1vZGlmaWVkRW5kIFRoZSBlbmQgYm91bmQgb2YgdGhlIG1vZGlmaWVkIHNlcXVlbmNlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbWlkT3JpZ2luYWwgVGhlIG1pZGRsZSBwb2ludCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2VcclxuICAgICAqIEBwYXJhbSBtaWRNb2RpZmllZCBUaGUgbWlkZGxlIHBvaW50IG9mIHRoZSBtb2RpZmllZCBzZXF1ZW5jZSByYW5nZVxyXG4gICAgICogQHJldHVybnMgVGhlIGRpZmYgY2hhbmdlcywgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgbnVsbFxyXG4gICAgICovXHJcbiAgICBDb21wdXRlUmVjdXJzaW9uUG9pbnQob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kLCBtaWRPcmlnaW5hbEFyciwgbWlkTW9kaWZpZWRBcnIsIHF1aXRFYXJseUFycikge1xyXG4gICAgICAgIGxldCBvcmlnaW5hbEluZGV4ID0gMCwgbW9kaWZpZWRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IGRpYWdvbmFsRm9yd2FyZFN0YXJ0ID0gMCwgZGlhZ29uYWxGb3J3YXJkRW5kID0gMDtcclxuICAgICAgICBsZXQgZGlhZ29uYWxSZXZlcnNlU3RhcnQgPSAwLCBkaWFnb25hbFJldmVyc2VFbmQgPSAwO1xyXG4gICAgICAgIC8vIFRvIHRyYXZlcnNlIHRoZSBlZGl0IGdyYXBoIGFuZCBwcm9kdWNlIHRoZSBwcm9wZXIgTENTLCBvdXIgYWN0dWFsXHJcbiAgICAgICAgLy8gc3RhcnQgcG9zaXRpb24gaXMganVzdCBvdXRzaWRlIHRoZSBnaXZlbiBib3VuZGFyeVxyXG4gICAgICAgIG9yaWdpbmFsU3RhcnQtLTtcclxuICAgICAgICBtb2RpZmllZFN0YXJ0LS07XHJcbiAgICAgICAgLy8gV2Ugc2V0IHRoZXNlIHVwIHRvIG1ha2UgdGhlIGNvbXBpbGVyIGhhcHB5LCBidXQgdGhleSB3aWxsXHJcbiAgICAgICAgLy8gYmUgcmVwbGFjZWQgYmVmb3JlIHdlIHJldHVybiB3aXRoIHRoZSBhY3R1YWwgcmVjdXJzaW9uIHBvaW50XHJcbiAgICAgICAgbWlkT3JpZ2luYWxBcnJbMF0gPSAwO1xyXG4gICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gMDtcclxuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGhpc3RvcnlcclxuICAgICAgICB0aGlzLm1fZm9yd2FyZEhpc3RvcnkgPSBbXTtcclxuICAgICAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkgPSBbXTtcclxuICAgICAgICAvLyBFYWNoIGNlbGwgaW4gdGhlIHR3byBhcnJheXMgY29ycmVzcG9uZHMgdG8gYSBkaWFnb25hbCBpbiB0aGUgZWRpdCBncmFwaC5cclxuICAgICAgICAvLyBUaGUgaW50ZWdlciB2YWx1ZSBpbiB0aGUgY2VsbCByZXByZXNlbnRzIHRoZSBvcmlnaW5hbEluZGV4IG9mIHRoZSBmdXJ0aGVzdFxyXG4gICAgICAgIC8vIHJlYWNoaW5nIHBvaW50IGZvdW5kIHNvIGZhciB0aGF0IGVuZHMgaW4gdGhhdCBkaWFnb25hbC5cclxuICAgICAgICAvLyBUaGUgbW9kaWZpZWRJbmRleCBjYW4gYmUgY29tcHV0ZWQgbWF0aGVtYXRpY2FsbHkgZnJvbSB0aGUgb3JpZ2luYWxJbmRleCBhbmQgdGhlIGRpYWdvbmFsIG51bWJlci5cclxuICAgICAgICBjb25zdCBtYXhEaWZmZXJlbmNlcyA9IChvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQpICsgKG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgbnVtRGlhZ29uYWxzID0gbWF4RGlmZmVyZW5jZXMgKyAxO1xyXG4gICAgICAgIGNvbnN0IGZvcndhcmRQb2ludHMgPSBuZXcgSW50MzJBcnJheShudW1EaWFnb25hbHMpO1xyXG4gICAgICAgIGNvbnN0IHJldmVyc2VQb2ludHMgPSBuZXcgSW50MzJBcnJheShudW1EaWFnb25hbHMpO1xyXG4gICAgICAgIC8vIGRpYWdvbmFsRm9yd2FyZEJhc2U6IEluZGV4IGludG8gZm9yd2FyZFBvaW50cyBvZiB0aGUgZGlhZ29uYWwgd2hpY2ggcGFzc2VzIHRocm91Z2ggKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpXHJcbiAgICAgICAgLy8gZGlhZ29uYWxSZXZlcnNlQmFzZTogSW5kZXggaW50byByZXZlcnNlUG9pbnRzIG9mIHRoZSBkaWFnb25hbCB3aGljaCBwYXNzZXMgdGhyb3VnaCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsRm9yd2FyZEJhc2UgPSAobW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0KTtcclxuICAgICAgICBjb25zdCBkaWFnb25hbFJldmVyc2VCYXNlID0gKG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgLy8gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0OiBHZW9tZXRyaWMgb2Zmc2V0IHdoaWNoIGFsbG93cyBtb2RpZmllZEluZGV4IHRvIGJlIGNvbXB1dGVkIGZyb20gb3JpZ2luYWxJbmRleCBhbmQgdGhlXHJcbiAgICAgICAgLy8gICAgZGlhZ29uYWwgbnVtYmVyIChyZWxhdGl2ZSB0byBkaWFnb25hbEZvcndhcmRCYXNlKVxyXG4gICAgICAgIC8vIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDogR2VvbWV0cmljIG9mZnNldCB3aGljaCBhbGxvd3MgbW9kaWZpZWRJbmRleCB0byBiZSBjb21wdXRlZCBmcm9tIG9yaWdpbmFsSW5kZXggYW5kIHRoZVxyXG4gICAgICAgIC8vICAgIGRpYWdvbmFsIG51bWJlciAocmVsYXRpdmUgdG8gZGlhZ29uYWxSZXZlcnNlQmFzZSlcclxuICAgICAgICBjb25zdCBkaWFnb25hbEZvcndhcmRPZmZzZXQgPSAob3JpZ2luYWxTdGFydCAtIG1vZGlmaWVkU3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsUmV2ZXJzZU9mZnNldCA9IChvcmlnaW5hbEVuZCAtIG1vZGlmaWVkRW5kKTtcclxuICAgICAgICAvLyBkZWx0YTogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZW5kIGRpYWdvbmFsIGFuZCB0aGUgc3RhcnQgZGlhZ29uYWwuIFRoaXMgaXMgdXNlZCB0byByZWxhdGUgZGlhZ29uYWwgbnVtYmVyc1xyXG4gICAgICAgIC8vICAgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IGRpYWdvbmFsIHdpdGggZGlhZ29uYWwgbnVtYmVycyByZWxhdGl2ZSB0byB0aGUgZW5kIGRpYWdvbmFsLlxyXG4gICAgICAgIC8vIFRoZSBFdmVuL09kZG4tbmVzcyBvZiB0aGlzIGRlbHRhIGlzIGltcG9ydGFudCBmb3IgZGV0ZXJtaW5pbmcgd2hlbiB3ZSBzaG91bGQgY2hlY2sgZm9yIG92ZXJsYXBcclxuICAgICAgICBjb25zdCBkZWx0YSA9IGRpYWdvbmFsUmV2ZXJzZUJhc2UgLSBkaWFnb25hbEZvcndhcmRCYXNlO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhSXNFdmVuID0gKGRlbHRhICUgMiA9PT0gMCk7XHJcbiAgICAgICAgLy8gSGVyZSB3ZSBzZXQgdXAgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFzIHRoZSBmdXJ0aGVzdCBwb2ludHMgZm91bmQgc28gZmFyXHJcbiAgICAgICAgLy8gaW4gYm90aCB0aGUgZm9yd2FyZCBhbmQgcmV2ZXJzZSBkaXJlY3Rpb25zLCByZXNwZWN0aXZlbHlcclxuICAgICAgICBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsRm9yd2FyZEJhc2VdID0gb3JpZ2luYWxTdGFydDtcclxuICAgICAgICByZXZlcnNlUG9pbnRzW2RpYWdvbmFsUmV2ZXJzZUJhc2VdID0gb3JpZ2luYWxFbmQ7XHJcbiAgICAgICAgLy8gUmVtZW1iZXIgaWYgd2UgcXVpdCBlYXJseSwgYW5kIHRodXMgbmVlZCB0byBkbyBhIGJlc3QtZWZmb3J0IHJlc3VsdCBpbnN0ZWFkIG9mIGEgcmVhbCByZXN1bHQuXHJcbiAgICAgICAgcXVpdEVhcmx5QXJyWzBdID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQSBjb3VwbGUgb2YgcG9pbnRzOlxyXG4gICAgICAgIC8vIC0tV2l0aCB0aGlzIG1ldGhvZCwgd2UgaXRlcmF0ZSBvbiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBzZXF1ZW5jZXMuXHJcbiAgICAgICAgLy8gICBUaGUgbW9yZSBkaWZmZXJlbmNlcyB0aGVyZSBhY3R1YWxseSBhcmUsIHRoZSBsb25nZXIgdGhpcyB3aWxsIHRha2UuXHJcbiAgICAgICAgLy8gLS1BbHNvLCBhcyB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGluY3JlYXNlcywgd2UgaGF2ZSB0byBzZWFyY2ggb24gZGlhZ29uYWxzIGZ1cnRoZXJcclxuICAgICAgICAvLyAgIGF3YXkgZnJvbSB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsICh3aGljaCBpcyBkaWFnb25hbEZvcndhcmRCYXNlIGZvciBmb3J3YXJkLCBkaWFnb25hbFJldmVyc2VCYXNlIGZvciByZXZlcnNlKS5cclxuICAgICAgICAvLyAtLVdlIGV4dGVuZCBvbiBldmVuIGRpYWdvbmFscyAocmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZSBkaWFnb25hbCkgb25seSB3aGVuIG51bURpZmZlcmVuY2VzXHJcbiAgICAgICAgLy8gICBpcyBldmVuIGFuZCBvZGQgZGlhZ29uYWxzIG9ubHkgd2hlbiBudW1EaWZmZXJlbmNlcyBpcyBvZGQuXHJcbiAgICAgICAgZm9yIChsZXQgbnVtRGlmZmVyZW5jZXMgPSAxOyBudW1EaWZmZXJlbmNlcyA8PSAobWF4RGlmZmVyZW5jZXMgLyAyKSArIDE7IG51bURpZmZlcmVuY2VzKyspIHtcclxuICAgICAgICAgICAgbGV0IGZ1cnRoZXN0T3JpZ2luYWxJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFsZ29yaXRobSBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgZGlhZ29uYWxGb3J3YXJkU3RhcnQgPSB0aGlzLkNsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsRm9yd2FyZEJhc2UgLSBudW1EaWZmZXJlbmNlcywgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsRm9yd2FyZEJhc2UsIG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZEVuZCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSArIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGlhZ29uYWwgPSBkaWFnb25hbEZvcndhcmRTdGFydDsgZGlhZ29uYWwgPD0gZGlhZ29uYWxGb3J3YXJkRW5kOyBkaWFnb25hbCArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDE6IFdlIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgIC8vIGJ5IGxvb2tpbmcgYXQgdGhlIGRpYWdvbmFscyBhYm92ZSBhbmQgYmVsb3cgYW5kIHBpY2tpbmcgdGhlIG9uZSB3aG9zZSBwb2ludFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgZnVydGhlciBhd2F5IGZyb20gdGhlIHN0YXJ0IHBvaW50IChvcmlnaW5hbFN0YXJ0LCBtb2RpZmllZFN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbEZvcndhcmRTdGFydCB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbEZvcndhcmRFbmQgJiYgZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdIDwgZm9yd2FyZFBvaW50c1tkaWFnb25hbCArIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gKGRpYWdvbmFsIC0gZGlhZ29uYWxGb3J3YXJkQmFzZSkgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IG9yaWdpbmFsSW5kZXggc28gd2UgY2FuIHRlc3QgZm9yIGZhbHNlIG92ZXJsYXAgaW4gc3RlcCAzXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDI6IFdlIGNhbiBjb250aW51ZSB0byBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBsb25nIGFzIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA8IG9yaWdpbmFsRW5kICYmIG1vZGlmaWVkSW5kZXggPCBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsXSA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCArIG1vZGlmaWVkSW5kZXggPiBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggKyBmdXJ0aGVzdE1vZGlmaWVkSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1cnRoZXN0TW9kaWZpZWRJbmRleCA9IG1vZGlmaWVkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDM6IElmIGRlbHRhIGlzIG9kZCAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIGZvcndhcmQgd2hlbiBkZWx0YSBpcyBvZGQpXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgZGlhZ29uYWwgaXMgaW4gdGhlIHJhbmdlIG9mIHJldmVyc2UgZGlhZ29uYWxzIGNvbXB1dGVkIGZvciBudW1EaWZmZXJlbmNlcy0xXHJcbiAgICAgICAgICAgICAgICAvLyAodGhlIHByZXZpb3VzIGl0ZXJhdGlvbjsgd2UgaGF2ZW4ndCBjb21wdXRlZCByZXZlcnNlIGRpYWdvbmFscyBmb3IgbnVtRGlmZmVyZW5jZXMgeWV0KVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBjaGVjayBmb3Igb3ZlcmxhcC5cclxuICAgICAgICAgICAgICAgIGlmICghZGVsdGFJc0V2ZW4gJiYgTWF0aC5hYnMoZGlhZ29uYWwgLSBkaWFnb25hbFJldmVyc2VCYXNlKSA8PSAobnVtRGlmZmVyZW5jZXMgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBtb2RpZmllZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcE9yaWdpbmFsSW5kZXggPD0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0gJiYgMTQ0NyAvKiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgZmFsc2Ugb3ZlcmxhcCwgb3Igd2UgZGlkbid0IGhhdmUgZW5vdWdoIG1lbW9yeSBmb3IgdGhlIGZ1bGwgdHJhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYmUgcXVpdHRpbmcgZWFybHksIGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBjb25zdCBtYXRjaExlbmd0aE9mTG9uZ2VzdCA9ICgoZnVydGhlc3RPcmlnaW5hbEluZGV4IC0gb3JpZ2luYWxTdGFydCkgKyAoZnVydGhlc3RNb2RpZmllZEluZGV4IC0gbW9kaWZpZWRTdGFydCkgLSBudW1EaWZmZXJlbmNlcykgLyAyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgIT09IG51bGwgJiYgIXRoaXMuQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKGZ1cnRoZXN0T3JpZ2luYWxJbmRleCwgbWF0Y2hMZW5ndGhPZkxvbmdlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBmaW5pc2gsIHNvIHNraXAgYWhlYWQgdG8gZ2VuZXJhdGluZyBhIHJlc3VsdCBmcm9tIHdoYXQgd2UgaGF2ZS5cclxuICAgICAgICAgICAgICAgIHF1aXRFYXJseUFyclswXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGZ1cnRoZXN0IGRpc3RhbmNlIHdlIGdvdCBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IGZ1cnRoZXN0T3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gZnVydGhlc3RNb2RpZmllZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoTGVuZ3RoT2ZMb25nZXN0ID4gMCAmJiAxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyA+IDAgJiYgbnVtRGlmZmVyZW5jZXMgPD0gKDE0NDcgLyogTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFbm91Z2ggb2YgdGhlIGhpc3RvcnkgaXMgaW4gbWVtb3J5IHRvIHdhbGsgaXQgYmFja3dhcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkaWRuJ3QgYWN0dWFsbHkgcmVtZW1iZXIgZW5vdWdoIG9mIHRoZSBoaXN0b3J5LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vU2luY2Ugd2UgYXJlIHF1aXRpbmcgdGhlIGRpZmYgZWFybHksIHdlIG5lZWQgdG8gc2hpZnQgYmFjayB0aGUgb3JpZ2luYWxTdGFydCBhbmQgbW9kaWZpZWQgc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAvL2JhY2sgaW50byB0aGUgYm91bmRhcnkgbGltaXRzIHNpbmNlIHdlIGRlY3JlbWVudGVkIHRoZWlyIHZhbHVlIGFib3ZlIGJleW9uZCB0aGUgYm91bmRhcnkgbGltaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnQrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQgKyAxLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbGdvcml0aG0gaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gdGhpcy5DbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbFJldmVyc2VCYXNlIC0gbnVtRGlmZmVyZW5jZXMsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbFJldmVyc2VCYXNlLCBudW1EaWFnb25hbHMpO1xyXG4gICAgICAgICAgICBkaWFnb25hbFJldmVyc2VFbmQgPSB0aGlzLkNsaXBEaWFnb25hbEJvdW5kKGRpYWdvbmFsUmV2ZXJzZUJhc2UgKyBudW1EaWZmZXJlbmNlcywgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIG51bURpYWdvbmFscyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRpYWdvbmFsID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7IGRpYWdvbmFsIDw9IGRpYWdvbmFsUmV2ZXJzZUVuZDsgZGlhZ29uYWwgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgLy8gU1RFUCAxOiBXZSBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICAvLyBieSBsb29raW5nIGF0IHRoZSBkaWFnb25hbHMgYWJvdmUgYW5kIGJlbG93IGFuZCBwaWNraW5nIHRoZSBvbmUgd2hvc2UgcG9pbnRcclxuICAgICAgICAgICAgICAgIC8vIGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBzdGFydCBwb2ludCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxyXG4gICAgICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbFJldmVyc2VTdGFydCB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbFJldmVyc2VFbmQgJiYgcmV2ZXJzZVBvaW50c1tkaWFnb25hbCAtIDFdID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbCArIDFdIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIChkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIC0gZGlhZ29uYWxSZXZlcnNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBvcmlnaW5hbEluZGV4IHNvIHdlIGNhbiB0ZXN0IGZvciBmYWxzZSBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAvLyBTVEVQIDI6IFdlIGNhbiBjb250aW51ZSB0byBleHRlbmQgdGhlIGZ1cnRoZXN0IHJlYWNoaW5nIHBvaW50IGluIHRoZSBwcmVzZW50IGRpYWdvbmFsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyBsb25nIGFzIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA+IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRJbmRleCA+IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldmVyc2VQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIFNURVAgNDogSWYgZGVsdGEgaXMgZXZlbiAob3ZlcmxhcCBmaXJzdCBoYXBwZW5zIG9uIHJldmVyc2Ugd2hlbiBkZWx0YSBpcyBldmVuKVxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpYWdvbmFsIGlzIGluIHRoZSByYW5nZSBvZiBmb3J3YXJkIGRpYWdvbmFscyBjb21wdXRlZCBmb3IgbnVtRGlmZmVyZW5jZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgZm9yIG92ZXJsYXAuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsdGFJc0V2ZW4gJiYgTWF0aC5hYnMoZGlhZ29uYWwgLSBkaWFnb25hbEZvcndhcmRCYXNlKSA8PSBudW1EaWZmZXJlbmNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDw9IGZvcndhcmRQb2ludHNbZGlhZ29uYWxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZE9yaWdpbmFsQXJyWzBdID0gb3JpZ2luYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkTW9kaWZpZWRBcnJbMF0gPSBtb2RpZmllZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcE9yaWdpbmFsSW5kZXggPj0gZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gJiYgMTQ0NyAvKiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIE1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCSU5HTyEgV2Ugb3ZlcmxhcHBlZCwgYW5kIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gbWVtb3J5IVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgZmFsc2Ugb3ZlcmxhcCwgb3Igd2UgZGlkbid0IGhhdmUgZW5vdWdoIG1lbW9yeSBmb3IgdGhlIGZ1bGwgdHJhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNhdmUgY3VycmVudCB2ZWN0b3JzIHRvIGhpc3RvcnkgYmVmb3JlIHRoZSBuZXh0IGl0ZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAobnVtRGlmZmVyZW5jZXMgPD0gMTQ0NyAvKiBNYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBhbGxvY2F0aW5nIHNwYWNlIGZvciBvbmUgZXh0cmEgaW50LCB3aGljaCB3ZSBmaWxsIHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgYmFzZSBpbmRleFxyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDIpO1xyXG4gICAgICAgICAgICAgICAgdGVtcFswXSA9IGRpYWdvbmFsRm9yd2FyZEJhc2UgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDE7XHJcbiAgICAgICAgICAgICAgICBNeUFycmF5LkNvcHkyKGZvcndhcmRQb2ludHMsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCB0ZW1wLCAxLCBkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tX2ZvcndhcmRIaXN0b3J5LnB1c2godGVtcCk7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gbmV3IEludDMyQXJyYXkoZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAyKTtcclxuICAgICAgICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbFJldmVyc2VCYXNlIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxO1xyXG4gICAgICAgICAgICAgICAgTXlBcnJheS5Db3B5MihyZXZlcnNlUG9pbnRzLCBkaWFnb25hbFJldmVyc2VTdGFydCwgdGVtcCwgMSwgZGlhZ29uYWxSZXZlcnNlRW5kIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubV9yZXZlcnNlSGlzdG9yeS5wdXNoKHRlbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHdlIGhhdmUgdGhlIGZ1bGwgdHJhY2UgaW4gaGlzdG9yeS4gV2UganVzdCBoYXZlIHRvIGNvbnZlcnQgaXQgdG8gYSBjaGFuZ2UgbGlzdFxyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgcGFydCBpcyBhIGJpdCBtZXNzeVxyXG4gICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGlmdHMgdGhlIGdpdmVuIGNoYW5nZXMgdG8gcHJvdmlkZSBhIG1vcmUgaW50dWl0aXZlIGRpZmYuXHJcbiAgICAgKiBXaGlsZSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIGRpZmYgbWF0Y2hlcyB0aGUgZmlyc3QgZWxlbWVudCBhZnRlciB0aGUgZGlmZixcclxuICAgICAqIHdlIHNoaWZ0IHRoZSBkaWZmIGRvd24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgVGhlIGxpc3Qgb2YgY2hhbmdlcyB0byBzaGlmdFxyXG4gICAgICogQHJldHVybnMgVGhlIHNoaWZ0ZWQgY2hhbmdlc1xyXG4gICAgICovXHJcbiAgICBQcmV0dGlmeUNoYW5nZXMoY2hhbmdlcykge1xyXG4gICAgICAgIC8vIFNoaWZ0IGFsbCB0aGUgY2hhbmdlcyBkb3duIGZpcnN0XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IChpIDwgY2hhbmdlcy5sZW5ndGggLSAxKSA/IGNoYW5nZXNbaSArIDFdLm9yaWdpbmFsU3RhcnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdG9wID0gKGkgPCBjaGFuZ2VzLmxlbmd0aCAtIDEpID8gY2hhbmdlc1tpICsgMV0ubW9kaWZpZWRTdGFydCA6IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBjaGVja09yaWdpbmFsID0gY2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCA8IG9yaWdpbmFsU3RvcFxyXG4gICAgICAgICAgICAgICAgJiYgY2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGggPCBtb2RpZmllZFN0b3BcclxuICAgICAgICAgICAgICAgICYmICghY2hlY2tPcmlnaW5hbCB8fCB0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpKVxyXG4gICAgICAgICAgICAgICAgJiYgKCFjaGVja01vZGlmaWVkIHx8IHRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFN0cmljdEVxdWFsID0gdGhpcy5FbGVtZW50c0FyZVN0cmljdEVxdWFsKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRTdHJpY3RFcXVhbCA9IHRoaXMuRWxlbWVudHNBcmVTdHJpY3RFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZFN0cmljdEVxdWFsICYmICFzdGFydFN0cmljdEVxdWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92aW5nIHRoZSBjaGFuZ2UgZG93biB3b3VsZCBjcmVhdGUgYW4gZXF1YWwgY2hhbmdlLCBidXQgdGhlIGVsZW1lbnRzIGFyZSBub3Qgc3RyaWN0IGVxdWFsXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2Uub3JpZ2luYWxTdGFydCsrO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbWVyZ2VkQ2hhbmdlQXJyID0gW251bGxdO1xyXG4gICAgICAgICAgICBpZiAoaSA8IGNoYW5nZXMubGVuZ3RoIC0gMSAmJiB0aGlzLkNoYW5nZXNPdmVybGFwKGNoYW5nZXNbaV0sIGNoYW5nZXNbaSArIDFdLCBtZXJnZWRDaGFuZ2VBcnIpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0gbWVyZ2VkQ2hhbmdlQXJyWzBdO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5zcGxpY2UoaSArIDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2hpZnQgY2hhbmdlcyBiYWNrIHVwIHVudGlsIHdlIGhpdCBlbXB0eSBvciB3aGl0ZXNwYWNlLW9ubHkgbGluZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xyXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdG9wID0gMDtcclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RvcCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoYW5nZSA9IGNoYW5nZXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTdG9wID0gcHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aDtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RvcCA9IHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydCArIHByZXZDaGFuZ2UubW9kaWZpZWRMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2hlY2tPcmlnaW5hbCA9IGNoYW5nZS5vcmlnaW5hbExlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrTW9kaWZpZWQgPSBjaGFuZ2UubW9kaWZpZWRMZW5ndGggPiAwO1xyXG4gICAgICAgICAgICBsZXQgYmVzdERlbHRhID0gMDtcclxuICAgICAgICAgICAgbGV0IGJlc3RTY29yZSA9IHRoaXMuX2JvdW5kYXJ5U2NvcmUoY2hhbmdlLm9yaWdpbmFsU3RhcnQsIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZExlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRlbHRhID0gMTs7IGRlbHRhKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnQgPSBjaGFuZ2Uub3JpZ2luYWxTdGFydCAtIGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydCA9IGNoYW5nZS5tb2RpZmllZFN0YXJ0IC0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxTdGFydCA8IG9yaWdpbmFsU3RvcCB8fCBtb2RpZmllZFN0YXJ0IDwgbW9kaWZpZWRTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tPcmlnaW5hbCAmJiAhdGhpcy5PcmlnaW5hbEVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVkICYmICF0aGlzLk1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbChtb2RpZmllZFN0YXJ0LCBtb2RpZmllZFN0YXJ0ICsgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hpbmdQcmV2aW91c0NoYW5nZSA9IChvcmlnaW5hbFN0YXJ0ID09PSBvcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRTdGFydCA9PT0gbW9kaWZpZWRTdG9wKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gKCh0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID8gNSA6IDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLl9ib3VuZGFyeVNjb3JlKG9yaWdpbmFsU3RhcnQsIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0RGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFuZ2Uub3JpZ2luYWxTdGFydCAtPSBiZXN0RGVsdGE7XHJcbiAgICAgICAgICAgIGNoYW5nZS5tb2RpZmllZFN0YXJ0IC09IGJlc3REZWx0YTtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2hhbmdlQXJyID0gW251bGxdO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgdGhpcy5DaGFuZ2VzT3ZlcmxhcChjaGFuZ2VzW2kgLSAxXSwgY2hhbmdlc1tpXSwgbWVyZ2VkQ2hhbmdlQXJyKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlc1tpIC0gMV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGxvbmdlc3QgY29tbW9uIHN1YnN0cmluZ3MuXHJcbiAgICAgICAgLy8gR2l2ZSBwcmVmZXJlbmNlIHRvIHRoZSBvbmVzIGNvbnRhaW5pbmcgbG9uZ2VyIGxpbmVzXHJcbiAgICAgICAgaWYgKHRoaXMuX2hhc1N0cmluZ3MpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGNoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFDaGFuZ2UgPSBjaGFuZ2VzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJDaGFuZ2UgPSBjaGFuZ2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZExlbmd0aCA9IGJDaGFuZ2Uub3JpZ2luYWxTdGFydCAtIGFDaGFuZ2Uub3JpZ2luYWxTdGFydCAtIGFDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhT3JpZ2luYWxTdGFydCA9IGFDaGFuZ2Uub3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJPcmlnaW5hbEVuZCA9IGJDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGJDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhYk9yaWdpbmFsTGVuZ3RoID0gYk9yaWdpbmFsRW5kIC0gYU9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhTW9kaWZpZWRTdGFydCA9IGFDaGFuZ2UubW9kaWZpZWRTdGFydDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJNb2RpZmllZEVuZCA9IGJDaGFuZ2UubW9kaWZpZWRTdGFydCArIGJDaGFuZ2UubW9kaWZpZWRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhYk1vZGlmaWVkTGVuZ3RoID0gYk1vZGlmaWVkRW5kIC0gYU1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCB3YXN0aW5nIGEgbG90IG9mIHRpbWUgd2l0aCB0aGVzZSBzZWFyY2hlc1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRMZW5ndGggPCA1ICYmIGFiT3JpZ2luYWxMZW5ndGggPCAyMCAmJiBhYk1vZGlmaWVkTGVuZ3RoIDwgMjApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5fZmluZEJldHRlckNvbnRpZ3VvdXNTZXF1ZW5jZShhT3JpZ2luYWxTdGFydCwgYWJPcmlnaW5hbExlbmd0aCwgYU1vZGlmaWVkU3RhcnQsIGFiTW9kaWZpZWRMZW5ndGgsIG1hdGNoZWRMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvcmlnaW5hbE1hdGNoU3RhcnQsIG1vZGlmaWVkTWF0Y2hTdGFydF0gPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxNYXRjaFN0YXJ0ICE9PSBhQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBhQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIHx8IG1vZGlmaWVkTWF0Y2hTdGFydCAhPT0gYUNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgYUNoYW5nZS5tb2RpZmllZExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIGFub3RoZXIgc2VxdWVuY2UgdGhhdCBoYXMgYSBiZXR0ZXIgc2NvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSBvcmlnaW5hbE1hdGNoU3RhcnQgLSBhQ2hhbmdlLm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID0gbW9kaWZpZWRNYXRjaFN0YXJ0IC0gYUNoYW5nZS5tb2RpZmllZFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5vcmlnaW5hbFN0YXJ0ID0gb3JpZ2luYWxNYXRjaFN0YXJ0ICsgbWF0Y2hlZExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJDaGFuZ2UubW9kaWZpZWRTdGFydCA9IG1vZGlmaWVkTWF0Y2hTdGFydCArIG1hdGNoZWRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID0gYk9yaWdpbmFsRW5kIC0gYkNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IGJNb2RpZmllZEVuZCAtIGJDaGFuZ2UubW9kaWZpZWRTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgIH1cclxuICAgIF9maW5kQmV0dGVyQ29udGlndW91c1NlcXVlbmNlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCwgZGVzaXJlZExlbmd0aCkge1xyXG4gICAgICAgIGlmIChvcmlnaW5hbExlbmd0aCA8IGRlc2lyZWRMZW5ndGggfHwgbW9kaWZpZWRMZW5ndGggPCBkZXNpcmVkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcmlnaW5hbE1heCA9IG9yaWdpbmFsU3RhcnQgKyBvcmlnaW5hbExlbmd0aCAtIGRlc2lyZWRMZW5ndGggKyAxO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTWF4ID0gbW9kaWZpZWRTdGFydCArIG1vZGlmaWVkTGVuZ3RoIC0gZGVzaXJlZExlbmd0aCArIDE7XHJcbiAgICAgICAgbGV0IGJlc3RTY29yZSA9IDA7XHJcbiAgICAgICAgbGV0IGJlc3RPcmlnaW5hbFN0YXJ0ID0gMDtcclxuICAgICAgICBsZXQgYmVzdE1vZGlmaWVkU3RhcnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBvcmlnaW5hbFN0YXJ0OyBpIDwgb3JpZ2luYWxNYXg7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbW9kaWZpZWRTdGFydDsgaiA8IG1vZGlmaWVkTWF4OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gdGhpcy5fY29udGlndW91c1NlcXVlbmNlU2NvcmUoaSwgaiwgZGVzaXJlZExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiAwICYmIHNjb3JlID4gYmVzdFNjb3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdE9yaWdpbmFsU3RhcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb2RpZmllZFN0YXJ0ID0gajtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdFNjb3JlID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW2Jlc3RPcmlnaW5hbFN0YXJ0LCBiZXN0TW9kaWZpZWRTdGFydF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgX2NvbnRpZ3VvdXNTZXF1ZW5jZVNjb3JlKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQsIGxlbmd0aCkge1xyXG4gICAgICAgIGxldCBzY29yZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBsZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0ICsgbCwgbW9kaWZpZWRTdGFydCArIGwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzY29yZSArPSB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW29yaWdpbmFsU3RhcnQgKyBsXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY29yZTtcclxuICAgIH1cclxuICAgIF9PcmlnaW5hbElzQm91bmRhcnkoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPD0gMCB8fCBpbmRleCA+PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyAmJiAvXlxccyokLy50ZXN0KHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbaW5kZXhdKSk7XHJcbiAgICB9XHJcbiAgICBfT3JpZ2luYWxSZWdpb25Jc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX09yaWdpbmFsSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0KSB8fCB0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxTdGFydCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3JpZ2luYWxMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRW5kID0gb3JpZ2luYWxTdGFydCArIG9yaWdpbmFsTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kIC0gMSkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX01vZGlmaWVkSXNCb3VuZGFyeShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8PSAwIHx8IGluZGV4ID49IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2gubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzICYmIC9eXFxzKiQvLnRlc3QodGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleF0pKTtcclxuICAgIH1cclxuICAgIF9Nb2RpZmllZFJlZ2lvbklzQm91bmRhcnkobW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fTW9kaWZpZWRJc0JvdW5kYXJ5KG1vZGlmaWVkU3RhcnQpIHx8IHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0IC0gMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RpZmllZExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRFbmQgPSBtb2RpZmllZFN0YXJ0ICsgbW9kaWZpZWRMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQgLSAxKSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFNjb3JlID0gKHRoaXMuX09yaWdpbmFsUmVnaW9uSXNCb3VuZGFyeShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCkgPyAxIDogMCk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRTY29yZSA9ICh0aGlzLl9Nb2RpZmllZFJlZ2lvbklzQm91bmRhcnkobW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpID8gMSA6IDApO1xyXG4gICAgICAgIHJldHVybiAob3JpZ2luYWxTY29yZSArIG1vZGlmaWVkU2NvcmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25jYXRlbmF0ZXMgdGhlIHR3byBpbnB1dCBEaWZmQ2hhbmdlIGxpc3RzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmdcclxuICAgICAqIGxpc3QuXHJcbiAgICAgKiBAcGFyYW0gVGhlIGxlZnQgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIFRoZSByaWdodCBjaGFuZ2VzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIGxpc3RcclxuICAgICAqL1xyXG4gICAgQ29uY2F0ZW5hdGVDaGFuZ2VzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgbGV0IG1lcmdlZENoYW5nZUFyciA9IFtdO1xyXG4gICAgICAgIGlmIChsZWZ0Lmxlbmd0aCA9PT0gMCB8fCByaWdodC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIChyaWdodC5sZW5ndGggPiAwKSA/IHJpZ2h0IDogbGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5DaGFuZ2VzT3ZlcmxhcChsZWZ0W2xlZnQubGVuZ3RoIC0gMV0sIHJpZ2h0WzBdLCBtZXJnZWRDaGFuZ2VBcnIpKSB7XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGJyZWFrIHRoZSBwcm9ibGVtIGRvd24gcmVjdXJzaXZlbHksIGl0IGlzIHBvc3NpYmxlIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gbWlnaHQgcmVjdXJzZSBpbiB0aGUgbWlkZGxlIG9mIGEgY2hhbmdlIHRoZXJlYnkgc3BsaXR0aW5nIGl0IGludG9cclxuICAgICAgICAgICAgLy8gdHdvIGNoYW5nZXMuIEhlcmUgaW4gdGhlIGNvbWJpbmluZyBzdGFnZSwgd2UgZGV0ZWN0IGFuZCBmdXNlIHRob3NlXHJcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgYmFjayB0b2dldGhlclxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgTXlBcnJheS5Db3B5KGxlZnQsIDAsIHJlc3VsdCwgMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgcmVzdWx0W2xlZnQubGVuZ3RoIC0gMV0gPSBtZXJnZWRDaGFuZ2VBcnJbMF07XHJcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMSwgcmVzdWx0LCBsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBNeUFycmF5LkNvcHkobGVmdCwgMCwgcmVzdWx0LCAwLCBsZWZ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMCwgcmVzdWx0LCBsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGNoYW5nZXMgb3ZlcmxhcCBhbmQgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlXHJcbiAgICAgKiBjaGFuZ2VcclxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IGNoYW5nZVxyXG4gICAgICogQHBhcmFtIHJpZ2h0IFRoZSByaWdodCBjaGFuZ2VcclxuICAgICAqIEBwYXJhbSBtZXJnZWRDaGFuZ2UgVGhlIG1lcmdlZCBjaGFuZ2UgaWYgdGhlIHR3byBvdmVybGFwLCBudWxsIG90aGVyd2lzZVxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHdvIGNoYW5nZXMgb3ZlcmxhcFxyXG4gICAgICovXHJcbiAgICBDaGFuZ2VzT3ZlcmxhcChsZWZ0LCByaWdodCwgbWVyZ2VkQ2hhbmdlQXJyKSB7XHJcbiAgICAgICAgRGVidWcuQXNzZXJ0KGxlZnQub3JpZ2luYWxTdGFydCA8PSByaWdodC5vcmlnaW5hbFN0YXJ0LCAnTGVmdCBjaGFuZ2UgaXMgbm90IGxlc3MgdGhhbiBvciBlcXVhbCB0byByaWdodCBjaGFuZ2UnKTtcclxuICAgICAgICBEZWJ1Zy5Bc3NlcnQobGVmdC5tb2RpZmllZFN0YXJ0IDw9IHJpZ2h0Lm1vZGlmaWVkU3RhcnQsICdMZWZ0IGNoYW5nZSBpcyBub3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHJpZ2h0IGNoYW5nZScpO1xyXG4gICAgICAgIGlmIChsZWZ0Lm9yaWdpbmFsU3RhcnQgKyBsZWZ0Lm9yaWdpbmFsTGVuZ3RoID49IHJpZ2h0Lm9yaWdpbmFsU3RhcnQgfHwgbGVmdC5tb2RpZmllZFN0YXJ0ICsgbGVmdC5tb2RpZmllZExlbmd0aCA+PSByaWdodC5tb2RpZmllZFN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnQgPSBsZWZ0Lm9yaWdpbmFsU3RhcnQ7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbExlbmd0aCA9IGxlZnQub3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnQgPSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllZExlbmd0aCA9IGxlZnQubW9kaWZpZWRMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Lm9yaWdpbmFsU3RhcnQgKyBsZWZ0Lm9yaWdpbmFsTGVuZ3RoID49IHJpZ2h0Lm9yaWdpbmFsU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGVuZ3RoID0gcmlnaHQub3JpZ2luYWxTdGFydCArIHJpZ2h0Lm9yaWdpbmFsTGVuZ3RoIC0gbGVmdC5vcmlnaW5hbFN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Lm1vZGlmaWVkU3RhcnQgKyBsZWZ0Lm1vZGlmaWVkTGVuZ3RoID49IHJpZ2h0Lm1vZGlmaWVkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVuZ3RoID0gcmlnaHQubW9kaWZpZWRTdGFydCArIHJpZ2h0Lm1vZGlmaWVkTGVuZ3RoIC0gbGVmdC5tb2RpZmllZFN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lcmdlZENoYW5nZUFyclswXSA9IG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIG1ldGhvZCB1c2VkIHRvIGNsaXAgYSBkaWFnb25hbCBpbmRleCB0byB0aGUgcmFuZ2Ugb2YgdmFsaWRcclxuICAgICAqIGRpYWdvbmFscy4gVGhpcyBhbHNvIGRlY2lkZXMgd2hldGhlciBvciBub3QgdGhlIGRpYWdvbmFsIGluZGV4LFxyXG4gICAgICogaWYgaXQgZXhjZWVkcyB0aGUgYm91bmRhcnksIHNob3VsZCBiZSBjbGlwcGVkIHRvIHRoZSBib3VuZGFyeSBvciBjbGlwcGVkXHJcbiAgICAgKiBvbmUgaW5zaWRlIHRoZSBib3VuZGFyeSBkZXBlbmRpbmcgb24gdGhlIEV2ZW4vT2RkIHN0YXR1cyBvZiB0aGUgYm91bmRhcnlcclxuICAgICAqIGFuZCBudW1EaWZmZXJlbmNlcy5cclxuICAgICAqIEBwYXJhbSBkaWFnb25hbCBUaGUgaW5kZXggb2YgdGhlIGRpYWdvbmFsIHRvIGNsaXAuXHJcbiAgICAgKiBAcGFyYW0gbnVtRGlmZmVyZW5jZXMgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGJlaW5nIGl0ZXJhdGVkIHVwb24uXHJcbiAgICAgKiBAcGFyYW0gZGlhZ29uYWxCYXNlSW5kZXggVGhlIGJhc2UgcmVmZXJlbmNlIGRpYWdvbmFsLlxyXG4gICAgICogQHBhcmFtIG51bURpYWdvbmFscyBUaGUgdG90YWwgbnVtYmVyIG9mIGRpYWdvbmFscy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjbGlwcGVkIGRpYWdvbmFsIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBDbGlwRGlhZ29uYWxCb3VuZChkaWFnb25hbCwgbnVtRGlmZmVyZW5jZXMsIGRpYWdvbmFsQmFzZUluZGV4LCBudW1EaWFnb25hbHMpIHtcclxuICAgICAgICBpZiAoZGlhZ29uYWwgPj0gMCAmJiBkaWFnb25hbCA8IG51bURpYWdvbmFscykge1xyXG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGNsaXAsIGl0cyBpbiByYW5nZVxyXG4gICAgICAgICAgICByZXR1cm4gZGlhZ29uYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRpYWdvbmFsc0JlbG93OiBUaGUgbnVtYmVyIG9mIGRpYWdvbmFscyBiZWxvdyB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsXHJcbiAgICAgICAgLy8gZGlhZ29uYWxzQWJvdmU6IFRoZSBudW1iZXIgb2YgZGlhZ29uYWxzIGFib3ZlIHRoZSByZWZlcmVuY2UgZGlhZ29uYWxcclxuICAgICAgICBjb25zdCBkaWFnb25hbHNCZWxvdyA9IGRpYWdvbmFsQmFzZUluZGV4O1xyXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsc0Fib3ZlID0gbnVtRGlhZ29uYWxzIC0gZGlhZ29uYWxCYXNlSW5kZXggLSAxO1xyXG4gICAgICAgIGNvbnN0IGRpZmZFdmVuID0gKG51bURpZmZlcmVuY2VzICUgMiA9PT0gMCk7XHJcbiAgICAgICAgaWYgKGRpYWdvbmFsIDwgMCkge1xyXG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kRXZlbiA9IChkaWFnb25hbHNCZWxvdyAlIDIgPT09IDApO1xyXG4gICAgICAgICAgICByZXR1cm4gKGRpZmZFdmVuID09PSBsb3dlckJvdW5kRXZlbikgPyAwIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyQm91bmRFdmVuID0gKGRpYWdvbmFsc0Fib3ZlICUgMiA9PT0gMCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGlmZkV2ZW4gPT09IHVwcGVyQm91bmRFdmVuKSA/IG51bURpYWdvbmFscyAtIDEgOiBudW1EaWFnb25hbHMgLSAyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgaXNXaW5kb3dzLCBpc01hY2ludG9zaCwgc2V0SW1tZWRpYXRlLCBnbG9iYWxzIH0gZnJvbSAnLi9wbGF0Zm9ybS5qcyc7XHJcbmxldCBzYWZlUHJvY2VzcztcclxuLy8gTmF0aXZlIHNhbmRib3ggZW52aXJvbm1lbnRcclxuaWYgKHR5cGVvZiBnbG9iYWxzLnZzY29kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbHMudnNjb2RlLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zdCBzYW5kYm94UHJvY2VzcyA9IGdsb2JhbHMudnNjb2RlLnByb2Nlc3M7XHJcbiAgICBzYWZlUHJvY2VzcyA9IHtcclxuICAgICAgICBnZXQgcGxhdGZvcm0oKSB7IHJldHVybiBzYW5kYm94UHJvY2Vzcy5wbGF0Zm9ybTsgfSxcclxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MuZW52OyB9LFxyXG4gICAgICAgIGN3ZCgpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLmN3ZCgpOyB9LFxyXG4gICAgICAgIG5leHRUaWNrKGNhbGxiYWNrKSB7IHJldHVybiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spOyB9XHJcbiAgICB9O1xyXG59XHJcbi8vIE5hdGl2ZSBub2RlLmpzIGVudmlyb25tZW50XHJcbmVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgc2FmZVByb2Nlc3MgPSB7XHJcbiAgICAgICAgZ2V0IHBsYXRmb3JtKCkgeyByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybTsgfSxcclxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4gcHJvY2Vzcy5lbnY7IH0sXHJcbiAgICAgICAgY3dkKCkgeyByZXR1cm4gcHJvY2Vzcy5lbnZbJ1ZTQ09ERV9DV0QnXSB8fCBwcm9jZXNzLmN3ZCgpOyB9LFxyXG4gICAgICAgIG5leHRUaWNrKGNhbGxiYWNrKSB7IHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTsgfVxyXG4gICAgfTtcclxufVxyXG4vLyBXZWIgZW52aXJvbm1lbnRcclxuZWxzZSB7XHJcbiAgICBzYWZlUHJvY2VzcyA9IHtcclxuICAgICAgICAvLyBTdXBwb3J0ZWRcclxuICAgICAgICBnZXQgcGxhdGZvcm0oKSB7IHJldHVybiBpc1dpbmRvd3MgPyAnd2luMzInIDogaXNNYWNpbnRvc2ggPyAnZGFyd2luJyA6ICdsaW51eCc7IH0sXHJcbiAgICAgICAgbmV4dFRpY2soY2FsbGJhY2spIHsgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7IH0sXHJcbiAgICAgICAgLy8gVW5zdXBwb3J0ZWRcclxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4ge307IH0sXHJcbiAgICAgICAgY3dkKCkgeyByZXR1cm4gJy8nOyB9XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzYWZlIGFjY2VzcyB0byB0aGUgYGN3ZGAgcHJvcGVydHkgaW4gbm9kZS5qcywgc2FuZGJveGVkIG9yIHdlYlxyXG4gKiBlbnZpcm9ubWVudHMuXHJcbiAqXHJcbiAqIE5vdGU6IGluIHdlYiwgdGhpcyBwcm9wZXJ0eSBpcyBoYXJkY29kZWQgdG8gYmUgYC9gLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGN3ZCA9IHNhZmVQcm9jZXNzLmN3ZDtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgZW52YCBwcm9wZXJ0eSBpbiBub2RlLmpzLCBzYW5kYm94ZWQgb3Igd2ViXHJcbiAqIGVudmlyb25tZW50cy5cclxuICpcclxuICogTm90ZTogaW4gd2ViLCB0aGlzIHByb3BlcnR5IGlzIGhhcmRjb2RlZCB0byBiZSBge31gLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudiA9IHNhZmVQcm9jZXNzLmVudjtcclxuLyoqXHJcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgcGxhdGZvcm1gIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcclxuICogZW52aXJvbm1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBsYXRmb3JtID0gc2FmZVByb2Nlc3MucGxhdGZvcm07XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBOT1RFOiBWU0NvZGUncyBjb3B5IG9mIG5vZGVqcyBwYXRoIGxpYnJhcnkgdG8gYmUgdXNhYmxlIGluIGNvbW1vbiAobm9uLW5vZGUpIG5hbWVzcGFjZVxyXG4vLyBDb3BpZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEyLjguMS9saWIvcGF0aC5qc1xyXG4vKipcclxuICogQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXHJcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxyXG4gKiBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcclxuICogZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXHJcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXHJcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxyXG4gKiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcclxuICogREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXHJcbiAqIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcclxuICogVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcbmltcG9ydCAqIGFzIHByb2Nlc3MgZnJvbSAnLi9wcm9jZXNzLmpzJztcclxuY29uc3QgQ0hBUl9VUFBFUkNBU0VfQSA9IDY1OyAvKiBBICovXHJcbmNvbnN0IENIQVJfTE9XRVJDQVNFX0EgPSA5NzsgLyogYSAqL1xyXG5jb25zdCBDSEFSX1VQUEVSQ0FTRV9aID0gOTA7IC8qIFogKi9cclxuY29uc3QgQ0hBUl9MT1dFUkNBU0VfWiA9IDEyMjsgLyogeiAqL1xyXG5jb25zdCBDSEFSX0RPVCA9IDQ2OyAvKiAuICovXHJcbmNvbnN0IENIQVJfRk9SV0FSRF9TTEFTSCA9IDQ3OyAvKiAvICovXHJcbmNvbnN0IENIQVJfQkFDS1dBUkRfU0xBU0ggPSA5MjsgLyogXFwgKi9cclxuY29uc3QgQ0hBUl9DT0xPTiA9IDU4OyAvKiA6ICovXHJcbmNvbnN0IENIQVJfUVVFU1RJT05fTUFSSyA9IDYzOyAvKiA/ICovXHJcbmNsYXNzIEVycm9ySW52YWxpZEFyZ1R5cGUgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcclxuICAgICAgICBsZXQgZGV0ZXJtaW5lcjtcclxuICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBleHBlY3RlZC5pbmRleE9mKCdub3QgJykgPT09IDApIHtcclxuICAgICAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XHJcbiAgICAgICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0eXBlID0gbmFtZS5pbmRleE9mKCcuJykgIT09IC0xID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XHJcbiAgICAgICAgbGV0IG1zZyA9IGBUaGUgXCIke25hbWV9XCIgJHt0eXBlfSAke2RldGVybWluZXJ9IG9mIHR5cGUgJHtleHBlY3RlZH1gO1xyXG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gO1xyXG4gICAgICAgIHN1cGVyKG1zZyk7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9JTlZBTElEX0FSR19UWVBFJztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgbmFtZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbnZhbGlkQXJnVHlwZShuYW1lLCAnc3RyaW5nJywgdmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUGF0aFNlcGFyYXRvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIIHx8IGNvZGUgPT09IENIQVJfQkFDS1dBUkRfU0xBU0g7XHJcbn1cclxuZnVuY3Rpb24gaXNQb3NpeFBhdGhTZXBhcmF0b3IoY29kZSkge1xyXG4gICAgcmV0dXJuIGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxufVxyXG5mdW5jdGlvbiBpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpIHtcclxuICAgIHJldHVybiBjb2RlID49IENIQVJfVVBQRVJDQVNFX0EgJiYgY29kZSA8PSBDSEFSX1VQUEVSQ0FTRV9aIHx8XHJcbiAgICAgICAgY29kZSA+PSBDSEFSX0xPV0VSQ0FTRV9BICYmIGNvZGUgPD0gQ0hBUl9MT1dFUkNBU0VfWjtcclxufVxyXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcclxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHBhdGgsIGFsbG93QWJvdmVSb290LCBzZXBhcmF0b3IsIGlzUGF0aFNlcGFyYXRvcikge1xyXG4gICAgbGV0IHJlcyA9ICcnO1xyXG4gICAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcclxuICAgIGxldCBsYXN0U2xhc2ggPSAtMTtcclxuICAgIGxldCBkb3RzID0gMDtcclxuICAgIGxldCBjb2RlID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvZGUgPSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTk9PUFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvdHMgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gQ0hBUl9ET1QgfHxcclxuICAgICAgICAgICAgICAgICAgICByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSByZXMubGVuZ3RoID4gMCA/IGAke3NlcGFyYXRvcn0uLmAgOiAnLi4nO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xyXG4gICAgICAgICAgICBkb3RzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gQ0hBUl9ET1QgJiYgZG90cyAhPT0gLTEpIHtcclxuICAgICAgICAgICAgKytkb3RzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG90cyA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcclxuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvckludmFsaWRBcmdUeXBlKCdwYXRoT2JqZWN0JywgJ09iamVjdCcsIHBhdGhPYmplY3QpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xyXG4gICAgY29uc3QgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fFxyXG4gICAgICAgIGAke3BhdGhPYmplY3QubmFtZSB8fCAnJ30ke3BhdGhPYmplY3QuZXh0IHx8ICcnfWA7XHJcbiAgICBpZiAoIWRpcikge1xyXG4gICAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpciA9PT0gcGF0aE9iamVjdC5yb290ID8gYCR7ZGlyfSR7YmFzZX1gIDogYCR7ZGlyfSR7c2VwfSR7YmFzZX1gO1xyXG59XHJcbmV4cG9ydCBjb25zdCB3aW4zMiA9IHtcclxuICAgIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcclxuICAgIHJlc29sdmUoLi4ucGF0aFNlZ21lbnRzKSB7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkRGV2aWNlID0gJyc7XHJcbiAgICAgICAgbGV0IHJlc29sdmVkVGFpbCA9ICcnO1xyXG4gICAgICAgIGxldCByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGhTZWdtZW50cy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IHBhdGg7XHJcbiAgICAgICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoU2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXNvbHZlZERldmljZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBwcm9jZXNzLmN3ZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2luZG93cyBoYXMgdGhlIGNvbmNlcHQgb2YgZHJpdmUtc3BlY2lmaWMgY3VycmVudCB3b3JraW5nXHJcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rvcmllcy4gSWYgd2UndmUgcmVzb2x2ZWQgYSBkcml2ZSBsZXR0ZXIgYnV0IG5vdCB5ZXQgYW5cclxuICAgICAgICAgICAgICAgIC8vIGFic29sdXRlIHBhdGgsIGdldCBjd2QgZm9yIHRoYXQgZHJpdmUsIG9yIHRoZSBwcm9jZXNzIGN3ZCBpZlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRyaXZlIGN3ZCBpcyBub3QgYXZhaWxhYmxlLiBXZSdyZSBzdXJlIHRoZSBkZXZpY2UgaXMgbm90XHJcbiAgICAgICAgICAgICAgICAvLyBhIFVOQyBwYXRoIGF0IHRoaXMgcG9pbnRzLCBiZWNhdXNlIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlLlxyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHByb2Nlc3MuZW52W2A9JHtyZXNvbHZlZERldmljZX1gXSB8fCBwcm9jZXNzLmN3ZCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgYSBjd2Qgd2FzIGZvdW5kIGFuZCB0aGF0IGl0IGFjdHVhbGx5IHBvaW50c1xyXG4gICAgICAgICAgICAgICAgLy8gdG8gb3VyIGRyaXZlLiBJZiBub3QsIGRlZmF1bHQgdG8gdGhlIGRyaXZlJ3Mgcm9vdC5cclxuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLnNsaWNlKDAsIDIpLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDIpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGAke3Jlc29sdmVkRGV2aWNlfVxcXFxgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkZXZpY2UgPSAnJztcclxuICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxyXG4gICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCBhIHNlcGFyYXRvciwgd2Uga25vdyB3ZSBhdCBsZWFzdCBoYXZlIGFuXHJcbiAgICAgICAgICAgICAgICAvLyBhYnNvbHV0ZSBwYXRoIG9mIHNvbWUga2luZCAoVU5DIG9yIG90aGVyd2lzZSlcclxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGogPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gcGF0aC5zbGljZShsYXN0LCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbiB8fCBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0LCBqKX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxyXG4gICAgICAgICAgICAgICAgZGV2aWNlID0gcGF0aC5zbGljZSgwLCAyKTtcclxuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVhdCBzZXBhcmF0b3IgZm9sbG93aW5nIGRyaXZlIG5hbWUgYXMgYW4gYWJzb2x1dGUgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXZpY2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkRGV2aWNlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwYXRoIHBvaW50cyB0byBhbm90aGVyIGRldmljZSBzbyBpdCBpcyBub3QgYXBwbGljYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZERldmljZSA9IGRldmljZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkRGV2aWNlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkVGFpbCA9IGAke3BhdGguc2xpY2Uocm9vdEVuZCl9XFxcXCR7cmVzb2x2ZWRUYWlsfWA7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gaXNBYnNvbHV0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlICYmIHJlc29sdmVkRGV2aWNlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCxcclxuICAgICAgICAvLyBidXQgaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKClcclxuICAgICAgICAvLyBmYWlscylcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHRhaWwgcGF0aFxyXG4gICAgICAgIHJlc29sdmVkVGFpbCA9IG5vcm1hbGl6ZVN0cmluZyhyZXNvbHZlZFRhaWwsICFyZXNvbHZlZEFic29sdXRlLCAnXFxcXCcsIGlzUGF0aFNlcGFyYXRvcik7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQWJzb2x1dGUgP1xyXG4gICAgICAgICAgICBgJHtyZXNvbHZlZERldmljZX1cXFxcJHtyZXNvbHZlZFRhaWx9YCA6XHJcbiAgICAgICAgICAgIGAke3Jlc29sdmVkRGV2aWNlfSR7cmVzb2x2ZWRUYWlsfWAgfHwgJy4nO1xyXG4gICAgfSxcclxuICAgIG5vcm1hbGl6ZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByb290RW5kID0gMDtcclxuICAgICAgICBsZXQgZGV2aWNlO1xyXG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xyXG4gICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHNpbmdsZSBjaGFyLCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUG9zaXhQYXRoU2VwYXJhdG9yKGNvZGUpID8gJ1xcXFwnIDogcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxyXG4gICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHdpdGggYSBzZXBhcmF0b3IsIHdlIGtub3cgd2UgYXQgbGVhc3QgaGF2ZSBhbiBhYnNvbHV0ZVxyXG4gICAgICAgICAgICAvLyBwYXRoIG9mIHNvbWUga2luZCAoVU5DIG9yIG90aGVyd2lzZSlcclxuICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhdGguc2xpY2UobGFzdCwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIFVOQyByb290IHNpbmNlIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBub3RoaW5nIGxlZnQgdG8gcHJvY2Vzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXCR7Zmlyc3RQYXJ0fVxcXFwke3BhdGguc2xpY2UobGFzdCl9XFxcXGA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0LCBqKX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb290RW5kID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xyXG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBkZXZpY2Ugcm9vdFxyXG4gICAgICAgICAgICBkZXZpY2UgPSBwYXRoLnNsaWNlKDAsIDIpO1xyXG4gICAgICAgICAgICByb290RW5kID0gMjtcclxuICAgICAgICAgICAgaWYgKGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHNlcGFyYXRvciBmb2xsb3dpbmcgZHJpdmUgbmFtZSBhcyBhbiBhYnNvbHV0ZSBwYXRoXHJcbiAgICAgICAgICAgICAgICAvLyBpbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRhaWwgPSByb290RW5kIDwgbGVuID9cclxuICAgICAgICAgICAgbm9ybWFsaXplU3RyaW5nKHBhdGguc2xpY2Uocm9vdEVuZCksICFpc0Fic29sdXRlLCAnXFxcXCcsIGlzUGF0aFNlcGFyYXRvcikgOlxyXG4gICAgICAgICAgICAnJztcclxuICAgICAgICBpZiAodGFpbC5sZW5ndGggPT09IDAgJiYgIWlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgdGFpbCA9ICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhaWwubGVuZ3RoID4gMCAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGxlbiAtIDEpKSkge1xyXG4gICAgICAgICAgICB0YWlsICs9ICdcXFxcJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRldmljZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYFxcXFwke3RhaWx9YCA6IHRhaWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYCR7ZGV2aWNlfVxcXFwke3RhaWx9YCA6IGAke2RldmljZX0ke3RhaWx9YDtcclxuICAgIH0sXHJcbiAgICBpc0Fic29sdXRlKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIHJldHVybiBpc1BhdGhTZXBhcmF0b3IoY29kZSkgfHxcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcclxuICAgICAgICAgICAgbGVuID4gMiAmJlxyXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OICYmXHJcbiAgICAgICAgICAgICAgICBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKTtcclxuICAgIH0sXHJcbiAgICBqb2luKC4uLnBhdGhzKSB7XHJcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgam9pbmVkO1xyXG4gICAgICAgIGxldCBmaXJzdFBhcnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcclxuICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcoYXJnLCAncGF0aCcpO1xyXG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGZpcnN0UGFydCA9IGFyZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCArPSBgXFxcXCR7YXJnfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBqb2luZWQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggdHdvIHNsYXNoZXMsIGJlY2F1c2VcclxuICAgICAgICAvLyBub3JtYWxpemUoKSB3aWxsIG1pc3Rha2UgaXQgZm9yIGFuIFVOQyBwYXRoIHRoZW4uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGlzIHN0ZXAgaXMgc2tpcHBlZCB3aGVuIGl0IGlzIHZlcnkgY2xlYXIgdGhhdCB0aGUgdXNlciBhY3R1YWxseVxyXG4gICAgICAgIC8vIGludGVuZGVkIHRvIHBvaW50IGF0IGFuIFVOQyBwYXRoLiBUaGlzIGlzIGFzc3VtZWQgd2hlbiB0aGUgZmlyc3RcclxuICAgICAgICAvLyBub24tZW1wdHkgc3RyaW5nIGFyZ3VtZW50cyBzdGFydHMgd2l0aCBleGFjdGx5IHR3byBzbGFzaGVzIGZvbGxvd2VkIGJ5XHJcbiAgICAgICAgLy8gYXQgbGVhc3Qgb25lIG1vcmUgbm9uLXNsYXNoIGNoYXJhY3Rlci5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE5vdGUgdGhhdCBmb3Igbm9ybWFsaXplKCkgdG8gdHJlYXQgYSBwYXRoIGFzIGFuIFVOQyBwYXRoIGl0IG5lZWRzIHRvXHJcbiAgICAgICAgLy8gaGF2ZSBhdCBsZWFzdCAyIGNvbXBvbmVudHMsIHNvIHdlIGRvbid0IGZpbHRlciBmb3IgdGhhdCBoZXJlLlxyXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdXNlciBjYW4gdXNlIGpvaW4gdG8gY29uc3RydWN0IFVOQyBwYXRocyBmcm9tXHJcbiAgICAgICAgLy8gYSBzZXJ2ZXIgbmFtZSBhbmQgYSBzaGFyZSBuYW1lOyBmb3IgZXhhbXBsZTpcclxuICAgICAgICAvLyAgIHBhdGguam9pbignLy9zZXJ2ZXInLCAnc2hhcmUnKSAtPiAnXFxcXFxcXFxzZXJ2ZXJcXFxcc2hhcmVcXFxcJylcclxuICAgICAgICBsZXQgbmVlZHNSZXBsYWNlID0gdHJ1ZTtcclxuICAgICAgICBsZXQgc2xhc2hDb3VudCA9IDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQgPT09ICdzdHJpbmcnICYmIGlzUGF0aFNlcGFyYXRvcihmaXJzdFBhcnQuY2hhckNvZGVBdCgwKSkpIHtcclxuICAgICAgICAgICAgKytzbGFzaENvdW50O1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdExlbiA9IGZpcnN0UGFydC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdExlbiA+IDEgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgKytzbGFzaENvdW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TGVuID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoZmlyc3RQYXJ0LmNoYXJDb2RlQXQoMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsrc2xhc2hDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcGF0aCBpbiB0aGUgZmlyc3QgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1JlcGxhY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lZWRzUmVwbGFjZSkge1xyXG4gICAgICAgICAgICAvLyBGaW5kIGFueSBtb3JlIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2UgbmVlZCB0byByZXBsYWNlXHJcbiAgICAgICAgICAgIHdoaWxlIChzbGFzaENvdW50IDwgam9pbmVkLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgaXNQYXRoU2VwYXJhdG9yKGpvaW5lZC5jaGFyQ29kZUF0KHNsYXNoQ291bnQpKSkge1xyXG4gICAgICAgICAgICAgICAgc2xhc2hDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHNsYXNoZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChzbGFzaENvdW50ID49IDIpIHtcclxuICAgICAgICAgICAgICAgIGpvaW5lZCA9IGBcXFxcJHtqb2luZWQuc2xpY2Uoc2xhc2hDb3VudCl9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2luMzIubm9ybWFsaXplKGpvaW5lZCk7XHJcbiAgICB9LFxyXG4gICAgLy8gSXQgd2lsbCBzb2x2ZSB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIGBmcm9tYCB0byBgdG9gLCBmb3IgaW5zdGFuY2U6XHJcbiAgICAvLyAgZnJvbSA9ICdDOlxcXFxvcmFuZGVhXFxcXHRlc3RcXFxcYWFhJ1xyXG4gICAgLy8gIHRvID0gJ0M6XFxcXG9yYW5kZWFcXFxcaW1wbFxcXFxiYmInXHJcbiAgICAvLyBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbiBzaG91bGQgYmU6ICcuLlxcXFwuLlxcXFxpbXBsXFxcXGJiYidcclxuICAgIHJlbGF0aXZlKGZyb20sIHRvKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcoZnJvbSwgJ2Zyb20nKTtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyh0bywgJ3RvJyk7XHJcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJvbU9yaWcgPSB3aW4zMi5yZXNvbHZlKGZyb20pO1xyXG4gICAgICAgIGNvbnN0IHRvT3JpZyA9IHdpbjMyLnJlc29sdmUodG8pO1xyXG4gICAgICAgIGlmIChmcm9tT3JpZyA9PT0gdG9PcmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJvbSA9IGZyb21PcmlnLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdG8gPSB0b09yaWcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXHJcbiAgICAgICAgbGV0IGZyb21TdGFydCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGZyb21TdGFydCA8IGZyb20ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgIGZyb21TdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KVxyXG4gICAgICAgIGxldCBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGZyb21FbmQgLSAxID4gZnJvbVN0YXJ0ICYmXHJcbiAgICAgICAgICAgIGZyb20uY2hhckNvZGVBdChmcm9tRW5kIC0gMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgZnJvbUVuZC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcclxuICAgICAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXHJcbiAgICAgICAgbGV0IHRvU3RhcnQgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0b1N0YXJ0IDwgdG8ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgdG9TdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIGJhY2tzbGFzaGVzIChhcHBsaWNhYmxlIHRvIFVOQyBwYXRocyBvbmx5KVxyXG4gICAgICAgIGxldCB0b0VuZCA9IHRvLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAodG9FbmQgLSAxID4gdG9TdGFydCAmJlxyXG4gICAgICAgICAgICB0by5jaGFyQ29kZUF0KHRvRW5kIC0gMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgdG9FbmQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XHJcbiAgICAgICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcclxuICAgICAgICBsZXQgbGFzdENvbW1vblNlcCA9IC0xO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUNvZGUgIT09IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgZm91bmQgYSBtaXNtYXRjaCBiZWZvcmUgdGhlIGZpcnN0IGNvbW1vbiBwYXRoIHNlcGFyYXRvciB3YXMgc2Vlbiwgc29cclxuICAgICAgICAvLyByZXR1cm4gdGhlIG9yaWdpbmFsIGB0b2AuXHJcbiAgICAgICAgaWYgKGkgIT09IGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b09yaWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcZm9vXFxcXGJhclxcXFxiYXonXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGRldmljZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPSdDOlxcXFwnOyB0bz0nQzpcXFxcZm9vJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b09yaWcuc2xpY2UodG9TdGFydCArIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcZm9vJ1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGRldmljZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPSdDOlxcXFxmb29cXFxcYmFyJzsgdG89J0M6XFxcXCdcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvdXQgPSAnJztcclxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYCBhbmRcclxuICAgICAgICAvLyBgZnJvbWBcclxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gb3V0Lmxlbmd0aCA9PT0gMCA/ICcuLicgOiAnXFxcXC4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XHJcbiAgICAgICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcclxuICAgICAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcclxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke291dH0ke3RvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvT3JpZy5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICsrdG9TdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCk7XHJcbiAgICB9LFxyXG4gICAgdG9OYW1lc3BhY2VkUGF0aChwYXRoKSB7XHJcbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsICpwcm9iYWJseSogdGhyb3cgc29tZXdoZXJlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHdpbjMyLnJlc29sdmUocGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENIQVJfUVVFU1RJT05fTUFSSyAmJiBjb2RlICE9PSBDSEFSX0RPVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgbm9uLWxvbmcgVU5DIHJvb3QsIGNvbnZlcnQgdGhlIHBhdGggdG8gYSBsb25nIFVOQyBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcVU5DXFxcXCR7cmVzb2x2ZWRQYXRoLnNsaWNlKDIpfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKSkgJiZcclxuICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcclxuICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMikgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgLy8gTWF0Y2hlZCBkZXZpY2Ugcm9vdCwgY29udmVydCB0aGUgcGF0aCB0byBhIGxvbmcgVU5DIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcJHtyZXNvbHZlZFBhdGh9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9LFxyXG4gICAgZGlybmFtZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByb290RW5kID0gLTE7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3IsIGV4aXQgZWFybHkgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yayBvciBhIGRvdC5cclxuICAgICAgICAgICAgcmV0dXJuIGlzUGF0aFNlcGFyYXRvcihjb2RlKSA/IHBhdGggOiAnLic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHJvb3RcclxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XHJcbiAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSAxO1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xyXG4gICAgICAgICAgICAgICAgbGV0IGogPSAyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgYnkgMSB0byBpbmNsdWRlIHRoZSBzZXBhcmF0b3IgYWZ0ZXIgdGhlIFVOQyByb290IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIFwibm9ybWFsIHJvb3RcIiBvbiB0b3Agb2YgYSAoVU5DKSByb290XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gb2Zmc2V0ID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcclxuICAgICAgICAgICAgcm9vdEVuZCA9IGxlbiA+IDIgJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkgPyAzIDogMjtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gcm9vdEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IG9mZnNldDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChyb290RW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmQgPSByb290RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xyXG4gICAgfSxcclxuICAgIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xyXG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhleHQsICdleHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBlbmQgPSAtMTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICAvLyBDaGVjayBmb3IgYSBkcml2ZSBsZXR0ZXIgcHJlZml4IHNvIGFzIG5vdCB0byBtaXN0YWtlIHRoZSBmb2xsb3dpbmdcclxuICAgICAgICAvLyBwYXRoIHNlcGFyYXRvciBhcyBhbiBleHRyYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0aCB0aGF0IGNhbiBiZVxyXG4gICAgICAgIC8vIGRpc3JlZ2FyZGVkXHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID49IDIgJiZcclxuICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChwYXRoLmNoYXJDb2RlQXQoMCkpICYmXHJcbiAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gQ0hBUl9DT0xPTikge1xyXG4gICAgICAgICAgICBzdGFydCA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChleHQgPT09IHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRJZHggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcclxuICAgICAgICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgZXh0bmFtZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xyXG4gICAgICAgIGxldCBzdGFydFBhcnQgPSAwO1xyXG4gICAgICAgIGxldCBlbmQgPSAtMTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXHJcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcclxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBhIGRyaXZlIGxldHRlciBwcmVmaXggc28gYXMgbm90IHRvIG1pc3Rha2UgdGhlIGZvbGxvd2luZ1xyXG4gICAgICAgIC8vIHBhdGggc2VwYXJhdG9yIGFzIGFuIGV4dHJhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXRoIHRoYXQgY2FuIGJlXHJcbiAgICAgICAgLy8gZGlzcmVnYXJkZWRcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPj0gMiAmJlxyXG4gICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcclxuICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChwYXRoLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRQYXJ0ID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXHJcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxyXG4gICAgICAgICAgICBlbmQgPT09IC0xIHx8XHJcbiAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XHJcbiAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XHJcbiAgICAgICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcclxuICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxyXG4gICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJ1xcXFwnKSxcclxuICAgIHBhcnNlKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGNvbnN0IHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XHJcbiAgICAgICAgbGV0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHBhdGggc2VwYXJhdG9yLCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXHJcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDtcclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxyXG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcclxuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcclxuICAgICAgICAgICAgcm9vdEVuZCA9IDE7XHJcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCB3aXRoIGxlZnRvdmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGogKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiYgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7XHJcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XHJcbiAgICAgICAgICAgIGlmIChsZW4gPD0gMikge1xyXG4gICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBkcml2ZSByb290LCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXHJcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290RW5kID0gMjtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBkcml2ZSByb290LCBleGl0IGVhcmx5IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29ya1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb290RW5kID4gMCkge1xyXG4gICAgICAgICAgICByZXQucm9vdCA9IHBhdGguc2xpY2UoMCwgcm9vdEVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xyXG4gICAgICAgIGxldCBzdGFydFBhcnQgPSByb290RW5kO1xyXG4gICAgICAgIGxldCBlbmQgPSAtMTtcclxuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcclxuICAgICAgICBsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXHJcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcclxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xyXG4gICAgICAgIC8vIEdldCBub24tZGlyIGluZm9cclxuICAgICAgICBmb3IgKDsgaSA+PSByb290RW5kOyAtLWkpIHtcclxuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kICE9PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcclxuICAgICAgICAgICAgICAgIChwcmVEb3RTdGF0ZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XHJcbiAgICAgICAgICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIGRpcmVjdG9yeSBpcyB0aGUgcm9vdCwgdXNlIHRoZSBlbnRpcmUgcm9vdCBhcyB0aGUgYGRpcmAgaW5jbHVkaW5nXHJcbiAgICAgICAgLy8gdGhlIHRyYWlsaW5nIHNsYXNoIGlmIGFueSAoYEM6XFxhYmNgIC0+IGBDOlxcYCkuIE90aGVyd2lzZSwgc3RyaXAgb3V0IHRoZVxyXG4gICAgICAgIC8vIHRyYWlsaW5nIHNsYXNoIChgQzpcXGFiY1xcZGVmYCAtPiBgQzpcXGFiY2ApLlxyXG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwICYmIHN0YXJ0UGFydCAhPT0gcm9vdEVuZCkge1xyXG4gICAgICAgICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSByZXQucm9vdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sXHJcbiAgICBzZXA6ICdcXFxcJyxcclxuICAgIGRlbGltaXRlcjogJzsnLFxyXG4gICAgd2luMzI6IG51bGwsXHJcbiAgICBwb3NpeDogbnVsbFxyXG59O1xyXG5leHBvcnQgY29uc3QgcG9zaXggPSB7XHJcbiAgICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXHJcbiAgICByZXNvbHZlKC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgICAgIGxldCByZXNvbHZlZFBhdGggPSAnJztcclxuICAgICAgICBsZXQgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBpID49IDAgPyBwYXRoU2VnbWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcclxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlZFBhdGggPSBgJHtwYXRofS8ke3Jlc29sdmVkUGF0aH1gO1xyXG4gICAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcclxuICAgICAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcclxuICAgICAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmcocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSwgJy8nLCBpc1Bvc2l4UGF0aFNlcGFyYXRvcik7XHJcbiAgICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAvJHtyZXNvbHZlZFBhdGh9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aC5sZW5ndGggPiAwID8gcmVzb2x2ZWRQYXRoIDogJy4nO1xyXG4gICAgfSxcclxuICAgIG5vcm1hbGl6ZShwYXRoKSB7XHJcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xyXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcclxuICAgICAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nKHBhdGgsICFpc0Fic29sdXRlLCAnLycsIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTtcclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nU2VwYXJhdG9yID8gJy4vJyA6ICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nU2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHBhdGggKz0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/IGAvJHtwYXRofWAgOiBwYXRoO1xyXG4gICAgfSxcclxuICAgIGlzQWJzb2x1dGUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgIH0sXHJcbiAgICBqb2luKC4uLnBhdGhzKSB7XHJcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgam9pbmVkO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJnID0gcGF0aHNbaV07XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTtcclxuICAgICAgICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgKz0gYC8ke2FyZ31gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9zaXgubm9ybWFsaXplKGpvaW5lZCk7XHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhmcm9tLCAnZnJvbScpO1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHRvLCAndG8nKTtcclxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmltIGxlYWRpbmcgZm9yd2FyZCBzbGFzaGVzLlxyXG4gICAgICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xyXG4gICAgICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XHJcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJvbVN0YXJ0ID0gMTtcclxuICAgICAgICBjb25zdCBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XHJcbiAgICAgICAgY29uc3QgdG9TdGFydCA9IDE7XHJcbiAgICAgICAgY29uc3QgdG9MZW4gPSB0by5sZW5ndGggLSB0b1N0YXJ0O1xyXG4gICAgICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3RcclxuICAgICAgICBjb25zdCBsZW5ndGggPSAoZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuKTtcclxuICAgICAgICBsZXQgbGFzdENvbW1vblNlcCA9IC0xO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xyXG4gICAgICAgICAgICBpZiAoZnJvbUNvZGUgIT09IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbUxlbiA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvJ1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvdXQgPSAnJztcclxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxyXG4gICAgICAgIC8vIGFuZCBgZnJvbWAuXHJcbiAgICAgICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gb3V0Lmxlbmd0aCA9PT0gMCA/ICcuLicgOiAnLy4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxyXG4gICAgICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0cy5cclxuICAgICAgICByZXR1cm4gYCR7b3V0fSR7dG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApfWA7XHJcbiAgICB9LFxyXG4gICAgdG9OYW1lc3BhY2VkUGF0aChwYXRoKSB7XHJcbiAgICAgICAgLy8gTm9uLW9wIG9uIHBvc2l4IHN5c3RlbXNcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH0sXHJcbiAgICBkaXJuYW1lKHBhdGgpIHtcclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYXNSb290ID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcvLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XHJcbiAgICB9LFxyXG4gICAgYmFzZW5hbWUocGF0aCwgZXh0KSB7XHJcbiAgICAgICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGV4dCwgJ2V4dCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChleHQgPT09IHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXHJcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcclxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgfSxcclxuICAgIGV4dG5hbWUocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcclxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxyXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XHJcbiAgICAgICAgICAgIGVuZCA9PT0gLTEgfHxcclxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcclxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcclxuICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xyXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXHJcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcclxuICAgIH0sXHJcbiAgICBmb3JtYXQ6IF9mb3JtYXQuYmluZChudWxsLCAnLycpLFxyXG4gICAgcGFyc2UocGF0aCkge1xyXG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XHJcbiAgICAgICAgY29uc3QgcmV0ID0geyByb290OiAnJywgZGlyOiAnJywgYmFzZTogJycsIGV4dDogJycsIG5hbWU6ICcnIH07XHJcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcclxuICAgICAgICBsZXQgc3RhcnQ7XHJcbiAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgcmV0LnJvb3QgPSAnLyc7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xyXG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xyXG4gICAgICAgIGxldCBpID0gcGF0aC5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcclxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxyXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XHJcbiAgICAgICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xyXG4gICAgICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcclxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRE9UKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxyXG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlID8gMSA6IHN0YXJ0UGFydDtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcclxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXHJcbiAgICAgICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnQsIHN0YXJ0RG90KTtcclxuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcclxuICAgICAgICAgICAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgIHJldC5kaXIgPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LFxyXG4gICAgc2VwOiAnLycsXHJcbiAgICBkZWxpbWl0ZXI6ICc6JyxcclxuICAgIHdpbjMyOiBudWxsLFxyXG4gICAgcG9zaXg6IG51bGxcclxufTtcclxucG9zaXgud2luMzIgPSB3aW4zMi53aW4zMiA9IHdpbjMyO1xyXG5wb3NpeC5wb3NpeCA9IHdpbjMyLnBvc2l4ID0gcG9zaXg7XHJcbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLm5vcm1hbGl6ZSA6IHBvc2l4Lm5vcm1hbGl6ZSk7XHJcbmV4cG9ydCBjb25zdCByZXNvbHZlID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5yZXNvbHZlIDogcG9zaXgucmVzb2x2ZSk7XHJcbmV4cG9ydCBjb25zdCByZWxhdGl2ZSA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIucmVsYXRpdmUgOiBwb3NpeC5yZWxhdGl2ZSk7XHJcbmV4cG9ydCBjb25zdCBkaXJuYW1lID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5kaXJuYW1lIDogcG9zaXguZGlybmFtZSk7XHJcbmV4cG9ydCBjb25zdCBiYXNlbmFtZSA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIuYmFzZW5hbWUgOiBwb3NpeC5iYXNlbmFtZSk7XHJcbmV4cG9ydCBjb25zdCBleHRuYW1lID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyB3aW4zMi5leHRuYW1lIDogcG9zaXguZXh0bmFtZSk7XHJcbmV4cG9ydCBjb25zdCBzZXAgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyLnNlcCA6IHBvc2l4LnNlcCk7XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBpc1dpbmRvd3MgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcclxuaW1wb3J0ICogYXMgcGF0aHMgZnJvbSAnLi9wYXRoLmpzJztcclxuY29uc3QgX3NjaGVtZVBhdHRlcm4gPSAvXlxcd1tcXHdcXGQrLi1dKiQvO1xyXG5jb25zdCBfc2luZ2xlU2xhc2hTdGFydCA9IC9eXFwvLztcclxuY29uc3QgX2RvdWJsZVNsYXNoU3RhcnQgPSAvXlxcL1xcLy87XHJcbmZ1bmN0aW9uIF92YWxpZGF0ZVVyaShyZXQsIF9zdHJpY3QpIHtcclxuICAgIC8vIHNjaGVtZSwgbXVzdCBiZSBzZXRcclxuICAgIGlmICghcmV0LnNjaGVtZSAmJiBfc3RyaWN0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBTY2hlbWUgaXMgbWlzc2luZzoge3NjaGVtZTogXCJcIiwgYXV0aG9yaXR5OiBcIiR7cmV0LmF1dGhvcml0eX1cIiwgcGF0aDogXCIke3JldC5wYXRofVwiLCBxdWVyeTogXCIke3JldC5xdWVyeX1cIiwgZnJhZ21lbnQ6IFwiJHtyZXQuZnJhZ21lbnR9XCJ9YCk7XHJcbiAgICB9XHJcbiAgICAvLyBzY2hlbWUsIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXHJcbiAgICAvLyBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcclxuICAgIGlmIChyZXQuc2NoZW1lICYmICFfc2NoZW1lUGF0dGVybi50ZXN0KHJldC5zY2hlbWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBTY2hlbWUgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzLicpO1xyXG4gICAgfVxyXG4gICAgLy8gcGF0aCwgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuM1xyXG4gICAgLy8gSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnRcclxuICAgIC8vIG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSBzbGFzaCAoXCIvXCIpIGNoYXJhY3Rlci4gIElmIGEgVVJJXHJcbiAgICAvLyBkb2VzIG5vdCBjb250YWluIGFuIGF1dGhvcml0eSBjb21wb25lbnQsIHRoZW4gdGhlIHBhdGggY2Fubm90IGJlZ2luXHJcbiAgICAvLyB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpLlxyXG4gICAgaWYgKHJldC5wYXRoKSB7XHJcbiAgICAgICAgaWYgKHJldC5hdXRob3JpdHkpIHtcclxuICAgICAgICAgICAgaWYgKCFfc2luZ2xlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKF9kb3VibGVTbGFzaFN0YXJ0LnRlc3QocmV0LnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGZvciBhIHdoaWxlIHdlIGFsbG93ZWQgdXJpcyAqd2l0aG91dCogc2NoZW1lcyBhbmQgdGhpcyBpcyB0aGUgbWlncmF0aW9uXHJcbi8vIGZvciB0aGVtLCBlLmcuIGFuIHVyaSB3aXRob3V0IHNjaGVtZSBhbmQgd2l0aG91dCBzdHJpY3QtbW9kZSB3YXJucyBhbmQgZmFsbHNcclxuLy8gYmFjayB0byB0aGUgZmlsZS1zY2hlbWUuIHRoYXQgc2hvdWxkIGNhdXNlIHRoZSBsZWFzdCBjYXJuYWdlIGFuZCBzdGlsbCBiZSBhXHJcbi8vIGNsZWFyIHdhcm5pbmdcclxuZnVuY3Rpb24gX3NjaGVtZUZpeChzY2hlbWUsIF9zdHJpY3QpIHtcclxuICAgIGlmICghc2NoZW1lICYmICFfc3RyaWN0KSB7XHJcbiAgICAgICAgcmV0dXJuICdmaWxlJztcclxuICAgIH1cclxuICAgIHJldHVybiBzY2hlbWU7XHJcbn1cclxuLy8gaW1wbGVtZW50cyBhIGJpdCBvZiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTVcclxuZnVuY3Rpb24gX3JlZmVyZW5jZVJlc29sdXRpb24oc2NoZW1lLCBwYXRoKSB7XHJcbiAgICAvLyB0aGUgc2xhc2gtY2hhcmFjdGVyIGlzIG91ciAnZGVmYXVsdCBiYXNlJyBhcyB3ZSBkb24ndFxyXG4gICAgLy8gc3VwcG9ydCBjb25zdHJ1Y3RpbmcgVVJJcyByZWxhdGl2ZSB0byBvdGhlciBVUklzLiBUaGlzXHJcbiAgICAvLyBhbHNvIG1lYW5zIHRoYXQgd2UgYWx0ZXIgYW5kIHBvdGVudGlhbGx5IGJyZWFrIHBhdGhzLlxyXG4gICAgLy8gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4xLjRcclxuICAgIHN3aXRjaCAoc2NoZW1lKSB7XHJcbiAgICAgICAgY2FzZSAnaHR0cHMnOlxyXG4gICAgICAgIGNhc2UgJ2h0dHAnOlxyXG4gICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aFswXSAhPT0gX3NsYXNoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gX3NsYXNoICsgcGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoO1xyXG59XHJcbmNvbnN0IF9lbXB0eSA9ICcnO1xyXG5jb25zdCBfc2xhc2ggPSAnLyc7XHJcbmNvbnN0IF9yZWdleHAgPSAvXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztcclxuLyoqXHJcbiAqIFVuaWZvcm0gUmVzb3VyY2UgSWRlbnRpZmllciAoVVJJKSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxyXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2ltcGxlIHBhcnNlciB3aGljaCBjcmVhdGVzIHRoZSBiYXNpYyBjb21wb25lbnQgcGFydHNcclxuICogKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zKSB3aXRoIG1pbmltYWwgdmFsaWRhdGlvblxyXG4gKiBhbmQgZW5jb2RpbmcuXHJcbiAqXHJcbiAqIGBgYHR4dFxyXG4gKiAgICAgICBmb286Ly9leGFtcGxlLmNvbTo4MDQyL292ZXIvdGhlcmU/bmFtZT1mZXJyZXQjbm9zZVxyXG4gKiAgICAgICBcXF8vICAgXFxfX19fX19fX19fX19fXy9cXF9fX19fX19fXy8gXFxfX19fX19fX18vIFxcX18vXHJcbiAqICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgfCAgICAgICAgICAgIHwgICAgICAgIHxcclxuICogICAgIHNjaGVtZSAgICAgYXV0aG9yaXR5ICAgICAgIHBhdGggICAgICAgIHF1ZXJ5ICAgZnJhZ21lbnRcclxuICogICAgICAgIHwgICBfX19fX19fX19fX19fX19fX19fX198X19cclxuICogICAgICAgLyBcXCAvICAgICAgICAgICAgICAgICAgICAgICAgXFxcclxuICogICAgICAgdXJuOmV4YW1wbGU6YW5pbWFsOmZlcnJldDpub3NlXHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFVSSSB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWVPckRhdGEsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50LCBfc3RyaWN0ID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtZU9yRGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBzY2hlbWVPckRhdGEuc2NoZW1lIHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBzY2hlbWVPckRhdGEuYXV0aG9yaXR5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gc2NoZW1lT3JEYXRhLnBhdGggfHwgX2VtcHR5O1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gc2NoZW1lT3JEYXRhLnF1ZXJ5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHNjaGVtZU9yRGF0YS5mcmFnbWVudCB8fCBfZW1wdHk7XHJcbiAgICAgICAgICAgIC8vIG5vIHZhbGlkYXRpb24gYmVjYXVzZSBpdCdzIHRoaXMgVVJJXHJcbiAgICAgICAgICAgIC8vIHRoYXQgY3JlYXRlcyB1cmkgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgLy8gX3ZhbGlkYXRlVXJpKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBfc2NoZW1lRml4KHNjaGVtZU9yRGF0YSwgX3N0cmljdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gYXV0aG9yaXR5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gX3JlZmVyZW5jZVJlc29sdXRpb24odGhpcy5zY2hlbWUsIHBhdGggfHwgX2VtcHR5KTtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50IHx8IF9lbXB0eTtcclxuICAgICAgICAgICAgX3ZhbGlkYXRlVXJpKHRoaXMsIF9zdHJpY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1VyaSh0aGluZykge1xyXG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIFVSSSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpbmcuYXV0aG9yaXR5ID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuZnJhZ21lbnQgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5wYXRoID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcucXVlcnkgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5zY2hlbWUgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5mc1BhdGggPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy53aXRoID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuICAgIC8vIC0tLS0gZmlsZXN5c3RlbSBwYXRoIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JyZXNwb25kaW5nIGZpbGUgc3lzdGVtIHBhdGggb2YgdGhpcyBVUkkuXHJcbiAgICAgKiBXaWxsIGhhbmRsZSBVTkMgcGF0aHMsIG5vcm1hbGl6ZXMgd2luZG93cyBkcml2ZSBsZXR0ZXJzIHRvIGxvd2VyLWNhc2UsIGFuZCB1c2VzIHRoZVxyXG4gICAgICogcGxhdGZvcm0gc3BlY2lmaWMgcGF0aCBzZXBhcmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogKiBXaWxsICpub3QqIHZhbGlkYXRlIHRoZSBwYXRoIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIHNlbWFudGljcy5cclxuICAgICAqICogV2lsbCAqbm90KiBsb29rIGF0IHRoZSBzY2hlbWUgb2YgdGhpcyBVUkkuXHJcbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGFjY2Vzc2luZyBhIGZpbGUgb24gZGlzay5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogVGhlICpkaWZmZXJlbmNlKiB0byBgVVJJI3BhdGhgIGlzIHRoZSB1c2Ugb2YgdGhlIHBsYXRmb3JtIHNwZWNpZmljIHNlcGFyYXRvciBhbmQgdGhlIGhhbmRsaW5nXHJcbiAgICAgKiBvZiBVTkMgcGF0aHMuIFNlZSB0aGUgYmVsb3cgc2FtcGxlIG9mIGEgZmlsZS11cmkgd2l0aCBhbiBhdXRob3JpdHkgKFVOQyBwYXRoKS5cclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICAgIGNvbnN0IHUgPSBVUkkucGFyc2UoJ2ZpbGU6Ly9zZXJ2ZXIvYyQvZm9sZGVyL2ZpbGUudHh0JylcclxuICAgICAgICB1LmF1dGhvcml0eSA9PT0gJ3NlcnZlcidcclxuICAgICAgICB1LnBhdGggPT09ICcvc2hhcmVzL2MkL2ZpbGUudHh0J1xyXG4gICAgICAgIHUuZnNQYXRoID09PSAnXFxcXHNlcnZlclxcYyRcXGZvbGRlclxcZmlsZS50eHQnXHJcbiAgICBgYGBcclxuICAgICAqXHJcbiAgICAgKiBVc2luZyBgVVJJI3BhdGhgIHRvIHJlYWQgYSBmaWxlICh1c2luZyBmcy1hcGlzKSB3b3VsZCBub3QgYmUgZW5vdWdoIGJlY2F1c2UgcGFydHMgb2YgdGhlIHBhdGgsXHJcbiAgICAgKiBuYW1lbHkgdGhlIHNlcnZlciBuYW1lLCB3b3VsZCBiZSBtaXNzaW5nLiBUaGVyZWZvcmUgYFVSSSNmc1BhdGhgIGV4aXN0cyAtIGl0J3Mgc3VnYXIgdG8gZWFzZSB3b3JraW5nXHJcbiAgICAgKiB3aXRoIFVSSXMgdGhhdCByZXByZXNlbnQgZmlsZXMgb24gZGlzayAoYGZpbGVgIHNjaGVtZSkuXHJcbiAgICAgKi9cclxuICAgIGdldCBmc1BhdGgoKSB7XHJcbiAgICAgICAgLy8gaWYgKHRoaXMuc2NoZW1lICE9PSAnZmlsZScpIHtcclxuICAgICAgICAvLyBcdGNvbnNvbGUud2FybihgW1VyaUVycm9yXSBjYWxsaW5nIGZzUGF0aCB3aXRoIHNjaGVtZSAke3RoaXMuc2NoZW1lfWApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gdXJpVG9Gc1BhdGgodGhpcywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBtb2RpZnkgdG8gbmV3IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHdpdGgoY2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQgfSA9IGNoYW5nZTtcclxuICAgICAgICBpZiAoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gdGhpcy5zY2hlbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzY2hlbWUgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhdXRob3JpdHkgPSB0aGlzLmF1dGhvcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXV0aG9yaXR5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IF9lbXB0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocXVlcnkgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcXVlcnkgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZnJhZ21lbnQgPSBfZW1wdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2hlbWUgPT09IHRoaXMuc2NoZW1lXHJcbiAgICAgICAgICAgICYmIGF1dGhvcml0eSA9PT0gdGhpcy5hdXRob3JpdHlcclxuICAgICAgICAgICAgJiYgcGF0aCA9PT0gdGhpcy5wYXRoXHJcbiAgICAgICAgICAgICYmIHF1ZXJ5ID09PSB0aGlzLnF1ZXJ5XHJcbiAgICAgICAgICAgICYmIGZyYWdtZW50ID09PSB0aGlzLmZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVyaShzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50KTtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gcGFyc2UgJiB2YWxpZGF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBVUkkgZnJvbSBhIHN0cmluZywgZS5nLiBgaHR0cDovL3d3dy5tc2Z0LmNvbS9zb21lL3BhdGhgLFxyXG4gICAgICogYGZpbGU6Ly8vdXNyL2hvbWVgLCBvciBgc2NoZW1lOndpdGgvcGF0aGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHdoaWNoIHJlcHJlc2VudHMgYW4gVVJJIChzZWUgYFVSSSN0b1N0cmluZ2ApLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIF9zdHJpY3QgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3JlZ2V4cC5leGVjKHZhbHVlKTtcclxuICAgICAgICBpZiAoIW1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJpKF9lbXB0eSwgX2VtcHR5LCBfZW1wdHksIF9lbXB0eSwgX2VtcHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVcmkobWF0Y2hbMl0gfHwgX2VtcHR5LCBwZXJjZW50RGVjb2RlKG1hdGNoWzRdIHx8IF9lbXB0eSksIHBlcmNlbnREZWNvZGUobWF0Y2hbNV0gfHwgX2VtcHR5KSwgcGVyY2VudERlY29kZShtYXRjaFs3XSB8fCBfZW1wdHkpLCBwZXJjZW50RGVjb2RlKG1hdGNoWzldIHx8IF9lbXB0eSksIF9zdHJpY3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFVSSSBmcm9tIGEgZmlsZSBzeXN0ZW0gcGF0aCwgZS5nLiBgYzpcXG15XFxmaWxlc2AsXHJcbiAgICAgKiBgL3Vzci9ob21lYCwgb3IgYFxcXFxzZXJ2ZXJcXHNoYXJlXFxzb21lXFxwYXRoYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgKmRpZmZlcmVuY2UqIGJldHdlZW4gYFVSSSNwYXJzZWAgYW5kIGBVUkkjZmlsZWAgaXMgdGhhdCB0aGUgbGF0dGVyIHRyZWF0cyB0aGUgYXJndW1lbnRcclxuICAgICAqIGFzIHBhdGgsIG5vdCBhcyBzdHJpbmdpZmllZC11cmkuIEUuZy4gYFVSSS5maWxlKHBhdGgpYCBpcyAqKm5vdCB0aGUgc2FtZSBhcyoqXHJcbiAgICAgKiBgVVJJLnBhcnNlKCdmaWxlOi8vJyArIHBhdGgpYCBiZWNhdXNlIHRoZSBwYXRoIG1pZ2h0IGNvbnRhaW4gY2hhcmFjdGVycyB0aGF0IGFyZVxyXG4gICAgICogaW50ZXJwcmV0ZWQgKCMgYW5kID8pLiBTZWUgdGhlIGZvbGxvd2luZyBzYW1wbGU6XHJcbiAgICAgKiBgYGB0c1xyXG4gICAgY29uc3QgZ29vZCA9IFVSSS5maWxlKCcvY29kaW5nL2MjL3Byb2plY3QxJyk7XHJcbiAgICBnb29kLnNjaGVtZSA9PT0gJ2ZpbGUnO1xyXG4gICAgZ29vZC5wYXRoID09PSAnL2NvZGluZy9jIy9wcm9qZWN0MSc7XHJcbiAgICBnb29kLmZyYWdtZW50ID09PSAnJztcclxuICAgIGNvbnN0IGJhZCA9IFVSSS5wYXJzZSgnZmlsZTovLycgKyAnL2NvZGluZy9jIy9wcm9qZWN0MScpO1xyXG4gICAgYmFkLnNjaGVtZSA9PT0gJ2ZpbGUnO1xyXG4gICAgYmFkLnBhdGggPT09ICcvY29kaW5nL2MnOyAvLyBwYXRoIGlzIG5vdyBicm9rZW5cclxuICAgIGJhZC5mcmFnbWVudCA9PT0gJy9wcm9qZWN0MSc7XHJcbiAgICBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBBIGZpbGUgc3lzdGVtIHBhdGggKHNlZSBgVVJJI2ZzUGF0aGApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmaWxlKHBhdGgpIHtcclxuICAgICAgICBsZXQgYXV0aG9yaXR5ID0gX2VtcHR5O1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0byBmd2Qtc2xhc2hlcyBvbiB3aW5kb3dzLFxyXG4gICAgICAgIC8vIG9uIG90aGVyIHN5c3RlbXMgYndkLXNsYXNoZXMgYXJlIHZhbGlkXHJcbiAgICAgICAgLy8gZmlsZW5hbWUgY2hhcmFjdGVyLCBlZyAvZlxcb28vYmFcXHIudHh0XHJcbiAgICAgICAgaWYgKGlzV2luZG93cykge1xyXG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIF9zbGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGZvciBhdXRob3JpdHkgYXMgdXNlZCBpbiBVTkMgc2hhcmVzXHJcbiAgICAgICAgLy8gb3IgdXNlIHRoZSBwYXRoIGFzIGdpdmVuXHJcbiAgICAgICAgaWYgKHBhdGhbMF0gPT09IF9zbGFzaCAmJiBwYXRoWzFdID09PSBfc2xhc2gpIHtcclxuICAgICAgICAgICAgY29uc3QgaWR4ID0gcGF0aC5pbmRleE9mKF9zbGFzaCwgMik7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyKTtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBfc2xhc2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHkgPSBwYXRoLnN1YnN0cmluZygyLCBpZHgpO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKGlkeCkgfHwgX3NsYXNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVXJpKCdmaWxlJywgYXV0aG9yaXR5LCBwYXRoLCBfZW1wdHksIF9lbXB0eSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbShjb21wb25lbnRzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShjb21wb25lbnRzLnNjaGVtZSwgY29tcG9uZW50cy5hdXRob3JpdHksIGNvbXBvbmVudHMucGF0aCwgY29tcG9uZW50cy5xdWVyeSwgY29tcG9uZW50cy5mcmFnbWVudCk7XHJcbiAgICAgICAgX3ZhbGlkYXRlVXJpKHJlc3VsdCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSm9pbiBhIFVSSSBwYXRoIHdpdGggcGF0aCBmcmFnbWVudHMgYW5kIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGlucHV0IFVSSS5cclxuICAgICAqIEBwYXJhbSBwYXRoRnJhZ21lbnQgVGhlIHBhdGggZnJhZ21lbnQgdG8gYWRkIHRvIHRoZSBVUkkgcGF0aC5cclxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRpbmcgVVJJLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgam9pblBhdGgodXJpLCAuLi5wYXRoRnJhZ21lbnQpIHtcclxuICAgICAgICBpZiAoIXVyaS5wYXRoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogY2Fubm90IGNhbGwgam9pblBhdGggb24gVVJJIHdpdGhvdXQgcGF0aGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3UGF0aDtcclxuICAgICAgICBpZiAoaXNXaW5kb3dzICYmIHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgICAgICBuZXdQYXRoID0gVVJJLmZpbGUocGF0aHMud2luMzIuam9pbih1cmlUb0ZzUGF0aCh1cmksIHRydWUpLCAuLi5wYXRoRnJhZ21lbnQpKS5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3UGF0aCA9IHBhdGhzLnBvc2l4LmpvaW4odXJpLnBhdGgsIC4uLnBhdGhGcmFnbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmkud2l0aCh7IHBhdGg6IG5ld1BhdGggfSk7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0tIHByaW50aW5nL2V4dGVybmFsaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGlzIFVSSS4gSXQncyBndWFyYW50ZWVkIHRoYXQgY2FsbGluZ1xyXG4gICAgICogYFVSSS5wYXJzZWAgd2l0aCB0aGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhbiBVUkkgd2hpY2ggaXMgZXF1YWxcclxuICAgICAqIHRvIHRoaXMgVVJJLlxyXG4gICAgICpcclxuICAgICAqICogVGhlIHJlc3VsdCBzaGFsbCAqbm90KiBiZSB1c2VkIGZvciBkaXNwbGF5IHB1cnBvc2VzIGJ1dCBmb3IgZXh0ZXJuYWxpemF0aW9uIG9yIHRyYW5zcG9ydC5cclxuICAgICAqICogVGhlIHJlc3VsdCB3aWxsIGJlIGVuY29kZWQgdXNpbmcgdGhlIHBlcmNlbnRhZ2UgZW5jb2RpbmcgYW5kIGVuY29kaW5nIGhhcHBlbnMgbW9zdGx5XHJcbiAgICAgKiBpZ25vcmUgdGhlIHNjaGVtZS1zcGVjaWZpYyBlbmNvZGluZyBydWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2tpcEVuY29kaW5nIERvIG5vdCBlbmNvZGUgdGhlIHJlc3VsdCwgZGVmYXVsdCBpcyBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKHNraXBFbmNvZGluZyA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCBza2lwRW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJldml2ZShkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVVJJKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShkYXRhKTtcclxuICAgICAgICAgICAgcmVzdWx0Ll9mb3JtYXR0ZWQgPSBkYXRhLmV4dGVybmFsO1xyXG4gICAgICAgICAgICByZXN1bHQuX2ZzUGF0aCA9IGRhdGEuX3NlcCA9PT0gX3BhdGhTZXBNYXJrZXIgPyBkYXRhLmZzUGF0aCA6IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IF9wYXRoU2VwTWFya2VyID0gaXNXaW5kb3dzID8gMSA6IHVuZGVmaW5lZDtcclxuLy8gVGhpcyBjbGFzcyBleGlzdHMgc28gdGhhdCBVUkkgaXMgY29tcGF0aWJpbGUgd2l0aCB2c2NvZGUuVXJpIChBUEkpLlxyXG5jbGFzcyBVcmkgZXh0ZW5kcyBVUkkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9mb3JtYXR0ZWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2ZzUGF0aCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgZnNQYXRoKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnNQYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZzUGF0aCA9IHVyaVRvRnNQYXRoKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZzUGF0aDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKHNraXBFbmNvZGluZyA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKCFza2lwRW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mb3JtYXR0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlZCA9IF9hc0Zvcm1hdHRlZCh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhY2hlIHRoYXRcclxuICAgICAgICAgICAgcmV0dXJuIF9hc0Zvcm1hdHRlZCh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgICAgICAkbWlkOiAxIC8qIFVyaSAqL1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FjaGVkIHN0YXRlXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZzUGF0aCkge1xyXG4gICAgICAgICAgICByZXMuZnNQYXRoID0gdGhpcy5fZnNQYXRoO1xyXG4gICAgICAgICAgICByZXMuX3NlcCA9IF9wYXRoU2VwTWFya2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZm9ybWF0dGVkKSB7XHJcbiAgICAgICAgICAgIHJlcy5leHRlcm5hbCA9IHRoaXMuX2Zvcm1hdHRlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXJpIGNvbXBvbmVudHNcclxuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHJlcy5wYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcclxuICAgICAgICAgICAgcmVzLnNjaGVtZSA9IHRoaXMuc2NoZW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hdXRob3JpdHkpIHtcclxuICAgICAgICAgICAgcmVzLmF1dGhvcml0eSA9IHRoaXMuYXV0aG9yaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5xdWVyeSkge1xyXG4gICAgICAgICAgICByZXMucXVlcnkgPSB0aGlzLnF1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudCkge1xyXG4gICAgICAgICAgICByZXMuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XHJcbi8vIHJlc2VydmVkIGNoYXJhY3RlcnM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4yXHJcbmNvbnN0IGVuY29kZVRhYmxlID0ge1xyXG4gICAgWzU4IC8qIENvbG9uICovXTogJyUzQScsXHJcbiAgICBbNDcgLyogU2xhc2ggKi9dOiAnJTJGJyxcclxuICAgIFs2MyAvKiBRdWVzdGlvbk1hcmsgKi9dOiAnJTNGJyxcclxuICAgIFszNSAvKiBIYXNoICovXTogJyUyMycsXHJcbiAgICBbOTEgLyogT3BlblNxdWFyZUJyYWNrZXQgKi9dOiAnJTVCJyxcclxuICAgIFs5MyAvKiBDbG9zZVNxdWFyZUJyYWNrZXQgKi9dOiAnJTVEJyxcclxuICAgIFs2NCAvKiBBdFNpZ24gKi9dOiAnJTQwJyxcclxuICAgIFszMyAvKiBFeGNsYW1hdGlvbk1hcmsgKi9dOiAnJTIxJyxcclxuICAgIFszNiAvKiBEb2xsYXJTaWduICovXTogJyUyNCcsXHJcbiAgICBbMzggLyogQW1wZXJzYW5kICovXTogJyUyNicsXHJcbiAgICBbMzkgLyogU2luZ2xlUXVvdGUgKi9dOiAnJTI3JyxcclxuICAgIFs0MCAvKiBPcGVuUGFyZW4gKi9dOiAnJTI4JyxcclxuICAgIFs0MSAvKiBDbG9zZVBhcmVuICovXTogJyUyOScsXHJcbiAgICBbNDIgLyogQXN0ZXJpc2sgKi9dOiAnJTJBJyxcclxuICAgIFs0MyAvKiBQbHVzICovXTogJyUyQicsXHJcbiAgICBbNDQgLyogQ29tbWEgKi9dOiAnJTJDJyxcclxuICAgIFs1OSAvKiBTZW1pY29sb24gKi9dOiAnJTNCJyxcclxuICAgIFs2MSAvKiBFcXVhbHMgKi9dOiAnJTNEJyxcclxuICAgIFszMiAvKiBTcGFjZSAqL106ICclMjAnLFxyXG59O1xyXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRGYXN0KHVyaUNvbXBvbmVudCwgYWxsb3dTbGFzaCkge1xyXG4gICAgbGV0IHJlcyA9IHVuZGVmaW5lZDtcclxuICAgIGxldCBuYXRpdmVFbmNvZGVQb3MgPSAtMTtcclxuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHVyaUNvbXBvbmVudC5sZW5ndGg7IHBvcysrKSB7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHVyaUNvbXBvbmVudC5jaGFyQ29kZUF0KHBvcyk7XHJcbiAgICAgICAgLy8gdW5yZXNlcnZlZCBjaGFyYWN0ZXJzOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuM1xyXG4gICAgICAgIGlmICgoY29kZSA+PSA5NyAvKiBhICovICYmIGNvZGUgPD0gMTIyIC8qIHogKi8pXHJcbiAgICAgICAgICAgIHx8IChjb2RlID49IDY1IC8qIEEgKi8gJiYgY29kZSA8PSA5MCAvKiBaICovKVxyXG4gICAgICAgICAgICB8fCAoY29kZSA+PSA0OCAvKiBEaWdpdDAgKi8gJiYgY29kZSA8PSA1NyAvKiBEaWdpdDkgKi8pXHJcbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDQ1IC8qIERhc2ggKi9cclxuICAgICAgICAgICAgfHwgY29kZSA9PT0gNDYgLyogUGVyaW9kICovXHJcbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDk1IC8qIFVuZGVybGluZSAqL1xyXG4gICAgICAgICAgICB8fCBjb2RlID09PSAxMjYgLyogVGlsZGUgKi9cclxuICAgICAgICAgICAgfHwgKGFsbG93U2xhc2ggJiYgY29kZSA9PT0gNDcgLyogU2xhc2ggKi8pKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBkZWxheWluZyBuYXRpdmUgZW5jb2RlXHJcbiAgICAgICAgICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zLCBwb3MpKTtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZUVuY29kZVBvcyA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIHdyaXRlIGludG8gYSBuZXcgc3RyaW5nIChieSBkZWZhdWx0IHdlIHRyeSB0byByZXR1cm4gdGhlIHBhcmFtKVxyXG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSB1cmlDb21wb25lbnQuY2hhckF0KHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGVuY29kaW5nIG5lZWRlZCwgd2UgbmVlZCB0byBhbGxvY2F0ZSBhIG5ldyBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB1cmlDb21wb25lbnQuc3Vic3RyKDAsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hlY2sgd2l0aCBkZWZhdWx0IHRhYmxlIGZpcnN0XHJcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWQgPSBlbmNvZGVUYWJsZVtjb2RlXTtcclxuICAgICAgICAgICAgaWYgKGVzY2FwZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGRlbGF5aW5nIG5hdGl2ZSBlbmNvZGVcclxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZVVSSUNvbXBvbmVudCh1cmlDb21wb25lbnQuc3Vic3RyaW5nKG5hdGl2ZUVuY29kZVBvcywgcG9zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgZXNjYXBlZCB2YXJpYW50IHRvIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVzY2FwZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmF0aXZlRW5jb2RlUG9zID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIG5hdGl2ZSBlbmNvZGUgb25seSB3aGVuIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gcG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5hdGl2ZUVuY29kZVBvcyAhPT0gLTEpIHtcclxuICAgICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudC5zdWJzdHJpbmcobmF0aXZlRW5jb2RlUG9zKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzICE9PSB1bmRlZmluZWQgPyByZXMgOiB1cmlDb21wb25lbnQ7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50TWluaW1hbChwYXRoKSB7XHJcbiAgICBsZXQgcmVzID0gdW5kZWZpbmVkO1xyXG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgcGF0aC5sZW5ndGg7IHBvcysrKSB7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChwb3MpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSAzNSAvKiBIYXNoICovIHx8IGNvZGUgPT09IDYzIC8qIFF1ZXN0aW9uTWFyayAqLykge1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHBhdGguc3Vic3RyKDAsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzICs9IGVuY29kZVRhYmxlW2NvZGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gcGF0aFtwb3NdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkID8gcmVzIDogcGF0aDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZSBgZnNQYXRoYCBmb3IgdGhlIGdpdmVuIHVyaVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVyaVRvRnNQYXRoKHVyaSwga2VlcERyaXZlTGV0dGVyQ2FzaW5nKSB7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBpZiAodXJpLmF1dGhvcml0eSAmJiB1cmkucGF0aC5sZW5ndGggPiAxICYmIHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgIC8vIHVuYyBwYXRoOiBmaWxlOi8vc2hhcmVzL2MkL2Zhci9ib29cclxuICAgICAgICB2YWx1ZSA9IGAvLyR7dXJpLmF1dGhvcml0eX0ke3VyaS5wYXRofWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh1cmkucGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKiBTbGFzaCAqL1xyXG4gICAgICAgICYmICh1cmkucGF0aC5jaGFyQ29kZUF0KDEpID49IDY1IC8qIEEgKi8gJiYgdXJpLnBhdGguY2hhckNvZGVBdCgxKSA8PSA5MCAvKiBaICovIHx8IHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPj0gOTcgLyogYSAqLyAmJiB1cmkucGF0aC5jaGFyQ29kZUF0KDEpIDw9IDEyMiAvKiB6ICovKVxyXG4gICAgICAgICYmIHVyaS5wYXRoLmNoYXJDb2RlQXQoMikgPT09IDU4IC8qIENvbG9uICovKSB7XHJcbiAgICAgICAgaWYgKCFrZWVwRHJpdmVMZXR0ZXJDYXNpbmcpIHtcclxuICAgICAgICAgICAgLy8gd2luZG93cyBkcml2ZSBsZXR0ZXI6IGZpbGU6Ly8vYzovZmFyL2Jvb1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoWzFdLnRvTG93ZXJDYXNlKCkgKyB1cmkucGF0aC5zdWJzdHIoMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHVyaS5wYXRoLnN1YnN0cigxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBvdGhlciBwYXRoXHJcbiAgICAgICAgdmFsdWUgPSB1cmkucGF0aDtcclxuICAgIH1cclxuICAgIGlmIChpc1dpbmRvd3MpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgdGhlIGV4dGVybmFsIHZlcnNpb24gb2YgYSB1cmlcclxuICovXHJcbmZ1bmN0aW9uIF9hc0Zvcm1hdHRlZCh1cmksIHNraXBFbmNvZGluZykge1xyXG4gICAgY29uc3QgZW5jb2RlciA9ICFza2lwRW5jb2RpbmdcclxuICAgICAgICA/IGVuY29kZVVSSUNvbXBvbmVudEZhc3RcclxuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudE1pbmltYWw7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBsZXQgeyBzY2hlbWUsIGF1dGhvcml0eSwgcGF0aCwgcXVlcnksIGZyYWdtZW50IH0gPSB1cmk7XHJcbiAgICBpZiAoc2NoZW1lKSB7XHJcbiAgICAgICAgcmVzICs9IHNjaGVtZTtcclxuICAgICAgICByZXMgKz0gJzonO1xyXG4gICAgfVxyXG4gICAgaWYgKGF1dGhvcml0eSB8fCBzY2hlbWUgPT09ICdmaWxlJykge1xyXG4gICAgICAgIHJlcyArPSBfc2xhc2g7XHJcbiAgICAgICAgcmVzICs9IF9zbGFzaDtcclxuICAgIH1cclxuICAgIGlmIChhdXRob3JpdHkpIHtcclxuICAgICAgICBsZXQgaWR4ID0gYXV0aG9yaXR5LmluZGV4T2YoJ0AnKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyA8dXNlcj5APGF1dGg+XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJpbmZvID0gYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpO1xyXG4gICAgICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkuc3Vic3RyKGlkeCArIDEpO1xyXG4gICAgICAgICAgICBpZHggPSB1c2VyaW5mby5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gZW5jb2Rlcih1c2VyaW5mbywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gPHVzZXI+OjxwYXNzPkA8YXV0aD5cclxuICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKHVzZXJpbmZvLnN1YnN0cigwLCBpZHgpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJzonO1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKGlkeCArIDEpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzICs9ICdAJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWR4ID0gYXV0aG9yaXR5LmluZGV4T2YoJzonKTtcclxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXMgKz0gZW5jb2RlcihhdXRob3JpdHksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIDxhdXRoPjo8cG9ydD5cclxuICAgICAgICAgICAgcmVzICs9IGVuY29kZXIoYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJlcyArPSBhdXRob3JpdHkuc3Vic3RyKGlkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhdGgpIHtcclxuICAgICAgICAvLyBsb3dlci1jYXNlIHdpbmRvd3MgZHJpdmUgbGV0dGVycyBpbiAvQzovZmZmIG9yIEM6L2ZmZlxyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAzICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyogU2xhc2ggKi8gJiYgcGF0aC5jaGFyQ29kZUF0KDIpID09PSA1OCAvKiBDb2xvbiAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDEpO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA+PSA2NSAvKiBBICovICYmIGNvZGUgPD0gOTAgLyogWiAqLykge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IGAvJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAzMil9OiR7cGF0aC5zdWJzdHIoMyl9YDsgLy8gXCIvYzpcIi5sZW5ndGggPT09IDNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gNTggLyogQ29sb24gKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPj0gNjUgLyogQSAqLyAmJiBjb2RlIDw9IDkwIC8qIFogKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhdGggPSBgJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAzMil9OiR7cGF0aC5zdWJzdHIoMil9YDsgLy8gXCIvYzpcIi5sZW5ndGggPT09IDNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGhcclxuICAgICAgICByZXMgKz0gZW5jb2RlcihwYXRoLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgIHJlcyArPSAnPyc7XHJcbiAgICAgICAgcmVzICs9IGVuY29kZXIocXVlcnksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGlmIChmcmFnbWVudCkge1xyXG4gICAgICAgIHJlcyArPSAnIyc7XHJcbiAgICAgICAgcmVzICs9ICFza2lwRW5jb2RpbmcgPyBlbmNvZGVVUklDb21wb25lbnRGYXN0KGZyYWdtZW50LCBmYWxzZSkgOiBmcmFnbWVudDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLy8gLS0tIGRlY29kZVxyXG5mdW5jdGlvbiBkZWNvZGVVUklDb21wb25lbnRHcmFjZWZ1bChzdHIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIDMpICsgZGVjb2RlVVJJQ29tcG9uZW50R3JhY2VmdWwoc3RyLnN1YnN0cigzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBfckVuY29kZWRBc0hleCA9IC8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO1xyXG5mdW5jdGlvbiBwZXJjZW50RGVjb2RlKHN0cikge1xyXG4gICAgaWYgKCFzdHIubWF0Y2goX3JFbmNvZGVkQXNIZXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHIucmVwbGFjZShfckVuY29kZWRBc0hleCwgKG1hdGNoKSA9PiBkZWNvZGVVUklDb21wb25lbnRHcmFjZWZ1bChtYXRjaCkpO1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vKipcclxuICogQSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBvc2l0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGxpbmVOdW1iZXIsIGNvbHVtbikge1xyXG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ld0xpbmVOdW1iZXIgbmV3IGxpbmUgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0gbmV3Q29sdW1uIG5ldyBjb2x1bW5cclxuICAgICAqL1xyXG4gICAgd2l0aChuZXdMaW5lTnVtYmVyID0gdGhpcy5saW5lTnVtYmVyLCBuZXdDb2x1bW4gPSB0aGlzLmNvbHVtbikge1xyXG4gICAgICAgIGlmIChuZXdMaW5lTnVtYmVyID09PSB0aGlzLmxpbmVOdW1iZXIgJiYgbmV3Q29sdW1uID09PSB0aGlzLmNvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obmV3TGluZU51bWJlciwgbmV3Q29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlcml2ZSBhIG5ldyBwb3NpdGlvbiBmcm9tIHRoaXMgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlbHRhTGluZU51bWJlciBsaW5lIG51bWJlciBkZWx0YVxyXG4gICAgICogQHBhcmFtIGRlbHRhQ29sdW1uIGNvbHVtbiBkZWx0YVxyXG4gICAgICovXHJcbiAgICBkZWx0YShkZWx0YUxpbmVOdW1iZXIgPSAwLCBkZWx0YUNvbHVtbiA9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aXRoKHRoaXMubGluZU51bWJlciArIGRlbHRhTGluZU51bWJlciwgdGhpcy5jb2x1bW4gKyBkZWx0YUNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBlcXVhbHMgb3RoZXIgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmVxdWFscyh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGVxdWFscyBwb3NpdGlvbiBgYmBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCEhYSAmJlxyXG4gICAgICAgICAgICAhIWIgJiZcclxuICAgICAgICAgICAgYS5saW5lTnVtYmVyID09PSBiLmxpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5jb2x1bW4gPT09IGIuY29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBvdGhlciBwb3NpdGlvbi5cclxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBpc0JlZm9yZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5pc0JlZm9yZSh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGlzIGJlZm9yZSBwb3NpdGlvbiBgYmAuXHJcbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQmVmb3JlKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5saW5lTnVtYmVyIDwgYi5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYi5saW5lTnVtYmVyIDwgYS5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuY29sdW1uIDwgYi5jb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXHJcbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSB0cnVlLlxyXG4gICAgICovXHJcbiAgICBpc0JlZm9yZU9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gUG9zaXRpb24uaXNCZWZvcmVPckVxdWFsKHRoaXMsIG90aGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cclxuICAgICAqIElmIHRoZSB0d28gcG9zaXRpb25zIGFyZSBlcXVhbCwgdGhlIHJlc3VsdCB3aWxsIGJlIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0JlZm9yZU9yRXF1YWwoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxpbmVOdW1iZXIgPCBiLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiLmxpbmVOdW1iZXIgPCBhLmxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS5jb2x1bW4gPD0gYi5jb2x1bW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyBwb3NpdGlvbnMsIHVzZWZ1bCBmb3Igc29ydGluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgbGV0IGFMaW5lTnVtYmVyID0gYS5saW5lTnVtYmVyIHwgMDtcclxuICAgICAgICBsZXQgYkxpbmVOdW1iZXIgPSBiLmxpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgIGlmIChhTGluZU51bWJlciA9PT0gYkxpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IGFDb2x1bW4gPSBhLmNvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgIGxldCBiQ29sdW1uID0gYi5jb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICByZXR1cm4gYUNvbHVtbiAtIGJDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhTGluZU51bWJlciAtIGJMaW5lTnVtYmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZSB0aGlzIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZU51bWJlciwgdGhpcy5jb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRvIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLmxpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLmNvbHVtbiArICcpJztcclxuICAgIH1cclxuICAgIC8vIC0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgUG9zaXRpb25gIGZyb20gYW4gYElQb3NpdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsaWZ0KHBvcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zLmxpbmVOdW1iZXIsIHBvcy5jb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUG9zaXRpb25gLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJUG9zaXRpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmoubGluZU51bWJlciA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmNvbHVtbiA9PT0gJ251bWJlcicpKTtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcclxuLyoqXHJcbiAqIEEgcmFuZ2UgaW4gdGhlIGVkaXRvci4gKHN0YXJ0TGluZU51bWJlcixzdGFydENvbHVtbikgaXMgPD0gKGVuZExpbmVOdW1iZXIsZW5kQ29sdW1uKVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xyXG4gICAgICAgIGlmICgoc3RhcnRMaW5lTnVtYmVyID4gZW5kTGluZU51bWJlcikgfHwgKHN0YXJ0TGluZU51bWJlciA9PT0gZW5kTGluZU51bWJlciAmJiBzdGFydENvbHVtbiA+IGVuZENvbHVtbikpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uO1xyXG4gICAgICAgICAgICB0aGlzLmVuZExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xyXG4gICAgICAgICAgICB0aGlzLmVuZExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhpcyByYW5nZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuaXNFbXB0eSh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFbXB0eShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGlzIGluIHRoaXMgcmFuZ2UuIElmIHRoZSBwb3NpdGlvbiBpcyBhdCB0aGUgZWRnZXMsIHdpbGwgcmV0dXJuIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuY29udGFpbnNQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYHBvc2l0aW9uYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBwb3NpdGlvbi5saW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uIDwgcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBwb3NpdGlvbi5jb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiByYW5nZSBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcmFuZ2UgaXMgZXF1YWwgdG8gdGhpcyByYW5nZSwgd2lsbCByZXR1cm4gdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5jb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgb3RoZXJSYW5nZWAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHJhbmdlcyBhcmUgZXF1YWwsIHdpbGwgcmV0dXJuIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb250YWluc1JhbmdlKHJhbmdlLCBvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPCByYW5nZS5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIHN0cmljdGx5IGluIHRoaXMgcmFuZ2UuIGByYW5nZWAgbXVzdCBzdGFydCBhZnRlciBhbmQgZW5kIGJlZm9yZSB0aGlzIHJhbmdlIGZvciB0aGUgcmVzdWx0IHRvIGJlIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0cmljdENvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2Uuc3RyaWN0Q29udGFpbnNSYW5nZSh0aGlzLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgYG90aGVyUmFuZ2VgIGlzIHN0cmluY3RseSBpbiBgcmFuZ2VgIChtdXN0IHN0YXJ0IGFmdGVyLCBhbmQgZW5kIGJlZm9yZSkuIElmIHRoZSByYW5nZXMgYXJlIGVxdWFsLCB3aWxsIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN0cmljdENvbnRhaW5zUmFuZ2UocmFuZ2UsIG90aGVyUmFuZ2UpIHtcclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlciB8fCBvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5zdGFydExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5zdGFydENvbHVtbiA8PSByYW5nZS5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPj0gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgcmV1bmlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cclxuICAgICAqIFRoZSBzbWFsbGVzdCBwb3NpdGlvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHN0YXJ0IHBvaW50LCBhbmQgdGhlIGxhcmdlc3Qgb25lIGFzIHRoZSBlbmQgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHBsdXNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5wbHVzUmFuZ2UodGhpcywgcmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXHJcbiAgICAgKiBUaGUgc21hbGxlc3QgcG9zaXRpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBzdGFydCBwb2ludCwgYW5kIHRoZSBsYXJnZXN0IG9uZSBhcyB0aGUgZW5kIHBvaW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGx1c1JhbmdlKGEsIGIpIHtcclxuICAgICAgICBsZXQgc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBzdGFydENvbHVtbjtcclxuICAgICAgICBsZXQgZW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgZW5kQ29sdW1uO1xyXG4gICAgICAgIGlmIChiLnN0YXJ0TGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGIuc3RhcnRMaW5lTnVtYmVyID09PSBhLnN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBNYXRoLm1pbihiLnN0YXJ0Q29sdW1uLCBhLnN0YXJ0Q29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGEuc3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiLmVuZExpbmVOdW1iZXIgPiBhLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlcjtcclxuICAgICAgICAgICAgZW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGIuZW5kTGluZU51bWJlciA9PT0gYS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IE1hdGgubWF4KGIuZW5kQ29sdW1uLCBhLmVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBhLmVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJhbmdlcy5cclxuICAgICAqL1xyXG4gICAgaW50ZXJzZWN0UmFuZ2VzKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmludGVyc2VjdFJhbmdlcyh0aGlzLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50ZXJzZWN0UmFuZ2VzKGEsIGIpIHtcclxuICAgICAgICBsZXQgcmVzdWx0U3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IHJlc3VsdFN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbjtcclxuICAgICAgICBsZXQgcmVzdWx0RW5kTGluZU51bWJlciA9IGEuZW5kTGluZU51bWJlcjtcclxuICAgICAgICBsZXQgcmVzdWx0RW5kQ29sdW1uID0gYS5lbmRDb2x1bW47XHJcbiAgICAgICAgbGV0IG90aGVyU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG90aGVyU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIGxldCBvdGhlckVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG90aGVyRW5kQ29sdW1uID0gYi5lbmRDb2x1bW47XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA8IG90aGVyU3RhcnRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0TGluZU51bWJlciA9IG90aGVyU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICByZXN1bHRTdGFydENvbHVtbiA9IG90aGVyU3RhcnRDb2x1bW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gb3RoZXJTdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0U3RhcnRDb2x1bW4gPSBNYXRoLm1heChyZXN1bHRTdGFydENvbHVtbiwgb3RoZXJTdGFydENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID4gb3RoZXJFbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdEVuZExpbmVOdW1iZXIgPSBvdGhlckVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIHJlc3VsdEVuZENvbHVtbiA9IG90aGVyRW5kQ29sdW1uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXN1bHRFbmRMaW5lTnVtYmVyID09PSBvdGhlckVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgcmVzdWx0RW5kQ29sdW1uID0gTWF0aC5taW4ocmVzdWx0RW5kQ29sdW1uLCBvdGhlckVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGlvbiBpcyBub3cgZW1wdHlcclxuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID4gcmVzdWx0RW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gcmVzdWx0RW5kTGluZU51bWJlciAmJiByZXN1bHRTdGFydENvbHVtbiA+IHJlc3VsdEVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHRTdGFydExpbmVOdW1iZXIsIHJlc3VsdFN0YXJ0Q29sdW1uLCByZXN1bHRFbmRMaW5lTnVtYmVyLCByZXN1bHRFbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgZXF1YWxzIG90aGVyLlxyXG4gICAgICovXHJcbiAgICBlcXVhbHNSYW5nZShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBSYW5nZS5lcXVhbHNSYW5nZSh0aGlzLCBvdGhlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgcmFuZ2UgYGFgIGVxdWFscyBgYmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlcXVhbHNSYW5nZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuICghIWEgJiZcclxuICAgICAgICAgICAgISFiICYmXHJcbiAgICAgICAgICAgIGEuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJlxyXG4gICAgICAgICAgICBhLnN0YXJ0Q29sdW1uID09PSBiLnN0YXJ0Q29sdW1uICYmXHJcbiAgICAgICAgICAgIGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyICYmXHJcbiAgICAgICAgICAgIGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZW5kIHBvc2l0aW9uICh3aGljaCB3aWxsIGJlIGFmdGVyIG9yIGVxdWFsIHRvIHRoZSBzdGFydCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgZ2V0RW5kUG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFJhbmdlLmdldEVuZFBvc2l0aW9uKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGVuZCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBhZnRlciBvciBlcXVhbCB0byB0aGUgc3RhcnQgcG9zaXRpb24pXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRFbmRQb3NpdGlvbihyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgZ2V0U3RhcnRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbih0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzdGFydCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGVuZCBwb3NpdGlvbilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFN0YXJ0UG9zaXRpb24ocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gdG8gYSB1c2VyIHByZXNlbnRhYmxlIHN0cmluZyByZXByZXNlbnRhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuc3RhcnRMaW5lTnVtYmVyICsgJywnICsgdGhpcy5zdGFydENvbHVtbiArICcgLT4gJyArIHRoaXMuZW5kTGluZU51bWJlciArICcsJyArIHRoaXMuZW5kQ29sdW1uICsgJ10nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLCBhbmQgdXNpbmcgZW5kTGluZU51bWJlciBhbmQgZW5kQ29sdW1uIGFzIHRoZSBlbmQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHNldEVuZFBvc2l0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3MgZW5kIHBvc2l0aW9uLCBhbmQgdXNpbmcgc3RhcnRMaW5lTnVtYmVyIGFuZCBzdGFydENvbHVtbiBhcyB0aGUgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIHNldFN0YXJ0UG9zaXRpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3Mgc3RhcnQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbGxhcHNlVG9TdGFydCgpIHtcclxuICAgICAgICByZXR1cm4gUmFuZ2UuY29sbGFwc2VUb1N0YXJ0KHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29sbGFwc2VUb1N0YXJ0KHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcclxuICAgIH1cclxuICAgIC8vIC0tLVxyXG4gICAgc3RhdGljIGZyb21Qb3NpdGlvbnMoc3RhcnQsIGVuZCA9IHN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBsaWZ0KHJhbmdlKSB7XHJcbiAgICAgICAgaWYgKCFyYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUmFuZ2VgLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJUmFuZ2Uob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5lbmRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouZW5kQ29sdW1uID09PSAnbnVtYmVyJykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHRoZSB0d28gcmFuZ2VzIGFyZSB0b3VjaGluZyBpbiBhbnkgd2F5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXJlSW50ZXJzZWN0aW5nT3JUb3VjaGluZyhhLCBiKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGFgIGlzIGJlZm9yZSBgYmBcclxuICAgICAgICBpZiAoYS5lbmRMaW5lTnVtYmVyIDwgYi5zdGFydExpbmVOdW1iZXIgfHwgKGEuZW5kTGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiYgYS5lbmRDb2x1bW4gPCBiLnN0YXJ0Q29sdW1uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIGlmIGBiYCBpcyBiZWZvcmUgYGFgXHJcbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyIHx8IChiLmVuZExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyICYmIGIuZW5kQ29sdW1uIDwgYS5zdGFydENvbHVtbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHJhbmdlcyBhcmUgaW50ZXJzZWN0aW5nLiBJZiB0aGUgcmFuZ2VzIGFyZSB0b3VjaGluZyBpdCByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhcmVJbnRlcnNlY3RpbmcoYSwgYikge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGBhYCBpcyBiZWZvcmUgYGJgXHJcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA8IGIuc3RhcnRMaW5lTnVtYmVyIHx8IChhLmVuZExpbmVOdW1iZXIgPT09IGIuc3RhcnRMaW5lTnVtYmVyICYmIGEuZW5kQ29sdW1uIDw9IGIuc3RhcnRDb2x1bW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYGJgIGlzIGJlZm9yZSBgYWBcclxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIgfHwgKGIuZW5kTGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIgJiYgYi5lbmRDb2x1bW4gPD0gYS5zdGFydENvbHVtbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHJhbmdlcywgdXNlZnVsIGZvciBzb3J0aW5nIHJhbmdlc1xyXG4gICAgICogSXQgd2lsbCBmaXJzdCBjb21wYXJlIHJhbmdlcyBvbiB0aGUgc3RhcnRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgZW5kUG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmVSYW5nZXNVc2luZ1N0YXJ0cyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgJiYgYikge1xyXG4gICAgICAgICAgICBjb25zdCBhU3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBiU3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXIgfCAwO1xyXG4gICAgICAgICAgICBpZiAoYVN0YXJ0TGluZU51bWJlciA9PT0gYlN0YXJ0TGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYVN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbiB8IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiU3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uIHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChhU3RhcnRDb2x1bW4gPT09IGJTdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFFbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlciB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFFbmRMaW5lTnVtYmVyID09PSBiRW5kTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhRW5kQ29sdW1uID0gYS5lbmRDb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiRW5kQ29sdW1uID0gYi5lbmRDb2x1bW4gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUVuZENvbHVtbiAtIGJFbmRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhRW5kTGluZU51bWJlciAtIGJFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFTdGFydENvbHVtbiAtIGJTdGFydENvbHVtbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYVN0YXJ0TGluZU51bWJlciAtIGJTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFFeGlzdHMgPSAoYSA/IDEgOiAwKTtcclxuICAgICAgICBjb25zdCBiRXhpc3RzID0gKGIgPyAxIDogMCk7XHJcbiAgICAgICAgcmV0dXJuIGFFeGlzdHMgLSBiRXhpc3RzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcmFuZ2VzLCB1c2VmdWwgZm9yIHNvcnRpbmcgcmFuZ2VzXHJcbiAgICAgKiBJdCB3aWxsIGZpcnN0IGNvbXBhcmUgcmFuZ2VzIG9uIHRoZSBlbmRQb3NpdGlvbiBhbmQgdGhlbiBvbiB0aGUgc3RhcnRQb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tcGFyZVJhbmdlc1VzaW5nRW5kcyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChhLmVuZENvbHVtbiA9PT0gYi5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydENvbHVtbiAtIGIuc3RhcnRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydExpbmVOdW1iZXIgLSBiLnN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYS5lbmRDb2x1bW4gLSBiLmVuZENvbHVtbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEuZW5kTGluZU51bWJlciAtIGIuZW5kTGluZU51bWJlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiB0aGUgcmFuZ2Ugc3BhbnMgbXVsdGlwbGUgbGluZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzcGFuc011bHRpcGxlTGluZXMocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2UuZW5kTGluZU51bWJlciA+IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgTGNzRGlmZiB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2RpZmYvZGlmZi5qcyc7XHJcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XHJcbmNvbnN0IE1JTklNVU1fTUFUQ0hJTkdfQ0hBUkFDVEVSX0xFTkdUSCA9IDM7XHJcbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSwgcHJldHR5KSB7XHJcbiAgICBjb25zdCBkaWZmQWxnbyA9IG5ldyBMY3NEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSk7XHJcbiAgICByZXR1cm4gZGlmZkFsZ28uQ29tcHV0ZURpZmYocHJldHR5KTtcclxufVxyXG5jbGFzcyBMaW5lU2VxdWVuY2Uge1xyXG4gICAgY29uc3RydWN0b3IobGluZXMpIHtcclxuICAgICAgICBjb25zdCBzdGFydENvbHVtbnMgPSBbXTtcclxuICAgICAgICBjb25zdCBlbmRDb2x1bW5zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uc1tpXSA9IGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xyXG4gICAgICAgICAgICBlbmRDb2x1bW5zW2ldID0gZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKGxpbmVzW2ldLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0Q29sdW1ucyA9IHN0YXJ0Q29sdW1ucztcclxuICAgICAgICB0aGlzLl9lbmRDb2x1bW5zID0gZW5kQ29sdW1ucztcclxuICAgIH1cclxuICAgIGdldEVsZW1lbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgZWxlbWVudHNbaV0gPSB0aGlzLmxpbmVzW2ldLnN1YnN0cmluZyh0aGlzLl9zdGFydENvbHVtbnNbaV0gLSAxLCB0aGlzLl9lbmRDb2x1bW5zW2ldIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgIH1cclxuICAgIGdldFN0cmljdEVsZW1lbnQoaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tpbmRleF07XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydExpbmVOdW1iZXIoaSkge1xyXG4gICAgICAgIHJldHVybiBpICsgMTtcclxuICAgIH1cclxuICAgIGdldEVuZExpbmVOdW1iZXIoaSkge1xyXG4gICAgICAgIHJldHVybiBpICsgMTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUNoYXJTZXF1ZW5jZShzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcclxuICAgICAgICBjb25zdCBjaGFyQ29kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBsaW5lTnVtYmVycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBbXTtcclxuICAgICAgICBsZXQgbGVuID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDw9IGVuZEluZGV4OyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdGhpcy5saW5lc1tpbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fc3RhcnRDb2x1bW5zW2luZGV4XSA6IDEpO1xyXG4gICAgICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSAoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgPyB0aGlzLl9lbmRDb2x1bW5zW2luZGV4XSA6IGxpbmVDb250ZW50Lmxlbmd0aCArIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSBzdGFydENvbHVtbjsgY29sIDwgZW5kQ29sdW1uOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgY2hhckNvZGVzW2xlbl0gPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNvbCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcnNbbGVuXSA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbHVtbnNbbGVuXSA9IGNvbDtcclxuICAgICAgICAgICAgICAgIGxlbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhclNlcXVlbmNlKGNoYXJDb2RlcywgbGluZU51bWJlcnMsIGNvbHVtbnMpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENoYXJTZXF1ZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFyQ29kZXMsIGxpbmVOdW1iZXJzLCBjb2x1bW5zKSB7XHJcbiAgICAgICAgdGhpcy5fY2hhckNvZGVzID0gY2hhckNvZGVzO1xyXG4gICAgICAgIHRoaXMuX2xpbmVOdW1iZXJzID0gbGluZU51bWJlcnM7XHJcbiAgICAgICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICB9XHJcbiAgICBnZXRFbGVtZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2hhckNvZGVzO1xyXG4gICAgfVxyXG4gICAgZ2V0U3RhcnRMaW5lTnVtYmVyKGkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU51bWJlcnNbaV07XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydENvbHVtbihpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNbaV07XHJcbiAgICB9XHJcbiAgICBnZXRFbmRMaW5lTnVtYmVyKGkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU51bWJlcnNbaV07XHJcbiAgICB9XHJcbiAgICBnZXRFbmRDb2x1bW4oaSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2ldICsgMTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDaGFyQ2hhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbikge1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRDb2x1bW4gPSBvcmlnaW5hbFN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRDb2x1bW4gPSBvcmlnaW5hbEVuZENvbHVtbjtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0Q29sdW1uID0gbW9kaWZpZWRTdGFydENvbHVtbjtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkRW5kQ29sdW1uID0gbW9kaWZpZWRFbmRDb2x1bW47XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbURpZmZDaGFuZ2UoZGlmZkNoYW5nZSwgb3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlKSB7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsRW5kQ29sdW1uO1xyXG4gICAgICAgIGxldCBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRTdGFydENvbHVtbjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBtb2RpZmllZEVuZENvbHVtbjtcclxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW4gPSAwO1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBvcmlnaW5hbEVuZENvbHVtbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0U3RhcnRDb2x1bW4oZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcclxuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0RW5kQ29sdW1uKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpZmZDaGFuZ2UubW9kaWZpZWRMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0Q29sdW1uID0gMDtcclxuICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW4gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KTtcclxuICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBtb2RpZmllZEVuZENvbHVtbiA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldEVuZENvbHVtbihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ2hhckNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcykge1xyXG4gICAgaWYgKHJhd0NoYW5nZXMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICByZXR1cm4gcmF3Q2hhbmdlcztcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IFtyYXdDaGFuZ2VzWzBdXTtcclxuICAgIGxldCBwcmV2Q2hhbmdlID0gcmVzdWx0WzBdO1xyXG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjdXJyQ2hhbmdlID0gcmF3Q2hhbmdlc1tpXTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbE1hdGNoaW5nTGVuZ3RoID0gY3VyckNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gKHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgLSAocHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCk7XHJcbiAgICAgICAgLy8gQm90aCBvZiB0aGUgYWJvdmUgc2hvdWxkIGJlIGVxdWFsLCBidXQgdGhlIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSBtYXkgcHJldmVudCB0aGlzIGZyb20gYmVpbmcgdHJ1ZVxyXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nTGVuZ3RoID0gTWF0aC5taW4ob3JpZ2luYWxNYXRjaGluZ0xlbmd0aCwgbW9kaWZpZWRNYXRjaGluZ0xlbmd0aCk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nTGVuZ3RoIDwgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBjdXJyZW50IGNoYW5nZSBpbnRvIHRoZSBwcmV2aW91cyBvbmVcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9IChjdXJyQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjdXJyQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSAtIHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydDtcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IChjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjdXJyQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSAtIHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjaGFuZ2VcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyckNoYW5nZSk7XHJcbiAgICAgICAgICAgIHByZXZDaGFuZ2UgPSBjdXJyQ2hhbmdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY2xhc3MgTGluZUNoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsRW5kTGluZU51bWJlcjtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRTdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5jaGFyQ2hhbmdlcyA9IGNoYXJDaGFuZ2VzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmUmVzdWx0KHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLCBvcmlnaW5hbExpbmVTZXF1ZW5jZSwgbW9kaWZpZWRMaW5lU2VxdWVuY2UsIGNvbnRpbnVlQ2hhckRpZmYsIHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xyXG4gICAgICAgIGxldCBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcclxuICAgICAgICBsZXQgbW9kaWZpZWRFbmRMaW5lTnVtYmVyO1xyXG4gICAgICAgIGxldCBjaGFyQ2hhbmdlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQpIC0gMTtcclxuICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCk7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpIC0gMTtcclxuICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyID0gbW9kaWZpZWRMaW5lU2VxdWVuY2UuZ2V0U3RhcnRMaW5lTnVtYmVyKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XHJcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzICYmIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwICYmIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPCAyMCAmJiBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID4gMCAmJiBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIDwgMjAgJiYgY29udGludWVDaGFyRGlmZigpKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2hhcmFjdGVyIGNoYW5nZXMgZm9yIGRpZmYgY2h1bmtzIG9mIGF0IG1vc3QgMjAgbGluZXMuLi5cclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFyU2VxdWVuY2UgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCwgZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZENoYXJTZXF1ZW5jZSA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmNyZWF0ZUNoYXJTZXF1ZW5jZShzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0LCBkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIGxldCByYXdDaGFuZ2VzID0gY29tcHV0ZURpZmYob3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlLCBjb250aW51ZUNoYXJEaWZmLCB0cnVlKS5jaGFuZ2VzO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgcmF3Q2hhbmdlcyA9IHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhckNoYW5nZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNoYXJDaGFuZ2VzLnB1c2goQ2hhckNoYW5nZS5jcmVhdGVGcm9tRGlmZkNoYW5nZShyYXdDaGFuZ2VzW2ldLCBvcmlnaW5hbENoYXJTZXF1ZW5jZSwgbW9kaWZpZWRDaGFyU2VxdWVuY2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbmVDaGFuZ2Uob3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kTGluZU51bWJlciwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kTGluZU51bWJlciwgY2hhckNoYW5nZXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBEaWZmQ29tcHV0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3B0cykge1xyXG4gICAgICAgIHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzID0gb3B0cy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXM7XHJcbiAgICAgICAgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzID0gb3B0cy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgPSBvcHRzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkTWFrZVByZXR0eURpZmYgPSBvcHRzLnNob3VsZE1ha2VQcmV0dHlEaWZmO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxMaW5lcyA9IG9yaWdpbmFsTGluZXM7XHJcbiAgICAgICAgdGhpcy5tb2RpZmllZExpbmVzID0gbW9kaWZpZWRMaW5lcztcclxuICAgICAgICB0aGlzLm9yaWdpbmFsID0gbmV3IExpbmVTZXF1ZW5jZShvcmlnaW5hbExpbmVzKTtcclxuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbmV3IExpbmVTZXF1ZW5jZShtb2RpZmllZExpbmVzKTtcclxuICAgICAgICB0aGlzLmNvbnRpbnVlTGluZURpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUpO1xyXG4gICAgICAgIHRoaXMuY29udGludWVDaGFyRGlmZiA9IGNyZWF0ZUNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZShvcHRzLm1heENvbXB1dGF0aW9uVGltZSA9PT0gMCA/IDAgOiBNYXRoLm1pbihvcHRzLm1heENvbXB1dGF0aW9uVGltZSwgNTAwMCkpOyAvLyBuZXZlciBydW4gYWZ0ZXIgNXMgZm9yIGNoYXJhY3RlciBjaGFuZ2VzLi4uXHJcbiAgICB9XHJcbiAgICBjb21wdXRlRGlmZigpIHtcclxuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbC5saW5lcy5sZW5ndGggPT09IDEgJiYgdGhpcy5vcmlnaW5hbC5saW5lc1swXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgb3JpZ2luYWwgPT4gZmFzdCBwYXRoXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGlmaWVkLmxpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1vZGlmaWVkLmxpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWl0RWFybHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IFtdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBxdWl0RWFybHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogdGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDaGFuZ2VzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kQ29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlcjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1vZGlmaWVkLmxpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1vZGlmaWVkLmxpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBlbXB0eSBtb2RpZmllZCA9PiBmYXN0IHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHF1aXRFYXJseTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyOiB0aGlzLm9yaWdpbmFsLmxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNoYW5nZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRDb2x1bW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRDb2x1bW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydExpbmVOdW1iZXI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRDb2x1bW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGNvbXB1dGVEaWZmKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVMaW5lRGlmZiwgdGhpcy5zaG91bGRNYWtlUHJldHR5RGlmZik7XHJcbiAgICAgICAgY29uc3QgcmF3Q2hhbmdlcyA9IGRpZmZSZXN1bHQuY2hhbmdlcztcclxuICAgICAgICBjb25zdCBxdWl0RWFybHkgPSBkaWZmUmVzdWx0LnF1aXRFYXJseTtcclxuICAgICAgICAvLyBUaGUgZGlmZiBpcyBhbHdheXMgY29tcHV0ZWQgd2l0aCBpZ25vcmluZyB0cmltIHdoaXRlc3BhY2VcclxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZ2V0IHRoZSBwcmV0dGllc3QgZGlmZlxyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDaGFuZ2VzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lQ2hhbmdlcy5wdXNoKExpbmVDaGFuZ2UuY3JlYXRlRnJvbURpZmZSZXN1bHQodGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgcmF3Q2hhbmdlc1tpXSwgdGhpcy5vcmlnaW5hbCwgdGhpcy5tb2RpZmllZCwgdGhpcy5jb250aW51ZUNoYXJEaWZmLCB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHF1aXRFYXJseTogcXVpdEVhcmx5LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlczogbGluZUNoYW5nZXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTmVlZCB0byBwb3N0LXByb2Nlc3MgYW5kIGludHJvZHVjZSBjaGFuZ2VzIHdoZXJlIHRoZSB0cmltIHdoaXRlc3BhY2UgaXMgZGlmZmVyZW50XHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFyZSBsb29waW5nIHN0YXJ0aW5nIGF0IC0xIHRvIGFsc28gY292ZXIgdGhlIGxpbmVzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsTGluZUluZGV4ID0gMDtcclxuICAgICAgICBsZXQgbW9kaWZpZWRMaW5lSW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAtMSAvKiAhISEhICovLCBsZW4gPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFuZ2UgPSAoaSArIDEgPCBsZW4gPyByYXdDaGFuZ2VzW2kgKyAxXSA6IG51bGwpO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSAobmV4dENoYW5nZSA/IG5leHRDaGFuZ2Uub3JpZ2luYWxTdGFydCA6IHRoaXMub3JpZ2luYWxMaW5lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZFN0b3AgPSAobmV4dENoYW5nZSA/IG5leHRDaGFuZ2UubW9kaWZpZWRTdGFydCA6IHRoaXMubW9kaWZpZWRMaW5lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxMaW5lSW5kZXggPCBvcmlnaW5hbFN0b3AgJiYgbW9kaWZpZWRMaW5lSW5kZXggPCBtb2RpZmllZFN0b3ApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZSA9IHRoaXMub3JpZ2luYWxMaW5lc1tvcmlnaW5hbExpbmVJbmRleF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmUgPSB0aGlzLm1vZGlmaWVkTGluZXNbbW9kaWZpZWRMaW5lSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZSAhPT0gbW9kaWZpZWRMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgbGluZXMgZGlmZmVyIG9ubHkgaW4gdHJpbSB3aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRDb2x1bW4gPSBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZFN0YXJ0Q29sdW1uID0gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbihtb2RpZmllZExpbmUsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxTdGFydENvbHVtbiA+IDEgJiYgbW9kaWZpZWRTdGFydENvbHVtbiA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG9yaWdpbmFsU3RhcnRDb2x1bW4gLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkQ2hhciA9IG1vZGlmaWVkTGluZS5jaGFyQ29kZUF0KG1vZGlmaWVkU3RhcnRDb2x1bW4gLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydENvbHVtbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0Q29sdW1uID4gMSB8fCBtb2RpZmllZFN0YXJ0Q29sdW1uID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgMSwgb3JpZ2luYWxTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lSW5kZXggKyAxLCAxLCBtb2RpZmllZFN0YXJ0Q29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgdHJhaWxpbmcgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsRW5kQ29sdW1uID0gZ2V0TGFzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZEVuZENvbHVtbiA9IGdldExhc3ROb25CbGFua0NvbHVtbihtb2RpZmllZExpbmUsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbE1heENvbHVtbiA9IG9yaWdpbmFsTGluZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZE1heENvbHVtbiA9IG1vZGlmaWVkTGluZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxFbmRDb2x1bW4gPCBvcmlnaW5hbE1heENvbHVtbiAmJiBtb2RpZmllZEVuZENvbHVtbiA8IG1vZGlmaWVkTWF4Q29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoYXIgPSBvcmlnaW5hbExpbmUuY2hhckNvZGVBdChvcmlnaW5hbEVuZENvbHVtbiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQobW9kaWZpZWRFbmRDb2x1bW4gLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW4rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kQ29sdW1uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRW5kQ29sdW1uIDwgb3JpZ2luYWxNYXhDb2x1bW4gfHwgbW9kaWZpZWRFbmRDb2x1bW4gPCBtb2RpZmllZE1heENvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgb3JpZ2luYWxFbmRDb2x1bW4sIG9yaWdpbmFsTWF4Q29sdW1uLCBtb2RpZmllZExpbmVJbmRleCArIDEsIG1vZGlmaWVkRW5kQ29sdW1uLCBtb2RpZmllZE1heENvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENoYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgYWN0dWFsIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTGluZUNoYW5nZS5jcmVhdGVGcm9tRGlmZlJlc3VsdCh0aGlzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBuZXh0Q2hhbmdlLCB0aGlzLm9yaWdpbmFsLCB0aGlzLm1vZGlmaWVkLCB0aGlzLmNvbnRpbnVlQ2hhckRpZmYsIHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzLCB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMpKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZUluZGV4ICs9IG5leHRDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZExpbmVJbmRleCArPSBuZXh0Q2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1aXRFYXJseTogcXVpdEVhcmx5LFxyXG4gICAgICAgICAgICBjaGFuZ2VzOiByZXN1bHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lcmdlVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikpIHtcclxuICAgICAgICAgICAgLy8gTWVyZ2VkIGludG8gcHJldmlvdXNcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2hhckNoYW5nZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGNoYXJDaGFuZ2VzID0gW25ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkTGluZU51bWJlciwgY2hhckNoYW5nZXMpKTtcclxuICAgIH1cclxuICAgIF9tZXJnZVRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcclxuICAgICAgICBjb25zdCBsZW4gPSByZXN1bHQubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlID0gcmVzdWx0W2xlbiAtIDFdO1xyXG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciA9PT0gMCB8fCBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBtZXJnZSB3aXRoIGluc2VydHMvZGVsZXRlc1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciArIDEgPT09IG9yaWdpbmFsTGluZU51bWJlciAmJiBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciArIDEgPT09IG1vZGlmaWVkTGluZU51bWJlcikge1xyXG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsTGluZU51bWJlcjtcclxuICAgICAgICAgICAgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZExpbmVOdW1iZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBwcmV2Q2hhbmdlLmNoYXJDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q2hhbmdlLmNoYXJDaGFuZ2VzLnB1c2gobmV3IENoYXJDaGFuZ2Uob3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4odHh0LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KHR4dCk7XHJcbiAgICBpZiAociA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHIgKyAxO1xyXG59XHJcbmZ1bmN0aW9uIGdldExhc3ROb25CbGFua0NvbHVtbih0eHQsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgY29uc3QgciA9IHN0cmluZ3MubGFzdE5vbldoaXRlc3BhY2VJbmRleCh0eHQpO1xyXG4gICAgaWYgKHIgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByICsgMjtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUobWF4aW11bVJ1bnRpbWUpIHtcclxuICAgIGlmIChtYXhpbXVtUnVudGltZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBzdGFydFRpbWUgPCBtYXhpbXVtUnVudGltZTtcclxuICAgIH07XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1VpbnQ4KHYpIHtcclxuICAgIGlmICh2IDwgMCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKHYgPiAyNTUgLyogTUFYX1VJTlRfOCAqLykge1xyXG4gICAgICAgIHJldHVybiAyNTUgLyogTUFYX1VJTlRfOCAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB2IHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdG9VaW50MzIodikge1xyXG4gICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAodiA+IDQyOTQ5NjcyOTUgLyogTUFYX1VJTlRfMzIgKi8pIHtcclxuICAgICAgICByZXR1cm4gNDI5NDk2NzI5NSAvKiBNQVhfVUlOVF8zMiAqLztcclxuICAgIH1cclxuICAgIHJldHVybiB2IHwgMDtcclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgdG9VaW50MzIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91aW50LmpzJztcclxuZXhwb3J0IGNsYXNzIFByZWZpeFN1bUluZGV4T2ZSZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXgsIHJlbWFpbmRlcikge1xyXG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bUluZGV4T2ZSZXN1bHRCcmFuZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZW1haW5kZXIgPSByZW1haW5kZXI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFByZWZpeFN1bUNvbXB1dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgIHRoaXMucHJlZml4U3VtID0gbmV3IFVpbnQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleCA9IG5ldyBJbnQzMkFycmF5KDEpO1xyXG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IC0xO1xyXG4gICAgfVxyXG4gICAgaW5zZXJ0VmFsdWVzKGluc2VydEluZGV4LCBpbnNlcnRWYWx1ZXMpIHtcclxuICAgICAgICBpbnNlcnRJbmRleCA9IHRvVWludDMyKGluc2VydEluZGV4KTtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZXMgPSB0aGlzLnZhbHVlcztcclxuICAgICAgICBjb25zdCBvbGRQcmVmaXhTdW0gPSB0aGlzLnByZWZpeFN1bTtcclxuICAgICAgICBjb25zdCBpbnNlcnRWYWx1ZXNMZW4gPSBpbnNlcnRWYWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChpbnNlcnRWYWx1ZXNMZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShvbGRWYWx1ZXMubGVuZ3RoICsgaW5zZXJ0VmFsdWVzTGVuKTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KDAsIGluc2VydEluZGV4KSwgMCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheShpbnNlcnRJbmRleCksIGluc2VydEluZGV4ICsgaW5zZXJ0VmFsdWVzTGVuKTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQoaW5zZXJ0VmFsdWVzLCBpbnNlcnRJbmRleCk7XHJcbiAgICAgICAgaWYgKGluc2VydEluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBpbnNlcnRJbmRleCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJlZml4U3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmFsdWVzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtLnNldChvbGRQcmVmaXhTdW0uc3ViYXJyYXkoMCwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNoYW5nZVZhbHVlKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIGluZGV4ID0gdG9VaW50MzIoaW5kZXgpO1xyXG4gICAgICAgIHZhbHVlID0gdG9VaW50MzIodmFsdWUpO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlc1tpbmRleF0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZXNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKGluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xyXG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBpbmRleCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVmFsdWVzKHN0YXJ0SW5kZXgsIGNvdW50KSB7XHJcbiAgICAgICAgc3RhcnRJbmRleCA9IHRvVWludDMyKHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgIGNvdW50ID0gdG9VaW50MzIoY291bnQpO1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlcyA9IHRoaXMudmFsdWVzO1xyXG4gICAgICAgIGNvbnN0IG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4ID49IG9sZFZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF4Q291bnQgPSBvbGRWYWx1ZXMubGVuZ3RoIC0gc3RhcnRJbmRleDtcclxuICAgICAgICBpZiAoY291bnQgPj0gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgY291bnQgPSBtYXhDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkob2xkVmFsdWVzLmxlbmd0aCAtIGNvdW50KTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KDAsIHN0YXJ0SW5kZXgpLCAwKTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KHN0YXJ0SW5kZXggKyBjb3VudCksIHN0YXJ0SW5kZXgpO1xyXG4gICAgICAgIHRoaXMucHJlZml4U3VtID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmFsdWVzLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IHN0YXJ0SW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0VG90YWxTdW0oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByZWZpeFN1bSh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuICAgIGdldFByZWZpeFN1bShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gdG9VaW50MzIoaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcmVmaXhTdW0oaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgX2dldFByZWZpeFN1bShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8PSB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxO1xyXG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtWzBdID0gdGhpcy52YWx1ZXNbMF07XHJcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGluZGV4OyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1baV0gPSB0aGlzLnByZWZpeFN1bVtpIC0gMV0gKyB0aGlzLnZhbHVlc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gTWF0aC5tYXgodGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdLCBpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcclxuICAgIH1cclxuICAgIGdldEluZGV4T2Yoc3VtKSB7XHJcbiAgICAgICAgc3VtID0gTWF0aC5mbG9vcihzdW0pOyAvL0BwZXJmXHJcbiAgICAgICAgLy8gQ29tcHV0ZSBhbGwgc3VtcyAodG8gZ2V0IGEgZnVsbHkgdmFsaWQgcHJlZml4U3VtKVxyXG4gICAgICAgIHRoaXMuZ2V0VG90YWxTdW0oKTtcclxuICAgICAgICBsZXQgbG93ID0gMDtcclxuICAgICAgICBsZXQgaGlnaCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgbGV0IG1pZCA9IDA7XHJcbiAgICAgICAgbGV0IG1pZFN0b3AgPSAwO1xyXG4gICAgICAgIGxldCBtaWRTdGFydCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcbiAgICAgICAgICAgIG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgIG1pZFN0b3AgPSB0aGlzLnByZWZpeFN1bVttaWRdO1xyXG4gICAgICAgICAgICBtaWRTdGFydCA9IG1pZFN0b3AgLSB0aGlzLnZhbHVlc1ttaWRdO1xyXG4gICAgICAgICAgICBpZiAoc3VtIDwgbWlkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN1bSA+PSBtaWRTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhTdW1JbmRleE9mUmVzdWx0KG1pZCwgc3VtIC0gbWlkU3RhcnQpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyBzcGxpdExpbmVzIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IFByZWZpeFN1bUNvbXB1dGVyIH0gZnJvbSAnLi4vdmlld01vZGVsL3ByZWZpeFN1bUNvbXB1dGVyLmpzJztcclxuZXhwb3J0IGNsYXNzIE1pcnJvclRleHRNb2RlbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmksIGxpbmVzLCBlb2wsIHZlcnNpb25JZCkge1xyXG4gICAgICAgIHRoaXMuX3VyaSA9IHVyaTtcclxuICAgICAgICB0aGlzLl9saW5lcyA9IGxpbmVzO1xyXG4gICAgICAgIHRoaXMuX2VvbCA9IGVvbDtcclxuICAgICAgICB0aGlzLl92ZXJzaW9uSWQgPSB2ZXJzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gbnVsbDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGdldCB2ZXJzaW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uSWQ7XHJcbiAgICB9XHJcbiAgICBnZXRUZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRUZXh0VmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gdGhpcy5fbGluZXMuam9pbih0aGlzLl9lb2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkVGV4dFZhbHVlO1xyXG4gICAgfVxyXG4gICAgb25FdmVudHMoZSkge1xyXG4gICAgICAgIGlmIChlLmVvbCAmJiBlLmVvbCAhPT0gdGhpcy5fZW9sKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VvbCA9IGUuZW9sO1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG15IGxpbmVzXHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGUuY2hhbmdlcztcclxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdERlbGV0ZVJhbmdlKGNoYW5nZS5yYW5nZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdEluc2VydFRleHQobmV3IFBvc2l0aW9uKGNoYW5nZS5yYW5nZS5zdGFydExpbmVOdW1iZXIsIGNoYW5nZS5yYW5nZS5zdGFydENvbHVtbiksIGNoYW5nZS50ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gZS52ZXJzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gbnVsbDtcclxuICAgIH1cclxuICAgIF9lbnN1cmVMaW5lU3RhcnRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbGluZVN0YXJ0cykge1xyXG4gICAgICAgICAgICBjb25zdCBlb2xMZW5ndGggPSB0aGlzLl9lb2wubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lc0xlbmd0aCA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbGluZVN0YXJ0VmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KGxpbmVzTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRWYWx1ZXNbaV0gPSB0aGlzLl9saW5lc1tpXS5sZW5ndGggKyBlb2xMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG5ldyBQcmVmaXhTdW1Db21wdXRlcihsaW5lU3RhcnRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsIGNoYW5nZXMgdG8gYSBsaW5lJ3MgdGV4dCBnbyB0aHJvdWdoIHRoaXMgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIF9zZXRMaW5lVGV4dChsaW5lSW5kZXgsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZXNbbGluZUluZGV4XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuY2hhbmdlVmFsdWUobGluZUluZGV4LCB0aGlzLl9saW5lc1tsaW5lSW5kZXhdLmxlbmd0aCArIHRoaXMuX2VvbC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hY2NlcHREZWxldGVSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29sdW1uID09PSByYW5nZS5lbmRDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZGVsZXRlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGVsZXRlIHRleHQgb24gdGhlIGFmZmVjdGVkIGxpbmVcclxuICAgICAgICAgICAgdGhpcy5fc2V0TGluZVRleHQocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSlcclxuICAgICAgICAgICAgICAgICsgdGhpcy5fbGluZXNbcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUYWtlIHJlbWFpbmluZyB0ZXh0IG9uIGxhc3QgbGluZSBhbmQgYXBwZW5kIGl0IHRvIHJlbWFpbmluZyB0ZXh0IG9uIGZpcnN0IGxpbmVcclxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKVxyXG4gICAgICAgICAgICArIHRoaXMuX2xpbmVzW3JhbmdlLmVuZExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2UuZW5kQ29sdW1uIC0gMSkpO1xyXG4gICAgICAgIC8vIERlbGV0ZSBtaWRkbGUgbGluZXNcclxuICAgICAgICB0aGlzLl9saW5lcy5zcGxpY2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcclxuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgcHJlZml4IHN1bVxyXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLnJlbW92ZVZhbHVlcyhyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLmVuZExpbmVOdW1iZXIgLSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hY2NlcHRJbnNlcnRUZXh0KHBvc2l0aW9uLCBpbnNlcnRUZXh0KSB7XHJcbiAgICAgICAgaWYgKGluc2VydFRleHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gaW5zZXJ0XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGluc2VydExpbmVzID0gc3BsaXRMaW5lcyhpbnNlcnRUZXh0KTtcclxuICAgICAgICBpZiAoaW5zZXJ0TGluZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydGluZyB0ZXh0IG9uIG9uZSBsaW5lXHJcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHBvc2l0aW9uLmxpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1twb3NpdGlvbi5saW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKDAsIHBvc2l0aW9uLmNvbHVtbiAtIDEpXHJcbiAgICAgICAgICAgICAgICArIGluc2VydExpbmVzWzBdXHJcbiAgICAgICAgICAgICAgICArIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uIC0gMSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGVuZCBvdmVyZmxvd2luZyB0ZXh0IGZyb20gZmlyc3QgbGluZSB0byB0aGUgZW5kIG9mIHRleHQgdG8gaW5zZXJ0XHJcbiAgICAgICAgaW5zZXJ0TGluZXNbaW5zZXJ0TGluZXMubGVuZ3RoIC0gMV0gKz0gdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4gLSAxKTtcclxuICAgICAgICAvLyBEZWxldGUgb3ZlcmZsb3dpbmcgdGV4dCBmcm9tIGZpcnN0IGxpbmUgYW5kIGluc2VydCB0ZXh0IG9uIGZpcnN0IGxpbmVcclxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCBwb3NpdGlvbi5jb2x1bW4gLSAxKVxyXG4gICAgICAgICAgICArIGluc2VydExpbmVzWzBdKTtcclxuICAgICAgICAvLyBJbnNlcnQgbmV3IGxpbmVzICYgc3RvcmUgbGVuZ3Roc1xyXG4gICAgICAgIGxldCBuZXdMZW5ndGhzID0gbmV3IFVpbnQzMkFycmF5KGluc2VydExpbmVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5zZXJ0TGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fbGluZXMuc3BsaWNlKHBvc2l0aW9uLmxpbmVOdW1iZXIgKyBpIC0gMSwgMCwgaW5zZXJ0TGluZXNbaV0pO1xyXG4gICAgICAgICAgICBuZXdMZW5ndGhzW2kgLSAxXSA9IGluc2VydExpbmVzW2ldLmxlbmd0aCArIHRoaXMuX2VvbC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9saW5lU3RhcnRzKSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuaW5zZXJ0VmFsdWVzKHBvc2l0aW9uLmxpbmVOdW1iZXIsIG5ld0xlbmd0aHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGNvbnN0IFVTVUFMX1dPUkRfU0VQQVJBVE9SUyA9ICdgfiFAIyQlXiYqKCktPStbe119XFxcXHw7OlxcJ1wiLC48Pi8/JztcclxuLyoqXHJcbiAqIENyZWF0ZSBhIHdvcmQgZGVmaW5pdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gYmFzZWQgb24gZGVmYXVsdCB3b3JkIHNlcGFyYXRvcnMuXHJcbiAqIE9wdGlvbmFsbHkgcHJvdmlkZSBhbGxvd2VkIHNlcGFyYXRvcnMgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gd29yZHMuXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IHdvdWxkIGxvb2sgbGlrZSB0aGlzOlxyXG4gKiAvKC0/XFxkKlxcLlxcZFxcdyopfChbXlxcYFxcflxcIVxcQFxcI1xcJFxcJVxcXlxcJlxcKlxcKFxcKVxcLVxcPVxcK1xcW1xce1xcXVxcfVxcXFxcXHxcXDtcXDpcXCdcXFwiXFwsXFwuXFw8XFw+XFwvXFw/XFxzXSspL2dcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdvcmRSZWdFeHAoYWxsb3dJbldvcmRzID0gJycpIHtcclxuICAgIGxldCBzb3VyY2UgPSAnKC0/XFxcXGQqXFxcXC5cXFxcZFxcXFx3Kil8KFteJztcclxuICAgIGZvciAoY29uc3Qgc2VwIG9mIFVTVUFMX1dPUkRfU0VQQVJBVE9SUykge1xyXG4gICAgICAgIGlmIChhbGxvd0luV29yZHMuaW5kZXhPZihzZXApID49IDApIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZSArPSAnXFxcXCcgKyBzZXA7XHJcbiAgICB9XHJcbiAgICBzb3VyY2UgKz0gJ1xcXFxzXSspJztcclxuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgJ2cnKTtcclxufVxyXG4vLyBjYXRjaGVzIG51bWJlcnMgKGluY2x1ZGluZyBmbG9hdGluZyBudW1iZXJzKSBpbiB0aGUgZmlyc3QgZ3JvdXAsIGFuZCBhbHBoYW51bSBpbiB0aGUgc2Vjb25kXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dPUkRfUkVHRVhQID0gY3JlYXRlV29yZFJlZ0V4cCgpO1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbikge1xyXG4gICAgbGV0IHJlc3VsdCA9IERFRkFVTFRfV09SRF9SRUdFWFA7XHJcbiAgICBpZiAod29yZERlZmluaXRpb24gJiYgKHdvcmREZWZpbml0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG4gICAgICAgIGlmICghd29yZERlZmluaXRpb24uZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgIGxldCBmbGFncyA9ICdnJztcclxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLmlnbm9yZUNhc2UpIHtcclxuICAgICAgICAgICAgICAgIGZsYWdzICs9ICdpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod29yZERlZmluaXRpb24ubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBmbGFncyArPSAnbSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLnVuaWNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHdvcmREZWZpbml0aW9uLnNvdXJjZSwgZmxhZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gd29yZERlZmluaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IDA7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IF9kZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgbWF4TGVuOiAxMDAwLFxyXG4gICAgd2luZG93U2l6ZTogMTUsXHJcbiAgICB0aW1lQnVkZ2V0OiAxNTBcclxufTtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRBdFRleHQoY29sdW1uLCB3b3JkRGVmaW5pdGlvbiwgdGV4dCwgdGV4dE9mZnNldCwgY29uZmlnID0gX2RlZmF1bHRDb25maWcpIHtcclxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IGNvbmZpZy5tYXhMZW4pIHtcclxuICAgICAgICAvLyBkb24ndCB0aHJvdyBzdHJpbmdzIHRoYXQgbG9uZyBhdCB0aGUgcmVnZXhwXHJcbiAgICAgICAgLy8gYnV0IHVzZSBhIHN1Yi1zdHJpbmcgaW4gd2hpY2ggYSB3b3JkIG11c3Qgb2NjdXJcclxuICAgICAgICBsZXQgc3RhcnQgPSBjb2x1bW4gLSBjb25maWcubWF4TGVuIC8gMjtcclxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRleHRPZmZzZXQgKz0gc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgY29sdW1uICsgY29uZmlnLm1heExlbiAvIDIpO1xyXG4gICAgICAgIHJldHVybiBnZXRXb3JkQXRUZXh0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQsIGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0MSA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBwb3MgPSBjb2x1bW4gLSAxIC0gdGV4dE9mZnNldDtcclxuICAgIGxldCBwcmV2UmVnZXhJbmRleCA9IC0xO1xyXG4gICAgbGV0IG1hdGNoID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSAxOzsgaSsrKSB7XHJcbiAgICAgICAgLy8gY2hlY2sgdGltZSBidWRnZXRcclxuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHQxID49IGNvbmZpZy50aW1lQnVkZ2V0KSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIHJlZ2V4cCBzaG91bGQgc3RhcnQgbWF0Y2hpbmcsIGFsc28ga25vdyB3aGVyZSBpdFxyXG4gICAgICAgIC8vIHNob3VsZCBzdG9wIHNvIHRoYXQgc3Vic2VxdWVudCBzZWFyY2ggZG9uJ3QgcmVwZWF0IHByZXZpb3VzIHNlYXJjaGVzXHJcbiAgICAgICAgY29uc3QgcmVnZXhJbmRleCA9IHBvcyAtIGNvbmZpZy53aW5kb3dTaXplICogaTtcclxuICAgICAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSBNYXRoLm1heCgwLCByZWdleEluZGV4KTtcclxuICAgICAgICBjb25zdCB0aGlzTWF0Y2ggPSBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBwcmV2UmVnZXhJbmRleCk7XHJcbiAgICAgICAgaWYgKCF0aGlzTWF0Y2ggJiYgbWF0Y2gpIHtcclxuICAgICAgICAgICAgLy8gc3RvcDogd2UgaGF2ZSBzb21ldGhpbmdcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hdGNoID0gdGhpc01hdGNoO1xyXG4gICAgICAgIC8vIHN0b3A6IHNlYXJjaGVkIGF0IHN0YXJ0XHJcbiAgICAgICAgaWYgKHJlZ2V4SW5kZXggPD0gMCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldlJlZ2V4SW5kZXggPSByZWdleEluZGV4O1xyXG4gICAgfVxyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgd29yZDogbWF0Y2hbMF0sXHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiB0ZXh0T2Zmc2V0ICsgMSArIG1hdGNoLmluZGV4LFxyXG4gICAgICAgICAgICBlbmRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcclxuICAgICAgICB9O1xyXG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIF9maW5kUmVnZXhNYXRjaEVuY2xvc2luZ1Bvc2l0aW9uKHdvcmREZWZpbml0aW9uLCB0ZXh0LCBwb3MsIHN0b3BQb3MpIHtcclxuICAgIGxldCBtYXRjaDtcclxuICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWModGV4dCkpIHtcclxuICAgICAgICBjb25zdCBtYXRjaEluZGV4ID0gbWF0Y2guaW5kZXggfHwgMDtcclxuICAgICAgICBpZiAobWF0Y2hJbmRleCA8PSBwb3MgJiYgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID49IHBvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0b3BQb3MgPiAwICYmIG1hdGNoSW5kZXggPiBzdG9wUG9zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5pbXBvcnQgeyB0b1VpbnQ4IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdWludC5qcyc7XHJcbi8qKlxyXG4gKiBBIGZhc3QgY2hhcmFjdGVyIGNsYXNzaWZpZXIgdGhhdCB1c2VzIGEgY29tcGFjdCBhcnJheSBmb3IgQVNDSUkgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENoYXJhY3RlckNsYXNzaWZpZXIge1xyXG4gICAgY29uc3RydWN0b3IoX2RlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGxldCBkZWZhdWx0VmFsdWUgPSB0b1VpbnQ4KF9kZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB0aGlzLl9hc2NpaU1hcCA9IENoYXJhY3RlckNsYXNzaWZpZXIuX2NyZWF0ZUFzY2lpTWFwKGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIF9jcmVhdGVBc2NpaU1hcChkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBsZXQgYXNjaWlNYXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgYXNjaWlNYXBbaV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc2NpaU1hcDtcclxuICAgIH1cclxuICAgIHNldChjaGFyQ29kZSwgX3ZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdG9VaW50OChfdmFsdWUpO1xyXG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAwICYmIGNoYXJDb2RlIDwgMjU2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FzY2lpTWFwW2NoYXJDb2RlXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChjaGFyQ29kZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldChjaGFyQ29kZSkge1xyXG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAwICYmIGNoYXJDb2RlIDwgMjU2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc2NpaU1hcFtjaGFyQ29kZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX21hcC5nZXQoY2hhckNvZGUpIHx8IHRoaXMuX2RlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJTZXQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gbmV3IENoYXJhY3RlckNsYXNzaWZpZXIoMCAvKiBGYWxzZSAqLyk7XHJcbiAgICB9XHJcbiAgICBhZGQoY2hhckNvZGUpIHtcclxuICAgICAgICB0aGlzLl9hY3R1YWwuc2V0KGNoYXJDb2RlLCAxIC8qIFRydWUgKi8pO1xyXG4gICAgfVxyXG4gICAgaGFzKGNoYXJDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hY3R1YWwuZ2V0KGNoYXJDb2RlKSA9PT0gMSAvKiBUcnVlICovKTtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgQ2hhcmFjdGVyQ2xhc3NpZmllciB9IGZyb20gJy4uL2NvcmUvY2hhcmFjdGVyQ2xhc3NpZmllci5qcyc7XHJcbmV4cG9ydCBjbGFzcyBVaW50OE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihyb3dzLCBjb2xzLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocm93cyAqIGNvbHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByb3dzICogY29sczsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XHJcbiAgICAgICAgdGhpcy5jb2xzID0gY29scztcclxuICAgIH1cclxuICAgIGdldChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhW3JvdyAqIHRoaXMuY29scyArIGNvbF07XHJcbiAgICB9XHJcbiAgICBzZXQocm93LCBjb2wsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZGF0YVtyb3cgKiB0aGlzLmNvbHMgKyBjb2xdID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFN0YXRlTWFjaGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlZGdlcykge1xyXG4gICAgICAgIGxldCBtYXhDaGFyQ29kZSA9IDA7XHJcbiAgICAgICAgbGV0IG1heFN0YXRlID0gMCAvKiBJbnZhbGlkICovO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlZGdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgW2Zyb20sIGNoQ29kZSwgdG9dID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChjaENvZGUgPiBtYXhDaGFyQ29kZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4Q2hhckNvZGUgPSBjaENvZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZyb20gPiBtYXhTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4U3RhdGUgPSBmcm9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0byA+IG1heFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhTdGF0ZSA9IHRvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1heENoYXJDb2RlKys7XHJcbiAgICAgICAgbWF4U3RhdGUrKztcclxuICAgICAgICBsZXQgc3RhdGVzID0gbmV3IFVpbnQ4TWF0cml4KG1heFN0YXRlLCBtYXhDaGFyQ29kZSwgMCAvKiBJbnZhbGlkICovKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWRnZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IFtmcm9tLCBjaENvZGUsIHRvXSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgICAgICBzdGF0ZXMuc2V0KGZyb20sIGNoQ29kZSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSBzdGF0ZXM7XHJcbiAgICAgICAgdGhpcy5fbWF4Q2hhckNvZGUgPSBtYXhDaGFyQ29kZTtcclxuICAgIH1cclxuICAgIG5leHRTdGF0ZShjdXJyZW50U3RhdGUsIGNoQ29kZSkge1xyXG4gICAgICAgIGlmIChjaENvZGUgPCAwIHx8IGNoQ29kZSA+PSB0aGlzLl9tYXhDaGFyQ29kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJbnZhbGlkICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmdldChjdXJyZW50U3RhdGUsIGNoQ29kZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gU3RhdGUgbWFjaGluZSBmb3IgaHR0cDovLyBvciBodHRwczovLyBvciBmaWxlOi8vXHJcbmxldCBfc3RhdGVNYWNoaW5lID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0U3RhdGVNYWNoaW5lKCkge1xyXG4gICAgaWYgKF9zdGF0ZU1hY2hpbmUgPT09IG51bGwpIHtcclxuICAgICAgICBfc3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZShbXHJcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCAxMDQgLyogaCAqLywgMiAvKiBIICovXSxcclxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDcyIC8qIEggKi8sIDIgLyogSCAqL10sXHJcbiAgICAgICAgICAgIFsxIC8qIFN0YXJ0ICovLCAxMDIgLyogZiAqLywgNiAvKiBGICovXSxcclxuICAgICAgICAgICAgWzEgLyogU3RhcnQgKi8sIDcwIC8qIEYgKi8sIDYgLyogRiAqL10sXHJcbiAgICAgICAgICAgIFsyIC8qIEggKi8sIDExNiAvKiB0ICovLCAzIC8qIEhUICovXSxcclxuICAgICAgICAgICAgWzIgLyogSCAqLywgODQgLyogVCAqLywgMyAvKiBIVCAqL10sXHJcbiAgICAgICAgICAgIFszIC8qIEhUICovLCAxMTYgLyogdCAqLywgNCAvKiBIVFQgKi9dLFxyXG4gICAgICAgICAgICBbMyAvKiBIVCAqLywgODQgLyogVCAqLywgNCAvKiBIVFQgKi9dLFxyXG4gICAgICAgICAgICBbNCAvKiBIVFQgKi8sIDExMiAvKiBwICovLCA1IC8qIEhUVFAgKi9dLFxyXG4gICAgICAgICAgICBbNCAvKiBIVFQgKi8sIDgwIC8qIFAgKi8sIDUgLyogSFRUUCAqL10sXHJcbiAgICAgICAgICAgIFs1IC8qIEhUVFAgKi8sIDExNSAvKiBzICovLCA5IC8qIEJlZm9yZUNvbG9uICovXSxcclxuICAgICAgICAgICAgWzUgLyogSFRUUCAqLywgODMgLyogUyAqLywgOSAvKiBCZWZvcmVDb2xvbiAqL10sXHJcbiAgICAgICAgICAgIFs1IC8qIEhUVFAgKi8sIDU4IC8qIENvbG9uICovLCAxMCAvKiBBZnRlckNvbG9uICovXSxcclxuICAgICAgICAgICAgWzYgLyogRiAqLywgMTA1IC8qIGkgKi8sIDcgLyogRkkgKi9dLFxyXG4gICAgICAgICAgICBbNiAvKiBGICovLCA3MyAvKiBJICovLCA3IC8qIEZJICovXSxcclxuICAgICAgICAgICAgWzcgLyogRkkgKi8sIDEwOCAvKiBsICovLCA4IC8qIEZJTCAqL10sXHJcbiAgICAgICAgICAgIFs3IC8qIEZJICovLCA3NiAvKiBMICovLCA4IC8qIEZJTCAqL10sXHJcbiAgICAgICAgICAgIFs4IC8qIEZJTCAqLywgMTAxIC8qIGUgKi8sIDkgLyogQmVmb3JlQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbOCAvKiBGSUwgKi8sIDY5IC8qIEUgKi8sIDkgLyogQmVmb3JlQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbOSAvKiBCZWZvcmVDb2xvbiAqLywgNTggLyogQ29sb24gKi8sIDEwIC8qIEFmdGVyQ29sb24gKi9dLFxyXG4gICAgICAgICAgICBbMTAgLyogQWZ0ZXJDb2xvbiAqLywgNDcgLyogU2xhc2ggKi8sIDExIC8qIEFsbW9zdFRoZXJlICovXSxcclxuICAgICAgICAgICAgWzExIC8qIEFsbW9zdFRoZXJlICovLCA0NyAvKiBTbGFzaCAqLywgMTIgLyogRW5kICovXSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfc3RhdGVNYWNoaW5lO1xyXG59XHJcbmxldCBfY2xhc3NpZmllciA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldENsYXNzaWZpZXIoKSB7XHJcbiAgICBpZiAoX2NsYXNzaWZpZXIgPT09IG51bGwpIHtcclxuICAgICAgICBfY2xhc3NpZmllciA9IG5ldyBDaGFyYWN0ZXJDbGFzc2lmaWVyKDAgLyogTm9uZSAqLyk7XHJcbiAgICAgICAgY29uc3QgRk9SQ0VfVEVSTUlOQVRJT05fQ0hBUkFDVEVSUyA9ICcgXFx0PD5cXCdcXFwi44CB44CC772h772k77yM77yO77ya77yb4oCY44CI44CM44CO44CU77yI77y7772b772i772j772d77y977yJ44CV44CP44CN44CJ4oCZ772A772e4oCmJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2NsYXNzaWZpZXIuc2V0KEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMuY2hhckNvZGVBdChpKSwgMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMgPSAnLiw7JztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENBTk5PVF9FTkRfV0lUSF9DSEFSQUNURVJTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9jbGFzc2lmaWVyLnNldChDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUy5jaGFyQ29kZUF0KGkpLCAyIC8qIENhbm5vdEVuZEluICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2NsYXNzaWZpZXI7XHJcbn1cclxuZXhwb3J0IGNsYXNzIExpbmtDb21wdXRlciB7XHJcbiAgICBzdGF0aWMgX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgbGluZU51bWJlciwgbGlua0JlZ2luSW5kZXgsIGxpbmtFbmRJbmRleCkge1xyXG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyB0byBlbmQgbGluayBpbiBjZXJ0YWluIGNoYXJhY3RlcnMuLi5cclxuICAgICAgICBsZXQgbGFzdEluY2x1ZGVkQ2hhckluZGV4ID0gbGlua0VuZEluZGV4IC0gMTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChsYXN0SW5jbHVkZWRDaGFySW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcclxuICAgICAgICAgICAgaWYgKGNoQ2xhc3MgIT09IDIgLyogQ2Fubm90RW5kSW4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RJbmNsdWRlZENoYXJJbmRleC0tO1xyXG4gICAgICAgIH0gd2hpbGUgKGxhc3RJbmNsdWRlZENoYXJJbmRleCA+IGxpbmtCZWdpbkluZGV4KTtcclxuICAgICAgICAvLyBIYW5kbGUgbGlua3MgZW5jbG9zZWQgaW4gcGFyZW5zLCBzcXVhcmUgYnJhY2tldHMgYW5kIGN1cmx5cy5cclxuICAgICAgICBpZiAobGlua0JlZ2luSW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlQmVmb3JlTGluayA9IGxpbmUuY2hhckNvZGVBdChsaW5rQmVnaW5JbmRleCAtIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0Q2hhckNvZGVJbkxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGFzdEluY2x1ZGVkQ2hhckluZGV4KTtcclxuICAgICAgICAgICAgaWYgKChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDQwIC8qIE9wZW5QYXJlbiAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDQxIC8qIENsb3NlUGFyZW4gKi8pXHJcbiAgICAgICAgICAgICAgICB8fCAoY2hhckNvZGVCZWZvcmVMaW5rID09PSA5MSAvKiBPcGVuU3F1YXJlQnJhY2tldCAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDkzIC8qIENsb3NlU3F1YXJlQnJhY2tldCAqLylcclxuICAgICAgICAgICAgICAgIHx8IChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDEyMyAvKiBPcGVuQ3VybHlCcmFjZSAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDEyNSAvKiBDbG9zZUN1cmx5QnJhY2UgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZW5kIGluICkgaWYgKCBpcyBiZWZvcmUgdGhlIGxpbmsgc3RhcnRcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBlbmQgaW4gXSBpZiBbIGlzIGJlZm9yZSB0aGUgbGluayBzdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGVuZCBpbiB9IGlmIHsgaXMgYmVmb3JlIHRoZSBsaW5rIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBsYXN0SW5jbHVkZWRDaGFySW5kZXgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IGxpbmtCZWdpbkluZGV4ICsgMSxcclxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGxhc3RJbmNsdWRlZENoYXJJbmRleCArIDJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXJsOiBsaW5lLnN1YnN0cmluZyhsaW5rQmVnaW5JbmRleCwgbGFzdEluY2x1ZGVkQ2hhckluZGV4ICsgMSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXB1dGVMaW5rcyhtb2RlbCwgc3RhdGVNYWNoaW5lID0gZ2V0U3RhdGVNYWNoaW5lKCkpIHtcclxuICAgICAgICBjb25zdCBjbGFzc2lmaWVyID0gZ2V0Q2xhc3NpZmllcigpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMSwgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7IGkgPD0gbGluZUNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IG1vZGVsLmdldExpbmVDb250ZW50KGkpO1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGogPSAwO1xyXG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBsZXQgbGlua0JlZ2luQ2hDb2RlID0gMDtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gMSAvKiBTdGFydCAqLztcclxuICAgICAgICAgICAgbGV0IGhhc09wZW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGhhc09wZW5TcXVhcmVCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBpblNxdWFyZUJyYWNrZXRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzZXRTdGF0ZU1hY2hpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoQ29kZSA9IGxpbmUuY2hhckNvZGVBdChqKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogQWNjZXB0ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaENvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MCAvKiBPcGVuUGFyZW4gKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuUGFyZW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIE5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MSAvKiBDbG9zZVBhcmVuICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuUGFyZW5zID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkxIC8qIE9wZW5TcXVhcmVCcmFja2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBOb25lICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTMgLyogQ2xvc2VTcXVhcmVCcmFja2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuU3F1YXJlQnJhY2tldCA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjMgLyogT3BlbkN1cmx5QnJhY2UgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIE5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjUgLyogQ2xvc2VDdXJseUJyYWNlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChoYXNPcGVuQ3VybHlCcmFja2V0ID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgZm9sbG93aW5nIHRocmVlIHJ1bGVzIG1ha2UgaXQgdGhhdCAnIG9yIFwiIG9yIGAgYXJlIGFsbG93ZWQgaW5zaWRlIGxpbmtzIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYSBkaWZmZXJlbnQgb25lICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzkgLyogU2luZ2xlUXVvdGUgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGxpbmtCZWdpbkNoQ29kZSA9PT0gMzQgLyogRG91YmxlUXVvdGUgKi8gfHwgbGlua0JlZ2luQ2hDb2RlID09PSA5NiAvKiBCYWNrVGljayAqLykgPyAwIC8qIE5vbmUgKi8gOiAxIC8qIEZvcmNlVGVybWluYXRpb24gKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNCAvKiBEb3VibGVRdW90ZSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAobGlua0JlZ2luQ2hDb2RlID09PSAzOSAvKiBTaW5nbGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDk2IC8qIEJhY2tUaWNrICovKSA/IDAgLyogTm9uZSAqLyA6IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk2IC8qIEJhY2tUaWNrICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDM5IC8qIFNpbmdsZVF1b3RlICovIHx8IGxpbmtCZWdpbkNoQ29kZSA9PT0gMzQgLyogRG91YmxlUXVvdGUgKi8pID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDIgLyogQXN0ZXJpc2sgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgKmAgdGVybWluYXRlcyBhIGxpbmsgaWYgdGhlIGxpbmsgYmVnYW4gd2l0aCBgKmBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAobGlua0JlZ2luQ2hDb2RlID09PSA0MiAvKiBBc3RlcmlzayAqLykgPyAxIC8qIEZvcmNlVGVybWluYXRpb24gKi8gOiAwIC8qIE5vbmUgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjQgLyogUGlwZSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGB8YCB0ZXJtaW5hdGVzIGEgbGluayBpZiB0aGUgbGluayBiZWdhbiB3aXRoIGB8YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDEyNCAvKiBQaXBlICovKSA/IDEgLyogRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogTm9uZSAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMyIC8qIFNwYWNlICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYCBgIGFsbG93IHNwYWNlIGluIGJldHdlZW4gWyBhbmQgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChpblNxdWFyZUJyYWNrZXRzID8gMCAvKiBOb25lICovIDogMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hDbGFzcyA9PT0gMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmtDb21wdXRlci5fY3JlYXRlTGluayhjbGFzc2lmaWVyLCBsaW5lLCBpLCBsaW5rQmVnaW5JbmRleCwgaikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEyIC8qIEVuZCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaENsYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENvZGUgPT09IDkxIC8qIE9wZW5TcXVhcmVCcmFja2V0ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGZvciB0aGUgYXV0aG9yaXR5IHBhcnQgdG8gY29udGFpbiBpcHY2IGFkZHJlc3NlcyB3aGljaCBjb250YWluIFsgYW5kIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlblNxdWFyZUJyYWNrZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBOb25lICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IGNsYXNzaWZpZXIuZ2V0KGNoQ29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hDbGFzcyA9PT0gMSAvKiBGb3JjZVRlcm1pbmF0aW9uICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTMgLyogQWNjZXB0ICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVNYWNoaW5lLm5leHRTdGF0ZShzdGF0ZSwgY2hDb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDAgLyogSW52YWxpZCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0U3RhdGVNYWNoaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFN0YXJ0ICovO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc09wZW5DdXJseUJyYWNrZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgd2hlcmUgdGhlIGxpbmsgc3RhcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkluZGV4ID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlua0JlZ2luQ2hDb2RlID0gY2hDb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMTMgLyogQWNjZXB0ICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgaSwgbGlua0JlZ2luSW5kZXgsIGxlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGxpbmtzIGNvbnRhaW5zIGluIHRoZSBwcm92aWRlZFxyXG4gKiBkb2N1bWVudC4gKk5vdGUqIHRoYXQgdGhpcyBvcGVyYXRpb24gaXMgY29tcHV0YXRpb25hbFxyXG4gKiBleHBlbnNpdmUgYW5kIHNob3VsZCBub3QgcnVuIGluIHRoZSBVSSB0aHJlYWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUxpbmtzKG1vZGVsKSB7XHJcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbC5nZXRMaW5lQ291bnQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG1vZGVsLmdldExpbmVDb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gVW5rbm93biBjYWxsZXIhXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIExpbmtDb21wdXRlci5jb21wdXRlTGlua3MobW9kZWwpO1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5leHBvcnQgY2xhc3MgQmFzaWNJbnBsYWNlUmVwbGFjZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTZXQgPSBbXHJcbiAgICAgICAgICAgIFsndHJ1ZScsICdmYWxzZSddLFxyXG4gICAgICAgICAgICBbJ1RydWUnLCAnRmFsc2UnXSxcclxuICAgICAgICAgICAgWydQcml2YXRlJywgJ1B1YmxpYycsICdGcmllbmQnLCAnUmVhZE9ubHknLCAnUGFydGlhbCcsICdQcm90ZWN0ZWQnLCAnV3JpdGVPbmx5J10sXHJcbiAgICAgICAgICAgIFsncHVibGljJywgJ3Byb3RlY3RlZCcsICdwcml2YXRlJ10sXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIG5hdmlnYXRlVmFsdWVTZXQocmFuZ2UxLCB0ZXh0MSwgcmFuZ2UyLCB0ZXh0MiwgdXApIHtcclxuICAgICAgICBpZiAocmFuZ2UxICYmIHRleHQxKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0MSwgdXApO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZTEsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFuZ2UyICYmIHRleHQyKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0MiwgdXApO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZTIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGRvTmF2aWdhdGVWYWx1ZVNldCh0ZXh0LCB1cCkge1xyXG4gICAgICAgIGxldCBudW1iZXJSZXN1bHQgPSB0aGlzLm51bWJlclJlcGxhY2UodGV4dCwgdXApO1xyXG4gICAgICAgIGlmIChudW1iZXJSZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlclJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFJlcGxhY2UodGV4dCwgdXApO1xyXG4gICAgfVxyXG4gICAgbnVtYmVyUmVwbGFjZSh2YWx1ZSwgdXApIHtcclxuICAgICAgICBsZXQgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHZhbHVlLmxlbmd0aCAtICh2YWx1ZS5sYXN0SW5kZXhPZignLicpICsgMSkpO1xyXG4gICAgICAgIGxldCBuMSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgbGV0IG4yID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFpc05hTihuMSkgJiYgIWlzTmFOKG4yKSAmJiBuMSA9PT0gbjIpIHtcclxuICAgICAgICAgICAgaWYgKG4xID09PSAwICYmICF1cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IGRvIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAvL1x0XHRcdH0gZWxzZSBpZihuMSA9PT0gOSAmJiB1cCkge1xyXG4gICAgICAgICAgICAgICAgLy9cdFx0XHRcdHJldHVybiBudWxsOyAvLyBkb24ndCBpbnNlcnQgMTAgaW50byBhIG51bWJlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbjEgPSBNYXRoLmZsb29yKG4xICogcHJlY2lzaW9uKTtcclxuICAgICAgICAgICAgICAgIG4xICs9IHVwID8gcHJlY2lzaW9uIDogLXByZWNpc2lvbjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcobjEgLyBwcmVjaXNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdGV4dFJlcGxhY2UodmFsdWUsIHVwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXRzUmVwbGFjZSh0aGlzLl9kZWZhdWx0VmFsdWVTZXQsIHZhbHVlLCB1cCk7XHJcbiAgICB9XHJcbiAgICB2YWx1ZVNldHNSZXBsYWNlKHZhbHVlU2V0cywgdmFsdWUsIHVwKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlU2V0cy5sZW5ndGg7IHJlc3VsdCA9PT0gbnVsbCAmJiBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52YWx1ZVNldFJlcGxhY2UodmFsdWVTZXRzW2ldLCB2YWx1ZSwgdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdmFsdWVTZXRSZXBsYWNlKHZhbHVlU2V0LCB2YWx1ZSwgdXApIHtcclxuICAgICAgICBsZXQgaWR4ID0gdmFsdWVTZXQuaW5kZXhPZih2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGlkeCArPSB1cCA/ICsxIDogLTE7XHJcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZHggPSB2YWx1ZVNldC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWR4ICU9IHZhbHVlU2V0Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVTZXRbaWR4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRSA9IG5ldyBCYXNpY0lucGxhY2VSZXBsYWNlKCk7XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5jbGFzcyBOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbk5vZGUuVW5kZWZpbmVkID0gbmV3IE5vZGUodW5kZWZpbmVkKTtcclxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyc3QgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9sYXN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZmlyc3Q7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgdW5zaGlmdChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChlbGVtZW50LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KGVsZW1lbnQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgX2luc2VydChlbGVtZW50LCBhdFRoZUVuZCkge1xyXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZShlbGVtZW50KTtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IG5ld05vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGF0VGhlRW5kKSB7XHJcbiAgICAgICAgICAgIC8vIHB1c2hcclxuICAgICAgICAgICAgY29uc3Qgb2xkTGFzdCA9IHRoaXMuX2xhc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICBuZXdOb2RlLnByZXYgPSBvbGRMYXN0O1xyXG4gICAgICAgICAgICBvbGRMYXN0Lm5leHQgPSBuZXdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdW5zaGlmdFxyXG4gICAgICAgICAgICBjb25zdCBvbGRGaXJzdCA9IHRoaXMuX2ZpcnN0O1xyXG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IG9sZEZpcnN0O1xyXG4gICAgICAgICAgICBvbGRGaXJzdC5wcmV2ID0gbmV3Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2l6ZSArPSAxO1xyXG4gICAgICAgIGxldCBkaWRSZW1vdmUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRpZFJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgZGlkUmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShuZXdOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzaGlmdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLl9maXJzdC5lbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGhpcy5fZmlyc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGFzdCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX2xhc3QuZWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMuX2xhc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW1vdmUobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnByZXYgIT09IE5vZGUuVW5kZWZpbmVkICYmIG5vZGUubmV4dCAhPT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gbWlkZGxlXHJcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgYW5jaG9yLm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gYW5jaG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnByZXYgPT09IE5vZGUuVW5kZWZpbmVkICYmIG5vZGUubmV4dCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gb25seSBub2RlXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBsYXN0XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSB0aGlzLl9sYXN0LnByZXY7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3QubmV4dCA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnByZXYgPT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fZmlyc3QubmV4dDtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3QucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkb25lXHJcbiAgICAgICAgdGhpcy5fc2l6ZSAtPSAxO1xyXG4gICAgfVxyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZmlyc3Q7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUuZWxlbWVudDtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcclxuY29uc3QgaGFzUGVyZm9ybWFuY2VOb3cgPSAoZ2xvYmFscy5wZXJmb3JtYW5jZSAmJiB0eXBlb2YgZ2xvYmFscy5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpO1xyXG5leHBvcnQgY2xhc3MgU3RvcFdhdGNoIHtcclxuICAgIGNvbnN0cnVjdG9yKGhpZ2hSZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5faGlnaFJlc29sdXRpb24gPSBoYXNQZXJmb3JtYW5jZU5vdyAmJiBoaWdoUmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLl9ub3coKTtcclxuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IC0xO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZShoaWdoUmVzb2x1dGlvbiA9IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFN0b3BXYXRjaChoaWdoUmVzb2x1dGlvbik7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BUaW1lID0gdGhpcy5fbm93KCk7XHJcbiAgICB9XHJcbiAgICBlbGFwc2VkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdG9wVGltZSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1lIC0gdGhpcy5fc3RhcnRUaW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fbm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XHJcbiAgICB9XHJcbiAgICBfbm93KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdoUmVzb2x1dGlvbiA/IGdsb2JhbHMucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IG9uVW5leHBlY3RlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xyXG5pbXBvcnQgeyBEaXNwb3NhYmxlLCBjb21iaW5lZERpc3Bvc2FibGUsIERpc3Bvc2FibGVTdG9yZSwgdG9EaXNwb3NhYmxlIH0gZnJvbSAnLi9saWZlY3ljbGUuanMnO1xyXG5pbXBvcnQgeyBMaW5rZWRMaXN0IH0gZnJvbSAnLi9saW5rZWRMaXN0LmpzJztcclxuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi9zdG9wd2F0Y2guanMnO1xyXG5leHBvcnQgdmFyIEV2ZW50O1xyXG4oZnVuY3Rpb24gKEV2ZW50KSB7XHJcbiAgICBFdmVudC5Ob25lID0gKCkgPT4gRGlzcG9zYWJsZS5Ob25lO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyBhbm90aGVyIGV2ZW50IHdoaWNoIG9ubHkgZmlyZXMgb25jZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25jZShldmVudCkge1xyXG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IHtcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzLCBpbiBjYXNlIHRoZSBldmVudCBmaXJlcyBkdXJpbmcgdGhlIGxpc3RlbmVyIGNhbGxcclxuICAgICAgICAgICAgbGV0IGRpZEZpcmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZXZlbnQoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlkRmlyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkaWRGaXJlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgICAgICBpZiAoZGlkRmlyZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBFdmVudC5vbmNlID0gb25jZTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgRE8gTk9UIHVzZSwgdGhpcyBsZWFrcyBtZW1vcnlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWFwKGV2ZW50LCBtYXApIHtcclxuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChpID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIG1hcChpKSksIG51bGwsIGRpc3Bvc2FibGVzKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5tYXAgPSBtYXA7XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIERPIE5PVCB1c2UsIHRoaXMgbGVha3MgbWVtb3J5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvckVhY2goZXZlbnQsIGVhY2gpIHtcclxuICAgICAgICByZXR1cm4gc25hcHNob3QoKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiBldmVudChpID0+IHsgZWFjaChpKTsgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgaSk7IH0sIG51bGwsIGRpc3Bvc2FibGVzKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5mb3JFYWNoID0gZm9yRWFjaDtcclxuICAgIGZ1bmN0aW9uIGZpbHRlcihldmVudCwgZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoZSA9PiBmaWx0ZXIoZSkgJiYgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSksIG51bGwsIGRpc3Bvc2FibGVzKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCByZXR1cm5zIHRoZSBzYW1lIGV2ZW50IGJ1dCB0eXBlZCBhcyBgRXZlbnQ8dm9pZD5gLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzaWduYWwoZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5zaWduYWwgPSBzaWduYWw7XHJcbiAgICBmdW5jdGlvbiBhbnkoLi4uZXZlbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gY29tYmluZWREaXNwb3NhYmxlKC4uLmV2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQoZSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKSwgbnVsbCwgZGlzcG9zYWJsZXMpKSk7XHJcbiAgICB9XHJcbiAgICBFdmVudC5hbnkgPSBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIERPIE5PVCB1c2UsIHRoaXMgbGVha3MgbWVtb3J5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlZHVjZShldmVudCwgbWVyZ2UsIGluaXRpYWwpIHtcclxuICAgICAgICBsZXQgb3V0cHV0ID0gaW5pdGlhbDtcclxuICAgICAgICByZXR1cm4gbWFwKGV2ZW50LCBlID0+IHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbWVyZ2Uob3V0cHV0LCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIEV2ZW50LnJlZHVjZSA9IHJlZHVjZTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgRE8gTk9UIHVzZSwgdGhpcyBsZWFrcyBtZW1vcnlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc25hcHNob3QoZXZlbnQpIHtcclxuICAgICAgICBsZXQgbGlzdGVuZXI7XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcclxuICAgICAgICAgICAgb25GaXJzdExpc3RlbmVyQWRkKCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBldmVudChlbWl0dGVyLmZpcmUsIGVtaXR0ZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkxhc3RMaXN0ZW5lclJlbW92ZSgpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBETyBOT1QgdXNlLCB0aGlzIGxlYWtzIG1lbW9yeVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWJvdW5jZShldmVudCwgbWVyZ2UsIGRlbGF5ID0gMTAwLCBsZWFkaW5nID0gZmFsc2UsIGxlYWtXYXJuaW5nVGhyZXNob2xkKSB7XHJcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICBsZXQgb3V0cHV0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBoYW5kbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IG51bURlYm91bmNlZENhbGxzID0gMDtcclxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xyXG4gICAgICAgICAgICBsZWFrV2FybmluZ1RocmVzaG9sZCxcclxuICAgICAgICAgICAgb25GaXJzdExpc3RlbmVyQWRkKCkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gZXZlbnQoY3VyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBudW1EZWJvdW5jZWRDYWxscysrO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG1lcmdlKG91dHB1dCwgY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVhZGluZyAmJiAhaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfb3V0cHV0ID0gb3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFkaW5nIHx8IG51bURlYm91bmNlZENhbGxzID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKF9vdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bURlYm91bmNlZENhbGxzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25MYXN0TGlzdGVuZXJSZW1vdmUoKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5kZWJvdW5jZSA9IGRlYm91bmNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBETyBOT1QgdXNlLCB0aGlzIGxlYWtzIG1lbW9yeVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBsYXRjaChldmVudCwgZXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIpIHtcclxuICAgICAgICBsZXQgZmlyc3RDYWxsID0gdHJ1ZTtcclxuICAgICAgICBsZXQgY2FjaGU7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcihldmVudCwgdmFsdWUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gZmlyc3RDYWxsIHx8ICFlcXVhbHModmFsdWUsIGNhY2hlKTtcclxuICAgICAgICAgICAgZmlyc3RDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhY2hlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRFbWl0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRXZlbnQubGF0Y2ggPSBsYXRjaDtcclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgRE8gTk9UIHVzZSwgdGhpcyBsZWFrcyBtZW1vcnlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3BsaXQoZXZlbnQsIGlzVCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIEV2ZW50LmZpbHRlcihldmVudCwgaXNUKSxcclxuICAgICAgICAgICAgRXZlbnQuZmlsdGVyKGV2ZW50LCBlID0+ICFpc1QoZSkpLFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbiAgICBFdmVudC5zcGxpdCA9IHNwbGl0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBETyBOT1QgdXNlLCB0aGlzIGxlYWtzIG1lbW9yeVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBidWZmZXIoZXZlbnQsIG5leHRUaWNrID0gZmFsc2UsIF9idWZmZXIgPSBbXSkge1xyXG4gICAgICAgIGxldCBidWZmZXIgPSBfYnVmZmVyLnNsaWNlKCk7XHJcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZXZlbnQoZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlci5mb3JFYWNoKGUgPT4gZW1pdHRlci5maXJlKGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWZmZXIgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcclxuICAgICAgICAgICAgb25GaXJzdExpc3RlbmVyQWRkKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gZXZlbnQoZSA9PiBlbWl0dGVyLmZpcmUoZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkZpcnN0TGlzdGVuZXJEaWRBZGQoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBFdmVudC5idWZmZXIgPSBidWZmZXI7XHJcbiAgICBjbGFzcyBDaGFpbmFibGVFdmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXAoZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChtYXAodGhpcy5ldmVudCwgZm4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yRWFjaChmbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGZvckVhY2godGhpcy5ldmVudCwgZm4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsdGVyKGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW5hYmxlRXZlbnQoZmlsdGVyKHRoaXMuZXZlbnQsIGZuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZHVjZShtZXJnZSwgaW5pdGlhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KHJlZHVjZSh0aGlzLmV2ZW50LCBtZXJnZSwgaW5pdGlhbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXRjaCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbmFibGVFdmVudChsYXRjaCh0aGlzLmV2ZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlYm91bmNlKG1lcmdlLCBkZWxheSA9IDEwMCwgbGVhZGluZyA9IGZhbHNlLCBsZWFrV2FybmluZ1RocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGRlYm91bmNlKHRoaXMuZXZlbnQsIG1lcmdlLCBkZWxheSwgbGVhZGluZywgbGVha1dhcm5pbmdUaHJlc2hvbGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb24obGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb25jZShsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbmNlKHRoaXMuZXZlbnQpKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgRE8gTk9UIHVzZSwgdGhpcyBsZWFrcyBtZW1vcnlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hhaW4oZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENoYWluYWJsZUV2ZW50KGV2ZW50KTtcclxuICAgIH1cclxuICAgIEV2ZW50LmNoYWluID0gY2hhaW47XHJcbiAgICBmdW5jdGlvbiBmcm9tTm9kZUV2ZW50RW1pdHRlcihlbWl0dGVyLCBldmVudE5hbWUsIG1hcCA9IGlkID0+IGlkKSB7XHJcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4gcmVzdWx0LmZpcmUobWFwKC4uLmFyZ3MpKTtcclxuICAgICAgICBjb25zdCBvbkZpcnN0TGlzdGVuZXJBZGQgPSAoKSA9PiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgZm4pO1xyXG4gICAgICAgIGNvbnN0IG9uTGFzdExpc3RlbmVyUmVtb3ZlID0gKCkgPT4gZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRW1pdHRlcih7IG9uRmlyc3RMaXN0ZW5lckFkZCwgb25MYXN0TGlzdGVuZXJSZW1vdmUgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ldmVudDtcclxuICAgIH1cclxuICAgIEV2ZW50LmZyb21Ob2RlRXZlbnRFbWl0dGVyID0gZnJvbU5vZGVFdmVudEVtaXR0ZXI7XHJcbiAgICBmdW5jdGlvbiBmcm9tRE9NRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbWFwID0gaWQgPT4gaWQpIHtcclxuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiByZXN1bHQuZmlyZShtYXAoLi4uYXJncykpO1xyXG4gICAgICAgIGNvbnN0IG9uRmlyc3RMaXN0ZW5lckFkZCA9ICgpID0+IGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcclxuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRW1pdHRlcih7IG9uRmlyc3RMaXN0ZW5lckFkZCwgb25MYXN0TGlzdGVuZXJSZW1vdmUgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ldmVudDtcclxuICAgIH1cclxuICAgIEV2ZW50LmZyb21ET01FdmVudEVtaXR0ZXIgPSBmcm9tRE9NRXZlbnRFbWl0dGVyO1xyXG4gICAgZnVuY3Rpb24gdG9Qcm9taXNlKGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gb25jZShldmVudCkocmVzb2x2ZSkpO1xyXG4gICAgfVxyXG4gICAgRXZlbnQudG9Qcm9taXNlID0gdG9Qcm9taXNlO1xyXG59KShFdmVudCB8fCAoRXZlbnQgPSB7fSkpO1xyXG5jbGFzcyBFdmVudFByb2ZpbGluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5faW52b2NhdGlvbkNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkT3ZlcmFsbCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IGAke25hbWV9XyR7RXZlbnRQcm9maWxpbmcuX2lkUG9vbCsrfWA7XHJcbiAgICB9XHJcbiAgICBzdGFydChsaXN0ZW5lckNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcFdhdGNoID0gbmV3IFN0b3BXYXRjaCh0cnVlKTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BXYXRjaCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gdGhpcy5fc3RvcFdhdGNoLmVsYXBzZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZE92ZXJhbGwgKz0gZWxhcHNlZDtcclxuICAgICAgICAgICAgdGhpcy5faW52b2NhdGlvbkNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgZGlkIEZJUkUgJHt0aGlzLl9uYW1lfTogZWxhcHNlZF9tczogJHtlbGFwc2VkLnRvRml4ZWQoNSl9LCBsaXN0ZW5lcjogJHt0aGlzLl9saXN0ZW5lckNvdW50fSAoZWxhcHNlZF9vdmVyYWxsOiAke3RoaXMuX2VsYXBzZWRPdmVyYWxsLnRvRml4ZWQoMil9LCBpbnZvY2F0aW9uczogJHt0aGlzLl9pbnZvY2F0aW9uQ291bnR9KWApO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wV2F0Y2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkV2ZW50UHJvZmlsaW5nLl9pZFBvb2wgPSAwO1xyXG5sZXQgX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkID0gLTE7XHJcbmNsYXNzIExlYWthZ2VNb25pdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGN1c3RvbVRocmVzaG9sZCwgbmFtZSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTgpLnNsaWNlKDIsIDUpKSB7XHJcbiAgICAgICAgdGhpcy5jdXN0b21UaHJlc2hvbGQgPSBjdXN0b21UaHJlc2hvbGQ7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLl93YXJuQ291bnRkb3duID0gMDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrcykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFja3MuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGVjayhsaXN0ZW5lckNvdW50KSB7XHJcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IF9nbG9iYWxMZWFrV2FybmluZ1RocmVzaG9sZDtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3VzdG9tVGhyZXNob2xkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSB0aGlzLmN1c3RvbVRocmVzaG9sZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRocmVzaG9sZCA8PSAwIHx8IGxpc3RlbmVyQ291bnQgPCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgzKS5qb2luKCdcXG4nKTtcclxuICAgICAgICBjb25zdCBjb3VudCA9ICh0aGlzLl9zdGFja3MuZ2V0KHN0YWNrKSB8fCAwKTtcclxuICAgICAgICB0aGlzLl9zdGFja3Muc2V0KHN0YWNrLCBjb3VudCArIDEpO1xyXG4gICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5fd2FybkNvdW50ZG93biA8PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgd2FybiBvbiBmaXJzdCBleGNlZWQgYW5kIHRoZW4gZXZlcnkgdGltZSB0aGUgbGltaXRcclxuICAgICAgICAgICAgLy8gaXMgZXhjZWVkZWQgYnkgNTAlIGFnYWluXHJcbiAgICAgICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gPSB0aHJlc2hvbGQgKiAwLjU7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgbW9zdCBmcmVxdWVudCBsaXN0ZW5lciBhbmQgcHJpbnQgd2FybmluZ1xyXG4gICAgICAgICAgICBsZXQgdG9wU3RhY2s7XHJcbiAgICAgICAgICAgIGxldCB0b3BDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3N0YWNrLCBjb3VudF0gb2YgdGhpcy5fc3RhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRvcFN0YWNrIHx8IHRvcENvdW50IDwgY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BTdGFjayA9IHN0YWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcENvdW50ID0gY291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbJHt0aGlzLm5hbWV9XSBwb3RlbnRpYWwgbGlzdGVuZXIgTEVBSyBkZXRlY3RlZCwgaGF2aW5nICR7bGlzdGVuZXJDb3VudH0gbGlzdGVuZXJzIGFscmVhZHkuIE1PU1QgZnJlcXVlbnQgbGlzdGVuZXIgKCR7dG9wQ291bnR9KTpgKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKHRvcFN0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSAodGhpcy5fc3RhY2tzLmdldChzdGFjaykgfHwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrcy5zZXQoc3RhY2ssIGNvdW50IC0gMSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIEVtaXR0ZXIgY2FuIGJlIHVzZWQgdG8gZXhwb3NlIGFuIEV2ZW50IHRvIHRoZSBwdWJsaWNcclxuICogdG8gZmlyZSBpdCBmcm9tIHRoZSBpbnNpZGVzLlxyXG4gKiBTYW1wbGU6XHJcbiAgICBjbGFzcyBEb2N1bWVudCB7XHJcblxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgX29uRGlkQ2hhbmdlID0gbmV3IEVtaXR0ZXI8KHZhbHVlOnN0cmluZyk9PmFueT4oKTtcclxuXHJcbiAgICAgICAgcHVibGljIG9uRGlkQ2hhbmdlID0gdGhpcy5fb25EaWRDaGFuZ2UuZXZlbnQ7XHJcblxyXG4gICAgICAgIC8vIGdldHRlci1zdHlsZVxyXG4gICAgICAgIC8vIGdldCBvbkRpZENoYW5nZSgpOiBFdmVudDwodmFsdWU6c3RyaW5nKT0+YW55PiB7XHJcbiAgICAgICAgLy8gXHRyZXR1cm4gdGhpcy5fb25EaWRDaGFuZ2UuZXZlbnQ7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBwcml2YXRlIF9kb0l0KCkge1xyXG4gICAgICAgICAgICAvLy4uLlxyXG4gICAgICAgICAgICB0aGlzLl9vbkRpZENoYW5nZS5maXJlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5fbGVha2FnZU1vbiA9IF9nbG9iYWxMZWFrV2FybmluZ1RocmVzaG9sZCA+IDAgPyBuZXcgTGVha2FnZU1vbml0b3IodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmxlYWtXYXJuaW5nVGhyZXNob2xkKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9wZXJmTW9uID0gKChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJvZk5hbWUpID8gbmV3IEV2ZW50UHJvZmlsaW5nKHRoaXMuX29wdGlvbnMuX3Byb2ZOYW1lKSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIHRoZSBwdWJsaWMgdG8gYWxsb3cgdG8gc3Vic2NyaWJlXHJcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcclxuICAgICAqL1xyXG4gICAgZ2V0IGV2ZW50KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnQgPSAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RMaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVycy5pc0VtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RMaXN0ZW5lciAmJiB0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSB0aGlzLl9saXN0ZW5lcnMucHVzaCghdGhpc0FyZ3MgPyBsaXN0ZW5lciA6IFtsaXN0ZW5lciwgdGhpc0FyZ3NdKTtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdExpc3RlbmVyICYmIHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJEaWRBZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckRpZEFkZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MaXN0ZW5lckRpZEFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MaXN0ZW5lckRpZEFkZCh0aGlzLCBsaXN0ZW5lciwgdGhpc0FyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgYW5kIHJlY29yZCB0aGlzIGVtaXR0ZXIgZm9yIHBvdGVudGlhbCBsZWFrYWdlXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVNb25pdG9yID0gKF9hID0gdGhpcy5fbGVha2FnZU1vbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoZWNrKHRoaXMuX2xpc3RlbmVycy5zaXplKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRvRGlzcG9zYWJsZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZU1vbml0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTW9uaXRvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLm9uTGFzdExpc3RlbmVyUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNMaXN0ZW5lcnMgPSAodGhpcy5fbGlzdGVuZXJzICYmICF0aGlzLl9saXN0ZW5lcnMuaXNFbXB0eSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGVzIGluc3RhbmNlb2YgRGlzcG9zYWJsZVN0b3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cclxuICAgICAqIHN1YnNjcmliZXJzXHJcbiAgICAgKi9cclxuICAgIGZpcmUoZXZlbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgLy8gcHV0IGFsbCBbbGlzdGVuZXIsZXZlbnRdLXBhaXJzIGludG8gZGVsaXZlcnkgcXVldWVcclxuICAgICAgICAgICAgLy8gdGhlbiBlbWl0IGFsbCBldmVudC4gYW4gaW5uZXIvbmVzdGVkIGV2ZW50IG1pZ2h0IGJlXHJcbiAgICAgICAgICAgIC8vIHRoZSBkcml2ZXIgb2YgdGhpc1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RlbGl2ZXJ5UXVldWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5wdXNoKFtsaXN0ZW5lciwgZXZlbnRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzdGFydC9zdG9wIHBlcmZvcm1hbmNlIGluc2lnaHQgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQodGhpcy5fZGVsaXZlcnlRdWV1ZS5zaXplKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2RlbGl2ZXJ5UXVldWUuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtsaXN0ZW5lciwgZXZlbnRdID0gdGhpcy5fZGVsaXZlcnlRdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclswXS5jYWxsKGxpc3RlbmVyWzFdLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvblVuZXhwZWN0ZWRFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5fbGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXIoKTtcclxuICAgICAgICAgICAgKF9iID0gdGhpcy5fZGVsaXZlcnlRdWV1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vbkxhc3RMaXN0ZW5lclJlbW92ZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xyXG4gICAgICAgICAgICAoX2UgPSB0aGlzLl9sZWFrYWdlTW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgUGF1c2VhYmxlRW1pdHRlciBleHRlbmRzIEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gMDtcclxuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgICAgICB0aGlzLl9tZXJnZUZuID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lcmdlO1xyXG4gICAgfVxyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQrKztcclxuICAgIH1cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQgIT09IDAgJiYgLS10aGlzLl9pc1BhdXNlZCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWVyZ2VGbikge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBtZXJnZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBzaW5nbGUgY29tcG9zaXRlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVudC4gbWFrZSBhIGNvcHkgaW4gY2FzZSBmaXJpbmcgcGF1c2VzIHRoaXMgZW1pdHRlclxyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh0aGlzLl9ldmVudFF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWUuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHN1cGVyLmZpcmUodGhpcy5fbWVyZ2VGbihldmVudHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIG1lcmdpbmcsIGZpcmUgZWFjaCBldmVudCBpbmRpdmlkdWFsbHkgYW5kIHRlc3RcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhpcyBlbWl0dGVyIGlzbid0IHBhdXNlZCBoYWxmd2F5IHRocm91Z2hcclxuICAgICAgICAgICAgICAgIHdoaWxlICghdGhpcy5faXNQYXVzZWQgJiYgdGhpcy5fZXZlbnRRdWV1ZS5zaXplICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZmlyZSh0aGlzLl9ldmVudFF1ZXVlLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmlyZShldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudFF1ZXVlLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3VwZXIuZmlyZShldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIERlYm91bmNlRW1pdHRlciBleHRlbmRzIFBhdXNlYWJsZUVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9kZWxheSA9IChfYSA9IG9wdGlvbnMuZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwMDtcclxuICAgIH1cclxuICAgIGZpcmUoZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5maXJlKGV2ZW50KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIEV2ZW50QnVmZmVyZXIgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgaW4gd2hpY2ggeW91IHdhbnRcclxuICogdG8gZGVsYXkgZmlyaW5nIHlvdXIgZXZlbnRzIGR1cmluZyBzb21lIGNvZGUuXHJcbiAqIFlvdSBjYW4gd3JhcCB0aGF0IGNvZGUgYW5kIGJlIHN1cmUgdGhhdCB0aGUgZXZlbnQgd2lsbCBub3RcclxuICogYmUgZmlyZWQgZHVyaW5nIHRoYXQgd3JhcC5cclxuICpcclxuICogYGBgXHJcbiAqIGNvbnN0IGVtaXR0ZXI6IEVtaXR0ZXI7XHJcbiAqIGNvbnN0IGRlbGF5ZXIgPSBuZXcgRXZlbnREZWxheWVyKCk7XHJcbiAqIGNvbnN0IGRlbGF5ZWRFdmVudCA9IGRlbGF5ZXIud3JhcEV2ZW50KGVtaXR0ZXIuZXZlbnQpO1xyXG4gKlxyXG4gKiBkZWxheWVkRXZlbnQoY29uc29sZS5sb2cpO1xyXG4gKlxyXG4gKiBkZWxheWVyLmJ1ZmZlckV2ZW50cygoKSA9PiB7XHJcbiAqICAgZW1pdHRlci5maXJlKCk7IC8vIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIHlldFxyXG4gKiB9KTtcclxuICpcclxuICogLy8gZXZlbnQgd2lsbCBvbmx5IGJlIGZpcmVkIGF0IHRoaXMgcG9pbnRcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXZlbnRCdWZmZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIHdyYXBFdmVudChldmVudCkge1xyXG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQoaSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbdGhpcy5idWZmZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKCgpID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIGRpc3Bvc2FibGVzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYnVmZmVyRXZlbnRzKGZuKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gW107XHJcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcclxuICAgICAgICBjb25zdCByID0gZm4oKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnMucG9wKCk7XHJcbiAgICAgICAgYnVmZmVyLmZvckVhY2goZmx1c2ggPT4gZmx1c2goKSk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgUmVsYXkgaXMgYW4gZXZlbnQgZm9yd2FyZGVyIHdoaWNoIGZ1bmN0aW9ucyBhcyBhIHJlcGx1Z2FiYmxlIGV2ZW50IHBpcGUuXHJcbiAqIE9uY2UgY3JlYXRlZCwgeW91IGNhbiBjb25uZWN0IGFuIGlucHV0IGV2ZW50IHRvIGl0IGFuZCBpdCB3aWxsIHNpbXBseSBmb3J3YXJkXHJcbiAqIGV2ZW50cyBmcm9tIHRoYXQgaW5wdXQgZXZlbnQgdGhyb3VnaCBpdHMgb3duIGBldmVudGAgcHJvcGVydHkuIFRoZSBgaW5wdXRgXHJcbiAqIGNhbiBiZSBjaGFuZ2VkIGF0IGFueSBwb2ludCBpbiB0aW1lLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlbGF5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50ID0gRXZlbnQuTm9uZTtcclxuICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lciA9IERpc3Bvc2FibGUuTm9uZTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcih7XHJcbiAgICAgICAgICAgIG9uRmlyc3RMaXN0ZW5lckRpZEFkZDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIgPSB0aGlzLmlucHV0RXZlbnQodGhpcy5lbWl0dGVyLmZpcmUsIHRoaXMuZW1pdHRlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uTGFzdExpc3RlbmVyUmVtb3ZlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHRoaXMuZW1pdHRlci5ldmVudDtcclxuICAgIH1cclxuICAgIHNldCBpbnB1dChldmVudCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXRFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyID0gZXZlbnQodGhpcy5lbWl0dGVyLmZpcmUsIHRoaXMuZW1pdHRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lci5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgRW1pdHRlciwgRXZlbnQgfSBmcm9tICcuL2V2ZW50LmpzJztcclxuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQoY29udGV4dCksIDApO1xyXG4gICAgcmV0dXJuIHsgZGlzcG9zZSgpIHsgY2xlYXJUaW1lb3V0KGhhbmRsZSk7IH0gfTtcclxufSk7XHJcbmV4cG9ydCB2YXIgQ2FuY2VsbGF0aW9uVG9rZW47XHJcbihmdW5jdGlvbiAoQ2FuY2VsbGF0aW9uVG9rZW4pIHtcclxuICAgIGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uVG9rZW4odGhpbmcpIHtcclxuICAgICAgICBpZiAodGhpbmcgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmUgfHwgdGhpbmcgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaW5nIHx8IHR5cGVvZiB0aGluZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaW5nLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkID09PSAnYm9vbGVhbidcclxuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uaXNDYW5jZWxsYXRpb25Ub2tlbiA9IGlzQ2FuY2VsbGF0aW9uVG9rZW47XHJcbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBFdmVudC5Ob25lXHJcbiAgICB9KTtcclxuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxyXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBzaG9ydGN1dEV2ZW50XHJcbiAgICB9KTtcclxufSkoQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKENhbmNlbGxhdGlvblRva2VuID0ge30pKTtcclxuY2xhc3MgTXV0YWJsZVRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcclxuICAgIH1cclxuICAgIGdldCBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENhbmNlbGxhdGlvblRva2VuU291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuX3Rva2VuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gcGFyZW50ICYmIHBhcmVudC5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCh0aGlzLmNhbmNlbCwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgdG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xyXG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxyXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxyXG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xyXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rva2VuIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGNhbmNlbFxyXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKGNhbmNlbCA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKGNhbmNlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcclxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xyXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBkaXNwb3NlXHJcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IGlsbGVnYWxBcmd1bWVudCB9IGZyb20gJy4vZXJyb3JzLmpzJztcclxuY2xhc3MgS2V5Q29kZVN0ck1hcCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9rZXlDb2RlVG9TdHIgPSBbXTtcclxuICAgICAgICB0aGlzLl9zdHJUb0tleUNvZGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgZGVmaW5lKGtleUNvZGUsIHN0cikge1xyXG4gICAgICAgIHRoaXMuX2tleUNvZGVUb1N0cltrZXlDb2RlXSA9IHN0cjtcclxuICAgICAgICB0aGlzLl9zdHJUb0tleUNvZGVbc3RyLnRvTG93ZXJDYXNlKCldID0ga2V5Q29kZTtcclxuICAgIH1cclxuICAgIGtleUNvZGVUb1N0cihrZXlDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNvZGVUb1N0cltrZXlDb2RlXTtcclxuICAgIH1cclxuICAgIHN0clRvS2V5Q29kZShzdHIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyVG9LZXlDb2RlW3N0ci50b0xvd2VyQ2FzZSgpXSB8fCAwIC8qIFVua25vd24gKi87XHJcbiAgICB9XHJcbn1cclxuY29uc3QgdWlNYXAgPSBuZXcgS2V5Q29kZVN0ck1hcCgpO1xyXG5jb25zdCB1c2VyU2V0dGluZ3NVU01hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XHJcbmNvbnN0IHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAgPSBuZXcgS2V5Q29kZVN0ck1hcCgpO1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gZGVmaW5lKGtleUNvZGUsIHVpTGFiZWwsIHVzVXNlclNldHRpbmdzTGFiZWwgPSB1aUxhYmVsLCBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwgPSB1c1VzZXJTZXR0aW5nc0xhYmVsKSB7XHJcbiAgICAgICAgdWlNYXAuZGVmaW5lKGtleUNvZGUsIHVpTGFiZWwpO1xyXG4gICAgICAgIHVzZXJTZXR0aW5nc1VTTWFwLmRlZmluZShrZXlDb2RlLCB1c1VzZXJTZXR0aW5nc0xhYmVsKTtcclxuICAgICAgICB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmRlZmluZShrZXlDb2RlLCBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwpO1xyXG4gICAgfVxyXG4gICAgZGVmaW5lKDAgLyogVW5rbm93biAqLywgJ3Vua25vd24nKTtcclxuICAgIGRlZmluZSgxIC8qIEJhY2tzcGFjZSAqLywgJ0JhY2tzcGFjZScpO1xyXG4gICAgZGVmaW5lKDIgLyogVGFiICovLCAnVGFiJyk7XHJcbiAgICBkZWZpbmUoMyAvKiBFbnRlciAqLywgJ0VudGVyJyk7XHJcbiAgICBkZWZpbmUoNCAvKiBTaGlmdCAqLywgJ1NoaWZ0Jyk7XHJcbiAgICBkZWZpbmUoNSAvKiBDdHJsICovLCAnQ3RybCcpO1xyXG4gICAgZGVmaW5lKDYgLyogQWx0ICovLCAnQWx0Jyk7XHJcbiAgICBkZWZpbmUoNyAvKiBQYXVzZUJyZWFrICovLCAnUGF1c2VCcmVhaycpO1xyXG4gICAgZGVmaW5lKDggLyogQ2Fwc0xvY2sgKi8sICdDYXBzTG9jaycpO1xyXG4gICAgZGVmaW5lKDkgLyogRXNjYXBlICovLCAnRXNjYXBlJyk7XHJcbiAgICBkZWZpbmUoMTAgLyogU3BhY2UgKi8sICdTcGFjZScpO1xyXG4gICAgZGVmaW5lKDExIC8qIFBhZ2VVcCAqLywgJ1BhZ2VVcCcpO1xyXG4gICAgZGVmaW5lKDEyIC8qIFBhZ2VEb3duICovLCAnUGFnZURvd24nKTtcclxuICAgIGRlZmluZSgxMyAvKiBFbmQgKi8sICdFbmQnKTtcclxuICAgIGRlZmluZSgxNCAvKiBIb21lICovLCAnSG9tZScpO1xyXG4gICAgZGVmaW5lKDE1IC8qIExlZnRBcnJvdyAqLywgJ0xlZnRBcnJvdycsICdMZWZ0Jyk7XHJcbiAgICBkZWZpbmUoMTYgLyogVXBBcnJvdyAqLywgJ1VwQXJyb3cnLCAnVXAnKTtcclxuICAgIGRlZmluZSgxNyAvKiBSaWdodEFycm93ICovLCAnUmlnaHRBcnJvdycsICdSaWdodCcpO1xyXG4gICAgZGVmaW5lKDE4IC8qIERvd25BcnJvdyAqLywgJ0Rvd25BcnJvdycsICdEb3duJyk7XHJcbiAgICBkZWZpbmUoMTkgLyogSW5zZXJ0ICovLCAnSW5zZXJ0Jyk7XHJcbiAgICBkZWZpbmUoMjAgLyogRGVsZXRlICovLCAnRGVsZXRlJyk7XHJcbiAgICBkZWZpbmUoMjEgLyogS0VZXzAgKi8sICcwJyk7XHJcbiAgICBkZWZpbmUoMjIgLyogS0VZXzEgKi8sICcxJyk7XHJcbiAgICBkZWZpbmUoMjMgLyogS0VZXzIgKi8sICcyJyk7XHJcbiAgICBkZWZpbmUoMjQgLyogS0VZXzMgKi8sICczJyk7XHJcbiAgICBkZWZpbmUoMjUgLyogS0VZXzQgKi8sICc0Jyk7XHJcbiAgICBkZWZpbmUoMjYgLyogS0VZXzUgKi8sICc1Jyk7XHJcbiAgICBkZWZpbmUoMjcgLyogS0VZXzYgKi8sICc2Jyk7XHJcbiAgICBkZWZpbmUoMjggLyogS0VZXzcgKi8sICc3Jyk7XHJcbiAgICBkZWZpbmUoMjkgLyogS0VZXzggKi8sICc4Jyk7XHJcbiAgICBkZWZpbmUoMzAgLyogS0VZXzkgKi8sICc5Jyk7XHJcbiAgICBkZWZpbmUoMzEgLyogS0VZX0EgKi8sICdBJyk7XHJcbiAgICBkZWZpbmUoMzIgLyogS0VZX0IgKi8sICdCJyk7XHJcbiAgICBkZWZpbmUoMzMgLyogS0VZX0MgKi8sICdDJyk7XHJcbiAgICBkZWZpbmUoMzQgLyogS0VZX0QgKi8sICdEJyk7XHJcbiAgICBkZWZpbmUoMzUgLyogS0VZX0UgKi8sICdFJyk7XHJcbiAgICBkZWZpbmUoMzYgLyogS0VZX0YgKi8sICdGJyk7XHJcbiAgICBkZWZpbmUoMzcgLyogS0VZX0cgKi8sICdHJyk7XHJcbiAgICBkZWZpbmUoMzggLyogS0VZX0ggKi8sICdIJyk7XHJcbiAgICBkZWZpbmUoMzkgLyogS0VZX0kgKi8sICdJJyk7XHJcbiAgICBkZWZpbmUoNDAgLyogS0VZX0ogKi8sICdKJyk7XHJcbiAgICBkZWZpbmUoNDEgLyogS0VZX0sgKi8sICdLJyk7XHJcbiAgICBkZWZpbmUoNDIgLyogS0VZX0wgKi8sICdMJyk7XHJcbiAgICBkZWZpbmUoNDMgLyogS0VZX00gKi8sICdNJyk7XHJcbiAgICBkZWZpbmUoNDQgLyogS0VZX04gKi8sICdOJyk7XHJcbiAgICBkZWZpbmUoNDUgLyogS0VZX08gKi8sICdPJyk7XHJcbiAgICBkZWZpbmUoNDYgLyogS0VZX1AgKi8sICdQJyk7XHJcbiAgICBkZWZpbmUoNDcgLyogS0VZX1EgKi8sICdRJyk7XHJcbiAgICBkZWZpbmUoNDggLyogS0VZX1IgKi8sICdSJyk7XHJcbiAgICBkZWZpbmUoNDkgLyogS0VZX1MgKi8sICdTJyk7XHJcbiAgICBkZWZpbmUoNTAgLyogS0VZX1QgKi8sICdUJyk7XHJcbiAgICBkZWZpbmUoNTEgLyogS0VZX1UgKi8sICdVJyk7XHJcbiAgICBkZWZpbmUoNTIgLyogS0VZX1YgKi8sICdWJyk7XHJcbiAgICBkZWZpbmUoNTMgLyogS0VZX1cgKi8sICdXJyk7XHJcbiAgICBkZWZpbmUoNTQgLyogS0VZX1ggKi8sICdYJyk7XHJcbiAgICBkZWZpbmUoNTUgLyogS0VZX1kgKi8sICdZJyk7XHJcbiAgICBkZWZpbmUoNTYgLyogS0VZX1ogKi8sICdaJyk7XHJcbiAgICBkZWZpbmUoNTcgLyogTWV0YSAqLywgJ01ldGEnKTtcclxuICAgIGRlZmluZSg1OCAvKiBDb250ZXh0TWVudSAqLywgJ0NvbnRleHRNZW51Jyk7XHJcbiAgICBkZWZpbmUoNTkgLyogRjEgKi8sICdGMScpO1xyXG4gICAgZGVmaW5lKDYwIC8qIEYyICovLCAnRjInKTtcclxuICAgIGRlZmluZSg2MSAvKiBGMyAqLywgJ0YzJyk7XHJcbiAgICBkZWZpbmUoNjIgLyogRjQgKi8sICdGNCcpO1xyXG4gICAgZGVmaW5lKDYzIC8qIEY1ICovLCAnRjUnKTtcclxuICAgIGRlZmluZSg2NCAvKiBGNiAqLywgJ0Y2Jyk7XHJcbiAgICBkZWZpbmUoNjUgLyogRjcgKi8sICdGNycpO1xyXG4gICAgZGVmaW5lKDY2IC8qIEY4ICovLCAnRjgnKTtcclxuICAgIGRlZmluZSg2NyAvKiBGOSAqLywgJ0Y5Jyk7XHJcbiAgICBkZWZpbmUoNjggLyogRjEwICovLCAnRjEwJyk7XHJcbiAgICBkZWZpbmUoNjkgLyogRjExICovLCAnRjExJyk7XHJcbiAgICBkZWZpbmUoNzAgLyogRjEyICovLCAnRjEyJyk7XHJcbiAgICBkZWZpbmUoNzEgLyogRjEzICovLCAnRjEzJyk7XHJcbiAgICBkZWZpbmUoNzIgLyogRjE0ICovLCAnRjE0Jyk7XHJcbiAgICBkZWZpbmUoNzMgLyogRjE1ICovLCAnRjE1Jyk7XHJcbiAgICBkZWZpbmUoNzQgLyogRjE2ICovLCAnRjE2Jyk7XHJcbiAgICBkZWZpbmUoNzUgLyogRjE3ICovLCAnRjE3Jyk7XHJcbiAgICBkZWZpbmUoNzYgLyogRjE4ICovLCAnRjE4Jyk7XHJcbiAgICBkZWZpbmUoNzcgLyogRjE5ICovLCAnRjE5Jyk7XHJcbiAgICBkZWZpbmUoNzggLyogTnVtTG9jayAqLywgJ051bUxvY2snKTtcclxuICAgIGRlZmluZSg3OSAvKiBTY3JvbGxMb2NrICovLCAnU2Nyb2xsTG9jaycpO1xyXG4gICAgZGVmaW5lKDgwIC8qIFVTX1NFTUlDT0xPTiAqLywgJzsnLCAnOycsICdPRU1fMScpO1xyXG4gICAgZGVmaW5lKDgxIC8qIFVTX0VRVUFMICovLCAnPScsICc9JywgJ09FTV9QTFVTJyk7XHJcbiAgICBkZWZpbmUoODIgLyogVVNfQ09NTUEgKi8sICcsJywgJywnLCAnT0VNX0NPTU1BJyk7XHJcbiAgICBkZWZpbmUoODMgLyogVVNfTUlOVVMgKi8sICctJywgJy0nLCAnT0VNX01JTlVTJyk7XHJcbiAgICBkZWZpbmUoODQgLyogVVNfRE9UICovLCAnLicsICcuJywgJ09FTV9QRVJJT0QnKTtcclxuICAgIGRlZmluZSg4NSAvKiBVU19TTEFTSCAqLywgJy8nLCAnLycsICdPRU1fMicpO1xyXG4gICAgZGVmaW5lKDg2IC8qIFVTX0JBQ0tUSUNLICovLCAnYCcsICdgJywgJ09FTV8zJyk7XHJcbiAgICBkZWZpbmUoMTEwIC8qIEFCTlRfQzEgKi8sICdBQk5UX0MxJyk7XHJcbiAgICBkZWZpbmUoMTExIC8qIEFCTlRfQzIgKi8sICdBQk5UX0MyJyk7XHJcbiAgICBkZWZpbmUoODcgLyogVVNfT1BFTl9TUVVBUkVfQlJBQ0tFVCAqLywgJ1snLCAnWycsICdPRU1fNCcpO1xyXG4gICAgZGVmaW5lKDg4IC8qIFVTX0JBQ0tTTEFTSCAqLywgJ1xcXFwnLCAnXFxcXCcsICdPRU1fNScpO1xyXG4gICAgZGVmaW5lKDg5IC8qIFVTX0NMT1NFX1NRVUFSRV9CUkFDS0VUICovLCAnXScsICddJywgJ09FTV82Jyk7XHJcbiAgICBkZWZpbmUoOTAgLyogVVNfUVVPVEUgKi8sICdcXCcnLCAnXFwnJywgJ09FTV83Jyk7XHJcbiAgICBkZWZpbmUoOTEgLyogT0VNXzggKi8sICdPRU1fOCcpO1xyXG4gICAgZGVmaW5lKDkyIC8qIE9FTV8xMDIgKi8sICdPRU1fMTAyJyk7XHJcbiAgICBkZWZpbmUoOTMgLyogTlVNUEFEXzAgKi8sICdOdW1QYWQwJyk7XHJcbiAgICBkZWZpbmUoOTQgLyogTlVNUEFEXzEgKi8sICdOdW1QYWQxJyk7XHJcbiAgICBkZWZpbmUoOTUgLyogTlVNUEFEXzIgKi8sICdOdW1QYWQyJyk7XHJcbiAgICBkZWZpbmUoOTYgLyogTlVNUEFEXzMgKi8sICdOdW1QYWQzJyk7XHJcbiAgICBkZWZpbmUoOTcgLyogTlVNUEFEXzQgKi8sICdOdW1QYWQ0Jyk7XHJcbiAgICBkZWZpbmUoOTggLyogTlVNUEFEXzUgKi8sICdOdW1QYWQ1Jyk7XHJcbiAgICBkZWZpbmUoOTkgLyogTlVNUEFEXzYgKi8sICdOdW1QYWQ2Jyk7XHJcbiAgICBkZWZpbmUoMTAwIC8qIE5VTVBBRF83ICovLCAnTnVtUGFkNycpO1xyXG4gICAgZGVmaW5lKDEwMSAvKiBOVU1QQURfOCAqLywgJ051bVBhZDgnKTtcclxuICAgIGRlZmluZSgxMDIgLyogTlVNUEFEXzkgKi8sICdOdW1QYWQ5Jyk7XHJcbiAgICBkZWZpbmUoMTAzIC8qIE5VTVBBRF9NVUxUSVBMWSAqLywgJ051bVBhZF9NdWx0aXBseScpO1xyXG4gICAgZGVmaW5lKDEwNCAvKiBOVU1QQURfQUREICovLCAnTnVtUGFkX0FkZCcpO1xyXG4gICAgZGVmaW5lKDEwNSAvKiBOVU1QQURfU0VQQVJBVE9SICovLCAnTnVtUGFkX1NlcGFyYXRvcicpO1xyXG4gICAgZGVmaW5lKDEwNiAvKiBOVU1QQURfU1VCVFJBQ1QgKi8sICdOdW1QYWRfU3VidHJhY3QnKTtcclxuICAgIGRlZmluZSgxMDcgLyogTlVNUEFEX0RFQ0lNQUwgKi8sICdOdW1QYWRfRGVjaW1hbCcpO1xyXG4gICAgZGVmaW5lKDEwOCAvKiBOVU1QQURfRElWSURFICovLCAnTnVtUGFkX0RpdmlkZScpO1xyXG59KSgpO1xyXG5leHBvcnQgdmFyIEtleUNvZGVVdGlscztcclxuKGZ1bmN0aW9uIChLZXlDb2RlVXRpbHMpIHtcclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKGtleUNvZGUpIHtcclxuICAgICAgICByZXR1cm4gdWlNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xyXG4gICAgfVxyXG4gICAgS2V5Q29kZVV0aWxzLnRvU3RyaW5nID0gdG9TdHJpbmc7XHJcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKGtleSkge1xyXG4gICAgICAgIHJldHVybiB1aU1hcC5zdHJUb0tleUNvZGUoa2V5KTtcclxuICAgIH1cclxuICAgIEtleUNvZGVVdGlscy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuICAgIGZ1bmN0aW9uIHRvVXNlclNldHRpbmdzVVMoa2V5Q29kZSkge1xyXG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NVU01hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XHJcbiAgICB9XHJcbiAgICBLZXlDb2RlVXRpbHMudG9Vc2VyU2V0dGluZ3NVUyA9IHRvVXNlclNldHRpbmdzVVM7XHJcbiAgICBmdW5jdGlvbiB0b1VzZXJTZXR0aW5nc0dlbmVyYWwoa2V5Q29kZSkge1xyXG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmtleUNvZGVUb1N0cihrZXlDb2RlKTtcclxuICAgIH1cclxuICAgIEtleUNvZGVVdGlscy50b1VzZXJTZXR0aW5nc0dlbmVyYWwgPSB0b1VzZXJTZXR0aW5nc0dlbmVyYWw7XHJcbiAgICBmdW5jdGlvbiBmcm9tVXNlclNldHRpbmdzKGtleSkge1xyXG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NVU01hcC5zdHJUb0tleUNvZGUoa2V5KSB8fCB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLnN0clRvS2V5Q29kZShrZXkpO1xyXG4gICAgfVxyXG4gICAgS2V5Q29kZVV0aWxzLmZyb21Vc2VyU2V0dGluZ3MgPSBmcm9tVXNlclNldHRpbmdzO1xyXG59KShLZXlDb2RlVXRpbHMgfHwgKEtleUNvZGVVdGlscyA9IHt9KSk7XHJcbmV4cG9ydCBmdW5jdGlvbiBLZXlDaG9yZChmaXJzdFBhcnQsIHNlY29uZFBhcnQpIHtcclxuICAgIGNvbnN0IGNob3JkUGFydCA9ICgoc2Vjb25kUGFydCAmIDB4MDAwMEZGRkYpIDw8IDE2KSA+Pj4gMDtcclxuICAgIHJldHVybiAoZmlyc3RQYXJ0IHwgY2hvcmRQYXJ0KSA+Pj4gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlS2V5YmluZGluZyhrZXliaW5kaW5nLCBPUykge1xyXG4gICAgaWYgKGtleWJpbmRpbmcgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpcnN0UGFydCA9IChrZXliaW5kaW5nICYgMHgwMDAwRkZGRikgPj4+IDA7XHJcbiAgICBjb25zdCBjaG9yZFBhcnQgPSAoa2V5YmluZGluZyAmIDB4RkZGRjAwMDApID4+PiAxNjtcclxuICAgIGlmIChjaG9yZFBhcnQgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gbmV3IENob3JkS2V5YmluZGluZyhbXHJcbiAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUtleWJpbmRpbmcoZmlyc3RQYXJ0LCBPUyksXHJcbiAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUtleWJpbmRpbmcoY2hvcmRQYXJ0LCBPUylcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQ2hvcmRLZXliaW5kaW5nKFtjcmVhdGVTaW1wbGVLZXliaW5kaW5nKGZpcnN0UGFydCwgT1MpXSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUtleWJpbmRpbmcoa2V5YmluZGluZywgT1MpIHtcclxuICAgIGNvbnN0IGN0cmxDbWQgPSAoa2V5YmluZGluZyAmIDIwNDggLyogQ3RybENtZCAqLyA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICBjb25zdCB3aW5DdHJsID0gKGtleWJpbmRpbmcgJiAyNTYgLyogV2luQ3RybCAqLyA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICBjb25zdCBjdHJsS2V5ID0gKE9TID09PSAyIC8qIE1hY2ludG9zaCAqLyA/IHdpbkN0cmwgOiBjdHJsQ21kKTtcclxuICAgIGNvbnN0IHNoaWZ0S2V5ID0gKGtleWJpbmRpbmcgJiAxMDI0IC8qIFNoaWZ0ICovID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgIGNvbnN0IGFsdEtleSA9IChrZXliaW5kaW5nICYgNTEyIC8qIEFsdCAqLyA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICBjb25zdCBtZXRhS2V5ID0gKE9TID09PSAyIC8qIE1hY2ludG9zaCAqLyA/IGN0cmxDbWQgOiB3aW5DdHJsKTtcclxuICAgIGNvbnN0IGtleUNvZGUgPSAoa2V5YmluZGluZyAmIDI1NSAvKiBLZXlDb2RlICovKTtcclxuICAgIHJldHVybiBuZXcgU2ltcGxlS2V5YmluZGluZyhjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5LCBrZXlDb2RlKTtcclxufVxyXG5leHBvcnQgY2xhc3MgU2ltcGxlS2V5YmluZGluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5LCBrZXlDb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jdHJsS2V5ID0gY3RybEtleTtcclxuICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gc2hpZnRLZXk7XHJcbiAgICAgICAgdGhpcy5hbHRLZXkgPSBhbHRLZXk7XHJcbiAgICAgICAgdGhpcy5tZXRhS2V5ID0gbWV0YUtleTtcclxuICAgICAgICB0aGlzLmtleUNvZGUgPSBrZXlDb2RlO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmN0cmxLZXkgPT09IG90aGVyLmN0cmxLZXlcclxuICAgICAgICAgICAgJiYgdGhpcy5zaGlmdEtleSA9PT0gb3RoZXIuc2hpZnRLZXlcclxuICAgICAgICAgICAgJiYgdGhpcy5hbHRLZXkgPT09IG90aGVyLmFsdEtleVxyXG4gICAgICAgICAgICAmJiB0aGlzLm1ldGFLZXkgPT09IG90aGVyLm1ldGFLZXlcclxuICAgICAgICAgICAgJiYgdGhpcy5rZXlDb2RlID09PSBvdGhlci5rZXlDb2RlKTtcclxuICAgIH1cclxuICAgIGlzTW9kaWZpZXJLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmtleUNvZGUgPT09IDAgLyogVW5rbm93biAqL1xyXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDUgLyogQ3RybCAqL1xyXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDU3IC8qIE1ldGEgKi9cclxuICAgICAgICAgICAgfHwgdGhpcy5rZXlDb2RlID09PSA2IC8qIEFsdCAqL1xyXG4gICAgICAgICAgICB8fCB0aGlzLmtleUNvZGUgPT09IDQgLyogU2hpZnQgKi8pO1xyXG4gICAgfVxyXG4gICAgdG9DaG9yZCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENob3JkS2V5YmluZGluZyhbdGhpc10pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIHRoaXMga2V5YmluZGluZyByZWZlciB0byB0aGUga2V5IGNvZGUgb2YgYSBtb2RpZmllciBhbmQgaXQgYWxzbyBoYXMgdGhlIG1vZGlmaWVyIGZsYWc/XHJcbiAgICAgKi9cclxuICAgIGlzRHVwbGljYXRlTW9kaWZpZXJDYXNlKCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuY3RybEtleSAmJiB0aGlzLmtleUNvZGUgPT09IDUgLyogQ3RybCAqLylcclxuICAgICAgICAgICAgfHwgKHRoaXMuc2hpZnRLZXkgJiYgdGhpcy5rZXlDb2RlID09PSA0IC8qIFNoaWZ0ICovKVxyXG4gICAgICAgICAgICB8fCAodGhpcy5hbHRLZXkgJiYgdGhpcy5rZXlDb2RlID09PSA2IC8qIEFsdCAqLylcclxuICAgICAgICAgICAgfHwgKHRoaXMubWV0YUtleSAmJiB0aGlzLmtleUNvZGUgPT09IDU3IC8qIE1ldGEgKi8pKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgQ2hvcmRLZXliaW5kaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsQXJndW1lbnQoYHBhcnRzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgUmVzb2x2ZWRLZXliaW5kaW5nUGFydCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5LCBrYkxhYmVsLCBrYkFyaWFMYWJlbCkge1xyXG4gICAgICAgIHRoaXMuY3RybEtleSA9IGN0cmxLZXk7XHJcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IHNoaWZ0S2V5O1xyXG4gICAgICAgIHRoaXMuYWx0S2V5ID0gYWx0S2V5O1xyXG4gICAgICAgIHRoaXMubWV0YUtleSA9IG1ldGFLZXk7XHJcbiAgICAgICAgdGhpcy5rZXlMYWJlbCA9IGtiTGFiZWw7XHJcbiAgICAgICAgdGhpcy5rZXlBcmlhTGFiZWwgPSBrYkFyaWFMYWJlbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSByZXNvbHZlZCBrZXliaW5kaW5nLiBDYW4gYmUgYSBzaW1wbGUga2V5YmluZGluZyBvciBhIGNob3JkIGtleWJpbmRpbmcuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVzb2x2ZWRLZXliaW5kaW5nIHtcclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL3JhbmdlLmpzJztcclxuLyoqXHJcbiAqIEEgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXHJcbiAqIFRoZSBzZWxlY3Rpb24gaXMgYSByYW5nZSB0aGF0IGhhcyBhbiBvcmllbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb24gZXh0ZW5kcyBSYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rpb25TdGFydExpbmVOdW1iZXIsIHNlbGVjdGlvblN0YXJ0Q29sdW1uLCBwb3NpdGlvbkxpbmVOdW1iZXIsIHBvc2l0aW9uQ29sdW1uKSB7XHJcbiAgICAgICAgc3VwZXIoc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbik7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPSBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbiA9IHNlbGVjdGlvblN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25MaW5lTnVtYmVyID0gcG9zaXRpb25MaW5lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25Db2x1bW4gPSBwb3NpdGlvbkNvbHVtbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtIHRvIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnWycgKyB0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciArICcsJyArIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gKyAnIC0+ICcgKyB0aGlzLnBvc2l0aW9uTGluZU51bWJlciArICcsJyArIHRoaXMucG9zaXRpb25Db2x1bW4gKyAnXSc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgZXF1YWxzIG90aGVyIHNlbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZXF1YWxzU2VsZWN0aW9uKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChTZWxlY3Rpb24uc2VsZWN0aW9uc0VxdWFsKHRoaXMsIG90aGVyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhlIHR3byBzZWxlY3Rpb25zIGFyZSBlcXVhbC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNlbGVjdGlvbnNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIChhLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gYi5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gYi5zZWxlY3Rpb25TdGFydENvbHVtbiAmJlxyXG4gICAgICAgICAgICBhLnBvc2l0aW9uTGluZU51bWJlciA9PT0gYi5wb3NpdGlvbkxpbmVOdW1iZXIgJiZcclxuICAgICAgICAgICAgYS5wb3NpdGlvbkNvbHVtbiA9PT0gYi5wb3NpdGlvbkNvbHVtbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBkaXJlY3Rpb25zIChMVFIgb3IgUlRMKS5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlyZWN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gdGhpcy5zdGFydExpbmVOdW1iZXIgJiYgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gdGhpcy5zdGFydENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBMVFIgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxIC8qIFJUTCAqLztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBzZXRFbmRQb3NpdGlvbihlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBMVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgdGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGF0IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBnZXRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMucG9zaXRpb25MaW5lTnVtYmVyLCB0aGlzLnBvc2l0aW9uQ29sdW1uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXJgIGFuZCBgc2VsZWN0aW9uU3RhcnRDb2x1bW5gLlxyXG4gICAgICovXHJcbiAgICBzZXRTdGFydFBvc2l0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pIHtcclxuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBMVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgdGhpcy5lbmRMaW5lTnVtYmVyLCB0aGlzLmVuZENvbHVtbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuZW5kTGluZU51bWJlciwgdGhpcy5lbmRDb2x1bW4sIHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIG9uZSBvciB0d28gcG9zaXRpb25zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQgPSBzdGFydCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0LmxpbmVOdW1iZXIsIHN0YXJ0LmNvbHVtbiwgZW5kLmxpbmVOdW1iZXIsIGVuZC5jb2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBmcm9tIGFuIGBJU2VsZWN0aW9uYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxpZnRTZWxlY3Rpb24oc2VsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciwgc2VsLnNlbGVjdGlvblN0YXJ0Q29sdW1uLCBzZWwucG9zaXRpb25MaW5lTnVtYmVyLCBzZWwucG9zaXRpb25Db2x1bW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgYWAgZXF1YWxzIGBiYC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNlbGVjdGlvbnNBcnJFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgJiYgIWIgfHwgIWEgJiYgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25zRXF1YWwoYVtpXSwgYltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdCBpZiBgb2JqYCBpcyBhbiBgSVNlbGVjdGlvbmAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0lTZWxlY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmpcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkxpbmVOdW1iZXIgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5wb3NpdGlvbkNvbHVtbiA9PT0gJ251bWJlcicpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHdpdGggYSBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVXaXRoRGlyZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gMCAvKiBMVFIgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcclxuICAgIH1cclxufVxyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0IGNsYXNzIFRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgdHlwZSwgbGFuZ3VhZ2UpIHtcclxuICAgICAgICB0aGlzLl90b2tlbkJyYW5kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHwgMDsgLy8gQHBlcmZcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLm9mZnNldCArICcsICcgKyB0aGlzLnR5cGUgKyAnKSc7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFRva2VuaXphdGlvblJlc3VsdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVuZFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uUmVzdWx0QnJhbmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XHJcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUb2tlbml6YXRpb25SZXN1bHQyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRva2VucywgZW5kU3RhdGUpIHtcclxuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25SZXN1bHQyQnJhbmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XHJcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBUSElTIElTIEEgR0VORVJBVEVEIEZJTEUuIERPIE5PVCBFRElUIERJUkVDVExZLlxyXG5leHBvcnQgdmFyIEFjY2Vzc2liaWxpdHlTdXBwb3J0O1xyXG4oZnVuY3Rpb24gKEFjY2Vzc2liaWxpdHlTdXBwb3J0KSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHRoZSBicm93c2VyIGNhc2Ugd2hlcmUgaXQgaXMgbm90IGtub3duIGlmIGEgc2NyZWVuIHJlYWRlciBpcyBhdHRhY2hlZCBvciBuby5cclxuICAgICAqL1xyXG4gICAgQWNjZXNzaWJpbGl0eVN1cHBvcnRbQWNjZXNzaWJpbGl0eVN1cHBvcnRbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcclxuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiRGlzYWJsZWRcIl0gPSAxXSA9IFwiRGlzYWJsZWRcIjtcclxuICAgIEFjY2Vzc2liaWxpdHlTdXBwb3J0W0FjY2Vzc2liaWxpdHlTdXBwb3J0W1wiRW5hYmxlZFwiXSA9IDJdID0gXCJFbmFibGVkXCI7XHJcbn0pKEFjY2Vzc2liaWxpdHlTdXBwb3J0IHx8IChBY2Nlc3NpYmlsaXR5U3VwcG9ydCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZTtcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdCB3aGl0ZXNwYWNlL2luZGVudGF0aW9uIG9mIG11bHRpbGluZSBpbnNlcnQgdGV4dHMgdG9cclxuICAgICAqIG1hdGNoIHRoZSBjdXJyZW50IGxpbmUgaW5kZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIktlZXBXaGl0ZXNwYWNlXCJdID0gMV0gPSBcIktlZXBXaGl0ZXNwYWNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIGBpbnNlcnRUZXh0YCBpcyBhIHNuaXBwZXQuXHJcbiAgICAgKi9cclxuICAgIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtcIkluc2VydEFzU25pcHBldFwiXSA9IDRdID0gXCJJbnNlcnRBc1NuaXBwZXRcIjtcclxufSkoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSB8fCAoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIk1ldGhvZFwiXSA9IDBdID0gXCJNZXRob2RcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbnN0cnVjdG9yXCJdID0gMl0gPSBcIkNvbnN0cnVjdG9yXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRmllbGRcIl0gPSAzXSA9IFwiRmllbGRcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJWYXJpYWJsZVwiXSA9IDRdID0gXCJWYXJpYWJsZVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNsYXNzXCJdID0gNV0gPSBcIkNsYXNzXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiU3RydWN0XCJdID0gNl0gPSBcIlN0cnVjdFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkludGVyZmFjZVwiXSA9IDddID0gXCJJbnRlcmZhY2VcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJNb2R1bGVcIl0gPSA4XSA9IFwiTW9kdWxlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiUHJvcGVydHlcIl0gPSA5XSA9IFwiUHJvcGVydHlcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFdmVudFwiXSA9IDEwXSA9IFwiRXZlbnRcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJPcGVyYXRvclwiXSA9IDExXSA9IFwiT3BlcmF0b3JcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJVbml0XCJdID0gMTJdID0gXCJVbml0XCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVmFsdWVcIl0gPSAxM10gPSBcIlZhbHVlXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiQ29uc3RhbnRcIl0gPSAxNF0gPSBcIkNvbnN0YW50XCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRW51bVwiXSA9IDE1XSA9IFwiRW51bVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkVudW1NZW1iZXJcIl0gPSAxNl0gPSBcIkVudW1NZW1iZXJcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJLZXl3b3JkXCJdID0gMTddID0gXCJLZXl3b3JkXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVGV4dFwiXSA9IDE4XSA9IFwiVGV4dFwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkNvbG9yXCJdID0gMTldID0gXCJDb2xvclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkZpbGVcIl0gPSAyMF0gPSBcIkZpbGVcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJSZWZlcmVuY2VcIl0gPSAyMV0gPSBcIlJlZmVyZW5jZVwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkN1c3RvbWNvbG9yXCJdID0gMjJdID0gXCJDdXN0b21jb2xvclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIkZvbGRlclwiXSA9IDIzXSA9IFwiRm9sZGVyXCI7XHJcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVHlwZVBhcmFtZXRlclwiXSA9IDI0XSA9IFwiVHlwZVBhcmFtZXRlclwiO1xyXG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlVzZXJcIl0gPSAyNV0gPSBcIlVzZXJcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJJc3N1ZVwiXSA9IDI2XSA9IFwiSXNzdWVcIjtcclxuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJTbmlwcGV0XCJdID0gMjddID0gXCJTbmlwcGV0XCI7XHJcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcclxuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbVRhZztcclxuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbVRhZykge1xyXG4gICAgQ29tcGxldGlvbkl0ZW1UYWdbQ29tcGxldGlvbkl0ZW1UYWdbXCJEZXByZWNhdGVkXCJdID0gMV0gPSBcIkRlcHJlY2F0ZWRcIjtcclxufSkoQ29tcGxldGlvbkl0ZW1UYWcgfHwgKENvbXBsZXRpb25JdGVtVGFnID0ge30pKTtcclxuLyoqXHJcbiAqIEhvdyBhIHN1Z2dlc3QgcHJvdmlkZXIgd2FzIHRyaWdnZXJlZC5cclxuICovXHJcbmV4cG9ydCB2YXIgQ29tcGxldGlvblRyaWdnZXJLaW5kO1xyXG4oZnVuY3Rpb24gKENvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xyXG4gICAgQ29tcGxldGlvblRyaWdnZXJLaW5kW0NvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcclxuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyQ2hhcmFjdGVyXCJdID0gMV0gPSBcIlRyaWdnZXJDaGFyYWN0ZXJcIjtcclxuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zXCJdID0gMl0gPSBcIlRyaWdnZXJGb3JJbmNvbXBsZXRlQ29tcGxldGlvbnNcIjtcclxufSkoQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xyXG4vKipcclxuICogQSBwb3NpdGlvbmluZyBwcmVmZXJlbmNlIGZvciByZW5kZXJpbmcgY29udGVudCB3aWRnZXRzLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlO1xyXG4oZnVuY3Rpb24gKENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGV4YWN0bHkgYXQgYSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJFWEFDVFwiXSA9IDBdID0gXCJFWEFDVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgYWJvdmUgYSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJBQk9WRVwiXSA9IDFdID0gXCJBQk9WRVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZSB0aGUgY29udGVudCB3aWRnZXQgYmVsb3cgYSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJCRUxPV1wiXSA9IDJdID0gXCJCRUxPV1wiO1xyXG59KShDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlIHx8IChDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgcmVhc29uIHRoZSBjdXJzb3IgaGFzIGNoYW5nZWQgaXRzIHBvc2l0aW9uLlxyXG4gKi9cclxuZXhwb3J0IHZhciBDdXJzb3JDaGFuZ2VSZWFzb247XHJcbihmdW5jdGlvbiAoQ3Vyc29yQ2hhbmdlUmVhc29uKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVua25vd24gb3Igbm90IHNldC5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIk5vdFNldFwiXSA9IDBdID0gXCJOb3RTZXRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBgbW9kZWwuc2V0VmFsdWUoKWAgd2FzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIkNvbnRlbnRGbHVzaFwiXSA9IDFdID0gXCJDb250ZW50Rmx1c2hcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBtb2RlbGAgaGFzIGJlZW4gY2hhbmdlZCBvdXRzaWRlIG9mIHRoaXMgY3Vyc29yIGFuZCB0aGUgY3Vyc29yIHJlY292ZXJzIGl0cyBwb3NpdGlvbiBmcm9tIGFzc29jaWF0ZWQgbWFya2Vycy5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlJlY292ZXJGcm9tTWFya2Vyc1wiXSA9IDJdID0gXCJSZWNvdmVyRnJvbU1hcmtlcnNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgd2FzIGFuIGV4cGxpY2l0IHVzZXIgZ2VzdHVyZS5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIkV4cGxpY2l0XCJdID0gM10gPSBcIkV4cGxpY2l0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZXJlIHdhcyBhIFBhc3RlLlxyXG4gICAgICovXHJcbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiUGFzdGVcIl0gPSA0XSA9IFwiUGFzdGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgd2FzIGFuIFVuZG8uXHJcbiAgICAgKi9cclxuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJVbmRvXCJdID0gNV0gPSBcIlVuZG9cIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlcmUgd2FzIGEgUmVkby5cclxuICAgICAqL1xyXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIlJlZG9cIl0gPSA2XSA9IFwiUmVkb1wiO1xyXG59KShDdXJzb3JDaGFuZ2VSZWFzb24gfHwgKEN1cnNvckNoYW5nZVJlYXNvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBlbmQgb2YgbGluZSB0byB1c2Ugd2hlbiBpbnN0YW50aWF0aW5nIG1vZGVscy5cclxuICovXHJcbmV4cG9ydCB2YXIgRGVmYXVsdEVuZE9mTGluZTtcclxuKGZ1bmN0aW9uIChEZWZhdWx0RW5kT2ZMaW5lKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdEVuZE9mTGluZVtEZWZhdWx0RW5kT2ZMaW5lW1wiTEZcIl0gPSAxXSA9IFwiTEZcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkIChcXHJcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIERlZmF1bHRFbmRPZkxpbmVbRGVmYXVsdEVuZE9mTGluZVtcIkNSTEZcIl0gPSAyXSA9IFwiQ1JMRlwiO1xyXG59KShEZWZhdWx0RW5kT2ZMaW5lIHx8IChEZWZhdWx0RW5kT2ZMaW5lID0ge30pKTtcclxuLyoqXHJcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcclxuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxyXG4gICAgICovXHJcbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiUmVhZFwiXSA9IDFdID0gXCJSZWFkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXHJcbiAgICAgKi9cclxuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJXcml0ZVwiXSA9IDJdID0gXCJXcml0ZVwiO1xyXG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGF1dG8gaW5kZW50YXRpb24gaW4gdGhlIGVkaXRvclxyXG4gKi9cclxuZXhwb3J0IHZhciBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5KSB7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiS2VlcFwiXSA9IDFdID0gXCJLZWVwXCI7XHJcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiQnJhY2tldHNcIl0gPSAyXSA9IFwiQnJhY2tldHNcIjtcclxuICAgIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbXCJBZHZhbmNlZFwiXSA9IDNdID0gXCJBZHZhbmNlZFwiO1xyXG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIkZ1bGxcIl0gPSA0XSA9IFwiRnVsbFwiO1xyXG59KShFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kgfHwgKEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgRWRpdG9yT3B0aW9uO1xyXG4oZnVuY3Rpb24gKEVkaXRvck9wdGlvbikge1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2VwdFN1Z2dlc3Rpb25PbkNvbW1pdENoYXJhY3RlclwiXSA9IDBdID0gXCJhY2NlcHRTdWdnZXN0aW9uT25Db21taXRDaGFyYWN0ZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhY2NlcHRTdWdnZXN0aW9uT25FbnRlclwiXSA9IDFdID0gXCJhY2NlcHRTdWdnZXN0aW9uT25FbnRlclwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2Vzc2liaWxpdHlTdXBwb3J0XCJdID0gMl0gPSBcImFjY2Vzc2liaWxpdHlTdXBwb3J0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYWNjZXNzaWJpbGl0eVBhZ2VTaXplXCJdID0gM10gPSBcImFjY2Vzc2liaWxpdHlQYWdlU2l6ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFyaWFMYWJlbFwiXSA9IDRdID0gXCJhcmlhTGFiZWxcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0JyYWNrZXRzXCJdID0gNV0gPSBcImF1dG9DbG9zaW5nQnJhY2tldHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiXSA9IDZdID0gXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nT3ZlcnR5cGVcIl0gPSA3XSA9IFwiYXV0b0Nsb3NpbmdPdmVydHlwZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nUXVvdGVzXCJdID0gOF0gPSBcImF1dG9DbG9zaW5nUXVvdGVzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b0luZGVudFwiXSA9IDldID0gXCJhdXRvSW5kZW50XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXV0b21hdGljTGF5b3V0XCJdID0gMTBdID0gXCJhdXRvbWF0aWNMYXlvdXRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvU3Vycm91bmRcIl0gPSAxMV0gPSBcImF1dG9TdXJyb3VuZFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvZGVMZW5zXCJdID0gMTJdID0gXCJjb2RlTGVuc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvZGVMZW5zRm9udEZhbWlseVwiXSA9IDEzXSA9IFwiY29kZUxlbnNGb250RmFtaWx5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNGb250U2l6ZVwiXSA9IDE0XSA9IFwiY29kZUxlbnNGb250U2l6ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbG9yRGVjb3JhdG9yc1wiXSA9IDE1XSA9IFwiY29sb3JEZWNvcmF0b3JzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29sdW1uU2VsZWN0aW9uXCJdID0gMTZdID0gXCJjb2x1bW5TZWxlY3Rpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb21tZW50c1wiXSA9IDE3XSA9IFwiY29tbWVudHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb250ZXh0bWVudVwiXSA9IDE4XSA9IFwiY29udGV4dG1lbnVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb3B5V2l0aFN5bnRheEhpZ2hsaWdodGluZ1wiXSA9IDE5XSA9IFwiY29weVdpdGhTeW50YXhIaWdobGlnaHRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JCbGlua2luZ1wiXSA9IDIwXSA9IFwiY3Vyc29yQmxpbmtpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTbW9vdGhDYXJldEFuaW1hdGlvblwiXSA9IDIxXSA9IFwiY3Vyc29yU21vb3RoQ2FyZXRBbmltYXRpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdHlsZVwiXSA9IDIyXSA9IFwiY3Vyc29yU3R5bGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCJdID0gMjNdID0gXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY3Vyc29yU3Vycm91bmRpbmdMaW5lc1N0eWxlXCJdID0gMjRdID0gXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzU3R5bGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JXaWR0aFwiXSA9IDI1XSA9IFwiY3Vyc29yV2lkdGhcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCJdID0gMjZdID0gXCJkaXNhYmxlTGF5ZXJIaW50aW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZGlzYWJsZU1vbm9zcGFjZU9wdGltaXphdGlvbnNcIl0gPSAyN10gPSBcImRpc2FibGVNb25vc3BhY2VPcHRpbWl6YXRpb25zXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZG9tUmVhZE9ubHlcIl0gPSAyOF0gPSBcImRvbVJlYWRPbmx5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZHJhZ0FuZERyb3BcIl0gPSAyOV0gPSBcImRyYWdBbmREcm9wXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZW1wdHlTZWxlY3Rpb25DbGlwYm9hcmRcIl0gPSAzMF0gPSBcImVtcHR5U2VsZWN0aW9uQ2xpcGJvYXJkXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZXh0cmFFZGl0b3JDbGFzc05hbWVcIl0gPSAzMV0gPSBcImV4dHJhRWRpdG9yQ2xhc3NOYW1lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZmFzdFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gMzJdID0gXCJmYXN0U2Nyb2xsU2Vuc2l0aXZpdHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmaW5kXCJdID0gMzNdID0gXCJmaW5kXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZml4ZWRPdmVyZmxvd1dpZGdldHNcIl0gPSAzNF0gPSBcImZpeGVkT3ZlcmZsb3dXaWRnZXRzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ1wiXSA9IDM1XSA9IFwiZm9sZGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdTdHJhdGVneVwiXSA9IDM2XSA9IFwiZm9sZGluZ1N0cmF0ZWd5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ0hpZ2hsaWdodFwiXSA9IDM3XSA9IFwiZm9sZGluZ0hpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdJbXBvcnRzQnlEZWZhdWx0XCJdID0gMzhdID0gXCJmb2xkaW5nSW1wb3J0c0J5RGVmYXVsdFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVuZm9sZE9uQ2xpY2tBZnRlckVuZE9mTGluZVwiXSA9IDM5XSA9IFwidW5mb2xkT25DbGlja0FmdGVyRW5kT2ZMaW5lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udEZhbWlseVwiXSA9IDQwXSA9IFwiZm9udEZhbWlseVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRJbmZvXCJdID0gNDFdID0gXCJmb250SW5mb1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbnRMaWdhdHVyZXNcIl0gPSA0Ml0gPSBcImZvbnRMaWdhdHVyZXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250U2l6ZVwiXSA9IDQzXSA9IFwiZm9udFNpemVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250V2VpZ2h0XCJdID0gNDRdID0gXCJmb250V2VpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9ybWF0T25QYXN0ZVwiXSA9IDQ1XSA9IFwiZm9ybWF0T25QYXN0ZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvcm1hdE9uVHlwZVwiXSA9IDQ2XSA9IFwiZm9ybWF0T25UeXBlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZ2x5cGhNYXJnaW5cIl0gPSA0N10gPSBcImdseXBoTWFyZ2luXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZ290b0xvY2F0aW9uXCJdID0gNDhdID0gXCJnb3RvTG9jYXRpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJoaWRlQ3Vyc29ySW5PdmVydmlld1J1bGVyXCJdID0gNDldID0gXCJoaWRlQ3Vyc29ySW5PdmVydmlld1J1bGVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaGlnaGxpZ2h0QWN0aXZlSW5kZW50R3VpZGVcIl0gPSA1MF0gPSBcImhpZ2hsaWdodEFjdGl2ZUluZGVudEd1aWRlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaG92ZXJcIl0gPSA1MV0gPSBcImhvdmVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5EaWZmRWRpdG9yXCJdID0gNTJdID0gXCJpbkRpZmZFZGl0b3JcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxpbmVTdWdnZXN0XCJdID0gNTNdID0gXCJpbmxpbmVTdWdnZXN0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGV0dGVyU3BhY2luZ1wiXSA9IDU0XSA9IFwibGV0dGVyU3BhY2luZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpZ2h0YnVsYlwiXSA9IDU1XSA9IFwibGlnaHRidWxiXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZURlY29yYXRpb25zV2lkdGhcIl0gPSA1Nl0gPSBcImxpbmVEZWNvcmF0aW9uc1dpZHRoXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZUhlaWdodFwiXSA9IDU3XSA9IFwibGluZUhlaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmVOdW1iZXJzXCJdID0gNThdID0gXCJsaW5lTnVtYmVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmVOdW1iZXJzTWluQ2hhcnNcIl0gPSA1OV0gPSBcImxpbmVOdW1iZXJzTWluQ2hhcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5rZWRFZGl0aW5nXCJdID0gNjBdID0gXCJsaW5rZWRFZGl0aW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGlua3NcIl0gPSA2MV0gPSBcImxpbmtzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibWF0Y2hCcmFja2V0c1wiXSA9IDYyXSA9IFwibWF0Y2hCcmFja2V0c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1pbmltYXBcIl0gPSA2M10gPSBcIm1pbmltYXBcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVN0eWxlXCJdID0gNjRdID0gXCJtb3VzZVN0eWxlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VXaGVlbFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gNjVdID0gXCJtb3VzZVdoZWVsU2Nyb2xsU2Vuc2l0aXZpdHlcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtb3VzZVdoZWVsWm9vbVwiXSA9IDY2XSA9IFwibW91c2VXaGVlbFpvb21cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvck1lcmdlT3ZlcmxhcHBpbmdcIl0gPSA2N10gPSBcIm11bHRpQ3Vyc29yTWVyZ2VPdmVybGFwcGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm11bHRpQ3Vyc29yTW9kaWZpZXJcIl0gPSA2OF0gPSBcIm11bHRpQ3Vyc29yTW9kaWZpZXJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvclBhc3RlXCJdID0gNjldID0gXCJtdWx0aUN1cnNvclBhc3RlXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wib2NjdXJyZW5jZXNIaWdobGlnaHRcIl0gPSA3MF0gPSBcIm9jY3VycmVuY2VzSGlnaGxpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wib3ZlcnZpZXdSdWxlckJvcmRlclwiXSA9IDcxXSA9IFwib3ZlcnZpZXdSdWxlckJvcmRlclwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm92ZXJ2aWV3UnVsZXJMYW5lc1wiXSA9IDcyXSA9IFwib3ZlcnZpZXdSdWxlckxhbmVzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGFkZGluZ1wiXSA9IDczXSA9IFwicGFkZGluZ1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBhcmFtZXRlckhpbnRzXCJdID0gNzRdID0gXCJwYXJhbWV0ZXJIaW50c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBlZWtXaWRnZXREZWZhdWx0Rm9jdXNcIl0gPSA3NV0gPSBcInBlZWtXaWRnZXREZWZhdWx0Rm9jdXNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkZWZpbml0aW9uTGlua09wZW5zSW5QZWVrXCJdID0gNzZdID0gXCJkZWZpbml0aW9uTGlua09wZW5zSW5QZWVrXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicXVpY2tTdWdnZXN0aW9uc1wiXSA9IDc3XSA9IFwicXVpY2tTdWdnZXN0aW9uc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInF1aWNrU3VnZ2VzdGlvbnNEZWxheVwiXSA9IDc4XSA9IFwicXVpY2tTdWdnZXN0aW9uc0RlbGF5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVhZE9ubHlcIl0gPSA3OV0gPSBcInJlYWRPbmx5XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuYW1lT25UeXBlXCJdID0gODBdID0gXCJyZW5hbWVPblR5cGVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJDb250cm9sQ2hhcmFjdGVyc1wiXSA9IDgxXSA9IFwicmVuZGVyQ29udHJvbENoYXJhY3RlcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJJbmRlbnRHdWlkZXNcIl0gPSA4Ml0gPSBcInJlbmRlckluZGVudEd1aWRlc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckZpbmFsTmV3bGluZVwiXSA9IDgzXSA9IFwicmVuZGVyRmluYWxOZXdsaW5lXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyTGluZUhpZ2hsaWdodFwiXSA9IDg0XSA9IFwicmVuZGVyTGluZUhpZ2hsaWdodFwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckxpbmVIaWdobGlnaHRPbmx5V2hlbkZvY3VzXCJdID0gODVdID0gXCJyZW5kZXJMaW5lSGlnaGxpZ2h0T25seVdoZW5Gb2N1c1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlclZhbGlkYXRpb25EZWNvcmF0aW9uc1wiXSA9IDg2XSA9IFwicmVuZGVyVmFsaWRhdGlvbkRlY29yYXRpb25zXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVuZGVyV2hpdGVzcGFjZVwiXSA9IDg3XSA9IFwicmVuZGVyV2hpdGVzcGFjZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJldmVhbEhvcml6b250YWxSaWdodFBhZGRpbmdcIl0gPSA4OF0gPSBcInJldmVhbEhvcml6b250YWxSaWdodFBhZGRpbmdcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyb3VuZGVkU2VsZWN0aW9uXCJdID0gODldID0gXCJyb3VuZGVkU2VsZWN0aW9uXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicnVsZXJzXCJdID0gOTBdID0gXCJydWxlcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxiYXJcIl0gPSA5MV0gPSBcInNjcm9sbGJhclwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNjcm9sbEJleW9uZExhc3RDb2x1bW5cIl0gPSA5Ml0gPSBcInNjcm9sbEJleW9uZExhc3RDb2x1bW5cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxCZXlvbmRMYXN0TGluZVwiXSA9IDkzXSA9IFwic2Nyb2xsQmV5b25kTGFzdExpbmVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxQcmVkb21pbmFudEF4aXNcIl0gPSA5NF0gPSBcInNjcm9sbFByZWRvbWluYW50QXhpc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdGlvbkNsaXBib2FyZFwiXSA9IDk1XSA9IFwic2VsZWN0aW9uQ2xpcGJvYXJkXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0aW9uSGlnaGxpZ2h0XCJdID0gOTZdID0gXCJzZWxlY3Rpb25IaWdobGlnaHRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzZWxlY3RPbkxpbmVOdW1iZXJzXCJdID0gOTddID0gXCJzZWxlY3RPbkxpbmVOdW1iZXJzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2hvd0ZvbGRpbmdDb250cm9sc1wiXSA9IDk4XSA9IFwic2hvd0ZvbGRpbmdDb250cm9sc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNob3dVbnVzZWRcIl0gPSA5OV0gPSBcInNob3dVbnVzZWRcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbmlwcGV0U3VnZ2VzdGlvbnNcIl0gPSAxMDBdID0gXCJzbmlwcGV0U3VnZ2VzdGlvbnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbWFydFNlbGVjdFwiXSA9IDEwMV0gPSBcInNtYXJ0U2VsZWN0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic21vb3RoU2Nyb2xsaW5nXCJdID0gMTAyXSA9IFwic21vb3RoU2Nyb2xsaW5nXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3RpY2t5VGFiU3RvcHNcIl0gPSAxMDNdID0gXCJzdGlja3lUYWJTdG9wc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIl0gPSAxMDRdID0gXCJzdG9wUmVuZGVyaW5nTGluZUFmdGVyXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdFwiXSA9IDEwNV0gPSBcInN1Z2dlc3RcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0Rm9udFNpemVcIl0gPSAxMDZdID0gXCJzdWdnZXN0Rm9udFNpemVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0TGluZUhlaWdodFwiXSA9IDEwN10gPSBcInN1Z2dlc3RMaW5lSGVpZ2h0XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdE9uVHJpZ2dlckNoYXJhY3RlcnNcIl0gPSAxMDhdID0gXCJzdWdnZXN0T25UcmlnZ2VyQ2hhcmFjdGVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RTZWxlY3Rpb25cIl0gPSAxMDldID0gXCJzdWdnZXN0U2VsZWN0aW9uXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiQ29tcGxldGlvblwiXSA9IDExMF0gPSBcInRhYkNvbXBsZXRpb25cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ0YWJJbmRleFwiXSA9IDExMV0gPSBcInRhYkluZGV4XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widW51c3VhbExpbmVUZXJtaW5hdG9yc1wiXSA9IDExMl0gPSBcInVudXN1YWxMaW5lVGVybWluYXRvcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1c2VTaGFkb3dET01cIl0gPSAxMTNdID0gXCJ1c2VTaGFkb3dET01cIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1c2VUYWJTdG9wc1wiXSA9IDExNF0gPSBcInVzZVRhYlN0b3BzXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFNlcGFyYXRvcnNcIl0gPSAxMTVdID0gXCJ3b3JkU2VwYXJhdG9yc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwXCJdID0gMTE2XSA9IFwid29yZFdyYXBcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcEJyZWFrQWZ0ZXJDaGFyYWN0ZXJzXCJdID0gMTE3XSA9IFwid29yZFdyYXBCcmVha0FmdGVyQ2hhcmFjdGVyc1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwQnJlYWtCZWZvcmVDaGFyYWN0ZXJzXCJdID0gMTE4XSA9IFwid29yZFdyYXBCcmVha0JlZm9yZUNoYXJhY3RlcnNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcENvbHVtblwiXSA9IDExOV0gPSBcIndvcmRXcmFwQ29sdW1uXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBPdmVycmlkZTFcIl0gPSAxMjBdID0gXCJ3b3JkV3JhcE92ZXJyaWRlMVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwT3ZlcnJpZGUyXCJdID0gMTIxXSA9IFwid29yZFdyYXBPdmVycmlkZTJcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3cmFwcGluZ0luZGVudFwiXSA9IDEyMl0gPSBcIndyYXBwaW5nSW5kZW50XCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid3JhcHBpbmdTdHJhdGVneVwiXSA9IDEyM10gPSBcIndyYXBwaW5nU3RyYXRlZ3lcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzaG93RGVwcmVjYXRlZFwiXSA9IDEyNF0gPSBcInNob3dEZXByZWNhdGVkXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5sYXlIaW50c1wiXSA9IDEyNV0gPSBcImlubGF5SGludHNcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJlZGl0b3JDbGFzc05hbWVcIl0gPSAxMjZdID0gXCJlZGl0b3JDbGFzc05hbWVcIjtcclxuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwaXhlbFJhdGlvXCJdID0gMTI3XSA9IFwicGl4ZWxSYXRpb1wiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInRhYkZvY3VzTW9kZVwiXSA9IDEyOF0gPSBcInRhYkZvY3VzTW9kZVwiO1xyXG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxheW91dEluZm9cIl0gPSAxMjldID0gXCJsYXlvdXRJbmZvXCI7XHJcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid3JhcHBpbmdJbmZvXCJdID0gMTMwXSA9IFwid3JhcHBpbmdJbmZvXCI7XHJcbn0pKEVkaXRvck9wdGlvbiB8fCAoRWRpdG9yT3B0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEVuZCBvZiBsaW5lIGNoYXJhY3RlciBwcmVmZXJlbmNlLlxyXG4gKi9cclxuZXhwb3J0IHZhciBFbmRPZkxpbmVQcmVmZXJlbmNlO1xyXG4oZnVuY3Rpb24gKEVuZE9mTGluZVByZWZlcmVuY2UpIHtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIgaWRlbnRpZmllZCBpbiB0aGUgdGV4dCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIEVuZE9mTGluZVByZWZlcmVuY2VbRW5kT2ZMaW5lUHJlZmVyZW5jZVtcIlRleHREZWZpbmVkXCJdID0gMF0gPSBcIlRleHREZWZpbmVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cclxuICAgICAqL1xyXG4gICAgRW5kT2ZMaW5lUHJlZmVyZW5jZVtFbmRPZkxpbmVQcmVmZXJlbmNlW1wiTEZcIl0gPSAxXSA9IFwiTEZcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkIChcXHJcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIEVuZE9mTGluZVByZWZlcmVuY2VbRW5kT2ZMaW5lUHJlZmVyZW5jZVtcIkNSTEZcIl0gPSAyXSA9IFwiQ1JMRlwiO1xyXG59KShFbmRPZkxpbmVQcmVmZXJlbmNlIHx8IChFbmRPZkxpbmVQcmVmZXJlbmNlID0ge30pKTtcclxuLyoqXHJcbiAqIEVuZCBvZiBsaW5lIGNoYXJhY3RlciBwcmVmZXJlbmNlLlxyXG4gKi9cclxuZXhwb3J0IHZhciBFbmRPZkxpbmVTZXF1ZW5jZTtcclxuKGZ1bmN0aW9uIChFbmRPZkxpbmVTZXF1ZW5jZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgbGluZSBmZWVkIChcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIEVuZE9mTGluZVNlcXVlbmNlW0VuZE9mTGluZVNlcXVlbmNlW1wiTEZcIl0gPSAwXSA9IFwiTEZcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkIChcXHJcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXHJcbiAgICAgKi9cclxuICAgIEVuZE9mTGluZVNlcXVlbmNlW0VuZE9mTGluZVNlcXVlbmNlW1wiQ1JMRlwiXSA9IDFdID0gXCJDUkxGXCI7XHJcbn0pKEVuZE9mTGluZVNlcXVlbmNlIHx8IChFbmRPZkxpbmVTZXF1ZW5jZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZXNjcmliZXMgd2hhdCB0byBkbyB3aXRoIHRoZSBpbmRlbnRhdGlvbiB3aGVuIHByZXNzaW5nIEVudGVyLlxyXG4gKi9cclxuZXhwb3J0IHZhciBJbmRlbnRBY3Rpb247XHJcbihmdW5jdGlvbiAoSW5kZW50QWN0aW9uKSB7XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBuZXcgbGluZSBhbmQgY29weSB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydCBuZXcgbGluZSBhbmQgaW5kZW50IG9uY2UgKHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBsaW5lJ3MgaW5kZW50YXRpb24pLlxyXG4gICAgICovXHJcbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiSW5kZW50XCJdID0gMV0gPSBcIkluZGVudFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgdHdvIG5ldyBsaW5lczpcclxuICAgICAqICAtIHRoZSBmaXJzdCBvbmUgaW5kZW50ZWQgd2hpY2ggd2lsbCBob2xkIHRoZSBjdXJzb3JcclxuICAgICAqICAtIHRoZSBzZWNvbmQgb25lIGF0IHRoZSBzYW1lIGluZGVudGF0aW9uIGxldmVsXHJcbiAgICAgKi9cclxuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJJbmRlbnRPdXRkZW50XCJdID0gMl0gPSBcIkluZGVudE91dGRlbnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IG5ldyBsaW5lIGFuZCBvdXRkZW50IG9uY2UgKHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBsaW5lJ3MgaW5kZW50YXRpb24pLlxyXG4gICAgICovXHJcbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiT3V0ZGVudFwiXSA9IDNdID0gXCJPdXRkZW50XCI7XHJcbn0pKEluZGVudEFjdGlvbiB8fCAoSW5kZW50QWN0aW9uID0ge30pKTtcclxuZXhwb3J0IHZhciBJbmxheUhpbnRLaW5kO1xyXG4oZnVuY3Rpb24gKElubGF5SGludEtpbmQpIHtcclxuICAgIElubGF5SGludEtpbmRbSW5sYXlIaW50S2luZFtcIk90aGVyXCJdID0gMF0gPSBcIk90aGVyXCI7XHJcbiAgICBJbmxheUhpbnRLaW5kW0lubGF5SGludEtpbmRbXCJUeXBlXCJdID0gMV0gPSBcIlR5cGVcIjtcclxuICAgIElubGF5SGludEtpbmRbSW5sYXlIaW50S2luZFtcIlBhcmFtZXRlclwiXSA9IDJdID0gXCJQYXJhbWV0ZXJcIjtcclxufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XHJcbi8qKlxyXG4gKiBIb3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25zUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgd2hpbGUgZWRpdGluZy5cclxuICAgICAqIEl0IGlzIHN1ZmZpY2llbnQgdG8gcmV0dXJuIGEgc2luZ2xlIGNvbXBsZXRpb24gaXRlbSBpbiB0aGlzIGNhc2UuXHJcbiAgICAgKi9cclxuICAgIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAwXSA9IFwiQXV0b21hdGljXCI7XHJcbiAgICAvKipcclxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGEgdXNlciBnZXN0dXJlLlxyXG4gICAgICogUmV0dXJuIG11bHRpcGxlIGNvbXBsZXRpb24gaXRlbXMgdG8gZW5hYmxlIGN5Y2xpbmcgdGhyb3VnaCB0aGVtLlxyXG4gICAgICovXHJcbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiRXhwbGljaXRcIl0gPSAxXSA9IFwiRXhwbGljaXRcIjtcclxufSkoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xyXG4vKipcclxuICogVmlydHVhbCBLZXkgQ29kZXMsIHRoZSB2YWx1ZSBkb2VzIG5vdCBob2xkIGFueSBpbmhlcmVudCBtZWFuaW5nLlxyXG4gKiBJbnNwaXJlZCBzb21ld2hhdCBmcm9tIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2RkMzc1NzMxKHY9dnMuODUpLmFzcHhcclxuICogQnV0IHRoZXNlIGFyZSBcIm1vcmUgZ2VuZXJhbFwiLCBhcyB0aGV5IHNob3VsZCB3b3JrIGFjcm9zcyBicm93c2VycyAmIE9TYHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIEtleUNvZGU7XHJcbihmdW5jdGlvbiAoS2V5Q29kZSkge1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGVwZW5kc09uS2JMYXlvdXRcIl0gPSAtMV0gPSBcIkRlcGVuZHNPbktiTGF5b3V0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFBsYWNlZCBmaXJzdCB0byBjb3ZlciB0aGUgMCB2YWx1ZSBvZiB0aGUgZW51bS5cclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVW5rbm93blwiXSA9IDBdID0gXCJVbmtub3duXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCYWNrc3BhY2VcIl0gPSAxXSA9IFwiQmFja3NwYWNlXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJUYWJcIl0gPSAyXSA9IFwiVGFiXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFbnRlclwiXSA9IDNdID0gXCJFbnRlclwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2hpZnRcIl0gPSA0XSA9IFwiU2hpZnRcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkN0cmxcIl0gPSA1XSA9IFwiQ3RybFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQWx0XCJdID0gNl0gPSBcIkFsdFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGF1c2VCcmVha1wiXSA9IDddID0gXCJQYXVzZUJyZWFrXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDYXBzTG9ja1wiXSA9IDhdID0gXCJDYXBzTG9ja1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRXNjYXBlXCJdID0gOV0gPSBcIkVzY2FwZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU3BhY2VcIl0gPSAxMF0gPSBcIlNwYWNlXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQYWdlVXBcIl0gPSAxMV0gPSBcIlBhZ2VVcFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGFnZURvd25cIl0gPSAxMl0gPSBcIlBhZ2VEb3duXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFbmRcIl0gPSAxM10gPSBcIkVuZFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiSG9tZVwiXSA9IDE0XSA9IFwiSG9tZVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTGVmdEFycm93XCJdID0gMTVdID0gXCJMZWZ0QXJyb3dcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVwQXJyb3dcIl0gPSAxNl0gPSBcIlVwQXJyb3dcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlJpZ2h0QXJyb3dcIl0gPSAxN10gPSBcIlJpZ2h0QXJyb3dcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRvd25BcnJvd1wiXSA9IDE4XSA9IFwiRG93bkFycm93XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJJbnNlcnRcIl0gPSAxOV0gPSBcIkluc2VydFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGVsZXRlXCJdID0gMjBdID0gXCJEZWxldGVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV8wXCJdID0gMjFdID0gXCJLRVlfMFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzFcIl0gPSAyMl0gPSBcIktFWV8xXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfMlwiXSA9IDIzXSA9IFwiS0VZXzJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV8zXCJdID0gMjRdID0gXCJLRVlfM1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzRcIl0gPSAyNV0gPSBcIktFWV80XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfNVwiXSA9IDI2XSA9IFwiS0VZXzVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV82XCJdID0gMjddID0gXCJLRVlfNlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZXzdcIl0gPSAyOF0gPSBcIktFWV83XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfOFwiXSA9IDI5XSA9IFwiS0VZXzhcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV85XCJdID0gMzBdID0gXCJLRVlfOVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0FcIl0gPSAzMV0gPSBcIktFWV9BXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfQlwiXSA9IDMyXSA9IFwiS0VZX0JcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9DXCJdID0gMzNdID0gXCJLRVlfQ1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0RcIl0gPSAzNF0gPSBcIktFWV9EXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfRVwiXSA9IDM1XSA9IFwiS0VZX0VcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9GXCJdID0gMzZdID0gXCJLRVlfRlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0dcIl0gPSAzN10gPSBcIktFWV9HXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfSFwiXSA9IDM4XSA9IFwiS0VZX0hcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9JXCJdID0gMzldID0gXCJLRVlfSVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX0pcIl0gPSA0MF0gPSBcIktFWV9KXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfS1wiXSA9IDQxXSA9IFwiS0VZX0tcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9MXCJdID0gNDJdID0gXCJLRVlfTFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX01cIl0gPSA0M10gPSBcIktFWV9NXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfTlwiXSA9IDQ0XSA9IFwiS0VZX05cIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9PXCJdID0gNDVdID0gXCJLRVlfT1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1BcIl0gPSA0Nl0gPSBcIktFWV9QXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfUVwiXSA9IDQ3XSA9IFwiS0VZX1FcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9SXCJdID0gNDhdID0gXCJLRVlfUlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1NcIl0gPSA0OV0gPSBcIktFWV9TXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfVFwiXSA9IDUwXSA9IFwiS0VZX1RcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9VXCJdID0gNTFdID0gXCJLRVlfVVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1ZcIl0gPSA1Ml0gPSBcIktFWV9WXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfV1wiXSA9IDUzXSA9IFwiS0VZX1dcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIktFWV9YXCJdID0gNTRdID0gXCJLRVlfWFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS0VZX1lcIl0gPSA1NV0gPSBcIktFWV9ZXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfWlwiXSA9IDU2XSA9IFwiS0VZX1pcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1ldGFcIl0gPSA1N10gPSBcIk1ldGFcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkNvbnRleHRNZW51XCJdID0gNThdID0gXCJDb250ZXh0TWVudVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjFcIl0gPSA1OV0gPSBcIkYxXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMlwiXSA9IDYwXSA9IFwiRjJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYzXCJdID0gNjFdID0gXCJGM1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjRcIl0gPSA2Ml0gPSBcIkY0XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGNVwiXSA9IDYzXSA9IFwiRjVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY2XCJdID0gNjRdID0gXCJGNlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjdcIl0gPSA2NV0gPSBcIkY3XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGOFwiXSA9IDY2XSA9IFwiRjhcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkY5XCJdID0gNjddID0gXCJGOVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjEwXCJdID0gNjhdID0gXCJGMTBcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMVwiXSA9IDY5XSA9IFwiRjExXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTJcIl0gPSA3MF0gPSBcIkYxMlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjEzXCJdID0gNzFdID0gXCJGMTNcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNFwiXSA9IDcyXSA9IFwiRjE0XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTVcIl0gPSA3M10gPSBcIkYxNVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE2XCJdID0gNzRdID0gXCJGMTZcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxN1wiXSA9IDc1XSA9IFwiRjE3XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMThcIl0gPSA3Nl0gPSBcIkYxOFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE5XCJdID0gNzddID0gXCJGMTlcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bUxvY2tcIl0gPSA3OF0gPSBcIk51bUxvY2tcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlNjcm9sbExvY2tcIl0gPSA3OV0gPSBcIlNjcm9sbExvY2tcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cclxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnOzonIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19TRU1JQ09MT05cIl0gPSA4MF0gPSBcIlVTX1NFTUlDT0xPTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJysnIGtleVxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICc9Kycga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX0VRVUFMXCJdID0gODFdID0gXCJVU19FUVVBTFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJywnIGtleVxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcsPCcga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX0NPTU1BXCJdID0gODJdID0gXCJVU19DT01NQVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJy0nIGtleVxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICctXycga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX01JTlVTXCJdID0gODNdID0gXCJVU19NSU5VU1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJy4nIGtleVxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcuPicga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX0RPVFwiXSA9IDg0XSA9IFwiVVNfRE9UXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJy8/JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfU0xBU0hcIl0gPSA4NV0gPSBcIlVTX1NMQVNIXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ2B+JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfQkFDS1RJQ0tcIl0gPSA4Nl0gPSBcIlVTX0JBQ0tUSUNLXCI7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXHJcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ1t7JyBrZXlcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVVNfT1BFTl9TUVVBUkVfQlJBQ0tFVFwiXSA9IDg3XSA9IFwiVVNfT1BFTl9TUVVBUkVfQlJBQ0tFVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICdcXHwnIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19CQUNLU0xBU0hcIl0gPSA4OF0gPSBcIlVTX0JBQ0tTTEFTSFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICddfScga2V5XHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVTX0NMT1NFX1NRVUFSRV9CUkFDS0VUXCJdID0gODldID0gXCJVU19DTE9TRV9TUVVBUkVfQlJBQ0tFVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxyXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcnXCInIGtleVxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVU19RVU9URVwiXSA9IDkwXSA9IFwiVVNfUVVPVEVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiT0VNXzhcIl0gPSA5MV0gPSBcIk9FTV84XCI7XHJcbiAgICAvKipcclxuICAgICAqIEVpdGhlciB0aGUgYW5nbGUgYnJhY2tldCBrZXkgb3IgdGhlIGJhY2tzbGFzaCBrZXkgb24gdGhlIFJUIDEwMi1rZXkga2V5Ym9hcmQuXHJcbiAgICAgKi9cclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk9FTV8xMDJcIl0gPSA5Ml0gPSBcIk9FTV8xMDJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF8wXCJdID0gOTNdID0gXCJOVU1QQURfMFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzFcIl0gPSA5NF0gPSBcIk5VTVBBRF8xXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfMlwiXSA9IDk1XSA9IFwiTlVNUEFEXzJcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF8zXCJdID0gOTZdID0gXCJOVU1QQURfM1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzRcIl0gPSA5N10gPSBcIk5VTVBBRF80XCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfNVwiXSA9IDk4XSA9IFwiTlVNUEFEXzVcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF82XCJdID0gOTldID0gXCJOVU1QQURfNlwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzdcIl0gPSAxMDBdID0gXCJOVU1QQURfN1wiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzhcIl0gPSAxMDFdID0gXCJOVU1QQURfOFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEXzlcIl0gPSAxMDJdID0gXCJOVU1QQURfOVwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX01VTFRJUExZXCJdID0gMTAzXSA9IFwiTlVNUEFEX01VTFRJUExZXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfQUREXCJdID0gMTA0XSA9IFwiTlVNUEFEX0FERFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX1NFUEFSQVRPUlwiXSA9IDEwNV0gPSBcIk5VTVBBRF9TRVBBUkFUT1JcIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIk5VTVBBRF9TVUJUUkFDVFwiXSA9IDEwNl0gPSBcIk5VTVBBRF9TVUJUUkFDVFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX0RFQ0lNQUxcIl0gPSAxMDddID0gXCJOVU1QQURfREVDSU1BTFwiO1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTlVNUEFEX0RJVklERVwiXSA9IDEwOF0gPSBcIk5VTVBBRF9ESVZJREVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ292ZXIgYWxsIGtleSBjb2RlcyB3aGVuIElNRSBpcyBwcm9jZXNzaW5nIGlucHV0LlxyXG4gICAgICovXHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfSU5fQ09NUE9TSVRJT05cIl0gPSAxMDldID0gXCJLRVlfSU5fQ09NUE9TSVRJT05cIjtcclxuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFCTlRfQzFcIl0gPSAxMTBdID0gXCJBQk5UX0MxXCI7XHJcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBQk5UX0MyXCJdID0gMTExXSA9IFwiQUJOVF9DMlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZWQgbGFzdCB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBlbnVtLlxyXG4gICAgICogUGxlYXNlIGRvIG5vdCBkZXBlbmQgb24gdGhpcyB2YWx1ZSFcclxuICAgICAqL1xyXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTUFYX1ZBTFVFXCJdID0gMTEyXSA9IFwiTUFYX1ZBTFVFXCI7XHJcbn0pKEtleUNvZGUgfHwgKEtleUNvZGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIE1hcmtlclNldmVyaXR5O1xyXG4oZnVuY3Rpb24gKE1hcmtlclNldmVyaXR5KSB7XHJcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIkhpbnRcIl0gPSAxXSA9IFwiSGludFwiO1xyXG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJJbmZvXCJdID0gMl0gPSBcIkluZm9cIjtcclxuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiV2FybmluZ1wiXSA9IDRdID0gXCJXYXJuaW5nXCI7XHJcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIkVycm9yXCJdID0gOF0gPSBcIkVycm9yXCI7XHJcbn0pKE1hcmtlclNldmVyaXR5IHx8IChNYXJrZXJTZXZlcml0eSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgTWFya2VyVGFnO1xyXG4oZnVuY3Rpb24gKE1hcmtlclRhZykge1xyXG4gICAgTWFya2VyVGFnW01hcmtlclRhZ1tcIlVubmVjZXNzYXJ5XCJdID0gMV0gPSBcIlVubmVjZXNzYXJ5XCI7XHJcbiAgICBNYXJrZXJUYWdbTWFya2VyVGFnW1wiRGVwcmVjYXRlZFwiXSA9IDJdID0gXCJEZXByZWNhdGVkXCI7XHJcbn0pKE1hcmtlclRhZyB8fCAoTWFya2VyVGFnID0ge30pKTtcclxuLyoqXHJcbiAqIFBvc2l0aW9uIGluIHRoZSBtaW5pbWFwIHRvIHJlbmRlciB0aGUgZGVjb3JhdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgTWluaW1hcFBvc2l0aW9uO1xyXG4oZnVuY3Rpb24gKE1pbmltYXBQb3NpdGlvbikge1xyXG4gICAgTWluaW1hcFBvc2l0aW9uW01pbmltYXBQb3NpdGlvbltcIklubGluZVwiXSA9IDFdID0gXCJJbmxpbmVcIjtcclxuICAgIE1pbmltYXBQb3NpdGlvbltNaW5pbWFwUG9zaXRpb25bXCJHdXR0ZXJcIl0gPSAyXSA9IFwiR3V0dGVyXCI7XHJcbn0pKE1pbmltYXBQb3NpdGlvbiB8fCAoTWluaW1hcFBvc2l0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIFR5cGUgb2YgaGl0IGVsZW1lbnQgd2l0aCB0aGUgbW91c2UgaW4gdGhlIGVkaXRvci5cclxuICovXHJcbmV4cG9ydCB2YXIgTW91c2VUYXJnZXRUeXBlO1xyXG4oZnVuY3Rpb24gKE1vdXNlVGFyZ2V0VHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYW4gdW5rbm93biBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgdGV4dGFyZWEgdXNlZCBmb3IgaW5wdXQuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJURVhUQVJFQVwiXSA9IDFdID0gXCJURVhUQVJFQVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIGdseXBoIG1hcmdpblxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0dMWVBIX01BUkdJTlwiXSA9IDJdID0gXCJHVVRURVJfR0xZUEhfTUFSR0lOXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgbGluZSBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJHVVRURVJfTElORV9OVU1CRVJTXCJdID0gM10gPSBcIkdVVFRFUl9MSU5FX05VTUJFUlNcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBsaW5lIGRlY29yYXRpb25zXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJHVVRURVJfTElORV9ERUNPUkFUSU9OU1wiXSA9IDRdID0gXCJHVVRURVJfTElORV9ERUNPUkFUSU9OU1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgdGhlIHdoaXRlc3BhY2UgbGVmdCBpbiB0aGUgZ3V0dGVyIGJ5IGEgdmlldyB6b25lLlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX1ZJRVdfWk9ORVwiXSA9IDVdID0gXCJHVVRURVJfVklFV19aT05FXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0ZXh0IGluIHRoZSBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9URVhUXCJdID0gNl0gPSBcIkNPTlRFTlRfVEVYVFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgZW1wdHkgc3BhY2UgaW4gdGhlIGNvbnRlbnQgKGUuZy4gYWZ0ZXIgbGluZSB0ZXh0IG9yIGJlbG93IGxhc3QgbGluZSlcclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfRU1QVFlcIl0gPSA3XSA9IFwiQ09OVEVOVF9FTVBUWVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYSB2aWV3IHpvbmUgaW4gdGhlIGNvbnRlbnQuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1ZJRVdfWk9ORVwiXSA9IDhdID0gXCJDT05URU5UX1ZJRVdfWk9ORVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYSBjb250ZW50IHdpZGdldC5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfV0lER0VUXCJdID0gOV0gPSBcIkNPTlRFTlRfV0lER0VUXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgZGVjb3JhdGlvbnMgb3ZlcnZpZXcgcnVsZXIuXHJcbiAgICAgKi9cclxuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJPVkVSVklFV19SVUxFUlwiXSA9IDEwXSA9IFwiT1ZFUlZJRVdfUlVMRVJcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgc2Nyb2xsYmFyLlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiU0NST0xMQkFSXCJdID0gMTFdID0gXCJTQ1JPTExCQVJcIjtcclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGFuIG92ZXJsYXkgd2lkZ2V0LlxyXG4gICAgICovXHJcbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiT1ZFUkxBWV9XSURHRVRcIl0gPSAxMl0gPSBcIk9WRVJMQVlfV0lER0VUXCI7XHJcbiAgICAvKipcclxuICAgICAqIE1vdXNlIGlzIG91dHNpZGUgb2YgdGhlIGVkaXRvci5cclxuICAgICAqL1xyXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9VVFNJREVfRURJVE9SXCJdID0gMTNdID0gXCJPVVRTSURFX0VESVRPUlwiO1xyXG59KShNb3VzZVRhcmdldFR5cGUgfHwgKE1vdXNlVGFyZ2V0VHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBIHBvc2l0aW9uaW5nIHByZWZlcmVuY2UgZm9yIHJlbmRlcmluZyBvdmVybGF5IHdpZGdldHMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2U7XHJcbihmdW5jdGlvbiAoT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiB0aGUgb3ZlcmxheSB3aWRnZXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXJcclxuICAgICAqL1xyXG4gICAgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiVE9QX1JJR0hUX0NPUk5FUlwiXSA9IDBdID0gXCJUT1BfUklHSFRfQ09STkVSXCI7XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIHRoZSBvdmVybGF5IHdpZGdldCBpbiB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lclxyXG4gICAgICovXHJcbiAgICBPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW092ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJCT1RUT01fUklHSFRfQ09STkVSXCJdID0gMV0gPSBcIkJPVFRPTV9SSUdIVF9DT1JORVJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gdGhlIG92ZXJsYXkgd2lkZ2V0IGluIHRoZSB0b3AgY2VudGVyXHJcbiAgICAgKi9cclxuICAgIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIlRPUF9DRU5URVJcIl0gPSAyXSA9IFwiVE9QX0NFTlRFUlwiO1xyXG59KShPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlIHx8IChPdmVybGF5V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlID0ge30pKTtcclxuLyoqXHJcbiAqIFZlcnRpY2FsIExhbmUgaW4gdGhlIG92ZXJ2aWV3IHJ1bGVyIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xyXG5leHBvcnQgdmFyIE92ZXJ2aWV3UnVsZXJMYW5lO1xyXG4oZnVuY3Rpb24gKE92ZXJ2aWV3UnVsZXJMYW5lKSB7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkxlZnRcIl0gPSAxXSA9IFwiTGVmdFwiO1xyXG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XHJcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkZ1bGxcIl0gPSA3XSA9IFwiRnVsbFwiO1xyXG59KShPdmVydmlld1J1bGVyTGFuZSB8fCAoT3ZlcnZpZXdSdWxlckxhbmUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIFJlbmRlckxpbmVOdW1iZXJzVHlwZTtcclxuKGZ1bmN0aW9uIChSZW5kZXJMaW5lTnVtYmVyc1R5cGUpIHtcclxuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJPZmZcIl0gPSAwXSA9IFwiT2ZmXCI7XHJcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiT25cIl0gPSAxXSA9IFwiT25cIjtcclxuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJSZWxhdGl2ZVwiXSA9IDJdID0gXCJSZWxhdGl2ZVwiO1xyXG4gICAgUmVuZGVyTGluZU51bWJlcnNUeXBlW1JlbmRlckxpbmVOdW1iZXJzVHlwZVtcIkludGVydmFsXCJdID0gM10gPSBcIkludGVydmFsXCI7XHJcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiQ3VzdG9tXCJdID0gNF0gPSBcIkN1c3RvbVwiO1xyXG59KShSZW5kZXJMaW5lTnVtYmVyc1R5cGUgfHwgKFJlbmRlckxpbmVOdW1iZXJzVHlwZSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgUmVuZGVyTWluaW1hcDtcclxuKGZ1bmN0aW9uIChSZW5kZXJNaW5pbWFwKSB7XHJcbiAgICBSZW5kZXJNaW5pbWFwW1JlbmRlck1pbmltYXBbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcclxuICAgIFJlbmRlck1pbmltYXBbUmVuZGVyTWluaW1hcFtcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xyXG4gICAgUmVuZGVyTWluaW1hcFtSZW5kZXJNaW5pbWFwW1wiQmxvY2tzXCJdID0gMl0gPSBcIkJsb2Nrc1wiO1xyXG59KShSZW5kZXJNaW5pbWFwIHx8IChSZW5kZXJNaW5pbWFwID0ge30pKTtcclxuZXhwb3J0IHZhciBTY3JvbGxUeXBlO1xyXG4oZnVuY3Rpb24gKFNjcm9sbFR5cGUpIHtcclxuICAgIFNjcm9sbFR5cGVbU2Nyb2xsVHlwZVtcIlNtb290aFwiXSA9IDBdID0gXCJTbW9vdGhcIjtcclxuICAgIFNjcm9sbFR5cGVbU2Nyb2xsVHlwZVtcIkltbWVkaWF0ZVwiXSA9IDFdID0gXCJJbW1lZGlhdGVcIjtcclxufSkoU2Nyb2xsVHlwZSB8fCAoU2Nyb2xsVHlwZSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgU2Nyb2xsYmFyVmlzaWJpbGl0eTtcclxuKGZ1bmN0aW9uIChTY3JvbGxiYXJWaXNpYmlsaXR5KSB7XHJcbiAgICBTY3JvbGxiYXJWaXNpYmlsaXR5W1Njcm9sbGJhclZpc2liaWxpdHlbXCJBdXRvXCJdID0gMV0gPSBcIkF1dG9cIjtcclxuICAgIFNjcm9sbGJhclZpc2liaWxpdHlbU2Nyb2xsYmFyVmlzaWJpbGl0eVtcIkhpZGRlblwiXSA9IDJdID0gXCJIaWRkZW5cIjtcclxuICAgIFNjcm9sbGJhclZpc2liaWxpdHlbU2Nyb2xsYmFyVmlzaWJpbGl0eVtcIlZpc2libGVcIl0gPSAzXSA9IFwiVmlzaWJsZVwiO1xyXG59KShTY3JvbGxiYXJWaXNpYmlsaXR5IHx8IChTY3JvbGxiYXJWaXNpYmlsaXR5ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBkaXJlY3Rpb24gb2YgYSBzZWxlY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgdmFyIFNlbGVjdGlvbkRpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChTZWxlY3Rpb25EaXJlY3Rpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlbGVjdGlvbiBzdGFydHMgYWJvdmUgd2hlcmUgaXQgZW5kcy5cclxuICAgICAqL1xyXG4gICAgU2VsZWN0aW9uRGlyZWN0aW9uW1NlbGVjdGlvbkRpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNlbGVjdGlvbiBzdGFydHMgYmVsb3cgd2hlcmUgaXQgZW5kcy5cclxuICAgICAqL1xyXG4gICAgU2VsZWN0aW9uRGlyZWN0aW9uW1NlbGVjdGlvbkRpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcclxufSkoU2VsZWN0aW9uRGlyZWN0aW9uIHx8IChTZWxlY3Rpb25EaXJlY3Rpb24gPSB7fSkpO1xyXG5leHBvcnQgdmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcclxuKGZ1bmN0aW9uIChTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQpIHtcclxuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiVHJpZ2dlckNoYXJhY3RlclwiXSA9IDJdID0gXCJUcmlnZ2VyQ2hhcmFjdGVyXCI7XHJcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiQ29udGVudENoYW5nZVwiXSA9IDNdID0gXCJDb250ZW50Q2hhbmdlXCI7XHJcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcclxuLyoqXHJcbiAqIEEgc3ltYm9sIGtpbmQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFN5bWJvbEtpbmQ7XHJcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmlsZVwiXSA9IDBdID0gXCJGaWxlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJNb2R1bGVcIl0gPSAxXSA9IFwiTW9kdWxlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJOYW1lc3BhY2VcIl0gPSAyXSA9IFwiTmFtZXNwYWNlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQYWNrYWdlXCJdID0gM10gPSBcIlBhY2thZ2VcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNsYXNzXCJdID0gNF0gPSBcIkNsYXNzXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJNZXRob2RcIl0gPSA1XSA9IFwiTWV0aG9kXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJQcm9wZXJ0eVwiXSA9IDZdID0gXCJQcm9wZXJ0eVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmllbGRcIl0gPSA3XSA9IFwiRmllbGRcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNvbnN0cnVjdG9yXCJdID0gOF0gPSBcIkNvbnN0cnVjdG9yXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtXCJdID0gOV0gPSBcIkVudW1cIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkludGVyZmFjZVwiXSA9IDEwXSA9IFwiSW50ZXJmYWNlXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJGdW5jdGlvblwiXSA9IDExXSA9IFwiRnVuY3Rpb25cIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlZhcmlhYmxlXCJdID0gMTJdID0gXCJWYXJpYWJsZVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQ29uc3RhbnRcIl0gPSAxM10gPSBcIkNvbnN0YW50XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJTdHJpbmdcIl0gPSAxNF0gPSBcIlN0cmluZ1wiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTnVtYmVyXCJdID0gMTVdID0gXCJOdW1iZXJcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkJvb2xlYW5cIl0gPSAxNl0gPSBcIkJvb2xlYW5cIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkFycmF5XCJdID0gMTddID0gXCJBcnJheVwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiT2JqZWN0XCJdID0gMThdID0gXCJPYmplY3RcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIktleVwiXSA9IDE5XSA9IFwiS2V5XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJOdWxsXCJdID0gMjBdID0gXCJOdWxsXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJFbnVtTWVtYmVyXCJdID0gMjFdID0gXCJFbnVtTWVtYmVyXCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJTdHJ1Y3RcIl0gPSAyMl0gPSBcIlN0cnVjdFwiO1xyXG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRXZlbnRcIl0gPSAyM10gPSBcIkV2ZW50XCI7XHJcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJPcGVyYXRvclwiXSA9IDI0XSA9IFwiT3BlcmF0b3JcIjtcclxuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlR5cGVQYXJhbWV0ZXJcIl0gPSAyNV0gPSBcIlR5cGVQYXJhbWV0ZXJcIjtcclxufSkoU3ltYm9sS2luZCB8fCAoU3ltYm9sS2luZCA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgU3ltYm9sVGFnO1xyXG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xyXG4gICAgU3ltYm9sVGFnW1N5bWJvbFRhZ1tcIkRlcHJlY2F0ZWRcIl0gPSAxXSA9IFwiRGVwcmVjYXRlZFwiO1xyXG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUga2luZCBvZiBhbmltYXRpb24gaW4gd2hpY2ggdGhlIGVkaXRvcidzIGN1cnNvciBzaG91bGQgYmUgcmVuZGVyZWQuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlO1xyXG4oZnVuY3Rpb24gKFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEhpZGRlblxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkhpZGRlblwiXSA9IDBdID0gXCJIaWRkZW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogQmxpbmtpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJCbGlua1wiXSA9IDFdID0gXCJCbGlua1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCbGlua2luZyB3aXRoIHNtb290aCBmYWRpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJTbW9vdGhcIl0gPSAyXSA9IFwiU21vb3RoXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJsaW5raW5nIHdpdGggcHJvbG9uZ2VkIGZpbGxlZCBzdGF0ZSBhbmQgc21vb3RoIGZhZGluZ1xyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIlBoYXNlXCJdID0gM10gPSBcIlBoYXNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEV4cGFuZCBjb2xsYXBzZSBhbmltYXRpb24gb24gdGhlIHkgYXhpc1xyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkV4cGFuZFwiXSA9IDRdID0gXCJFeHBhbmRcIjtcclxuICAgIC8qKlxyXG4gICAgICogTm8tQmxpbmtpbmdcclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJTb2xpZFwiXSA9IDVdID0gXCJTb2xpZFwiO1xyXG59KShUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSB8fCAoVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGUgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIHN0eWxlIGluIHdoaWNoIHRoZSBlZGl0b3IncyBjdXJzb3Igc2hvdWxkIGJlIHJlbmRlcmVkLlxyXG4gKi9cclxuZXhwb3J0IHZhciBUZXh0RWRpdG9yQ3Vyc29yU3R5bGU7XHJcbihmdW5jdGlvbiAoVGV4dEVkaXRvckN1cnNvclN0eWxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEFzIGEgdmVydGljYWwgbGluZSAoc2l0dGluZyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzKS5cclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkxpbmVcIl0gPSAxXSA9IFwiTGluZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcyBhIGJsb2NrIChzaXR0aW5nIG9uIHRvcCBvZiBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJCbG9ja1wiXSA9IDJdID0gXCJCbG9ja1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcyBhIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJVbmRlcmxpbmVcIl0gPSAzXSA9IFwiVW5kZXJsaW5lXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFzIGEgdGhpbiB2ZXJ0aWNhbCBsaW5lIChzaXR0aW5nIGJldHdlZW4gdHdvIGNoYXJhY3RlcnMpLlxyXG4gICAgICovXHJcbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiTGluZVRoaW5cIl0gPSA0XSA9IFwiTGluZVRoaW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogQXMgYW4gb3V0bGluZWQgYmxvY2sgKHNpdHRpbmcgb24gdG9wIG9mIGEgY2hhcmFjdGVyKS5cclxuICAgICAqL1xyXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkJsb2NrT3V0bGluZVwiXSA9IDVdID0gXCJCbG9ja091dGxpbmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXMgYSB0aGluIGhvcml6b250YWwgbGluZSAoc2l0dGluZyB1bmRlciBhIGNoYXJhY3RlcikuXHJcbiAgICAgKi9cclxuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJVbmRlcmxpbmVUaGluXCJdID0gNl0gPSBcIlVuZGVybGluZVRoaW5cIjtcclxufSkoVGV4dEVkaXRvckN1cnNvclN0eWxlIHx8IChUZXh0RWRpdG9yQ3Vyc29yU3R5bGUgPSB7fSkpO1xyXG4vKipcclxuICogRGVzY3JpYmVzIHRoZSBiZWhhdmlvciBvZiBkZWNvcmF0aW9ucyB3aGVuIHR5cGluZy9lZGl0aW5nIG5lYXIgdGhlaXIgZWRnZXMuXHJcbiAqIE5vdGU6IFBsZWFzZSBkbyBub3QgZWRpdCB0aGUgdmFsdWVzLCBhcyB0aGV5IHZlcnkgY2FyZWZ1bGx5IG1hdGNoIGBEZWNvcmF0aW9uUmFuZ2VCZWhhdmlvcmBcclxuICovXHJcbmV4cG9ydCB2YXIgVHJhY2tlZFJhbmdlU3RpY2tpbmVzcztcclxuKGZ1bmN0aW9uIChUcmFja2VkUmFuZ2VTdGlja2luZXNzKSB7XHJcbiAgICBUcmFja2VkUmFuZ2VTdGlja2luZXNzW1RyYWNrZWRSYW5nZVN0aWNraW5lc3NbXCJBbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCJdID0gMF0gPSBcIkFsd2F5c0dyb3dzV2hlblR5cGluZ0F0RWRnZXNcIjtcclxuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIk5ldmVyR3Jvd3NXaGVuVHlwaW5nQXRFZGdlc1wiXSA9IDFdID0gXCJOZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXNcIjtcclxuICAgIFRyYWNrZWRSYW5nZVN0aWNraW5lc3NbVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tcIkdyb3dzT25seVdoZW5UeXBpbmdCZWZvcmVcIl0gPSAyXSA9IFwiR3Jvd3NPbmx5V2hlblR5cGluZ0JlZm9yZVwiO1xyXG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiR3Jvd3NPbmx5V2hlblR5cGluZ0FmdGVyXCJdID0gM10gPSBcIkdyb3dzT25seVdoZW5UeXBpbmdBZnRlclwiO1xyXG59KShUcmFja2VkUmFuZ2VTdGlja2luZXNzIHx8IChUcmFja2VkUmFuZ2VTdGlja2luZXNzID0ge30pKTtcclxuLyoqXHJcbiAqIERlc2NyaWJlcyBob3cgdG8gaW5kZW50IHdyYXBwZWQgbGluZXMuXHJcbiAqL1xyXG5leHBvcnQgdmFyIFdyYXBwaW5nSW5kZW50O1xyXG4oZnVuY3Rpb24gKFdyYXBwaW5nSW5kZW50KSB7XHJcbiAgICAvKipcclxuICAgICAqIE5vIGluZGVudGF0aW9uID0+IHdyYXBwZWQgbGluZXMgYmVnaW4gYXQgY29sdW1uIDEuXHJcbiAgICAgKi9cclxuICAgIFdyYXBwaW5nSW5kZW50W1dyYXBwaW5nSW5kZW50W1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNhbWUgPT4gd3JhcHBlZCBsaW5lcyBnZXQgdGhlIHNhbWUgaW5kZW50YXRpb24gYXMgdGhlIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJTYW1lXCJdID0gMV0gPSBcIlNhbWVcIjtcclxuICAgIC8qKlxyXG4gICAgICogSW5kZW50ID0+IHdyYXBwZWQgbGluZXMgZ2V0ICsxIGluZGVudGF0aW9uIHRvd2FyZCB0aGUgcGFyZW50LlxyXG4gICAgICovXHJcbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIkluZGVudFwiXSA9IDJdID0gXCJJbmRlbnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGVlcEluZGVudCA9PiB3cmFwcGVkIGxpbmVzIGdldCArMiBpbmRlbnRhdGlvbiB0b3dhcmQgdGhlIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgV3JhcHBpbmdJbmRlbnRbV3JhcHBpbmdJbmRlbnRbXCJEZWVwSW5kZW50XCJdID0gM10gPSBcIkRlZXBJbmRlbnRcIjtcclxufSkoV3JhcHBpbmdJbmRlbnQgfHwgKFdyYXBwaW5nSW5kZW50ID0ge30pKTtcclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vY2FuY2VsbGF0aW9uLmpzJztcclxuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2V2ZW50LmpzJztcclxuaW1wb3J0IHsgS2V5Q2hvcmQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9rZXlDb2Rlcy5qcyc7XHJcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3VyaS5qcyc7XHJcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XHJcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJy4uL2NvcmUvc2VsZWN0aW9uLmpzJztcclxuaW1wb3J0IHsgVG9rZW4gfSBmcm9tICcuLi9jb3JlL3Rva2VuLmpzJztcclxuaW1wb3J0ICogYXMgc3RhbmRhbG9uZUVudW1zIGZyb20gJy4vc3RhbmRhbG9uZUVudW1zLmpzJztcclxuZXhwb3J0IGNsYXNzIEtleU1vZCB7XHJcbiAgICBzdGF0aWMgY2hvcmQoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIEtleUNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XHJcbiAgICB9XHJcbn1cclxuS2V5TW9kLkN0cmxDbWQgPSAyMDQ4IC8qIEN0cmxDbWQgKi87XHJcbktleU1vZC5TaGlmdCA9IDEwMjQgLyogU2hpZnQgKi87XHJcbktleU1vZC5BbHQgPSA1MTIgLyogQWx0ICovO1xyXG5LZXlNb2QuV2luQ3RybCA9IDI1NiAvKiBXaW5DdHJsICovO1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9uYWNvQmFzZUFQSSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZWRpdG9yOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbGFuZ3VhZ2VzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U6IENhbmNlbGxhdGlvblRva2VuU291cmNlLFxyXG4gICAgICAgIEVtaXR0ZXI6IEVtaXR0ZXIsXHJcbiAgICAgICAgS2V5Q29kZTogc3RhbmRhbG9uZUVudW1zLktleUNvZGUsXHJcbiAgICAgICAgS2V5TW9kOiBLZXlNb2QsXHJcbiAgICAgICAgUG9zaXRpb246IFBvc2l0aW9uLFxyXG4gICAgICAgIFJhbmdlOiBSYW5nZSxcclxuICAgICAgICBTZWxlY3Rpb246IFNlbGVjdGlvbixcclxuICAgICAgICBTZWxlY3Rpb25EaXJlY3Rpb246IHN0YW5kYWxvbmVFbnVtcy5TZWxlY3Rpb25EaXJlY3Rpb24sXHJcbiAgICAgICAgTWFya2VyU2V2ZXJpdHk6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJTZXZlcml0eSxcclxuICAgICAgICBNYXJrZXJUYWc6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJUYWcsXHJcbiAgICAgICAgVXJpOiBVUkksXHJcbiAgICAgICAgVG9rZW46IFRva2VuXHJcbiAgICB9O1xyXG59XHJcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbmltcG9ydCB7IHN0cmluZ0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vcGxhdGZvcm0uanMnO1xyXG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xyXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xyXG5pbXBvcnQgeyBEaWZmQ29tcHV0ZXIgfSBmcm9tICcuLi9kaWZmL2RpZmZDb21wdXRlci5qcyc7XHJcbmltcG9ydCB7IE1pcnJvclRleHRNb2RlbCBhcyBCYXNlTWlycm9yTW9kZWwgfSBmcm9tICcuLi9tb2RlbC9taXJyb3JUZXh0TW9kZWwuanMnO1xyXG5pbXBvcnQgeyBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uLCBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vbW9kZWwvd29yZEhlbHBlci5qcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVMaW5rcyB9IGZyb20gJy4uL21vZGVzL2xpbmtDb21wdXRlci5qcyc7XHJcbmltcG9ydCB7IEJhc2ljSW5wbGFjZVJlcGxhY2UgfSBmcm9tICcuLi9tb2Rlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVNb25hY29CYXNlQVBJIH0gZnJvbSAnLi4vc3RhbmRhbG9uZS9zdGFuZGFsb25lQmFzZS5qcyc7XHJcbmltcG9ydCAqIGFzIHR5cGVzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3R5cGVzLmpzJztcclxuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzJztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgTWlycm9yTW9kZWwgZXh0ZW5kcyBCYXNlTWlycm9yTW9kZWwge1xyXG4gICAgZ2V0IHVyaSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVvbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW9sO1xyXG4gICAgfVxyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGluZXNDb250ZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5zbGljZSgwKTtcclxuICAgIH1cclxuICAgIGdldExpbmVDb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV07XHJcbiAgICB9XHJcbiAgICBnZXRXb3JkQXRQb3NpdGlvbihwb3NpdGlvbiwgd29yZERlZmluaXRpb24pIHtcclxuICAgICAgICBsZXQgd29yZEF0VGV4dCA9IGdldFdvcmRBdFRleHQocG9zaXRpb24uY29sdW1uLCBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uKHdvcmREZWZpbml0aW9uKSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLCAwKTtcclxuICAgICAgICBpZiAod29yZEF0VGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRBdFRleHQuc3RhcnRDb2x1bW4sIHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRBdFRleHQuZW5kQ29sdW1uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB3b3Jkcyh3b3JkRGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fbGluZXM7XHJcbiAgICAgICAgY29uc3Qgd29yZGVuaXplID0gdGhpcy5fd29yZGVuaXplLmJpbmQodGhpcyk7XHJcbiAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBsaW5lVGV4dCA9ICcnO1xyXG4gICAgICAgIGxldCB3b3JkUmFuZ2VzSWR4ID0gMDtcclxuICAgICAgICBsZXQgd29yZFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmRSYW5nZXNJZHggPCB3b3JkUmFuZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGxpbmVUZXh0LnN1YnN0cmluZyh3b3JkUmFuZ2VzW3dvcmRSYW5nZXNJZHhdLnN0YXJ0LCB3b3JkUmFuZ2VzW3dvcmRSYW5nZXNJZHhdLmVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXNJZHggKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlciA8IGxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRleHQgPSBsaW5lc1tsaW5lTnVtYmVyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXMgPSB3b3JkZW5pemUobGluZVRleHQsIHdvcmREZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRSYW5nZXNJZHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0TGluZVdvcmRzKGxpbmVOdW1iZXIsIHdvcmREZWZpbml0aW9uKSB7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV07XHJcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuX3dvcmRlbml6ZShjb250ZW50LCB3b3JkRGVmaW5pdGlvbik7XHJcbiAgICAgICAgbGV0IHdvcmRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHtcclxuICAgICAgICAgICAgd29yZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB3b3JkOiBjb250ZW50LnN1YnN0cmluZyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiByYW5nZS5zdGFydCArIDEsXHJcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZCArIDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3b3JkcztcclxuICAgIH1cclxuICAgIF93b3JkZW5pemUoY29udGVudCwgd29yZERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBsZXQgbWF0Y2g7XHJcbiAgICAgICAgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID0gMDsgLy8gcmVzZXQgbGFzdEluZGV4IGp1c3QgdG8gYmUgc3VyZVxyXG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWMoY29udGVudCkpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaXQgZGlkIG1hdGNoIHRoZSBlbXB0eSBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgc3RhcnQ6IG1hdGNoLmluZGV4LCBlbmQ6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZ2V0VmFsdWVJblJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmFuZ2UgPSB0aGlzLl92YWxpZGF0ZVJhbmdlKHJhbmdlKTtcclxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByYW5nZS5lbmRDb2x1bW4gLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxpbmVFbmRpbmcgPSB0aGlzLl9lb2w7XHJcbiAgICAgICAgbGV0IHN0YXJ0TGluZUluZGV4ID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTtcclxuICAgICAgICBsZXQgZW5kTGluZUluZGV4ID0gcmFuZ2UuZW5kTGluZU51bWJlciAtIDE7XHJcbiAgICAgICAgbGV0IHJlc3VsdExpbmVzID0gW107XHJcbiAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tzdGFydExpbmVJbmRleF0uc3Vic3RyaW5nKHJhbmdlLnN0YXJ0Q29sdW1uIC0gMSkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmVJbmRleCArIDE7IGkgPCBlbmRMaW5lSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tlbmRMaW5lSW5kZXhdLnN1YnN0cmluZygwLCByYW5nZS5lbmRDb2x1bW4gLSAxKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzLmpvaW4obGluZUVuZGluZyk7XHJcbiAgICB9XHJcbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xyXG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlTGluZVN0YXJ0cygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lU3RhcnRzLmdldFByZWZpeFN1bShwb3NpdGlvbi5saW5lTnVtYmVyIC0gMikgKyAocG9zaXRpb24uY29sdW1uIC0gMSk7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xyXG4gICAgICAgIG9mZnNldCA9IE1hdGguZmxvb3Iob2Zmc2V0KTtcclxuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBvZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUxpbmVTdGFydHMoKTtcclxuICAgICAgICBsZXQgb3V0ID0gdGhpcy5fbGluZVN0YXJ0cy5nZXRJbmRleE9mKG9mZnNldCk7XHJcbiAgICAgICAgbGV0IGxpbmVMZW5ndGggPSB0aGlzLl9saW5lc1tvdXQuaW5kZXhdLmxlbmd0aDtcclxuICAgICAgICAvLyBFbnN1cmUgd2UgcmV0dXJuIGEgdmFsaWQgcG9zaXRpb25cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiAxICsgb3V0LmluZGV4LFxyXG4gICAgICAgICAgICBjb2x1bW46IDEgKyBNYXRoLm1pbihvdXQucmVtYWluZGVyLCBsaW5lTGVuZ3RoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfdmFsaWRhdGVSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fdmFsaWRhdGVQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9KTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uKHsgbGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlciwgY29sdW1uOiByYW5nZS5lbmRDb2x1bW4gfSk7XHJcbiAgICAgICAgaWYgKHN0YXJ0LmxpbmVOdW1iZXIgIT09IHJhbmdlLnN0YXJ0TGluZU51bWJlclxyXG4gICAgICAgICAgICB8fCBzdGFydC5jb2x1bW4gIT09IHJhbmdlLnN0YXJ0Q29sdW1uXHJcbiAgICAgICAgICAgIHx8IGVuZC5saW5lTnVtYmVyICE9PSByYW5nZS5lbmRMaW5lTnVtYmVyXHJcbiAgICAgICAgICAgIHx8IGVuZC5jb2x1bW4gIT09IHJhbmdlLmVuZENvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydC5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0LmNvbHVtbixcclxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGVuZC5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiBlbmQuY29sdW1uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZTtcclxuICAgIH1cclxuICAgIF92YWxpZGF0ZVBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFQb3NpdGlvbi5pc0lQb3NpdGlvbihwb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9zaXRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgbGluZU51bWJlciwgY29sdW1uIH0gPSBwb3NpdGlvbjtcclxuICAgICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChsaW5lTnVtYmVyIDwgMSkge1xyXG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gMTtcclxuICAgICAgICAgICAgY29sdW1uID0gMTtcclxuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxpbmVOdW1iZXIgPiB0aGlzLl9saW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGluZU51bWJlciA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgY29sdW1uID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IG1heENoYXJhY3RlciA9IHRoaXMuX2xpbmVzW2xpbmVOdW1iZXIgLSAxXS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uID0gMTtcclxuICAgICAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbiA+IG1heENoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uID0gbWF4Q2hhcmFjdGVyO1xyXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmVOdW1iZXIsIGNvbHVtbiB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRWRpdG9yU2ltcGxlV29ya2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGhvc3QsIGZvcmVpZ25Nb2R1bGVGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgdGhpcy5fbW9kZWxzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeSA9IGZvcmVpZ25Nb2R1bGVGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLl9tb2RlbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgX2dldE1vZGVsKHVyaSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHNbdXJpXTtcclxuICAgIH1cclxuICAgIF9nZXRNb2RlbHMoKSB7XHJcbiAgICAgICAgbGV0IGFsbCA9IFtdO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscykuZm9yRWFjaCgoa2V5KSA9PiBhbGwucHVzaCh0aGlzLl9tb2RlbHNba2V5XSkpO1xyXG4gICAgICAgIHJldHVybiBhbGw7XHJcbiAgICB9XHJcbiAgICBhY2NlcHROZXdNb2RlbChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5fbW9kZWxzW2RhdGEudXJsXSA9IG5ldyBNaXJyb3JNb2RlbChVUkkucGFyc2UoZGF0YS51cmwpLCBkYXRhLmxpbmVzLCBkYXRhLkVPTCwgZGF0YS52ZXJzaW9uSWQpO1xyXG4gICAgfVxyXG4gICAgYWNjZXB0TW9kZWxDaGFuZ2VkKHN0clVSTCwgZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbW9kZWxzW3N0clVSTF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbW9kZWwgPSB0aGlzLl9tb2RlbHNbc3RyVVJMXTtcclxuICAgICAgICBtb2RlbC5vbkV2ZW50cyhlKTtcclxuICAgIH1cclxuICAgIGFjY2VwdFJlbW92ZWRNb2RlbChzdHJVUkwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21vZGVsc1tzdHJVUkxdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVsc1tzdHJVUkxdO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBCRUdJTiBkaWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBjb21wdXRlRGlmZihvcmlnaW5hbFVybCwgbW9kaWZpZWRVcmwsIGlnbm9yZVRyaW1XaGl0ZXNwYWNlLCBtYXhDb21wdXRhdGlvblRpbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXMuX2dldE1vZGVsKG9yaWdpbmFsVXJsKTtcclxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWQgPSB0aGlzLl9nZXRNb2RlbChtb2RpZmllZFVybCk7XHJcbiAgICAgICAgICAgIGlmICghb3JpZ2luYWwgfHwgIW1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVzID0gb3JpZ2luYWwuZ2V0TGluZXNDb250ZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZXMgPSBtb2RpZmllZC5nZXRMaW5lc0NvbnRlbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZGlmZkNvbXB1dGVyID0gbmV3IERpZmZDb21wdXRlcihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRDb21wdXRlQ2hhckNoYW5nZXM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2U6IGlnbm9yZVRyaW1XaGl0ZXNwYWNlLFxyXG4gICAgICAgICAgICAgICAgc2hvdWxkTWFrZVByZXR0eURpZmY6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtYXhDb21wdXRhdGlvblRpbWU6IG1heENvbXB1dGF0aW9uVGltZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGRpZmZDb21wdXRlci5jb21wdXRlRGlmZigpO1xyXG4gICAgICAgICAgICBjb25zdCBpZGVudGljYWwgPSAoZGlmZlJlc3VsdC5jaGFuZ2VzLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRoaXMuX21vZGVsc0FyZUlkZW50aWNhbChvcmlnaW5hbCwgbW9kaWZpZWQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHF1aXRFYXJseTogZGlmZlJlc3VsdC5xdWl0RWFybHksXHJcbiAgICAgICAgICAgICAgICBpZGVudGljYWw6IGlkZW50aWNhbCxcclxuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGRpZmZSZXN1bHQuY2hhbmdlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX21vZGVsc0FyZUlkZW50aWNhbChvcmlnaW5hbCwgbW9kaWZpZWQpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVDb3VudCA9IG9yaWdpbmFsLmdldExpbmVDb3VudCgpO1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZUNvdW50ID0gbW9kaWZpZWQuZ2V0TGluZUNvdW50KCk7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsTGluZUNvdW50ICE9PSBtb2RpZmllZExpbmVDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGxpbmUgPSAxOyBsaW5lIDw9IG9yaWdpbmFsTGluZUNvdW50OyBsaW5lKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lID0gb3JpZ2luYWwuZ2V0TGluZUNvbnRlbnQobGluZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkLmdldExpbmVDb250ZW50KGxpbmUpO1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxMaW5lICE9PSBtb2RpZmllZExpbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbXB1dGVNb3JlTWluaW1hbEVkaXRzKG1vZGVsVXJsLCBlZGl0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xyXG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIGxldCBsYXN0RW9sID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBlZGl0cyA9IGVkaXRzLnNsaWNlKDApLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLnJhbmdlICYmIGIucmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmFuZ2UuY29tcGFyZVJhbmdlc1VzaW5nU3RhcnRzKGEucmFuZ2UsIGIucmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZW9sIG9ubHkgY2hhbmdlcyBzaG91bGQgZ28gdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgbGV0IGFSbmcgPSBhLnJhbmdlID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgYlJuZyA9IGIucmFuZ2UgPyAwIDogMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhUm5nIC0gYlJuZztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHsgcmFuZ2UsIHRleHQsIGVvbCB9IG9mIGVkaXRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVvbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RW9sID0gZW9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFJhbmdlLmlzRW1wdHkocmFuZ2UpICYmICF0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHkgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShyYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG58XFxufFxcci9nLCBtb2RlbC5lb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsID09PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGRpZmYgd29uJ3QgdGFrZSB0b28gbG9uZ1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWF4KHRleHQubGVuZ3RoLCBvcmlnaW5hbC5sZW5ndGgpID4gRWRpdG9yU2ltcGxlV29ya2VyLl9kaWZmTGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHJhbmdlLCB0ZXh0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIGJldHdlZW4gb3JpZ2luYWwgYW5kIGVkaXQudGV4dFxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHN0cmluZ0RpZmYob3JpZ2luYWwsIHRleHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRPZmZzZXQgPSBtb2RlbC5vZmZzZXRBdChSYW5nZS5saWZ0KHJhbmdlKS5nZXRTdGFydFBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IG1vZGVsLnBvc2l0aW9uQXQoZWRpdE9mZnNldCArIGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGl0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LnN1YnN0cihjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHsgc3RhcnRMaW5lTnVtYmVyOiBzdGFydC5saW5lTnVtYmVyLCBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLCBlbmRMaW5lTnVtYmVyOiBlbmQubGluZU51bWJlciwgZW5kQ29sdW1uOiBlbmQuY29sdW1uIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5nZXRWYWx1ZUluUmFuZ2UobmV3RWRpdC5yYW5nZSkgIT09IG5ld0VkaXQudGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdFZGl0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0RW9sID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBlb2w6IGxhc3RFb2wsIHRleHQ6ICcnLCByYW5nZTogeyBzdGFydExpbmVOdW1iZXI6IDAsIHN0YXJ0Q29sdW1uOiAwLCBlbmRMaW5lTnVtYmVyOiAwLCBlbmRDb2x1bW46IDAgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBFTkQgbWluaW1hbCBlZGl0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGNvbXB1dGVMaW5rcyhtb2RlbFVybCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVMaW5rcyhtb2RlbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0ZXh0dWFsU3VnZ2VzdChtb2RlbFVybHMsIGxlYWRpbmdXb3JkLCB3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdyA9IG5ldyBTdG9wV2F0Y2godHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIG91dGVyOiBmb3IgKGxldCB1cmwgb2YgbW9kZWxVcmxzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKHVybCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB3b3JkIG9mIG1vZGVsLndvcmRzKHdvcmREZWZSZWdFeHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQgPT09IGxlYWRpbmdXb3JkIHx8ICFpc05hTihOdW1iZXIod29yZCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWVuLmFkZCh3b3JkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vlbi5zaXplID4gRWRpdG9yU2ltcGxlV29ya2VyLl9zdWdnZXN0aW9uc0xpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyB3b3JkczogQXJyYXkuZnJvbShzZWVuKSwgZHVyYXRpb246IHN3LmVsYXBzZWQoKSB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLSBFTkQgc3VnZ2VzdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8jcmVnaW9uIC0tIHdvcmQgcmFuZ2VzIC0tXHJcbiAgICBjb21wdXRlV29yZFJhbmdlcyhtb2RlbFVybCwgcmFuZ2UsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbGluZSA9IHJhbmdlLnN0YXJ0TGluZU51bWJlcjsgbGluZSA8IHJhbmdlLmVuZExpbmVOdW1iZXI7IGxpbmUrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdvcmRzID0gbW9kZWwuZ2V0TGluZVdvcmRzKGxpbmUsIHdvcmREZWZSZWdFeHApO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIod29yZC53b3JkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhcnJheSA9IHJlc3VsdFt3b3JkLndvcmRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3dvcmQud29yZF0gPSBhcnJheTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogbGluZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHdvcmQuc3RhcnRDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbHVtbjogd29yZC5lbmRDb2x1bW5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8jZW5kcmVnaW9uXHJcbiAgICBuYXZpZ2F0ZVZhbHVlU2V0KG1vZGVsVXJsLCByYW5nZSwgdXAsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcclxuICAgICAgICAgICAgaWYgKCFtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHdvcmREZWZSZWdFeHAgPSBuZXcgUmVnRXhwKHdvcmREZWYsIHdvcmREZWZGbGFncyk7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4sXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcclxuICAgICAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZENvbHVtbiArIDFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvblRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgICBsZXQgd29yZFJhbmdlID0gbW9kZWwuZ2V0V29yZEF0UG9zaXRpb24oeyBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4gfSwgd29yZERlZlJlZ0V4cCk7XHJcbiAgICAgICAgICAgIGlmICghd29yZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgd29yZCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZSh3b3JkUmFuZ2UpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRS5uYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlLCBzZWxlY3Rpb25UZXh0LCB3b3JkUmFuZ2UsIHdvcmQsIHVwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIC0tLS0gQkVHSU4gZm9yZWlnbiBtb2R1bGUgc3VwcG9ydCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbG9hZEZvcmVpZ25Nb2R1bGUobW9kdWxlSWQsIGNyZWF0ZURhdGEsIGZvcmVpZ25Ib3N0TWV0aG9kcykge1xyXG4gICAgICAgIGNvbnN0IHByb3h5TWV0aG9kUmVxdWVzdCA9IChtZXRob2QsIGFyZ3MpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3QuZmhyKG1ldGhvZCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmb3JlaWduSG9zdCA9IHR5cGVzLmNyZWF0ZVByb3h5T2JqZWN0KGZvcmVpZ25Ib3N0TWV0aG9kcywgcHJveHlNZXRob2RSZXF1ZXN0KTtcclxuICAgICAgICBsZXQgY3R4ID0ge1xyXG4gICAgICAgICAgICBob3N0OiBmb3JlaWduSG9zdCxcclxuICAgICAgICAgICAgZ2V0TWlycm9yTW9kZWxzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TW9kZWxzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlID0gdGhpcy5fZm9yZWlnbk1vZHVsZUZhY3RvcnkoY3R4LCBjcmVhdGVEYXRhKTtcclxuICAgICAgICAgICAgLy8gc3RhdGljIGZvcmVpbmcgbW9kdWxlXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fZm9yZWlnbk1vZHVsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFU00tY29tbWVudC1iZWdpblxyXG4gICAgICAgIC8vIFx0XHRyZXR1cm4gbmV3IFByb21pc2U8YW55PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgLy8gXHRcdFx0cmVxdWlyZShbbW9kdWxlSWRdLCAoZm9yZWlnbk1vZHVsZTogeyBjcmVhdGU6IElGb3JlaWduTW9kdWxlRmFjdG9yeSB9KSA9PiB7XHJcbiAgICAgICAgLy8gXHRcdFx0XHR0aGlzLl9mb3JlaWduTW9kdWxlID0gZm9yZWlnbk1vZHVsZS5jcmVhdGUoY3R4LCBjcmVhdGVEYXRhKTtcclxuICAgICAgICAvLyBcclxuICAgICAgICAvLyBcdFx0XHRcdHJlc29sdmUodHlwZXMuZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fZm9yZWlnbk1vZHVsZSkpO1xyXG4gICAgICAgIC8vIFxyXG4gICAgICAgIC8vIFx0XHRcdH0sIHJlamVjdCk7XHJcbiAgICAgICAgLy8gXHRcdH0pO1xyXG4gICAgICAgIC8vIEVTTS1jb21tZW50LWVuZFxyXG4gICAgICAgIC8vIEVTTS11bmNvbW1lbnQtYmVnaW5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBVbmV4cGVjdGVkIHVzYWdlYCkpO1xyXG4gICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXHJcbiAgICB9XHJcbiAgICAvLyBmb3JlaWduIG1ldGhvZCByZXF1ZXN0XHJcbiAgICBmbXIobWV0aG9kLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mb3JlaWduTW9kdWxlIHx8IHR5cGVvZiB0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyByZXF1ZXN0SGFuZGxlciBvciBtZXRob2Q6ICcgKyBtZXRob2QpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9mb3JlaWduTW9kdWxlW21ldGhvZF0uYXBwbHkodGhpcy5fZm9yZWlnbk1vZHVsZSwgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIC0tLS0gRU5EIGRpZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gLS0tLSBCRUdJTiBtaW5pbWFsIGVkaXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5FZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCA9IDEwMDAwMDtcclxuLy8gLS0tLSBCRUdJTiBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbkVkaXRvclNpbXBsZVdvcmtlci5fc3VnZ2VzdGlvbnNMaW1pdCA9IDEwMDAwO1xyXG4vKipcclxuICogQ2FsbGVkIG9uIHRoZSB3b3JrZXIgc2lkZVxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoaG9zdCkge1xyXG4gICAgcmV0dXJuIG5ldyBFZGl0b3JTaW1wbGVXb3JrZXIoaG9zdCwgbnVsbCk7XHJcbn1cclxuaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAvLyBSdW5uaW5nIGluIGEgd2ViIHdvcmtlclxyXG4gICAgZ2xvYmFscy5tb25hY28gPSBjcmVhdGVNb25hY29CYXNlQVBJKCk7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCB7IFNpbXBsZVdvcmtlclNlcnZlciB9IGZyb20gJy4uL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanMnO1xyXG5pbXBvcnQgeyBFZGl0b3JTaW1wbGVXb3JrZXIgfSBmcm9tICcuL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMnO1xyXG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUoZm9yZWlnbk1vZHVsZSkge1xyXG4gICAgaWYgKGluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgY29uc3Qgc2ltcGxlV29ya2VyID0gbmV3IFNpbXBsZVdvcmtlclNlcnZlcigobXNnKSA9PiB7XHJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShtc2cpO1xyXG4gICAgfSwgKGhvc3QpID0+IG5ldyBFZGl0b3JTaW1wbGVXb3JrZXIoaG9zdCwgZm9yZWlnbk1vZHVsZSkpO1xyXG4gICAgc2VsZi5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgIHNpbXBsZVdvcmtlci5vbm1lc3NhZ2UoZS5kYXRhKTtcclxuICAgIH07XHJcbn1cclxuc2VsZi5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgLy8gSWdub3JlIGZpcnN0IG1lc3NhZ2UgaW4gdGhpcyBjYXNlIGFuZCBpbml0aWFsaXplIGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcclxuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICBpbml0aWFsaXplKG51bGwpO1xyXG4gICAgfVxyXG59O1xyXG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQ3JlYXRlcyBhIEpTT04gc2Nhbm5lciBvbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIElmIGlnbm9yZVRyaXZpYSBpcyBzZXQsIHdoaXRlc3BhY2VzIG9yIGNvbW1lbnRzIGFyZSBpZ25vcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2Nhbm5lcih0ZXh0LCBpZ25vcmVUcml2aWEpIHtcbiAgICBpZiAoaWdub3JlVHJpdmlhID09PSB2b2lkIDApIHsgaWdub3JlVHJpdmlhID0gZmFsc2U7IH1cbiAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IDAsIHZhbHVlID0gJycsIHRva2VuT2Zmc2V0ID0gMCwgdG9rZW4gPSAxNiAvKiBVbmtub3duICovLCBsaW5lTnVtYmVyID0gMCwgbGluZVN0YXJ0T2Zmc2V0ID0gMCwgdG9rZW5MaW5lU3RhcnRPZmZzZXQgPSAwLCBwcmV2VG9rZW5MaW5lU3RhcnRPZmZzZXQgPSAwLCBzY2FuRXJyb3IgPSAwIC8qIE5vbmUgKi87XG4gICAgZnVuY3Rpb24gc2NhbkhleERpZ2l0cyhjb3VudCwgZXhhY3QpIHtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IDA7XG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgIHdoaWxlIChkaWdpdHMgPCBjb3VudCB8fCAhZXhhY3QpIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID49IDQ4IC8qIF8wICovICYmIGNoIDw9IDU3IC8qIF85ICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA0OCAvKiBfMCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID49IDY1IC8qIEEgKi8gJiYgY2ggPD0gNzAgLyogRiAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNoIC0gNjUgLyogQSAqLyArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gOTcgLyogYSAqLyAmJiBjaCA8PSAxMDIgLyogZiAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNoIC0gOTcgLyogYSAqLyArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWdpdHMgPCBjb3VudCkge1xuICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKSB7XG4gICAgICAgIHBvcyA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB0b2tlbk9mZnNldCA9IDA7XG4gICAgICAgIHRva2VuID0gMTYgLyogVW5rbm93biAqLztcbiAgICAgICAgc2NhbkVycm9yID0gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuTnVtYmVyKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb3M7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDggLyogXzAgKi8pIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ2IC8qIGRvdCAqLykge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMyAvKiBVbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlbmQgPSBwb3M7XG4gICAgICAgIGlmIChwb3MgPCB0ZXh0Lmxlbmd0aCAmJiAodGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDY5IC8qIEUgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDEwMSAvKiBlICovKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQzIC8qIHBsdXMgKi8gfHwgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ1IC8qIG1pbnVzICovKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDMgLyogVW5leHBlY3RlZEVuZE9mTnVtYmVyICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhblN0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLCBzdGFydCA9IHBvcztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDIgLyogVW5leHBlY3RlZEVuZE9mU3RyaW5nICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDM0IC8qIGRvdWJsZVF1b3RlICovKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSA5MiAvKiBiYWNrc2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMiAvKiBVbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2gyID0gdGV4dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoMikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM0IC8qIGRvdWJsZVF1b3RlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFwiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDkyIC8qIGJhY2tzbGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0NyAvKiBzbGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OCAvKiBiICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAyIC8qIGYgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTAgLyogbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNCAvKiByICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE2IC8qIHQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTcgLyogdSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaDMgPSBzY2FuSGV4RGlnaXRzKDQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoMyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDQgLyogSW52YWxpZFVuaWNvZGUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDUgLyogSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPj0gMCAmJiBjaCA8PSAweDFmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZUJyZWFrKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDIgLyogVW5leHBlY3RlZEVuZE9mU3RyaW5nICovO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDYgLyogSW52YWxpZENoYXJhY3RlciAqLztcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayBhcyBlcnJvciBidXQgY29udGludWUgd2l0aCBzdHJpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuTmV4dCgpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgc2NhbkVycm9yID0gMCAvKiBOb25lICovO1xuICAgICAgICB0b2tlbk9mZnNldCA9IHBvcztcbiAgICAgICAgbGluZVN0YXJ0T2Zmc2V0ID0gbGluZU51bWJlcjtcbiAgICAgICAgcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gdG9rZW5MaW5lU3RhcnRPZmZzZXQ7XG4gICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0b2tlbk9mZnNldCA9IGxlbjtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDE3IC8qIEVPRiAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAvLyB0cml2aWE6IHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjb2RlKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgfSB3aGlsZSAoaXNXaGl0ZVNwYWNlKGNvZGUpKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDE1IC8qIFRyaXZpYSAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyB0cml2aWE6IG5ld2xpbmVzXG4gICAgICAgIGlmIChpc0xpbmVCcmVhayhjb2RlKSkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEzIC8qIGNhcnJpYWdlUmV0dXJuICovICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCAvKiBsaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgdG9rZW5MaW5lU3RhcnRPZmZzZXQgPSBwb3M7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNCAvKiBMaW5lQnJlYWtUcml2aWEgKi87XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAvLyB0b2tlbnM6IFtde306LFxuICAgICAgICAgICAgY2FzZSAxMjMgLyogb3BlbkJyYWNlICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDEgLyogT3BlbkJyYWNlVG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDEyNSAvKiBjbG9zZUJyYWNlICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDIgLyogQ2xvc2VCcmFjZVRva2VuICovO1xuICAgICAgICAgICAgY2FzZSA5MSAvKiBvcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAzIC8qIE9wZW5CcmFja2V0VG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDkzIC8qIGNsb3NlQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSA0IC8qIENsb3NlQnJhY2tldFRva2VuICovO1xuICAgICAgICAgICAgY2FzZSA1OCAvKiBjb2xvbiAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSA2IC8qIENvbG9uVG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDQ0IC8qIGNvbW1hICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDUgLyogQ29tbWFUb2tlbiAqLztcbiAgICAgICAgICAgIC8vIHN0cmluZ3NcbiAgICAgICAgICAgIGNhc2UgMzQgLyogZG91YmxlUXVvdGUgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTAgLyogU3RyaW5nTGl0ZXJhbCAqLztcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzXG4gICAgICAgICAgICBjYXNlIDQ3IC8qIHNsYXNoICovOlxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHBvcyAtIDE7XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIHNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMiAvKiBMaW5lQ29tbWVudFRyaXZpYSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTXVsdGktbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDIgLyogYXN0ZXJpc2sgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlTGVuZ3RoID0gbGVuIC0gMTsgLy8gRm9yIGxvb2thaGVhZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnRDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHNhZmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0MiAvKiBhc3RlcmlzayAqLyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ3IC8qIHNsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudENsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmVCcmVhayhjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIGNhcnJpYWdlUmV0dXJuICovICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMCAvKiBsaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudENsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAxIC8qIFVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTMgLyogQmxvY2tDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBqdXN0IGEgc2luZ2xlIHNsYXNoXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxNiAvKiBVbmtub3duICovO1xuICAgICAgICAgICAgLy8gbnVtYmVyc1xuICAgICAgICAgICAgY2FzZSA0NSAvKiBtaW51cyAqLzpcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IGxlbiB8fCAhaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogVW5rbm93biAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3VuZCBhIG1pbnVzLCBmb2xsb3dlZCBieSBhIG51bWJlciBzb1xuICAgICAgICAgICAgLy8gd2UgZmFsbCB0aHJvdWdoIHRvIHByb2NlZWQgd2l0aCBzY2FubmluZ1xuICAgICAgICAgICAgLy8gbnVtYmVyc1xuICAgICAgICAgICAgY2FzZSA0OCAvKiBfMCAqLzpcbiAgICAgICAgICAgIGNhc2UgNDkgLyogXzEgKi86XG4gICAgICAgICAgICBjYXNlIDUwIC8qIF8yICovOlxuICAgICAgICAgICAgY2FzZSA1MSAvKiBfMyAqLzpcbiAgICAgICAgICAgIGNhc2UgNTIgLyogXzQgKi86XG4gICAgICAgICAgICBjYXNlIDUzIC8qIF81ICovOlxuICAgICAgICAgICAgY2FzZSA1NCAvKiBfNiAqLzpcbiAgICAgICAgICAgIGNhc2UgNTUgLyogXzcgKi86XG4gICAgICAgICAgICBjYXNlIDU2IC8qIF84ICovOlxuICAgICAgICAgICAgY2FzZSA1NyAvKiBfOSAqLzpcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBzY2FuTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTEgLyogTnVtZXJpY0xpdGVyYWwgKi87XG4gICAgICAgICAgICAvLyBsaXRlcmFscyBhbmQgdW5rbm93biBzeW1ib2xzXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGlzIGEgbGl0ZXJhbD8gUmVhZCB0aGUgZnVsbCB3b3JkLlxuICAgICAgICAgICAgICAgIHdoaWxlIChwb3MgPCBsZW4gJiYgaXNVbmtub3duQ29udGVudENoYXJhY3Rlcihjb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5PZmZzZXQgIT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHRva2VuT2Zmc2V0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXl3b3JkczogdHJ1ZSwgZmFsc2UsIG51bGxcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6IHJldHVybiB0b2tlbiA9IDggLyogVHJ1ZUtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6IHJldHVybiB0b2tlbiA9IDkgLyogRmFsc2VLZXl3b3JkICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVsbCc6IHJldHVybiB0b2tlbiA9IDcgLyogTnVsbEtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogVW5rbm93biAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogVW5rbm93biAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1Vua25vd25Db250ZW50Q2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjb2RlKSB8fCBpc0xpbmVCcmVhayhjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSAxMjUgLyogY2xvc2VCcmFjZSAqLzpcbiAgICAgICAgICAgIGNhc2UgOTMgLyogY2xvc2VCcmFja2V0ICovOlxuICAgICAgICAgICAgY2FzZSAxMjMgLyogb3BlbkJyYWNlICovOlxuICAgICAgICAgICAgY2FzZSA5MSAvKiBvcGVuQnJhY2tldCAqLzpcbiAgICAgICAgICAgIGNhc2UgMzQgLyogZG91YmxlUXVvdGUgKi86XG4gICAgICAgICAgICBjYXNlIDU4IC8qIGNvbG9uICovOlxuICAgICAgICAgICAgY2FzZSA0NCAvKiBjb21tYSAqLzpcbiAgICAgICAgICAgIGNhc2UgNDcgLyogc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuTmV4dE5vblRyaXZpYSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2Nhbk5leHQoKTtcbiAgICAgICAgfSB3aGlsZSAocmVzdWx0ID49IDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovICYmIHJlc3VsdCA8PSAxNSAvKiBUcml2aWEgKi8pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBwb3M7IH0sXG4gICAgICAgIHNjYW46IGlnbm9yZVRyaXZpYSA/IHNjYW5OZXh0Tm9uVHJpdmlhIDogc2Nhbk5leHQsXG4gICAgICAgIGdldFRva2VuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b2tlbjsgfSxcbiAgICAgICAgZ2V0VG9rZW5WYWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sXG4gICAgICAgIGdldFRva2VuT2Zmc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b2tlbk9mZnNldDsgfSxcbiAgICAgICAgZ2V0VG9rZW5MZW5ndGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvcyAtIHRva2VuT2Zmc2V0OyB9LFxuICAgICAgICBnZXRUb2tlblN0YXJ0TGluZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZVN0YXJ0T2Zmc2V0OyB9LFxuICAgICAgICBnZXRUb2tlblN0YXJ0Q2hhcmFjdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0b2tlbk9mZnNldCAtIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldDsgfSxcbiAgICAgICAgZ2V0VG9rZW5FcnJvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NhbkVycm9yOyB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDMyIC8qIHNwYWNlICovIHx8IGNoID09PSA5IC8qIHRhYiAqLyB8fCBjaCA9PT0gMTEgLyogdmVydGljYWxUYWIgKi8gfHwgY2ggPT09IDEyIC8qIGZvcm1GZWVkICovIHx8XG4gICAgICAgIGNoID09PSAxNjAgLyogbm9uQnJlYWtpbmdTcGFjZSAqLyB8fCBjaCA9PT0gNTc2MCAvKiBvZ2hhbSAqLyB8fCBjaCA+PSA4MTkyIC8qIGVuUXVhZCAqLyAmJiBjaCA8PSA4MjAzIC8qIHplcm9XaWR0aFNwYWNlICovIHx8XG4gICAgICAgIGNoID09PSA4MjM5IC8qIG5hcnJvd05vQnJlYWtTcGFjZSAqLyB8fCBjaCA9PT0gODI4NyAvKiBtYXRoZW1hdGljYWxTcGFjZSAqLyB8fCBjaCA9PT0gMTIyODggLyogaWRlb2dyYXBoaWNTcGFjZSAqLyB8fCBjaCA9PT0gNjUyNzkgLyogYnl0ZU9yZGVyTWFyayAqLztcbn1cbmZ1bmN0aW9uIGlzTGluZUJyZWFrKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSAxMCAvKiBsaW5lRmVlZCAqLyB8fCBjaCA9PT0gMTMgLyogY2FycmlhZ2VSZXR1cm4gKi8gfHwgY2ggPT09IDgyMzIgLyogbGluZVNlcGFyYXRvciAqLyB8fCBjaCA9PT0gODIzMyAvKiBwYXJhZ3JhcGhTZXBhcmF0b3IgKi87XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDQ4IC8qIF8wICovICYmIGNoIDw9IDU3IC8qIF85ICovO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBjcmVhdGVTY2FubmVyIH0gZnJvbSAnLi9zY2FubmVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoZG9jdW1lbnRUZXh0LCByYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciBpbml0aWFsSW5kZW50TGV2ZWw7XG4gICAgdmFyIGZvcm1hdFRleHQ7XG4gICAgdmFyIGZvcm1hdFRleHRTdGFydDtcbiAgICB2YXIgcmFuZ2VTdGFydDtcbiAgICB2YXIgcmFuZ2VFbmQ7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlU3RhcnQgPSByYW5nZS5vZmZzZXQ7XG4gICAgICAgIHJhbmdlRW5kID0gcmFuZ2VTdGFydCArIHJhbmdlLmxlbmd0aDtcbiAgICAgICAgZm9ybWF0VGV4dFN0YXJ0ID0gcmFuZ2VTdGFydDtcbiAgICAgICAgd2hpbGUgKGZvcm1hdFRleHRTdGFydCA+IDAgJiYgIWlzRU9MKGRvY3VtZW50VGV4dCwgZm9ybWF0VGV4dFN0YXJ0IC0gMSkpIHtcbiAgICAgICAgICAgIGZvcm1hdFRleHRTdGFydC0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSByYW5nZUVuZDtcbiAgICAgICAgd2hpbGUgKGVuZE9mZnNldCA8IGRvY3VtZW50VGV4dC5sZW5ndGggJiYgIWlzRU9MKGRvY3VtZW50VGV4dCwgZW5kT2Zmc2V0KSkge1xuICAgICAgICAgICAgZW5kT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0VGV4dCA9IGRvY3VtZW50VGV4dC5zdWJzdHJpbmcoZm9ybWF0VGV4dFN0YXJ0LCBlbmRPZmZzZXQpO1xuICAgICAgICBpbml0aWFsSW5kZW50TGV2ZWwgPSBjb21wdXRlSW5kZW50TGV2ZWwoZm9ybWF0VGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3JtYXRUZXh0ID0gZG9jdW1lbnRUZXh0O1xuICAgICAgICBpbml0aWFsSW5kZW50TGV2ZWwgPSAwO1xuICAgICAgICBmb3JtYXRUZXh0U3RhcnQgPSAwO1xuICAgICAgICByYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgcmFuZ2VFbmQgPSBkb2N1bWVudFRleHQubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgZW9sID0gZ2V0RU9MKG9wdGlvbnMsIGRvY3VtZW50VGV4dCk7XG4gICAgdmFyIGxpbmVCcmVhayA9IGZhbHNlO1xuICAgIHZhciBpbmRlbnRMZXZlbCA9IDA7XG4gICAgdmFyIGluZGVudFZhbHVlO1xuICAgIGlmIChvcHRpb25zLmluc2VydFNwYWNlcykge1xuICAgICAgICBpbmRlbnRWYWx1ZSA9IHJlcGVhdCgnICcsIG9wdGlvbnMudGFiU2l6ZSB8fCA0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluZGVudFZhbHVlID0gJ1xcdCc7XG4gICAgfVxuICAgIHZhciBzY2FubmVyID0gY3JlYXRlU2Nhbm5lcihmb3JtYXRUZXh0LCBmYWxzZSk7XG4gICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gbmV3TGluZUFuZEluZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIGVvbCArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuTmV4dCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIGxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAodG9rZW4gPT09IDE1IC8qIFRyaXZpYSAqLyB8fCB0b2tlbiA9PT0gMTQgLyogTGluZUJyZWFrVHJpdmlhICovKSB7XG4gICAgICAgICAgICBsaW5lQnJlYWsgPSBsaW5lQnJlYWsgfHwgKHRva2VuID09PSAxNCAvKiBMaW5lQnJlYWtUcml2aWEgKi8pO1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFcnJvciA9IHRva2VuID09PSAxNiAvKiBVbmtub3duICovIHx8IHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpICE9PSAwIC8qIE5vbmUgKi87XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgdmFyIGVkaXRPcGVyYXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gYWRkRWRpdCh0ZXh0LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmICghaGFzRXJyb3IgJiYgKCFyYW5nZSB8fCAoc3RhcnRPZmZzZXQgPCByYW5nZUVuZCAmJiBlbmRPZmZzZXQgPiByYW5nZVN0YXJ0KSkgJiYgZG9jdW1lbnRUZXh0LnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSAhPT0gdGV4dCkge1xuICAgICAgICAgICAgZWRpdE9wZXJhdGlvbnMucHVzaCh7IG9mZnNldDogc3RhcnRPZmZzZXQsIGxlbmd0aDogZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQsIGNvbnRlbnQ6IHRleHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZpcnN0VG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgIGlmIChmaXJzdFRva2VuICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgdmFyIGZpcnN0VG9rZW5TdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgdmFyIGluaXRpYWxJbmRlbnQgPSByZXBlYXQoaW5kZW50VmFsdWUsIGluaXRpYWxJbmRlbnRMZXZlbCk7XG4gICAgICAgIGFkZEVkaXQoaW5pdGlhbEluZGVudCwgZm9ybWF0VGV4dFN0YXJ0LCBmaXJzdFRva2VuU3RhcnQpO1xuICAgIH1cbiAgICB3aGlsZSAoZmlyc3RUb2tlbiAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgIHZhciBmaXJzdFRva2VuRW5kID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xuICAgICAgICB2YXIgc2Vjb25kVG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgICAgICB2YXIgcmVwbGFjZUNvbnRlbnQgPSAnJztcbiAgICAgICAgdmFyIG5lZWRzTGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghbGluZUJyZWFrICYmIChzZWNvbmRUb2tlbiA9PT0gMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgc2Vjb25kVG9rZW4gPT09IDEzIC8qIEJsb2NrQ29tbWVudFRyaXZpYSAqLykpIHtcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzIG9uIHRoZSBzYW1lIGxpbmU6IGtlZXAgdGhlbSBvbiB0aGUgc2FtZSBsaW5lLCBidXQgaWdub3JlIHRoZW0gb3RoZXJ3aXNlXG4gICAgICAgICAgICB2YXIgY29tbWVudFRva2VuU3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgICAgICBhZGRFZGl0KCcgJywgZmlyc3RUb2tlbkVuZCwgY29tbWVudFRva2VuU3RhcnQpO1xuICAgICAgICAgICAgZmlyc3RUb2tlbkVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgICAgIG5lZWRzTGluZUJyZWFrID0gc2Vjb25kVG9rZW4gPT09IDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovO1xuICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZWVkc0xpbmVCcmVhayA/IG5ld0xpbmVBbmRJbmRlbnQoKSA6ICcnO1xuICAgICAgICAgICAgc2Vjb25kVG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWNvbmRUb2tlbiA9PT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRva2VuICE9PSAxIC8qIE9wZW5CcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50TGV2ZWwtLTtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWNvbmRUb2tlbiA9PT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgaWYgKGZpcnN0VG9rZW4gIT09IDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGluZGVudExldmVsLS07XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpcnN0VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGluZGVudExldmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZUFuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogQ29tbWFUb2tlbiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZUFuZEluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFuZWVkc0xpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ltYm9sIGZvbGxvd2luZyBjb21tZW50IG9uIHRoZSBzYW1lIGxpbmU6IGtlZXAgb24gc2FtZSBsaW5lLCBzZXBhcmF0ZSB3aXRoICcgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2IC8qIENvbG9uVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAgLyogU3RyaW5nTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZFRva2VuID09PSA2IC8qIENvbG9uVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDcgLyogTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA4IC8qIFRydWVLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIGNhc2UgOSAvKiBGYWxzZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMSAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQ2xvc2VCcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY29uZFRva2VuID09PSAxMiAvKiBMaW5lQ29tbWVudFRyaXZpYSAqLyB8fCBzZWNvbmRUb2tlbiA9PT0gMTMgLyogQmxvY2tDb21tZW50VHJpdmlhICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5lZWRzTGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Vjb25kVG9rZW4gIT09IDUgLyogQ29tbWFUb2tlbiAqLyAmJiBzZWNvbmRUb2tlbiAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNiAvKiBVbmtub3duICovOlxuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmVCcmVhayAmJiAoc2Vjb25kVG9rZW4gPT09IDEyIC8qIExpbmVDb21tZW50VHJpdmlhICovIHx8IHNlY29uZFRva2VuID09PSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi8pKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZFRva2VuID09PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gb3B0aW9ucy5pbnNlcnRGaW5hbE5ld2xpbmUgPyBlb2wgOiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vjb25kVG9rZW5TdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgYWRkRWRpdChyZXBsYWNlQ29udGVudCwgZmlyc3RUb2tlbkVuZCwgc2Vjb25kVG9rZW5TdGFydCk7XG4gICAgICAgIGZpcnN0VG9rZW4gPSBzZWNvbmRUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRPcGVyYXRpb25zO1xufVxuZnVuY3Rpb24gcmVwZWF0KHMsIGNvdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbmRlbnRMZXZlbChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuQ2hhcnMgPSAwO1xuICAgIHZhciB0YWJTaXplID0gb3B0aW9ucy50YWJTaXplIHx8IDQ7XG4gICAgd2hpbGUgKGkgPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBjb250ZW50LmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpIHtcbiAgICAgICAgICAgIG5DaGFycysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFx0Jykge1xuICAgICAgICAgICAgbkNoYXJzICs9IHRhYlNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKG5DaGFycyAvIHRhYlNpemUpO1xufVxuZnVuY3Rpb24gZ2V0RU9MKG9wdGlvbnMsIHRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgIGlmIChpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcclxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1xccic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChvcHRpb25zICYmIG9wdGlvbnMuZW9sKSB8fCAnXFxuJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0VPTCh0ZXh0LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gJ1xcclxcbicuaW5kZXhPZih0ZXh0LmNoYXJBdChvZmZzZXQpKSAhPT0gLTE7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGNyZWF0ZVNjYW5uZXIgfSBmcm9tICcuL3NjYW5uZXIuanMnO1xudmFyIFBhcnNlT3B0aW9ucztcbihmdW5jdGlvbiAoUGFyc2VPcHRpb25zKSB7XG4gICAgUGFyc2VPcHRpb25zLkRFRkFVTFQgPSB7XG4gICAgICAgIGFsbG93VHJhaWxpbmdDb21tYTogZmFsc2VcbiAgICB9O1xufSkoUGFyc2VPcHRpb25zIHx8IChQYXJzZU9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBGb3IgYSBnaXZlbiBvZmZzZXQsIGV2YWx1YXRlIHRoZSBsb2NhdGlvbiBpbiB0aGUgSlNPTiBkb2N1bWVudC4gRWFjaCBzZWdtZW50IGluIHRoZSBsb2NhdGlvbiBwYXRoIGlzIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYW4gYXJyYXkgaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbih0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBzZWdtZW50cyA9IFtdOyAvLyBzdHJpbmdzIG9yIG51bWJlcnNcbiAgICB2YXIgZWFybHlSZXR1cm5FeGNlcHRpb24gPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJldmlvdXNOb2RlSW5zdCA9IHtcbiAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHBhcmVudDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB2YXIgaXNBdFByb3BlcnR5S2V5ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc2V0UHJldmlvdXNOb2RlKHZhbHVlLCBvZmZzZXQsIGxlbmd0aCwgdHlwZSkge1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3Qub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC50eXBlID0gdHlwZTtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC5jb2xvbk9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcHJldmlvdXNOb2RlID0gcHJldmlvdXNOb2RlSW5zdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdmlzaXQodGV4dCwge1xuICAgICAgICAgICAgb25PYmplY3RCZWdpbjogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlzQXRQcm9wZXJ0eUtleSA9IHBvc2l0aW9uID4gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goJycpOyAvLyBwdXNoIGEgcGxhY2Vob2xkZXIgKHdpbGwgYmUgcmVwbGFjZWQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25PYmplY3RQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c05vZGUobmFtZSwgb2Zmc2V0LCBsZW5ndGgsICdwcm9wZXJ0eScpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk9iamVjdEVuZDogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQXJyYXlCZWdpbjogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BcnJheUVuZDogZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcmV2aW91c05vZGUodmFsdWUsIG9mZnNldCwgbGVuZ3RoLCBnZXROb2RlVHlwZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VwYXJhdG9yOiBmdW5jdGlvbiAoc2VwLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICc6JyAmJiBwcmV2aW91c05vZGUgJiYgcHJldmlvdXNOb2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlLmNvbG9uT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpc0F0UHJvcGVydHlLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXAgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9IGxhc3QgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlICE9PSBlYXJseVJldHVybkV4Y2VwdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBzZWdtZW50cyxcbiAgICAgICAgcHJldmlvdXNOb2RlOiBwcmV2aW91c05vZGUsXG4gICAgICAgIGlzQXRQcm9wZXJ0eUtleTogaXNBdFByb3BlcnR5S2V5LFxuICAgICAgICBtYXRjaGVzOiBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGsgPCBwYXR0ZXJuLmxlbmd0aCAmJiBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybltrXSA9PT0gc2VnbWVudHNbaV0gfHwgcGF0dGVybltrXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybltrXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGsgPT09IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIHRoZSBvYmplY3QgdGhlIEpTT04gY29udGVudCByZXByZXNlbnRzLiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICogVGhlcmVmb3JlIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGVycm9ycywgb3B0aW9ucykge1xuICAgIGlmIChlcnJvcnMgPT09IHZvaWQgMCkgeyBlcnJvcnMgPSBbXTsgfVxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IFBhcnNlT3B0aW9ucy5ERUZBVUxUOyB9XG4gICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBbXTtcbiAgICB2YXIgcHJldmlvdXNQYXJlbnRzID0gW107XG4gICAgZnVuY3Rpb24gb25WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UGFyZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50UHJvcGVydHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRbY3VycmVudFByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB2aXNpdG9yID0ge1xuICAgICAgICBvbk9iamVjdEJlZ2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBvblZhbHVlKG9iamVjdCk7XG4gICAgICAgICAgICBwcmV2aW91c1BhcmVudHMucHVzaChjdXJyZW50UGFyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvYmplY3Q7XG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2aW91c1BhcmVudHMucG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlCZWdpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICBvblZhbHVlKGFycmF5KTtcbiAgICAgICAgICAgIHByZXZpb3VzUGFyZW50cy5wdXNoKGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGFycmF5O1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25BcnJheUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHByZXZpb3VzUGFyZW50cy5wb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6IG9uVmFsdWUsXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvciwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgZXJyb3I6IGVycm9yLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50UGFyZW50WzBdO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgYSB0cmVlIHJlcHJlc2VudGF0aW9uIHRoZSBKU09OIGNvbnRlbnQuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyZWUodGV4dCwgZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgaWYgKGVycm9ycyA9PT0gdm9pZCAwKSB7IGVycm9ycyA9IFtdOyB9XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gUGFyc2VPcHRpb25zLkRFRkFVTFQ7IH1cbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHsgdHlwZTogJ2FycmF5Jywgb2Zmc2V0OiAtMSwgbGVuZ3RoOiAtMSwgY2hpbGRyZW46IFtdLCBwYXJlbnQ6IHVuZGVmaW5lZCB9OyAvLyBhcnRpZmljaWFsIHJvb3RcbiAgICBmdW5jdGlvbiBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoY3VycmVudFBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IGVuZE9mZnNldCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVmFsdWUodmFsdWVOb2RlKSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICByZXR1cm4gdmFsdWVOb2RlO1xuICAgIH1cbiAgICB2YXIgdmlzaXRvciA9IHtcbiAgICAgICAgb25PYmplY3RCZWdpbjogZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAnb2JqZWN0Jywgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvblZhbHVlKHsgdHlwZTogJ3Byb3BlcnR5Jywgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBuYW1lLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGgsIHBhcmVudDogY3VycmVudFBhcmVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpOyAvLyBpbiBjYXNlIG9mIGEgbWlzc2luZyB2YWx1ZSBmb3IgYSBwcm9wZXJ0eTogbWFrZSBzdXJlIHByb3BlcnR5IGlzIGNvbXBsZXRlXG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IG9mZnNldCArIGxlbmd0aCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5QmVnaW46IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAnYXJyYXknLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiAtMSwgcGFyZW50OiBjdXJyZW50UGFyZW50LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXJyYXlFbmQ6IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5sZW5ndGggPSBvZmZzZXQgKyBsZW5ndGggLSBjdXJyZW50UGFyZW50Lm9mZnNldDtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGVuc3VyZVByb3BlcnR5Q29tcGxldGUob2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG9uVmFsdWUoeyB0eXBlOiBnZXROb2RlVHlwZSh2YWx1ZSksIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCwgcGFyZW50OiBjdXJyZW50UGFyZW50LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2VwYXJhdG9yOiBmdW5jdGlvbiAoc2VwLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXAgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmNvbG9uT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXAgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7IGVycm9yOiBlcnJvciwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2aXNpdCh0ZXh0LCB2aXNpdG9yLCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gY3VycmVudFBhcmVudC5jaGlsZHJlblswXTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcGF0aCBpbiBhIEpTT04gRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVBdExvY2F0aW9uKHJvb3QsIHBhdGgpIHtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIF9pID0gMCwgcGF0aF8xID0gcGF0aDsgX2kgPCBwYXRoXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gcGF0aF8xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ29iamVjdCcgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gbm9kZS5jaGlsZHJlbjsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOb2RlID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5Tm9kZS5jaGlsZHJlbikgJiYgcHJvcGVydHlOb2RlLmNoaWxkcmVuWzBdLnZhbHVlID09PSBzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwcm9wZXJ0eU5vZGUuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWdtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ2FycmF5JyB8fCBpbmRleCA8IDAgfHwgIUFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgfHwgaW5kZXggPj0gbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBKU09OIHBhdGggb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVQYXRoKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUucGFyZW50IHx8ICFub2RlLnBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBwYXRoID0gZ2V0Tm9kZVBhdGgobm9kZS5wYXJlbnQpO1xuICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgIHZhciBrZXkgPSBub2RlLnBhcmVudC5jaGlsZHJlblswXS52YWx1ZTtcbiAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbm9kZS5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBKYXZhU2NyaXB0IG9iamVjdCBvZiB0aGUgZ2l2ZW4gSlNPTiBET00gbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVZhbHVlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZ2V0Tm9kZVZhbHVlKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUuY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlTm9kZSA9IHByb3AuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcC5jaGlsZHJlblswXS52YWx1ZV0gPSBnZXROb2RlVmFsdWUodmFsdWVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpIHtcbiAgICBpZiAoaW5jbHVkZVJpZ2h0Qm91bmQgPT09IHZvaWQgMCkgeyBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIChvZmZzZXQgPj0gbm9kZS5vZmZzZXQgJiYgb2Zmc2V0IDwgKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKSB8fCBpbmNsdWRlUmlnaHRCb3VuZCAmJiAob2Zmc2V0ID09PSAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbW9zdCBpbm5lciBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVBdE9mZnNldChub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKSB7XG4gICAgaWYgKGluY2x1ZGVSaWdodEJvdW5kID09PSB2b2lkIDApIHsgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZTsgfVxuICAgIGlmIChjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2ldLm9mZnNldCA8PSBvZmZzZXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZmluZE5vZGVBdE9mZnNldChjaGlsZHJlbltpXSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVDsgfVxuICAgIHZhciBfc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIodGV4dCwgZmFsc2UpO1xuICAgIGZ1bmN0aW9uIHRvTm9BcmdWaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpOyB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdmlzaXRGdW5jdGlvbihhcmcsIF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSk7IH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIH1cbiAgICB2YXIgb25PYmplY3RCZWdpbiA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0QmVnaW4pLCBvbk9iamVjdFByb3BlcnR5ID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0UHJvcGVydHkpLCBvbk9iamVjdEVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uT2JqZWN0RW5kKSwgb25BcnJheUJlZ2luID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25BcnJheUJlZ2luKSwgb25BcnJheUVuZCA9IHRvTm9BcmdWaXNpdCh2aXNpdG9yLm9uQXJyYXlFbmQpLCBvbkxpdGVyYWxWYWx1ZSA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkxpdGVyYWxWYWx1ZSksIG9uU2VwYXJhdG9yID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uU2VwYXJhdG9yKSwgb25Db21tZW50ID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25Db21tZW50KSwgb25FcnJvciA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkVycm9yKTtcbiAgICB2YXIgZGlzYWxsb3dDb21tZW50cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNhbGxvd0NvbW1lbnRzO1xuICAgIHZhciBhbGxvd1RyYWlsaW5nQ29tbWEgPSBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hO1xuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gX3NjYW5uZXIuc2NhbigpO1xuICAgICAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogSW52YWxpZFVuaWNvZGUgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE0IC8qIEludmFsaWRVbmljb2RlICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIEludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDE1IC8qIEludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogVW5leHBlY3RlZEVuZE9mTnVtYmVyICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMyAvKiBVbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMSAvKiBVbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMiAvKiBVbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYgLyogSW52YWxpZENoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTYgLyogSW52YWxpZENoYXJhY3RlciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhbGxvd0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMCAvKiBJbnZhbGlkQ29tbWVudFRva2VuICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTYgLyogVW5rbm93biAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMSAvKiBJbnZhbGlkU3ltYm9sICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNSAvKiBUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNCAvKiBMaW5lQnJlYWtUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgc2tpcFVudGlsQWZ0ZXIsIHNraXBVbnRpbCkge1xuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIgPT09IHZvaWQgMCkgeyBza2lwVW50aWxBZnRlciA9IFtdOyB9XG4gICAgICAgIGlmIChza2lwVW50aWwgPT09IHZvaWQgMCkgeyBza2lwVW50aWwgPSBbXTsgfVxuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmxlbmd0aCArIHNraXBVbnRpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBfc2Nhbm5lci5nZXRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChza2lwVW50aWwuaW5kZXhPZih0b2tlbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcoaXNWYWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgIGlmIChpc1ZhbHVlKSB7XG4gICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbk9iamVjdFByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuTmV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VMaXRlcmFsKCkge1xuICAgICAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMTEgLyogTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuVmFsdWUgPSBfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKHRva2VuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMiAvKiBJbnZhbGlkTnVtYmVyRm9ybWF0ICovKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDcgLyogTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDggLyogVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogRmFsc2VLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIG9uTGl0ZXJhbFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNjYW5OZXh0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5KCkge1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTAgLyogU3RyaW5nTGl0ZXJhbCAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoMyAvKiBQcm9wZXJ0eU5hbWVFeHBlY3RlZCAqLywgW10sIFsyIC8qIENsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VTdHJpbmcoZmFsc2UpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNiAvKiBDb2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBvblNlcGFyYXRvcignOicpO1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb2xvblxuICAgICAgICAgICAgaWYgKCFwYXJzZVZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoNSAvKiBDb2xvbkV4cGVjdGVkICovLCBbXSwgWzIgLyogQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIENvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3QoKSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW4oKTtcbiAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBvcGVuIGJyYWNlXG4gICAgICAgIHZhciBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIENsb3NlQnJhY2VUb2tlbiAqLyAmJiBfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIENvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8gJiYgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig2IC8qIENvbW1hRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnNlUHJvcGVydHkoKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDQgLyogVmFsdWVFeHBlY3RlZCAqLywgW10sIFsyIC8qIENsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvbk9iamVjdEVuZCgpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKDcgLyogQ2xvc2VCcmFjZUV4cGVjdGVkICovLCBbMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi9dLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNsb3NlIGJyYWNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgICAgIG9uQXJyYXlCZWdpbigpO1xuICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIG9wZW4gYnJhY2tldFxuICAgICAgICB2YXIgbmVlZHNDb21tYSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBFT0YgKi8pIHtcbiAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIENvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLyAmJiBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDYgLyogQ29tbWFFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgWzQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi8sIDUgLyogQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVlZHNDb21tYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgb25BcnJheUVuZCgpO1xuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoOCAvKiBDbG9zZUJyYWNrZXRFeHBlY3RlZCAqLywgWzQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi9dLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNsb3NlIGJyYWNrZXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSgpIHtcbiAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbigpKSB7XG4gICAgICAgICAgICBjYXNlIDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAxIC8qIE9wZW5CcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCgpO1xuICAgICAgICAgICAgY2FzZSAxMCAvKiBTdHJpbmdMaXRlcmFsICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZyh0cnVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTGl0ZXJhbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW5OZXh0KCk7XG4gICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0VtcHR5Q29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBWYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDQgLyogVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDkgLyogRW5kT2ZGaWxlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBUYWtlcyBKU09OIHdpdGggSmF2YVNjcmlwdC1zdHlsZSBjb21tZW50cyBhbmQgcmVtb3ZlXG4gKiB0aGVtLiBPcHRpb25hbGx5IHJlcGxhY2VzIGV2ZXJ5IG5vbmUtbmV3bGluZSBjaGFyYWN0ZXJcbiAqIG9mIGNvbW1lbnRzIHdpdGggYSByZXBsYWNlQ2hhcmFjdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcENvbW1lbnRzKHRleHQsIHJlcGxhY2VDaCkge1xuICAgIHZhciBfc2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXIodGV4dCksIHBhcnRzID0gW10sIGtpbmQsIG9mZnNldCA9IDAsIHBvcztcbiAgICBkbyB7XG4gICAgICAgIHBvcyA9IF9zY2FubmVyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGtpbmQgPSBfc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAxMiAvKiBMaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTMgLyogQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgY2FzZSAxNyAvKiBFT0YgKi86XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBwb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VDaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpLnJlcGxhY2UoL1teXFxyXFxuXS9nLCByZXBsYWNlQ2gpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3NjYW5uZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGtpbmQgIT09IDE3IC8qIEVPRiAqLyk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVUeXBlKHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICdudWxsJztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGZvcm1hdCwgaXNFT0wgfSBmcm9tICcuL2Zvcm1hdC5qcyc7XG5pbXBvcnQgeyBwYXJzZVRyZWUsIGZpbmROb2RlQXRMb2NhdGlvbiB9IGZyb20gJy4vcGFyc2VyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0eSh0ZXh0LCBwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHNldFByb3BlcnR5KHRleHQsIHBhdGgsIHZvaWQgMCwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkodGV4dCwgb3JpZ2luYWxQYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcGF0aCA9IG9yaWdpbmFsUGF0aC5zbGljZSgpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgcm9vdCA9IHBhcnNlVHJlZSh0ZXh0LCBlcnJvcnMpO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gdm9pZCAwO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGFzdFNlZ21lbnQgPSBwYXRoLnBvcCgpO1xuICAgICAgICBwYXJlbnQgPSBmaW5kTm9kZUF0TG9jYXRpb24ocm9vdCwgcGF0aCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKF9hID0ge30sIF9hW2xhc3RTZWdtZW50XSA9IHZhbHVlLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAvLyBlbXB0eSBkb2N1bWVudFxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZWxldGUgaW4gZW1wdHkgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgeyBvZmZzZXQ6IHJvb3QgPyByb290Lm9mZnNldCA6IDAsIGxlbmd0aDogcm9vdCA/IHJvb3QubGVuZ3RoIDogMCwgY29udGVudDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gZmluZE5vZGVBdExvY2F0aW9uKHBhcmVudCwgW2xhc3RTZWdtZW50XSk7XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBBU1QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihleGlzdGluZy5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVCZWdpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlRW5kID0gZXhpc3RpbmcucGFyZW50Lm9mZnNldCArIGV4aXN0aW5nLnBhcmVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29tbWEgb2YgdGhlIHByZXZpb3VzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3Byb3BlcnR5SW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQmVnaW4gPSBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVCZWdpbiA9IHBhcmVudC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29tbWEgb2YgdGhlIG5leHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBwYXJlbnQuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFbmQgPSBuZXh0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgeyBvZmZzZXQ6IHJlbW92ZUJlZ2luLCBsZW5ndGg6IHJlbW92ZUVuZCAtIHJlbW92ZUJlZ2luLCBjb250ZW50OiAnJyB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZSBvZiBleGlzdGluZyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCB7IG9mZnNldDogZXhpc3Rpbmcub2Zmc2V0LCBsZW5ndGg6IGV4aXN0aW5nLmxlbmd0aCwgY29udGVudDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBwcm9wZXJ0eSBkb2VzIG5vdCBleGlzdCwgbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld1Byb3BlcnR5ID0gSlNPTi5zdHJpbmdpZnkobGFzdFNlZ21lbnQpICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gb3B0aW9ucy5nZXRJbnNlcnRpb25JbmRleCA/IG9wdGlvbnMuZ2V0SW5zZXJ0aW9uSW5kZXgocGFyZW50LmNoaWxkcmVuLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5jaGlsZHJlblswXS52YWx1ZTsgfSkpIDogcGFyZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBlZGl0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoLCBsZW5ndGg6IDAsIGNvbnRlbnQ6ICcsJyArIG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSArICcsJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudC50eXBlID09PSAnYXJyYXknICYmIHR5cGVvZiBsYXN0U2VnbWVudCA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShwYXJlbnQuY2hpbGRyZW4pKSB7XG4gICAgICAgIHZhciBpbnNlcnRJbmRleCA9IGxhc3RTZWdtZW50O1xuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRcbiAgICAgICAgICAgIHZhciBuZXdQcm9wZXJ0eSA9IFwiXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgZWRpdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmFsXG4gICAgICAgICAgICB2YXIgcmVtb3ZhbEluZGV4ID0gbGFzdFNlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4XTtcbiAgICAgICAgICAgIHZhciBlZGl0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGl0ZW1cbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IHBhcmVudC5sZW5ndGggLSAyLCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEgPT09IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltyZW1vdmFsSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbmRPZmZzZXQgPSBwYXJlbnQub2Zmc2V0ICsgcGFyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBwYXJlbnRFbmRPZmZzZXQgLSAyIC0gb2Zmc2V0LCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiB0b1JlbW92ZS5vZmZzZXQsIGxlbmd0aDogcGFyZW50LmNoaWxkcmVuW3JlbW92YWxJbmRleCArIDFdLm9mZnNldCAtIHRvUmVtb3ZlLm9mZnNldCwgY29udGVudDogJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgZWRpdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBuZXdQcm9wZXJ0eSA9IFwiXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaXNBcnJheUluc2VydGlvbiAmJiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID4gbGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9Nb2RpZnkgPSBwYXJlbnQuY2hpbGRyZW5bbGFzdFNlZ21lbnRdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogdG9Nb2RpZnkub2Zmc2V0LCBsZW5ndGg6IHRvTW9kaWZ5Lmxlbmd0aCwgY29udGVudDogbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgbGFzdFNlZ21lbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBuZXdQcm9wZXJ0eSA6IG5ld1Byb3BlcnR5ICsgJywnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsYXN0U2VnbWVudCA+IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPyBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIDogbGFzdFNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gcGFyZW50LmNoaWxkcmVuW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwcmV2aW91cy5vZmZzZXQgKyBwcmV2aW91cy5sZW5ndGgsIGxlbmd0aDogMCwgY29udGVudDogJywnICsgbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgXCIgKyAodmFsdWUgPT09IHZvaWQgMCA/ICdyZW1vdmUnIDogKG9wdGlvbnMuaXNBcnJheUluc2VydGlvbiA/ICdpbnNlcnQnIDogJ21vZGlmeScpKSArIFwiIEFycmF5IGluZGV4IFwiICsgaW5zZXJ0SW5kZXggKyBcIiBhcyBsZW5ndGggaXMgbm90IHN1ZmZpY2llbnRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWRkIFwiICsgKHR5cGVvZiBsYXN0U2VnbWVudCAhPT0gJ251bWJlcicgPyAnaW5kZXgnIDogJ3Byb3BlcnR5JykgKyBcIiB0byBwYXJlbnQgb2YgdHlwZSBcIiArIHBhcmVudC50eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBbZWRpdF07XG4gICAgfVxuICAgIC8vIGFwcGx5IHRoZSBlZGl0XG4gICAgdmFyIG5ld1RleHQgPSBhcHBseUVkaXQodGV4dCwgZWRpdCk7XG4gICAgLy8gZm9ybWF0IHRoZSBuZXcgdGV4dFxuICAgIHZhciBiZWdpbiA9IGVkaXQub2Zmc2V0O1xuICAgIHZhciBlbmQgPSBlZGl0Lm9mZnNldCArIGVkaXQuY29udGVudC5sZW5ndGg7XG4gICAgaWYgKGVkaXQubGVuZ3RoID09PSAwIHx8IGVkaXQuY29udGVudC5sZW5ndGggPT09IDApIHsgLy8gaW5zZXJ0IG9yIHJlbW92ZVxuICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmICFpc0VPTChuZXdUZXh0LCBiZWdpbiAtIDEpKSB7XG4gICAgICAgICAgICBiZWdpbi0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBuZXdUZXh0Lmxlbmd0aCAmJiAhaXNFT0wobmV3VGV4dCwgZW5kKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGVkaXRzID0gZm9ybWF0KG5ld1RleHQsIHsgb2Zmc2V0OiBiZWdpbiwgbGVuZ3RoOiBlbmQgLSBiZWdpbiB9LCBvcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zKTtcbiAgICAvLyBhcHBseSB0aGUgZm9ybWF0dGluZyBlZGl0cyBhbmQgdHJhY2sgdGhlIGJlZ2luIGFuZCBlbmQgb2Zmc2V0cyBvZiB0aGUgY2hhbmdlc1xuICAgIGZvciAodmFyIGkgPSBlZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZWRpdF8xID0gZWRpdHNbaV07XG4gICAgICAgIG5ld1RleHQgPSBhcHBseUVkaXQobmV3VGV4dCwgZWRpdF8xKTtcbiAgICAgICAgYmVnaW4gPSBNYXRoLm1pbihiZWdpbiwgZWRpdF8xLm9mZnNldCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KGVuZCwgZWRpdF8xLm9mZnNldCArIGVkaXRfMS5sZW5ndGgpO1xuICAgICAgICBlbmQgKz0gZWRpdF8xLmNvbnRlbnQubGVuZ3RoIC0gZWRpdF8xLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgc2luZ2xlIGVkaXQgd2l0aCBhbGwgY2hhbmdlc1xuICAgIHZhciBlZGl0TGVuZ3RoID0gdGV4dC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggLSBlbmQpIC0gYmVnaW47XG4gICAgcmV0dXJuIFt7IG9mZnNldDogYmVnaW4sIGxlbmd0aDogZWRpdExlbmd0aCwgY29udGVudDogbmV3VGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCkgfV07XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlFZGl0KHRleHQsIGVkaXQpIHtcbiAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoMCwgZWRpdC5vZmZzZXQpICsgZWRpdC5jb250ZW50ICsgdGV4dC5zdWJzdHJpbmcoZWRpdC5vZmZzZXQgKyBlZGl0Lmxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNXUyh0ZXh0LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gJ1xcclxcbiBcXHQnLmluZGV4T2YodGV4dC5jaGFyQXQob2Zmc2V0KSkgIT09IC0xO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyBmb3JtYXR0ZXIgZnJvbSAnLi9pbXBsL2Zvcm1hdC5qcyc7XG5pbXBvcnQgKiBhcyBlZGl0IGZyb20gJy4vaW1wbC9lZGl0LmpzJztcbmltcG9ydCAqIGFzIHNjYW5uZXIgZnJvbSAnLi9pbXBsL3NjYW5uZXIuanMnO1xuaW1wb3J0ICogYXMgcGFyc2VyIGZyb20gJy4vaW1wbC9wYXJzZXIuanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCB2YXIgY3JlYXRlU2Nhbm5lciA9IHNjYW5uZXIuY3JlYXRlU2Nhbm5lcjtcbi8qKlxuICogRm9yIGEgZ2l2ZW4gb2Zmc2V0LCBldmFsdWF0ZSB0aGUgbG9jYXRpb24gaW4gdGhlIEpTT04gZG9jdW1lbnQuIEVhY2ggc2VnbWVudCBpbiB0aGUgbG9jYXRpb24gcGF0aCBpcyBlaXRoZXIgYSBwcm9wZXJ0eSBuYW1lIG9yIGFuIGFycmF5IGluZGV4LlxuICovXG5leHBvcnQgdmFyIGdldExvY2F0aW9uID0gcGFyc2VyLmdldExvY2F0aW9uO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgdGhlIG9iamVjdCB0aGUgSlNPTiBjb250ZW50IHJlcHJlc2VudHMuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKiBUaGVyZWZvcmUsIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuZXhwb3J0IHZhciBwYXJzZSA9IHBhcnNlci5wYXJzZTtcbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIGEgdHJlZSByZXByZXNlbnRhdGlvbiB0aGUgSlNPTiBjb250ZW50LiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICovXG5leHBvcnQgdmFyIHBhcnNlVHJlZSA9IHBhcnNlci5wYXJzZVRyZWU7XG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwYXRoIGluIGEgSlNPTiBET00uXG4gKi9cbmV4cG9ydCB2YXIgZmluZE5vZGVBdExvY2F0aW9uID0gcGFyc2VyLmZpbmROb2RlQXRMb2NhdGlvbjtcbi8qKlxuICogRmluZHMgdGhlIGlubmVybW9zdCBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5leHBvcnQgdmFyIGZpbmROb2RlQXRPZmZzZXQgPSBwYXJzZXIuZmluZE5vZGVBdE9mZnNldDtcbi8qKlxuICogR2V0cyB0aGUgSlNPTiBwYXRoIG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmV4cG9ydCB2YXIgZ2V0Tm9kZVBhdGggPSBwYXJzZXIuZ2V0Tm9kZVBhdGg7XG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgSmF2YVNjcmlwdCBvYmplY3Qgb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuZXhwb3J0IHZhciBnZXROb2RlVmFsdWUgPSBwYXJzZXIuZ2V0Tm9kZVZhbHVlO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIGludm9rZXMgdGhlIHZpc2l0b3IgZnVuY3Rpb25zIGZvciBlYWNoIG9iamVjdCwgYXJyYXkgYW5kIGxpdGVyYWwgcmVhY2hlZC5cbiAqL1xuZXhwb3J0IHZhciB2aXNpdCA9IHBhcnNlci52aXNpdDtcbi8qKlxuICogVGFrZXMgSlNPTiB3aXRoIEphdmFTY3JpcHQtc3R5bGUgY29tbWVudHMgYW5kIHJlbW92ZVxuICogdGhlbS4gT3B0aW9uYWxseSByZXBsYWNlcyBldmVyeSBub25lLW5ld2xpbmUgY2hhcmFjdGVyXG4gKiBvZiBjb21tZW50cyB3aXRoIGEgcmVwbGFjZUNoYXJhY3RlclxuICovXG5leHBvcnQgdmFyIHN0cmlwQ29tbWVudHMgPSBwYXJzZXIuc3RyaXBDb21tZW50cztcbmV4cG9ydCBmdW5jdGlvbiBwcmludFBhcnNlRXJyb3JDb2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIEludmFsaWRTeW1ib2wgKi86IHJldHVybiAnSW52YWxpZFN5bWJvbCc7XG4gICAgICAgIGNhc2UgMiAvKiBJbnZhbGlkTnVtYmVyRm9ybWF0ICovOiByZXR1cm4gJ0ludmFsaWROdW1iZXJGb3JtYXQnO1xuICAgICAgICBjYXNlIDMgLyogUHJvcGVydHlOYW1lRXhwZWN0ZWQgKi86IHJldHVybiAnUHJvcGVydHlOYW1lRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDQgLyogVmFsdWVFeHBlY3RlZCAqLzogcmV0dXJuICdWYWx1ZUV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA1IC8qIENvbG9uRXhwZWN0ZWQgKi86IHJldHVybiAnQ29sb25FeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgNiAvKiBDb21tYUV4cGVjdGVkICovOiByZXR1cm4gJ0NvbW1hRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDcgLyogQ2xvc2VCcmFjZUV4cGVjdGVkICovOiByZXR1cm4gJ0Nsb3NlQnJhY2VFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOCAvKiBDbG9zZUJyYWNrZXRFeHBlY3RlZCAqLzogcmV0dXJuICdDbG9zZUJyYWNrZXRFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgOSAvKiBFbmRPZkZpbGVFeHBlY3RlZCAqLzogcmV0dXJuICdFbmRPZkZpbGVFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgMTAgLyogSW52YWxpZENvbW1lbnRUb2tlbiAqLzogcmV0dXJuICdJbnZhbGlkQ29tbWVudFRva2VuJztcbiAgICAgICAgY2FzZSAxMSAvKiBVbmV4cGVjdGVkRW5kT2ZDb21tZW50ICovOiByZXR1cm4gJ1VuZXhwZWN0ZWRFbmRPZkNvbW1lbnQnO1xuICAgICAgICBjYXNlIDEyIC8qIFVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZTdHJpbmcnO1xuICAgICAgICBjYXNlIDEzIC8qIFVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzogcmV0dXJuICdVbmV4cGVjdGVkRW5kT2ZOdW1iZXInO1xuICAgICAgICBjYXNlIDE0IC8qIEludmFsaWRVbmljb2RlICovOiByZXR1cm4gJ0ludmFsaWRVbmljb2RlJztcbiAgICAgICAgY2FzZSAxNSAvKiBJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyICovOiByZXR1cm4gJ0ludmFsaWRFc2NhcGVDaGFyYWN0ZXInO1xuICAgICAgICBjYXNlIDE2IC8qIEludmFsaWRDaGFyYWN0ZXIgKi86IHJldHVybiAnSW52YWxpZENoYXJhY3Rlcic7XG4gICAgfVxuICAgIHJldHVybiAnPHVua25vd24gUGFyc2VFcnJvckNvZGU+Jztcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXRzIG5lZWRlZCB0byBmb3JtYXQgYSBKU09OIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudFRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gZm9ybWF0IG9yIGB1bmRlZmluZWRgIHRvIGZvcm1hdCB0aGUgZnVsbCBjb250ZW50XG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgZm9ybWF0dGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgZWRpdCBvcGVyYXRpb25zIGRlc2NyaWJpbmcgdGhlIGZvcm1hdHRpbmcgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuIEVkaXRzIGNhbiBiZSBlaXRoZXIgaW5zZXJ0cywgcmVwbGFjZW1lbnRzIG9yXG4gKiByZW1vdmFscyBvZiB0ZXh0IHNlZ21lbnRzLiBBbGwgb2Zmc2V0cyByZWZlciB0byB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50LiBObyB0d28gZWRpdHMgbXVzdCBjaGFuZ2Ugb3IgcmVtb3ZlIHRoZSBzYW1lIHJhbmdlIG9mXG4gKiB0ZXh0IGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudC4gSG93ZXZlciwgbXVsdGlwbGUgZWRpdHMgY2FuIGhhdmVcbiAqIHRoZSBzYW1lIG9mZnNldCwgZm9yIGV4YW1wbGUgbXVsdGlwbGUgaW5zZXJ0cywgb3IgYW4gaW5zZXJ0IGZvbGxvd2VkIGJ5IGEgcmVtb3ZlIG9yIHJlcGxhY2UuIFRoZSBvcmRlciBpbiB0aGUgYXJyYXkgZGVmaW5lcyB3aGljaCBlZGl0IGlzIGFwcGxpZWQgZmlyc3QuXG4gKiBUbyBhcHBseSBlZGl0cyB0byBhbiBpbnB1dCwgeW91IGNhbiB1c2UgYGFwcGx5RWRpdHNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGRvY3VtZW50VGV4dCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChkb2N1bWVudFRleHQsIHJhbmdlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXRzIG5lZWRlZCB0byBtb2RpZnkgYSB2YWx1ZSBpbiB0aGUgSlNPTiBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0gZG9jdW1lbnRUZXh0IFRoZSBpbnB1dCB0ZXh0XG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgdmFsdWUgdG8gY2hhbmdlLiBUaGUgcGF0aCByZXByZXNlbnRzIGVpdGhlciB0byB0aGUgZG9jdW1lbnQgcm9vdCwgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBpdGVtLlxuICogSWYgdGhlIHBhdGggcG9pbnRzIHRvIGFuIG5vbi1leGlzdGluZyBwcm9wZXJ0eSBvciBpdGVtLCBpdCB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBvciBpdGVtLiBJZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLFxuICogdGhlIHByb3BlcnR5IG9yIGl0ZW0gd2lsbCBiZSByZW1vdmVkLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uc1xuICogQHJldHVybnMgQSBsaXN0IG9mIGVkaXQgb3BlcmF0aW9ucyBkZXNjcmliaW5nIHRoZSBmb3JtYXR0aW5nIGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50LiBFZGl0cyBjYW4gYmUgZWl0aGVyIGluc2VydHMsIHJlcGxhY2VtZW50cyBvclxuICogcmVtb3ZhbHMgb2YgdGV4dCBzZWdtZW50cy4gQWxsIG9mZnNldHMgcmVmZXIgdG8gdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudC4gTm8gdHdvIGVkaXRzIG11c3QgY2hhbmdlIG9yIHJlbW92ZSB0aGUgc2FtZSByYW5nZSBvZlxuICogdGV4dCBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuIEhvd2V2ZXIsIG11bHRpcGxlIGVkaXRzIGNhbiBoYXZlXG4gKiB0aGUgc2FtZSBvZmZzZXQsIGZvciBleGFtcGxlIG11bHRpcGxlIGluc2VydHMsIG9yIGFuIGluc2VydCBmb2xsb3dlZCBieSBhIHJlbW92ZSBvciByZXBsYWNlLiBUaGUgb3JkZXIgaW4gdGhlIGFycmF5IGRlZmluZXMgd2hpY2ggZWRpdCBpcyBhcHBsaWVkIGZpcnN0LlxuICogVG8gYXBwbHkgZWRpdHMgdG8gYW4gaW5wdXQsIHlvdSBjYW4gdXNlIGBhcHBseUVkaXRzYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmeSh0ZXh0LCBwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0LnNldFByb3BlcnR5KHRleHQsIHBhdGgsIHZhbHVlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQXBwbGllcyBlZGl0cyB0byBhIGlucHV0IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RWRpdHModGV4dCwgZWRpdHMpIHtcbiAgICBmb3IgKHZhciBpID0gZWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGV4dCA9IGVkaXQuYXBwbHlFZGl0KHRleHQsIGVkaXRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMob25lLCBvdGhlcikge1xuICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob25lID09PSBudWxsIHx8IG9uZSA9PT0gdW5kZWZpbmVkIHx8IG90aGVyID09PSBudWxsIHx8IG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gdHlwZW9mIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChBcnJheS5pc0FycmF5KG9uZSkpICE9PSAoQXJyYXkuaXNBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGksIGtleTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvbmUpKSB7XG4gICAgICAgIGlmIChvbmUubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9uZUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb25lKSB7XG4gICAgICAgICAgICBvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvbmVLZXlzLnNvcnQoKTtcbiAgICAgICAgdmFyIG90aGVyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIGlmIChoYXlzdGFjay5sZW5ndGggPCBuZWVkbGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWVkbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhheXN0YWNrW2ldICE9PSBuZWVkbGVbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBoYXlzdGFjayBlbmRzIHdpdGggbmVlZGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5kc1dpdGgoaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgIHZhciBkaWZmID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlLmxlbmd0aDtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLmxhc3RJbmRleE9mKG5lZWRsZSkgPT09IGRpZmY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrID09PSBuZWVkbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTaW1wbGUyUmVnRXhwUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xcLVxcXFxcXHtcXH1cXCtcXD9cXHxcXF5cXCRcXC5cXCxcXFtcXF1cXChcXClcXCNcXHNdL2csICdcXFxcJCYnKS5yZXBsYWNlKC9bXFwqXS9nLCAnLionKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXQodmFsdWUsIGNvdW50KSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgICAgcyArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgY291bnQgPSBjb3VudCA+Pj4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kZWRSZWdFeHAocGF0dGVybikge1xuICAgIGlmIChzdGFydHNXaXRoKHBhdHRlcm4sICcoP2kpJykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybi5zdWJzdHJpbmcoNCksICdpJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG59XG4iLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4ndXNlIHN0cmljdCc7XG5leHBvcnQgdmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0Nztcbn0pKGludGVnZXIgfHwgKGludGVnZXIgPSB7fSkpO1xuZXhwb3J0IHZhciB1aW50ZWdlcjtcbihmdW5jdGlvbiAodWludGVnZXIpIHtcbiAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgIHVpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbUG9zaXRpb25dKCNQb3NpdGlvbikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3RlcjogY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW1Bvc2l0aW9uXSgjUG9zaXRpb24pIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5jaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBQb3NpdGlvbi5pcyA9IGlzO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW1JhbmdlXSgjUmFuZ2UpIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFJhbmdlO1xuKGZ1bmN0aW9uIChSYW5nZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcbiAgICAgICAgaWYgKElzLnVpbnRlZ2VyKG9uZSkgJiYgSXMudWludGVnZXIodHdvKSAmJiBJcy51aW50ZWdlcih0aHJlZSkgJiYgSXMudWludGVnZXIoZm91cikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBQb3NpdGlvbi5jcmVhdGUob25lLCB0d28pLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSh0aHJlZSwgZm91cikgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQb3NpdGlvbi5pcyhvbmUpICYmIFBvc2l0aW9uLmlzKHR3bykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBvbmUsIGVuZDogdHdvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSNjcmVhdGUgY2FsbGVkIHdpdGggaW52YWxpZCBhcmd1bWVudHNbXCIgKyBvbmUgKyBcIiwgXCIgKyB0d28gKyBcIiwgXCIgKyB0aHJlZSArIFwiLCBcIiArIGZvdXIgKyBcIl1cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbUmFuZ2VdKCNSYW5nZSkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0xvY2F0aW9uXSgjTG9jYXRpb24pIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIExvY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2NhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbiBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGxvY2F0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgbG9jYXRpb24ncyByYW5nZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCByYW5nZSkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0xvY2F0aW9uXSgjTG9jYXRpb24pIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUudXJpKSk7XG4gICAgfVxuICAgIExvY2F0aW9uLmlzID0gaXM7XG59KShMb2NhdGlvbiB8fCAoTG9jYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgTG9jYXRpb25MaW5rIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0xvY2F0aW9uTGlua10oI0xvY2F0aW9uTGluaykgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpOiB0YXJnZXRVcmksIHRhcmdldFJhbmdlOiB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2U6IHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZTogb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0xvY2F0aW9uTGlua10oI0xvY2F0aW9uTGluaykgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSkpXG4gICAgICAgICAgICAmJiAoUmFuZ2UuaXMoY2FuZGlkYXRlLm9yaWdpblNlbGVjdGlvblJhbmdlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLm9yaWdpblNlbGVjdGlvblJhbmdlKSk7XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5pcyA9IGlzO1xufSkoTG9jYXRpb25MaW5rIHx8IChMb2NhdGlvbkxpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbQ29sb3JdKCNDb2xvcikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3I7XG4oZnVuY3Rpb24gKENvbG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvciBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVkOiByZWQsXG4gICAgICAgICAgICBncmVlbjogZ3JlZW4sXG4gICAgICAgICAgICBibHVlOiBibHVlLFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtDb2xvcl0oI0NvbG9yKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLnJlZCwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ncmVlbiwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmFscGhhLCAwLCAxKTtcbiAgICB9XG4gICAgQ29sb3IuaXMgPSBpcztcbn0pKENvbG9yIHx8IChDb2xvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2xvckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBjb2xvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBDb2xvci5pcyhjYW5kaWRhdGUuY29sb3IpO1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmlzID0gaXM7XG59KShDb2xvckluZm9ybWF0aW9uIHx8IChDb2xvckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0NvbG9yUHJlc2VudGF0aW9uXSgjQ29sb3JQcmVzZW50YXRpb24pIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvbG9yUHJlc2VudGF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgIHRleHRFZGl0OiB0ZXh0RWRpdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUZXh0RWRpdHM6IGFkZGl0aW9uYWxUZXh0RWRpdHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbG9ySW5mb3JtYXRpb25dKCNDb2xvckluZm9ybWF0aW9uKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRleHRFZGl0KSB8fCBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uaXMgPSBpcztcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEVudW0gb2Yga25vd24gcmFuZ2Uga2luZHNcbiAqL1xuZXhwb3J0IHZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZFtcIkNvbW1lbnRcIl0gPSBcImNvbW1lbnRcIjtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGltcG9ydHMgb3IgaW5jbHVkZXNcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kW1wiSW1wb3J0c1wiXSA9IFwiaW1wb3J0c1wiO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kW1wiUmVnaW9uXCJdID0gXCJyZWdpb25cIjtcbn0pKEZvbGRpbmdSYW5nZUtpbmQgfHwgKEZvbGRpbmdSYW5nZUtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZm9sZGluZyByYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtGb2xkaW5nUmFuZ2VdKCNGb2xkaW5nUmFuZ2UpIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0ZvbGRpbmdSYW5nZV0oI0ZvbGRpbmdSYW5nZSkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0RpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb25dKCNEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbl0oI0RpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24pIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzID0gaXM7XG59KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMncyBzZXZlcml0eS5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXZlcml0eSkge1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yID0gMTtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgd2FybmluZy5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyA9IDI7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb24gPSAzO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSBoaW50LlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5IaW50ID0gNDtcbn0pKERpYWdub3N0aWNTZXZlcml0eSB8fCAoRGlhZ25vc3RpY1NldmVyaXR5ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgdGFncy5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbmV4cG9ydCB2YXIgRGlhZ25vc3RpY1RhZztcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1RhZykge1xuICAgIC8qKlxuICAgICAqIFVudXNlZCBvciB1bm5lY2Vzc2FyeSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXIgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBmYWRlZCBvdXQgaW5zdGVhZCBvZiBoYXZpbmdcbiAgICAgKiBhbiBlcnJvciBzcXVpZ2dsZS5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLlVubmVjZXNzYXJ5ID0gMTtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG9yIG9ic29sZXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlcmVkIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgc3RyaWtlIHRocm91Z2guXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkID0gMjtcbn0pKERpYWdub3N0aWNUYWcgfHwgKERpYWdub3N0aWNUYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZURlc2NyaXB0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGRlc2NyaXB0aW9ucyBmb3IgZGlhZ25vc3RpYyBjb2Rlcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgQ29kZURlc2NyaXB0aW9uO1xuKGZ1bmN0aW9uIChDb2RlRGVzY3JpcHRpb24pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogW0RpYWdub3N0aWNdKCNEaWFnbm9zdGljKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgc291cmNlLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlLCBtZXNzYWdlOiBtZXNzYWdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNldmVyaXR5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29kZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHJlbGF0ZWRJbmZvcm1hdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxhdGVkSW5mb3JtYXRpb24gPSByZWxhdGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtEaWFnbm9zdGljXSgjRGlhZ25vc3RpYykgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtDb21tYW5kXSgjQ29tbWFuZCkgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWFuZCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0aXRsZTogdGl0bGUsIGNvbW1hbmQ6IGNvbW1hbmQgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb21tYW5kLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvbW1hbmRdKCNDb21tYW5kKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG5leHBvcnQgdmFyIFRleHRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaXMgPSBpcztcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XG5leHBvcnQgdmFyIENoYW5nZUFubm90YXRpb247XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIG5lZWRzQ29uZmlybWF0aW9uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKG5lZWRzQ29uZmlybWF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5uZWVkc0NvbmZpcm1hdGlvbiA9IG5lZWRzQ29uZmlybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgJiZcbiAgICAgICAgICAgIChJcy5ib29sZWFuKGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbikgfHwgY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uIHx8IChDaGFuZ2VBbm5vdGF0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI7XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGNhbmRpZGF0ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSB7fSkpO1xuZXhwb3J0IHZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJywgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmRlbCA9IGRlbDtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LCBlZGl0czogZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG5leHBvcnQgdmFyIENyZWF0ZUZpbGU7XG4oZnVuY3Rpb24gKENyZWF0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2NyZWF0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIENyZWF0ZUZpbGUuaXMgPSBpcztcbn0pKENyZWF0ZUZpbGUgfHwgKENyZWF0ZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBSZW5hbWVGaWxlO1xuKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpOiBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLnJlY3Vyc2l2ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEZWxldGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdkZWxldGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBEZWxldGVGaWxlLmlzID0gaXM7XG59KShEZWxldGVGaWxlIHx8IChEZWxldGVGaWxlID0ge30pKTtcbmV4cG9ydCB2YXIgV29ya3NwYWNlRWRpdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRWRpdCkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGFuZ2VzICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuc3RyaW5nKGNoYW5nZS5raW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlRmlsZS5pcyhjaGFuZ2UpIHx8IFJlbmFtZUZpbGUuaXMoY2hhbmdlKSB8fCBEZWxldGVGaWxlLmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gICAgV29ya3NwYWNlRWRpdC5pcyA9IGlzO1xufSkoV29ya3NwYWNlRWRpdCB8fCAoV29ya3NwYWNlRWRpdCA9IHt9KSk7XG52YXIgVGV4dEVkaXRDaGFuZ2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgY2hhbmdlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZUFubm90YXRpb25zID0gY2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgdmFyIGVkaXQ7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LmRlbChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlZGl0KSB7XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0cztcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWRpdHMuc3BsaWNlKDAsIHRoaXMuZWRpdHMubGVuZ3RoKTtcbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHQgZWRpdCBjaGFuZ2UgaXMgbm90IGNvbmZpZ3VyZWQgdG8gbWFuYWdlIGNoYW5nZSBhbm5vdGF0aW9ucy5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXh0RWRpdENoYW5nZUltcGw7XG59KCkpO1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzc1xuICovXG52YXIgQ2hhbmdlQW5ub3RhdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlQW5ub3RhdGlvbnMoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IGFubm90YXRpb25zO1xuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25zLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubWFuYWdlID0gZnVuY3Rpb24gKGlkT3JBbm5vdGF0aW9uLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGlkT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklkIFwiICsgaWQgKyBcIiBpcyBhbHJlYWR5IGluIHVzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgXCIgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBXb3Jrc3BhY2VDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XG4gICAgICAgICAgICBpZiAod29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCBfdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSB0ZXh0RWRpdENoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod29ya3NwYWNlRWRpdC5jaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLCBcImVkaXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBbV29ya3NwYWNlRWRpdF0oI1dvcmtzcGFjZUVkaXQpIGxpdGVyYWxcbiAgICAgICAgICogdXNlIHRvIGJlIHJldHVybmVkIGZyb20gYSB3b3Jrc3BhY2UgZWRpdCBvcGVyYXRpb24gbGlrZSByZW5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93b3Jrc3BhY2VFZGl0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5nZXRUZXh0RWRpdENoYW5nZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnQgPSB7IHVyaToga2V5LnVyaSwgdmVyc2lvbjoga2V5LnZlcnNpb24gfTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0RG9jdW1lbnRFZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHRleHREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHM6IGVkaXRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKHRleHREb2N1bWVudEVkaXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIHRoaXMuX2NoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3Igbm9ybWFsIHRleHQgZWRpdCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWRpdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSA9IGVkaXRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5pbml0RG9jdW1lbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgPSBuZXcgQ2hhbmdlQW5ub3RhdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuaW5pdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmNyZWF0ZUZpbGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBDcmVhdGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBDcmVhdGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUucmVuYW1lRmlsZSA9IGZ1bmN0aW9uIChvbGRVcmksIG5ld1VyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5kZWxldGVGaWxlID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYXRpb247XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gRGVsZXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gRGVsZXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gV29ya3NwYWNlQ2hhbmdlO1xufSgpKTtcbmV4cG9ydCB7IFdvcmtzcGFjZUNoYW5nZSB9O1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVGV4dERvY3VtZW50SWRlbnRpZmllcikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVGV4dERvY3VtZW50SWRlbnRpZmllcikgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaTogdXJpLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG4gICAgfVxuICAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcl0oI1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJdKCNPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyXSgjT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbVGV4dERvY3VtZW50SXRlbV0oI1RleHREb2N1bWVudEl0ZW0pIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudEl0ZW07XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudEl0ZW0gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCwgdmVyc2lvbjogdmVyc2lvbiwgdGV4dDogdGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW1RleHREb2N1bWVudEl0ZW1dKCNUZXh0RG9jdW1lbnRJdGVtKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG5leHBvcnQgdmFyIE1hcmt1cEtpbmQ7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0IGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5QbGFpblRleHQgPSAncGxhaW50ZXh0JztcbiAgICAvKipcbiAgICAgKiBNYXJrZG93biBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuTWFya2Rvd24gPSAnbWFya2Rvd24nO1xufSkoTWFya3VwS2luZCB8fCAoTWFya3VwS2luZCA9IHt9KSk7XG4oZnVuY3Rpb24gKE1hcmt1cEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWx1ZSBvZiB0aGUgW01hcmt1cEtpbmRdKCNNYXJrdXBLaW5kKSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya3VwQ29udGVudDtcbihmdW5jdGlvbiAoTWFya3VwQ29udGVudCkge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUgW01hcmt1cENvbnRlbnRdKCNNYXJrdXBDb250ZW50KSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xuZXhwb3J0IHZhciBJbnNlcnRUZXh0Rm9ybWF0O1xuKGZ1bmN0aW9uIChJbnNlcnRUZXh0Rm9ybWF0KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgcGxhaW4gc3RyaW5nLlxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0ID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBzbmlwcGV0LlxuICAgICAqXG4gICAgICogQSBzbmlwcGV0IGNhbiBkZWZpbmUgdGFiIHN0b3BzIGFuZCBwbGFjZWhvbGRlcnMgd2l0aCBgJDFgLCBgJDJgXG4gICAgICogYW5kIGAkezM6Zm9vfWAuIGAkMGAgZGVmaW5lcyB0aGUgZmluYWwgdGFiIHN0b3AsIGl0IGRlZmF1bHRzIHRvXG4gICAgICogdGhlIGVuZCBvZiB0aGUgc25pcHBldC4gUGxhY2Vob2xkZXJzIHdpdGggZXF1YWwgaWRlbnRpZmllcnMgYXJlIGxpbmtlZCxcbiAgICAgKiB0aGF0IGlzIHR5cGluZyBpbiBvbmUgd2lsbCB1cGRhdGUgb3RoZXJzIHRvby5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvOiBodHRwczovL21pY3Jvc29mdC5naXRodWIuaW8vbGFuZ3VhZ2Utc2VydmVyLXByb3RvY29sL3NwZWNpZmljYXRpb25zL3NwZWNpZmljYXRpb24tY3VycmVudC8jc25pcHBldF9zeW50YXhcbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQgPSAyO1xufSkoSW5zZXJ0VGV4dEZvcm1hdCB8fCAoSW5zZXJ0VGV4dEZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIENvbXBsZXRpb24gaXRlbSB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBjb21wbGV0aW9uXG4gKiBpdGVtLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbSW5zZXJ0UmVwbGFjZUVkaXRdKCNJbnNlcnRSZXBsYWNlRWRpdCkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbDogbGFiZWwgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW0uY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkl0ZW0gfHwgKENvbXBsZXRpb25JdGVtID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25MaXN0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGxpc3RzLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uTGlzdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBjb21wbGV0aW9uIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSBbTWFya2VkU3RyaW5nXSgjTWFya2VkU3RyaW5nKSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcbmV4cG9ydCB2YXIgSG92ZXI7XG4oZnVuY3Rpb24gKEhvdmVyKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSBbSG92ZXJdKCNIb3ZlcikgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbUGFyYW1ldGVySW5mb3JtYXRpb25dKCNQYXJhbWV0ZXJJbmZvcm1hdGlvbikgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtTaWduYXR1cmVJbmZvcm1hdGlvbl0oI1NpZ25hdHVyZUluZm9ybWF0aW9uKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU2lnbmF0dXJlSW5mb3JtYXRpb24gfHwgKFNpZ25hdHVyZUluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgdGV4dHVhbCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5UZXh0ID0gMTtcbiAgICAvKipcbiAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlJlYWQgPSAyO1xuICAgIC8qKlxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLldyaXRlID0gMztcbn0pKERvY3VtZW50SGlnaGxpZ2h0S2luZCB8fCAoRG9jdW1lbnRIaWdobGlnaHRLaW5kID0ge30pKTtcbi8qKlxuICogRG9jdW1lbnRIaWdobGlnaHQgbmFtZXNwYWNlIHRvIHByb3ZpZGUgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtEb2N1bWVudEhpZ2hsaWdodF0oI0RvY3VtZW50SGlnaGxpZ2h0KSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEb2N1bWVudEhpZ2hsaWdodCBvYmplY3QuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0aGUgaGlnaGxpZ2h0IGFwcGxpZXMgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICBpZiAoSXMubnVtYmVyKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRIaWdobGlnaHQuY3JlYXRlID0gY3JlYXRlO1xufSkoRG9jdW1lbnRIaWdobGlnaHQgfHwgKERvY3VtZW50SGlnaGxpZ2h0ID0ge30pKTtcbi8qKlxuICogQSBzeW1ib2wga2luZC5cbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kO1xuKGZ1bmN0aW9uIChTeW1ib2xLaW5kKSB7XG4gICAgU3ltYm9sS2luZC5GaWxlID0gMTtcbiAgICBTeW1ib2xLaW5kLk1vZHVsZSA9IDI7XG4gICAgU3ltYm9sS2luZC5OYW1lc3BhY2UgPSAzO1xuICAgIFN5bWJvbEtpbmQuUGFja2FnZSA9IDQ7XG4gICAgU3ltYm9sS2luZC5DbGFzcyA9IDU7XG4gICAgU3ltYm9sS2luZC5NZXRob2QgPSA2O1xuICAgIFN5bWJvbEtpbmQuUHJvcGVydHkgPSA3O1xuICAgIFN5bWJvbEtpbmQuRmllbGQgPSA4O1xuICAgIFN5bWJvbEtpbmQuQ29uc3RydWN0b3IgPSA5O1xuICAgIFN5bWJvbEtpbmQuRW51bSA9IDEwO1xuICAgIFN5bWJvbEtpbmQuSW50ZXJmYWNlID0gMTE7XG4gICAgU3ltYm9sS2luZC5GdW5jdGlvbiA9IDEyO1xuICAgIFN5bWJvbEtpbmQuVmFyaWFibGUgPSAxMztcbiAgICBTeW1ib2xLaW5kLkNvbnN0YW50ID0gMTQ7XG4gICAgU3ltYm9sS2luZC5TdHJpbmcgPSAxNTtcbiAgICBTeW1ib2xLaW5kLk51bWJlciA9IDE2O1xuICAgIFN5bWJvbEtpbmQuQm9vbGVhbiA9IDE3O1xuICAgIFN5bWJvbEtpbmQuQXJyYXkgPSAxODtcbiAgICBTeW1ib2xLaW5kLk9iamVjdCA9IDE5O1xuICAgIFN5bWJvbEtpbmQuS2V5ID0gMjA7XG4gICAgU3ltYm9sS2luZC5OdWxsID0gMjE7XG4gICAgU3ltYm9sS2luZC5FbnVtTWVtYmVyID0gMjI7XG4gICAgU3ltYm9sS2luZC5TdHJ1Y3QgPSAyMztcbiAgICBTeW1ib2xLaW5kLkV2ZW50ID0gMjQ7XG4gICAgU3ltYm9sS2luZC5PcGVyYXRvciA9IDI1O1xuICAgIFN5bWJvbEtpbmQuVHlwZVBhcmFtZXRlciA9IDI2O1xufSkoU3ltYm9sS2luZCB8fCAoU3ltYm9sS2luZCA9IHt9KSk7XG4vKipcbiAqIFN5bWJvbCB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBzeW1ib2wuXG4gKiBAc2luY2UgMy4xNlxuICovXG5leHBvcnQgdmFyIFN5bWJvbFRhZztcbihmdW5jdGlvbiAoU3ltYm9sVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc3ltYm9sIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBTeW1ib2xUYWcuRGVwcmVjYXRlZCA9IDE7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG5leHBvcnQgdmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLCBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sIGNvbnRhaW5pbmcgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwga2luZCwgcmFuZ2UsIHVyaSwgY29udGFpbmVyTmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICBsb2NhdGlvbjogeyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTeW1ib2xJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTeW1ib2xJbmZvcm1hdGlvbiB8fCAoU3ltYm9sSW5mb3JtYXRpb24gPSB7fSkpO1xuZXhwb3J0IHZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRG9jdW1lbnRTeW1ib2xdKCNEb2N1bWVudFN5bWJvbCkgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmtpbmQpICYmXG4gICAgICAgICAgICBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5zZWxlY3Rpb25SYW5nZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXByZWNhdGVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuZGVwcmVjYXRlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuY2hpbGRyZW4pKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS50YWdzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUudGFncykpO1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5pcyA9IGlzO1xufSkoRG9jdW1lbnRTeW1ib2wgfHwgKERvY3VtZW50U3ltYm9sID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBjb2RlIGFjdGlvbiBraW5kc1xuICovXG5leHBvcnQgdmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlQWN0aW9uQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtDb2RlQWN0aW9uQ29udGV4dF0oI0NvZGVBY3Rpb25Db250ZXh0KSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlQWN0aW9uQ29udGV4dDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbkNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVBY3Rpb25Db250ZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IGRpYWdub3N0aWNzOiBkaWFnbm9zdGljcyB9O1xuICAgICAgICBpZiAob25seSAhPT0gdW5kZWZpbmVkICYmIG9ubHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vbmx5ID0gb25seTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIFtDb2RlQWN0aW9uQ29udGV4dF0oI0NvZGVBY3Rpb25Db250ZXh0KSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSAmJiAoY2FuZGlkYXRlLm9ubHkgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5vbmx5LCBJcy5zdHJpbmcpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbkNvbnRleHQuaXMgPSBpcztcbn0pKENvZGVBY3Rpb25Db250ZXh0IHx8IChDb2RlQWN0aW9uQ29udGV4dCA9IHt9KSk7XG5leHBvcnQgdmFyIENvZGVBY3Rpb247XG4oZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGtpbmRPckNvbW1hbmRPckVkaXQsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlIH07XG4gICAgICAgIHZhciBjaGVja0tpbmQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGtpbmRPckNvbW1hbmRPckVkaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGVja0tpbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDb21tYW5kLmlzKGtpbmRPckNvbW1hbmRPckVkaXQpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29tbWFuZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZWRpdCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrS2luZCAmJiBraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50aXRsZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGlhZ25vc3RpY3MgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcykpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmtpbmQgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ICE9PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmNvbW1hbmQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzUHJlZmVycmVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCA9PT0gdW5kZWZpbmVkIHx8IFdvcmtzcGFjZUVkaXQuaXMoY2FuZGlkYXRlLmVkaXQpKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbiB8fCAoQ29kZUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlTGVucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIFtDb2RlTGVuc10oI0NvZGVMZW5zKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVMZW5zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUgW0NvZGVMZW5zXSgjQ29kZUxlbnMpIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIENvZGVMZW5zLmlzID0gaXM7XG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbRm9ybWF0dGluZ09wdGlvbnNdKCNGb3JtYXR0aW5nT3B0aW9ucykgbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZTogdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzOiBpbnNlcnRTcGFjZXMgfTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRm9ybWF0dGluZ09wdGlvbnNdKCNGb3JtYXR0aW5nT3B0aW9ucykgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiBbRG9jdW1lbnRMaW5rXSgjRG9jdW1lbnRMaW5rKSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudExpbms7XG4oZnVuY3Rpb24gKERvY3VtZW50TGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRG9jdW1lbnRMaW5rIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0YXJnZXQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0YXJnZXQ6IHRhcmdldCwgZGF0YTogZGF0YSB9O1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbRG9jdW1lbnRMaW5rXSgjRG9jdW1lbnRMaW5rKSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGFyZ2V0KSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldCkpO1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuaXMgPSBpcztcbn0pKERvY3VtZW50TGluayB8fCAoRG9jdW1lbnRMaW5rID0ge30pKTtcbi8qKlxuICogVGhlIFNlbGVjdGlvblJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gd29yayB3aXRoXG4gKiBTZWxlY3Rpb25SYW5nZSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHBhcmVudDogcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChjYW5kaWRhdGUucGFyZW50ID09PSB1bmRlZmluZWQgfHwgU2VsZWN0aW9uUmFuZ2UuaXMoY2FuZGlkYXRlLnBhcmVudCkpO1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5pcyA9IGlzO1xufSkoU2VsZWN0aW9uUmFuZ2UgfHwgKFNlbGVjdGlvblJhbmdlID0ge30pKTtcbmV4cG9ydCB2YXIgRU9MID0gWydcXG4nLCAnXFxyXFxuJywgJ1xcciddO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCAgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSBbSVRleHREb2N1bWVudF0oI0lUZXh0RG9jdW1lbnQpIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmxhbmd1YWdlSWQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lQ291bnQpXG4gICAgICAgICAgICAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5nZXRUZXh0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5wb3NpdGlvbkF0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vZmZzZXRBdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIC8vIHNvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB2YXIgbGVmdElkeCA9IDA7XG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgSXM7XG4oZnVuY3Rpb24gKElzKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG4iLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4ndXNlIHN0cmljdCc7XG52YXIgRnVsbFRleHREb2N1bWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwidXJpXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUsIFwibGFuZ3VhZ2VJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgY2hhbmdlc18xID0gY2hhbmdlczsgX2kgPCBjaGFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc18xW19pXTtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZShjaGFuZ2UucmFuZ2UpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnQubGluZSwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZExpbmUgPSBNYXRoLm1heChyYW5nZS5lbmQubGluZSwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5fbGluZU9mZnNldHM7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlLmFwcGx5KGxpbmVPZmZzZXRzLCBbc3RhcnRMaW5lICsgMSwgZW5kTGluZSAtIHN0YXJ0TGluZV0uY29uY2F0KGFkZGVkTGluZU9mZnNldHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYXZvaWQgdG9vIG1hbnkgYXJndW1lbnRzIGZvciBzcGxpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cy5zbGljZSgwLCBzdGFydExpbmUgKyAxKS5jb25jYXQoYWRkZWRMaW5lT2Zmc2V0cywgbGluZU9mZnNldHMuc2xpY2UoZW5kTGluZSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZSArIDEgKyBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCwgbGVuID0gbGluZU9mZnNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzW2ldID0gbGluZU9mZnNldHNbaV0gKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRnVsbFRleHREb2N1bWVudC5pc0Z1bGwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjaGFuZ2UudGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFuZ2UgZXZlbnQgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUucG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogMCwgY2hhcmFjdGVyOiBvZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5wcm90b3R5cGUub2Zmc2V0QXQgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgdmFyIG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsaW5lQ291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpbmVPZmZzZXRzKCkubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIH07XG4gICAgRnVsbFRleHREb2N1bWVudC5pc0Z1bGwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bGxUZXh0RG9jdW1lbnQ7XG59KCkpO1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkICBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyBpbml0aWFsIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgVGV4dERvY3VtZW50IGJ5IG1vZGlmaW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0RG9jdW1lbnQuIE5vdGU6IFRoYXQncyB0aGUgc2FtZSBkb2N1bWVudCBpbnN0YW5jZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKGRvY3VtZW50LCBjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEZ1bGxUZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dERvY3VtZW50LnVwZGF0ZTogZG9jdW1lbnQgbXVzdCBiZSBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQudXBkYXRlID0gdXBkYXRlO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMubWFwKGdldFdlbGxmb3JtZWRFZGl0KSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZE9mZnNldCA9IDA7XG4gICAgICAgIHZhciBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvcnRlZEVkaXRzXzEgPSBzb3J0ZWRFZGl0czsgX2kgPCBzb3J0ZWRFZGl0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGUgPSBzb3J0ZWRFZGl0c18xW19pXTtcbiAgICAgICAgICAgIHZhciBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0IDwgbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydE9mZnNldCA+IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHJpbmcobGFzdE1vZGlmaWVkT2Zmc2V0LCBzdGFydE9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHNwYW5zLmpvaW4oJycpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG5mdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIC8vIHNvcnRlZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgdmFyIGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIHZhciByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgdmFyIGxlZnRJZHggPSAwO1xuICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lT2Zmc2V0cyh0ZXh0LCBpc0F0TGluZVN0YXJ0LCB0ZXh0T2Zmc2V0KSB7XG4gICAgaWYgKHRleHRPZmZzZXQgPT09IHZvaWQgMCkgeyB0ZXh0T2Zmc2V0ID0gMDsgfVxuICAgIHZhciByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDYXJyaWFnZVJldHVybiAqLyB8fCBjaCA9PT0gMTAgLyogTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgLyogQ2FycmlhZ2VSZXR1cm4gKi8gJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCAvKiBMaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRPZmZzZXQgKyBpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRSYW5nZShyYW5nZSkge1xuICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIHZhciByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgaWYgKHJhbmdlICE9PSB0ZXh0RWRpdC5yYW5nZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiB0ZXh0RWRpdC5uZXdUZXh0LCByYW5nZTogcmFuZ2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRFZGl0O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBSYW5nZSwgVGV4dEVkaXQsIENvbG9yLCBDb2xvckluZm9ybWF0aW9uLCBDb2xvclByZXNlbnRhdGlvbiwgRm9sZGluZ1JhbmdlLCBGb2xkaW5nUmFuZ2VLaW5kLCBNYXJrdXBLaW5kLCBTZWxlY3Rpb25SYW5nZSwgRGlhZ25vc3RpYywgRGlhZ25vc3RpY1NldmVyaXR5LCBDb21wbGV0aW9uSXRlbSwgQ29tcGxldGlvbkl0ZW1LaW5kLCBDb21wbGV0aW9uTGlzdCwgUG9zaXRpb24sIEluc2VydFRleHRGb3JtYXQsIE1hcmt1cENvbnRlbnQsIFN5bWJvbEluZm9ybWF0aW9uLCBTeW1ib2xLaW5kLCBEb2N1bWVudFN5bWJvbCwgTG9jYXRpb24sIEhvdmVyLCBNYXJrZWRTdHJpbmcgfSBmcm9tICcuLy4uL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcy9tYWluLmpzJztcbmltcG9ydCB7IFRleHREb2N1bWVudCB9IGZyb20gJy4vLi4vdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudC9saWIvZXNtL21haW4uanMnO1xuZXhwb3J0IHsgVGV4dERvY3VtZW50LCBSYW5nZSwgVGV4dEVkaXQsIENvbG9yLCBDb2xvckluZm9ybWF0aW9uLCBDb2xvclByZXNlbnRhdGlvbiwgRm9sZGluZ1JhbmdlLCBGb2xkaW5nUmFuZ2VLaW5kLCBTZWxlY3Rpb25SYW5nZSwgRGlhZ25vc3RpYywgRGlhZ25vc3RpY1NldmVyaXR5LCBDb21wbGV0aW9uSXRlbSwgQ29tcGxldGlvbkl0ZW1LaW5kLCBDb21wbGV0aW9uTGlzdCwgUG9zaXRpb24sIEluc2VydFRleHRGb3JtYXQsIE1hcmt1cENvbnRlbnQsIE1hcmt1cEtpbmQsIFN5bWJvbEluZm9ybWF0aW9uLCBTeW1ib2xLaW5kLCBEb2N1bWVudFN5bWJvbCwgTG9jYXRpb24sIEhvdmVyLCBNYXJrZWRTdHJpbmcgfTtcbi8qKlxuICogRXJyb3IgY29kZXMgdXNlZCBieSBkaWFnbm9zdGljc1xuICovXG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlVuZGVmaW5lZFwiXSA9IDBdID0gXCJVbmRlZmluZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRW51bVZhbHVlTWlzbWF0Y2hcIl0gPSAxXSA9IFwiRW51bVZhbHVlTWlzbWF0Y2hcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRGVwcmVjYXRlZFwiXSA9IDJdID0gXCJEZXByZWNhdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIl0gPSAyNTddID0gXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiXSA9IDI1OF0gPSBcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIl0gPSAyNTldID0gXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSW52YWxpZFVuaWNvZGVcIl0gPSAyNjBdID0gXCJJbnZhbGlkVW5pY29kZVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyXCJdID0gMjYxXSA9IFwiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJJbnZhbGlkQ2hhcmFjdGVyXCJdID0gMjYyXSA9IFwiSW52YWxpZENoYXJhY3RlclwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQcm9wZXJ0eUV4cGVjdGVkXCJdID0gNTEzXSA9IFwiUHJvcGVydHlFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb21tYUV4cGVjdGVkXCJdID0gNTE0XSA9IFwiQ29tbWFFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb2xvbkV4cGVjdGVkXCJdID0gNTE1XSA9IFwiQ29sb25FeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJWYWx1ZUV4cGVjdGVkXCJdID0gNTE2XSA9IFwiVmFsdWVFeHBlY3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZFwiXSA9IDUxN10gPSBcIkNvbW1hT3JDbG9zZUJhY2tldEV4cGVjdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNvbW1hT3JDbG9zZUJyYWNlRXhwZWN0ZWRcIl0gPSA1MThdID0gXCJDb21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlRyYWlsaW5nQ29tbWFcIl0gPSA1MTldID0gXCJUcmFpbGluZ0NvbW1hXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkR1cGxpY2F0ZUtleVwiXSA9IDUyMF0gPSBcIkR1cGxpY2F0ZUtleVwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJDb21tZW50Tm90UGVybWl0dGVkXCJdID0gNTIxXSA9IFwiQ29tbWVudE5vdFBlcm1pdHRlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJTY2hlbWFSZXNvbHZlRXJyb3JcIl0gPSA3NjhdID0gXCJTY2hlbWFSZXNvbHZlRXJyb3JcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmV4cG9ydCB2YXIgQ2xpZW50Q2FwYWJpbGl0aWVzO1xuKGZ1bmN0aW9uIChDbGllbnRDYXBhYmlsaXRpZXMpIHtcbiAgICBDbGllbnRDYXBhYmlsaXRpZXMuTEFURVNUID0ge1xuICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGNvbXBsZXRpb246IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uSXRlbToge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbTWFya3VwS2luZC5NYXJrZG93biwgTWFya3VwS2luZC5QbGFpblRleHRdLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRDaGFyYWN0ZXJzU3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KShDbGllbnRDYXBhYmlsaXRpZXMgfHwgKENsaWVudENhcGFiaWxpdGllcyA9IHt9KSk7XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxyXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXN1bHQgPSBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbWVzc2FnZS5yZXBsYWNlKC9cXHsoXFxkKylcXH0vZywgZnVuY3Rpb24gKG1hdGNoLCByZXN0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHJlc3RbMF07XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnc1tpbmRleF0gIT09ICd1bmRlZmluZWQnID8gYXJnc1tpbmRleF0gOiBtYXRjaDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gbG9jYWxpemUoa2V5LCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbG9hZE1lc3NhZ2VCdW5kbGUoZmlsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsaXplO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb25maWcob3B0KSB7XHJcbiAgICByZXR1cm4gbG9hZE1lc3NhZ2VCdW5kbGU7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuLy4uLy4uL2pzb25jLXBhcnNlci9tYWluLmpzJztcbmltcG9ydCB7IGlzTnVtYmVyLCBlcXVhbHMsIGlzQm9vbGVhbiwgaXNTdHJpbmcsIGlzRGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL29iamVjdHMuanMnO1xuaW1wb3J0IHsgZXh0ZW5kZWRSZWdFeHAgfSBmcm9tICcuLi91dGlscy9zdHJpbmdzLmpzJztcbmltcG9ydCB7IEVycm9yQ29kZSwgRGlhZ25vc3RpYywgRGlhZ25vc3RpY1NldmVyaXR5LCBSYW5nZSB9IGZyb20gJy4uL2pzb25MYW5ndWFnZVR5cGVzLmpzJztcbmltcG9ydCAqIGFzIG5scyBmcm9tICcuLy4uLy4uLy4uL2ZpbGxlcnMvdnNjb2RlLW5scy5qcyc7XG52YXIgbG9jYWxpemUgPSBubHMubG9hZE1lc3NhZ2VCdW5kbGUoKTtcbnZhciBmb3JtYXRzID0ge1xuICAgICdjb2xvci1oZXgnOiB7IGVycm9yTWVzc2FnZTogbG9jYWxpemUoJ2NvbG9ySGV4Rm9ybWF0V2FybmluZycsICdJbnZhbGlkIGNvbG9yIGZvcm1hdC4gVXNlICNSR0IsICNSR0JBLCAjUlJHR0JCIG9yICNSUkdHQkJBQS4nKSwgcGF0dGVybjogL14jKFswLTlBLUZhLWZdezMsNH18KFswLTlBLUZhLWZdezJ9KXszLDR9KSQvIH0sXG4gICAgJ2RhdGUtdGltZSc6IHsgZXJyb3JNZXNzYWdlOiBsb2NhbGl6ZSgnZGF0ZVRpbWVGb3JtYXRXYXJuaW5nJywgJ1N0cmluZyBpcyBub3QgYSBSRkMzMzM5IGRhdGUtdGltZS4nKSwgcGF0dGVybjogL14oXFxkezR9KS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXxbMTJdWzAtOV18M1swMV0pVChbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKFxcLlswLTldKyk/KFp8KFxcK3wtKShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSkpJC9pIH0sXG4gICAgJ2RhdGUnOiB7IGVycm9yTWVzc2FnZTogbG9jYWxpemUoJ2RhdGVGb3JtYXRXYXJuaW5nJywgJ1N0cmluZyBpcyBub3QgYSBSRkMzMzM5IGRhdGUuJyksIHBhdHRlcm46IC9eKFxcZHs0fSktKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEyXVswLTldfDNbMDFdKSQvaSB9LFxuICAgICd0aW1lJzogeyBlcnJvck1lc3NhZ2U6IGxvY2FsaXplKCd0aW1lRm9ybWF0V2FybmluZycsICdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSB0aW1lLicpLCBwYXR0ZXJuOiAvXihbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKFxcLlswLTldKyk/KFp8KFxcK3wtKShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSkpJC9pIH0sXG4gICAgJ2VtYWlsJzogeyBlcnJvck1lc3NhZ2U6IGxvY2FsaXplKCdlbWFpbEZvcm1hdFdhcm5pbmcnLCAnU3RyaW5nIGlzIG5vdCBhbiBlLW1haWwgYWRkcmVzcy4nKSwgcGF0dGVybjogL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC8gfVxufTtcbnZhciBBU1ROb2RlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU1ROb2RlSW1wbChwYXJlbnQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgeyBsZW5ndGggPSAwOyB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBU1ROb2RlSW1wbC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFTVE5vZGVJbXBsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICd0eXBlOiAnICsgdGhpcy50eXBlICsgJyAoJyArIHRoaXMub2Zmc2V0ICsgJy8nICsgdGhpcy5sZW5ndGggKyAnKScgKyAodGhpcy5wYXJlbnQgPyAnIHBhcmVudDogeycgKyB0aGlzLnBhcmVudC50b1N0cmluZygpICsgJ30nIDogJycpO1xuICAgIH07XG4gICAgcmV0dXJuIEFTVE5vZGVJbXBsO1xufSgpKTtcbmV4cG9ydCB7IEFTVE5vZGVJbXBsIH07XG52YXIgTnVsbEFTVE5vZGVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOdWxsQVNUTm9kZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVsbEFTVE5vZGVJbXBsKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgb2Zmc2V0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ251bGwnO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE51bGxBU1ROb2RlSW1wbDtcbn0oQVNUTm9kZUltcGwpKTtcbmV4cG9ydCB7IE51bGxBU1ROb2RlSW1wbCB9O1xudmFyIEJvb2xlYW5BU1ROb2RlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQm9vbGVhbkFTVE5vZGVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJvb2xlYW5BU1ROb2RlSW1wbChwYXJlbnQsIGJvb2xWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgb2Zmc2V0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ2Jvb2xlYW4nO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IGJvb2xWYWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbkFTVE5vZGVJbXBsO1xufShBU1ROb2RlSW1wbCkpO1xuZXhwb3J0IHsgQm9vbGVhbkFTVE5vZGVJbXBsIH07XG52YXIgQXJyYXlBU1ROb2RlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlBU1ROb2RlSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheUFTVE5vZGVJbXBsKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgb2Zmc2V0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ2FycmF5JztcbiAgICAgICAgX3RoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlBU1ROb2RlSW1wbC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5QVNUTm9kZUltcGw7XG59KEFTVE5vZGVJbXBsKSk7XG5leHBvcnQgeyBBcnJheUFTVE5vZGVJbXBsIH07XG52YXIgTnVtYmVyQVNUTm9kZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlckFTVE5vZGVJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bWJlckFTVE5vZGVJbXBsKHBhcmVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgb2Zmc2V0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gJ251bWJlcic7XG4gICAgICAgIF90aGlzLmlzSW50ZWdlciA9IHRydWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gTnVtYmVyLk5hTjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyQVNUTm9kZUltcGw7XG59KEFTVE5vZGVJbXBsKSk7XG5leHBvcnQgeyBOdW1iZXJBU1ROb2RlSW1wbCB9O1xudmFyIFN0cmluZ0FTVE5vZGVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJpbmdBU1ROb2RlSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJpbmdBU1ROb2RlSW1wbChwYXJlbnQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgb2Zmc2V0LCBsZW5ndGgpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgX3RoaXMudmFsdWUgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nQVNUTm9kZUltcGw7XG59KEFTVE5vZGVJbXBsKSk7XG5leHBvcnQgeyBTdHJpbmdBU1ROb2RlSW1wbCB9O1xudmFyIFByb3BlcnR5QVNUTm9kZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5QVNUTm9kZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvcGVydHlBU1ROb2RlSW1wbChwYXJlbnQsIG9mZnNldCwga2V5Tm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIG9mZnNldCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdwcm9wZXJ0eSc7XG4gICAgICAgIF90aGlzLmNvbG9uT2Zmc2V0ID0gLTE7XG4gICAgICAgIF90aGlzLmtleU5vZGUgPSBrZXlOb2RlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eUFTVE5vZGVJbXBsLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVOb2RlID8gW3RoaXMua2V5Tm9kZSwgdGhpcy52YWx1ZU5vZGVdIDogW3RoaXMua2V5Tm9kZV07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvcGVydHlBU1ROb2RlSW1wbDtcbn0oQVNUTm9kZUltcGwpKTtcbmV4cG9ydCB7IFByb3BlcnR5QVNUTm9kZUltcGwgfTtcbnZhciBPYmplY3RBU1ROb2RlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0QVNUTm9kZUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0QVNUTm9kZUltcGwocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCBvZmZzZXQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgX3RoaXMucHJvcGVydGllcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RBU1ROb2RlSW1wbC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0QVNUTm9kZUltcGw7XG59KEFTVE5vZGVJbXBsKSk7XG5leHBvcnQgeyBPYmplY3RBU1ROb2RlSW1wbCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGFzU2NoZW1hKHNjaGVtYSkge1xuICAgIGlmIChpc0Jvb2xlYW4oc2NoZW1hKSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hID8ge30gOiB7IFwibm90XCI6IHt9IH07XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG5leHBvcnQgdmFyIEVudW1NYXRjaDtcbihmdW5jdGlvbiAoRW51bU1hdGNoKSB7XG4gICAgRW51bU1hdGNoW0VudW1NYXRjaFtcIktleVwiXSA9IDBdID0gXCJLZXlcIjtcbiAgICBFbnVtTWF0Y2hbRW51bU1hdGNoW1wiRW51bVwiXSA9IDFdID0gXCJFbnVtXCI7XG59KShFbnVtTWF0Y2ggfHwgKEVudW1NYXRjaCA9IHt9KSk7XG52YXIgU2NoZW1hQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjaGVtYUNvbGxlY3Rvcihmb2N1c09mZnNldCwgZXhjbHVkZSkge1xuICAgICAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHZvaWQgMCkgeyBmb2N1c09mZnNldCA9IC0xOyB9XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgICAgdGhpcy5leGNsdWRlID0gZXhjbHVkZTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gW107XG4gICAgfVxuICAgIFNjaGVtYUNvbGxlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICB0aGlzLnNjaGVtYXMucHVzaChzY2hlbWEpO1xuICAgIH07XG4gICAgU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnNjaGVtYXMsIG90aGVyLnNjaGVtYXMpO1xuICAgIH07XG4gICAgU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5pbmNsdWRlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZvY3VzT2Zmc2V0ID09PSAtMSB8fCBjb250YWlucyhub2RlLCB0aGlzLmZvY3VzT2Zmc2V0KSkgJiYgKG5vZGUgIT09IHRoaXMuZXhjbHVkZSk7XG4gICAgfTtcbiAgICBTY2hlbWFDb2xsZWN0b3IucHJvdG90eXBlLm5ld1N1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWFDb2xsZWN0b3IoLTEsIHRoaXMuZXhjbHVkZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2NoZW1hQ29sbGVjdG9yO1xufSgpKTtcbnZhciBOb09wU2NoZW1hQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vT3BTY2hlbWFDb2xsZWN0b3IoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb09wU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZSwgXCJzY2hlbWFzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5vT3BTY2hlbWFDb2xsZWN0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzY2hlbWEpIHsgfTtcbiAgICBOb09wU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikgeyB9O1xuICAgIE5vT3BTY2hlbWFDb2xsZWN0b3IucHJvdG90eXBlLmluY2x1ZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICBOb09wU2NoZW1hQ29sbGVjdG9yLnByb3RvdHlwZS5uZXdTdWIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIE5vT3BTY2hlbWFDb2xsZWN0b3IuaW5zdGFuY2UgPSBuZXcgTm9PcFNjaGVtYUNvbGxlY3RvcigpO1xuICAgIHJldHVybiBOb09wU2NoZW1hQ29sbGVjdG9yO1xufSgpKTtcbnZhciBWYWxpZGF0aW9uUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHRoaXMucHJvYmxlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyA9IDA7XG4gICAgICAgIHRoaXMucHJpbWFyeVZhbHVlTWF0Y2hlcyA9IDA7XG4gICAgICAgIHRoaXMuZW51bVZhbHVlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbnVtVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBWYWxpZGF0aW9uUmVzdWx0LnByb3RvdHlwZS5oYXNQcm9ibGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wcm9ibGVtcy5sZW5ndGg7XG4gICAgfTtcbiAgICBWYWxpZGF0aW9uUmVzdWx0LnByb3RvdHlwZS5tZXJnZUFsbCA9IGZ1bmN0aW9uICh2YWxpZGF0aW9uUmVzdWx0cykge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbGlkYXRpb25SZXN1bHRzXzEgPSB2YWxpZGF0aW9uUmVzdWx0czsgX2kgPCB2YWxpZGF0aW9uUmVzdWx0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25SZXN1bHQgPSB2YWxpZGF0aW9uUmVzdWx0c18xW19pXTtcbiAgICAgICAgICAgIHRoaXMubWVyZ2UodmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZhbGlkYXRpb25SZXN1bHQucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgdGhpcy5wcm9ibGVtcyA9IHRoaXMucHJvYmxlbXMuY29uY2F0KHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMpO1xuICAgIH07XG4gICAgVmFsaWRhdGlvblJlc3VsdC5wcm90b3R5cGUubWVyZ2VFbnVtVmFsdWVzID0gZnVuY3Rpb24gKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVudW1WYWx1ZU1hdGNoICYmICF2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoICYmIHRoaXMuZW51bVZhbHVlcyAmJiB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW51bVZhbHVlcyA9IHRoaXMuZW51bVZhbHVlcy5jb25jYXQodmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnByb2JsZW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBsb2NhbGl6ZSgnZW51bVdhcm5pbmcnLCAnVmFsdWUgaXMgbm90IGFjY2VwdGVkLiBWYWxpZCB2YWx1ZXM6IHswfS4nLCB0aGlzLmVudW1WYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsgfSkuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBWYWxpZGF0aW9uUmVzdWx0LnByb3RvdHlwZS5tZXJnZVByb3BlcnR5TWF0Y2ggPSBmdW5jdGlvbiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHRoaXMubWVyZ2UocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzTWF0Y2hlcysrO1xuICAgICAgICBpZiAocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoIHx8ICFwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSAmJiBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMgJiYgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmFsaWRhdGlvblJlc3VsdC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgaGFzUHJvYmxlbXMgPSB0aGlzLmhhc1Byb2JsZW1zKCk7XG4gICAgICAgIGlmIChoYXNQcm9ibGVtcyAhPT0gb3RoZXIuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb2JsZW1zID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVudW1WYWx1ZU1hdGNoICE9PSBvdGhlci5lbnVtVmFsdWVNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmVudW1WYWx1ZU1hdGNoID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgIT09IG90aGVyLnByaW1hcnlWYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgLSBvdGhlci5wcmltYXJ5VmFsdWVNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgIT09IG90aGVyLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgLSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNNYXRjaGVzIC0gb3RoZXIucHJvcGVydGllc01hdGNoZXM7XG4gICAgfTtcbiAgICByZXR1cm4gVmFsaWRhdGlvblJlc3VsdDtcbn0oKSk7XG5leHBvcnQgeyBWYWxpZGF0aW9uUmVzdWx0IH07XG5leHBvcnQgZnVuY3Rpb24gbmV3SlNPTkRvY3VtZW50KHJvb3QsIGRpYWdub3N0aWNzKSB7XG4gICAgaWYgKGRpYWdub3N0aWNzID09PSB2b2lkIDApIHsgZGlhZ25vc3RpY3MgPSBbXTsgfVxuICAgIHJldHVybiBuZXcgSlNPTkRvY3VtZW50KHJvb3QsIGRpYWdub3N0aWNzLCBbXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVZhbHVlKG5vZGUpIHtcbiAgICByZXR1cm4gSnNvbi5nZXROb2RlVmFsdWUobm9kZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVBhdGgobm9kZSkge1xuICAgIHJldHVybiBKc29uLmdldE5vZGVQYXRoKG5vZGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zKG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpIHtcbiAgICBpZiAoaW5jbHVkZVJpZ2h0Qm91bmQgPT09IHZvaWQgMCkgeyBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG9mZnNldCA+PSBub2RlLm9mZnNldCAmJiBvZmZzZXQgPCAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkgfHwgaW5jbHVkZVJpZ2h0Qm91bmQgJiYgb2Zmc2V0ID09PSAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCk7XG59XG52YXIgSlNPTkRvY3VtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05Eb2N1bWVudChyb290LCBzeW50YXhFcnJvcnMsIGNvbW1lbnRzKSB7XG4gICAgICAgIGlmIChzeW50YXhFcnJvcnMgPT09IHZvaWQgMCkgeyBzeW50YXhFcnJvcnMgPSBbXTsgfVxuICAgICAgICBpZiAoY29tbWVudHMgPT09IHZvaWQgMCkgeyBjb21tZW50cyA9IFtdOyB9XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuc3ludGF4RXJyb3JzID0gc3ludGF4RXJyb3JzO1xuICAgICAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHM7XG4gICAgfVxuICAgIEpTT05Eb2N1bWVudC5wcm90b3R5cGUuZ2V0Tm9kZUZyb21PZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCkge1xuICAgICAgICBpZiAoaW5jbHVkZVJpZ2h0Qm91bmQgPT09IHZvaWQgMCkgeyBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBKc29uLmZpbmROb2RlQXRPZmZzZXQodGhpcy5yb290LCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSlNPTkRvY3VtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHZhciBkb1Zpc2l0XzEgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdG4gPSB2aXNpdG9yKG5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGN0bjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG4gPSBkb1Zpc2l0XzEoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdG47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9WaXNpdF8xKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAodGV4dERvY3VtZW50LCBzY2hlbWEsIHNldmVyaXR5KSB7XG4gICAgICAgIGlmIChzZXZlcml0eSA9PT0gdm9pZCAwKSB7IHNldmVyaXR5ID0gRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc7IH1cbiAgICAgICAgaWYgKHRoaXMucm9vdCAmJiBzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgIHZhbGlkYXRlKHRoaXMucm9vdCwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQocC5sb2NhdGlvbi5vZmZzZXQpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChwLmxvY2F0aW9uLm9mZnNldCArIHAubG9jYXRpb24ubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBwLm1lc3NhZ2UsIChfYSA9IHAuc2V2ZXJpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNldmVyaXR5LCBwLmNvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudC5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdTY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSwgZm9jdXNPZmZzZXQsIGV4Y2x1ZGUpIHtcbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID09PSB2b2lkIDApIHsgZm9jdXNPZmZzZXQgPSAtMTsgfVxuICAgICAgICB2YXIgbWF0Y2hpbmdTY2hlbWFzID0gbmV3IFNjaGVtYUNvbGxlY3Rvcihmb2N1c09mZnNldCwgZXhjbHVkZSk7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgJiYgc2NoZW1hKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZSh0aGlzLnJvb3QsIHNjaGVtYSwgbmV3IFZhbGlkYXRpb25SZXN1bHQoKSwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdTY2hlbWFzLnNjaGVtYXM7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkRvY3VtZW50O1xufSgpKTtcbmV4cG9ydCB7IEpTT05Eb2N1bWVudCB9O1xuZnVuY3Rpb24gdmFsaWRhdGUobiwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICBpZiAoIW4gfHwgIW1hdGNoaW5nU2NoZW1hcy5pbmNsdWRlKG4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBuO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBfdmFsaWRhdGVPYmplY3ROb2RlKG5vZGUsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICBfdmFsaWRhdGVBcnJheU5vZGUobm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBfdmFsaWRhdGVTdHJpbmdOb2RlKG5vZGUsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgX3ZhbGlkYXRlTnVtYmVyTm9kZShub2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHJvcGVydHknOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlKG5vZGUudmFsdWVOb2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgfVxuICAgIF92YWxpZGF0ZU5vZGUoKTtcbiAgICBtYXRjaGluZ1NjaGVtYXMuYWRkKHsgbm9kZTogbm9kZSwgc2NoZW1hOiBzY2hlbWEgfSk7XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlTm9kZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hlc1R5cGUodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gdHlwZSB8fCAodHlwZSA9PT0gJ2ludGVnZXInICYmIG5vZGUudHlwZSA9PT0gJ251bWJlcicgJiYgbm9kZS5pc0ludGVnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEudHlwZS5zb21lKG1hdGNoZXNUeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgndHlwZUFycmF5TWlzbWF0Y2hXYXJuaW5nJywgJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBvbmUgb2YgezB9LicsIHNjaGVtYS50eXBlLmpvaW4oJywgJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlc1R5cGUoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCd0eXBlTWlzbWF0Y2hXYXJuaW5nJywgJ0luY29ycmVjdCB0eXBlLiBFeHBlY3RlZCBcInswfVwiLicsIHNjaGVtYS50eXBlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzY2hlbWEuYWxsT2Y7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlNjaGVtYVJlZiA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBhc1NjaGVtYShzdWJTY2hlbWFSZWYpLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub3RTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEubm90KTtcbiAgICAgICAgaWYgKG5vdFNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIHN1YlZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgdmFyIHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUsIG5vdFNjaGVtYSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIGlmICghc3ViVmFsaWRhdGlvblJlc3VsdC5oYXNQcm9ibGVtcygpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnbm90U2NoZW1hV2FybmluZycsIFwiTWF0Y2hlcyBhIHNjaGVtYSB0aGF0IGlzIG5vdCBhbGxvd2VkLlwiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHN1Yk1hdGNoaW5nU2NoZW1hcy5zY2hlbWFzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBtcyA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtcy5pbnZlcnRlZCA9ICFtcy5pbnZlcnRlZDtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMuYWRkKG1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVzdEFsdGVybmF0aXZlcyA9IGZ1bmN0aW9uIChhbHRlcm5hdGl2ZXMsIG1heE9uZU1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGJlc3QgbWF0Y2ggdGhhdCBpcyB1c2VkIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYWx0ZXJuYXRpdmVzXzEgPSBhbHRlcm5hdGl2ZXM7IF9pIDwgYWx0ZXJuYXRpdmVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlNjaGVtYVJlZiA9IGFsdGVybmF0aXZlc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgc3ViU2NoZW1hID0gYXNTY2hlbWEoc3ViU2NoZW1hUmVmKTtcbiAgICAgICAgICAgICAgICB2YXIgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBzdWJTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHN1YlNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmVzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHsgc2NoZW1hOiBzdWJTY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQ6IHN1YlZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hczogc3ViTWF0Y2hpbmdTY2hlbWFzIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heE9uZU1hdGNoICYmICFzdWJWYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkgJiYgIWJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGVycm9ycywgYm90aCBhcmUgZXF1YWxseSBnb29kIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICs9IHN1YlZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXJlUmVzdWx0ID0gc3ViVmFsaWRhdGlvblJlc3VsdC5jb21wYXJlKGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlUmVzdWx0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91ciBub2RlIGlzIHRoZSBiZXN0IG1hdGNoaW5nIHNvIGZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHsgc2NoZW1hOiBzdWJTY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQ6IHN1YlZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hczogc3ViTWF0Y2hpbmdTY2hlbWFzIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wYXJlUmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUncyBhbHJlYWR5IGEgYmVzdCBtYXRjaGluZyBidXQgd2UgYXJlIGFzIGdvb2RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2gubWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQubWVyZ2VFbnVtVmFsdWVzKHN1YlZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSAmJiBtYXhPbmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogMSB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnb25lT2ZXYXJuaW5nJywgXCJNYXRjaGVzIG11bHRpcGxlIHNjaGVtYXMgd2hlbiBvbmx5IG9uZSBtdXN0IHZhbGlkYXRlLlwiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2UoYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMgKz0gYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXM7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzICs9IGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXM7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB7XG4gICAgICAgICAgICB0ZXN0QWx0ZXJuYXRpdmVzKHNjaGVtYS5hbnlPZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcbiAgICAgICAgICAgIHRlc3RBbHRlcm5hdGl2ZXMoc2NoZW1hLm9uZU9mLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVzdEJyYW5jaCA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBzdWJWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgIHZhciBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBhc1NjaGVtYShzY2hlbWEpLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZShzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMgKz0gc3ViVmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcztcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyArPSBzdWJWYWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXM7XG4gICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRlc3RDb25kaXRpb24gPSBmdW5jdGlvbiAoaWZTY2hlbWEsIHRoZW5TY2hlbWEsIGVsc2VTY2hlbWEpIHtcbiAgICAgICAgICAgIHZhciBzdWJTY2hlbWEgPSBhc1NjaGVtYShpZlNjaGVtYSk7XG4gICAgICAgICAgICB2YXIgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICB2YXIgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgdmFsaWRhdGUobm9kZSwgc3ViU2NoZW1hLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKHN1Yk1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICBpZiAoIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGVuU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RCcmFuY2godGhlblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxzZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHRlc3RCcmFuY2goZWxzZVNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpZlNjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYS5pZik7XG4gICAgICAgIGlmIChpZlNjaGVtYSkge1xuICAgICAgICAgICAgdGVzdENvbmRpdGlvbihpZlNjaGVtYSwgYXNTY2hlbWEoc2NoZW1hLnRoZW4pLCBhc1NjaGVtYShzY2hlbWEuZWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIHZhciBlbnVtVmFsdWVNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IHNjaGVtYS5lbnVtOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gX2VbX2RdO1xuICAgICAgICAgICAgICAgIGlmIChlcXVhbHModmFsLCBlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyA9IHNjaGVtYS5lbnVtO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCA9IGVudW1WYWx1ZU1hdGNoO1xuICAgICAgICAgICAgaWYgKCFlbnVtVmFsdWVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkVudW1WYWx1ZU1pc21hdGNoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCdlbnVtV2FybmluZycsICdWYWx1ZSBpcyBub3QgYWNjZXB0ZWQuIFZhbGlkIHZhbHVlczogezB9LicsIHNjaGVtYS5lbnVtLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7IH0pLmpvaW4oJywgJykpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZ2V0Tm9kZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbHModmFsLCBzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBFcnJvckNvZGUuRW51bVZhbHVlTWlzbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgbG9jYWxpemUoJ2NvbnN0V2FybmluZycsICdWYWx1ZSBtdXN0IGJlIHswfS4nLCBKU09OLnN0cmluZ2lmeShzY2hlbWEuY29uc3QpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzID0gW3NjaGVtYS5jb25zdF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5kZXByZWNhdGlvbk1lc3NhZ2UgJiYgbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLnBhcmVudC5vZmZzZXQsIGxlbmd0aDogbm9kZS5wYXJlbnQubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6IERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5kZXByZWNhdGlvbk1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkRlcHJlY2F0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICAgICAgdmFyIHZhbCA9IG5vZGUudmFsdWU7XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUZsb2F0cyhmbG9hdCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gL14oLT9cXGQrKSg/OlxcLihcXGQrKSk/KD86ZShbLStdXFxkKykpPyQvLmV4ZWMoZmxvYXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMgJiYge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIocGFydHNbMV0gKyAocGFydHNbMl0gfHwgJycpKSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyOiAoKChfYSA9IHBhcnRzWzJdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwKSAtIChwYXJzZUludChwYXJ0c1szXSkgfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gLTE7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihzY2hlbWEubXVsdGlwbGVPZikpIHtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSB2YWwgJSBzY2hlbWEubXVsdGlwbGVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub3JtTXVsdGlwbGVPZiA9IG5vcm1hbGl6ZUZsb2F0cyhzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1WYWx1ZSA9IG5vcm1hbGl6ZUZsb2F0cyh2YWwpO1xuICAgICAgICAgICAgICAgIGlmIChub3JtTXVsdGlwbGVPZiAmJiBub3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTWF0aC5hYnMobm9ybVZhbHVlLm11bHRpcGxpZXIgLSBub3JtTXVsdGlwbGVPZi5tdWx0aXBsaWVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtVmFsdWUubXVsdGlwbGllciA8IG5vcm1NdWx0aXBsZU9mLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1WYWx1ZS52YWx1ZSAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybU11bHRpcGxlT2YudmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBub3JtVmFsdWUudmFsdWUgJSBub3JtTXVsdGlwbGVPZi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluZGVyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnbXVsdGlwbGVPZldhcm5pbmcnLCAnVmFsdWUgaXMgbm90IGRpdmlzaWJsZSBieSB7MH0uJywgc2NoZW1hLm11bHRpcGxlT2YpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXhjbHVzaXZlTGltaXQobGltaXQsIGV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGV4Y2x1c2l2ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihleGNsdXNpdmUpICYmIGV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGltaXQobGltaXQsIGV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgaWYgKCFpc0Jvb2xlYW4oZXhjbHVzaXZlKSB8fCAhZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhjbHVzaXZlTWluaW11bSA9IGdldEV4Y2x1c2l2ZUxpbWl0KHNjaGVtYS5taW5pbXVtLCBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSk7XG4gICAgICAgIGlmIChpc051bWJlcihleGNsdXNpdmVNaW5pbXVtKSAmJiB2YWwgPD0gZXhjbHVzaXZlTWluaW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ2V4Y2x1c2l2ZU1pbmltdW1XYXJuaW5nJywgJ1ZhbHVlIGlzIGJlbG93IHRoZSBleGNsdXNpdmUgbWluaW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWluaW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleGNsdXNpdmVNYXhpbXVtID0gZ2V0RXhjbHVzaXZlTGltaXQoc2NoZW1hLm1heGltdW0sIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGV4Y2x1c2l2ZU1heGltdW0pICYmIHZhbCA+PSBleGNsdXNpdmVNYXhpbXVtKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnZXhjbHVzaXZlTWF4aW11bVdhcm5pbmcnLCAnVmFsdWUgaXMgYWJvdmUgdGhlIGV4Y2x1c2l2ZSBtYXhpbXVtIG9mIHswfS4nLCBleGNsdXNpdmVNYXhpbXVtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbmltdW0gPSBnZXRMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIobWluaW11bSkgJiYgdmFsIDwgbWluaW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ21pbmltdW1XYXJuaW5nJywgJ1ZhbHVlIGlzIGJlbG93IHRoZSBtaW5pbXVtIG9mIHswfS4nLCBtaW5pbXVtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heGltdW0gPSBnZXRMaW1pdChzY2hlbWEubWF4aW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIobWF4aW11bSkgJiYgdmFsID4gbWF4aW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ21heGltdW1XYXJuaW5nJywgJ1ZhbHVlIGlzIGFib3ZlIHRoZSBtYXhpbXVtIG9mIHswfS4nLCBtYXhpbXVtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlU3RyaW5nTm9kZShub2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcykge1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCkgJiYgbm9kZS52YWx1ZS5sZW5ndGggPCBzY2hlbWEubWluTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnbWluTGVuZ3RoV2FybmluZycsICdTdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB7MH0uJywgc2NoZW1hLm1pbkxlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4TGVuZ3RoKSAmJiBub2RlLnZhbHVlLmxlbmd0aCA+IHNjaGVtYS5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdtYXhMZW5ndGhXYXJuaW5nJywgJ1N0cmluZyBpcyBsb25nZXIgdGhhbiB0aGUgbWF4aW11bSBsZW5ndGggb2YgezB9LicsIHNjaGVtYS5tYXhMZW5ndGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcoc2NoZW1hLnBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChzY2hlbWEucGF0dGVybik7XG4gICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3Qobm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5wYXR0ZXJuRXJyb3JNZXNzYWdlIHx8IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgbG9jYWxpemUoJ3BhdHRlcm5XYXJuaW5nJywgJ1N0cmluZyBkb2VzIG5vdCBtYXRjaCB0aGUgcGF0dGVybiBvZiBcInswfVwiLicsIHNjaGVtYS5wYXR0ZXJuKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1cmknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3VyaS1yZWZlcmVuY2UnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gbG9jYWxpemUoJ3VyaUVtcHR5JywgJ1VSSSBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IC9eKChbXjovPyNdKz8pOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8vLmV4ZWMobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBsb2NhbGl6ZSgndXJpTWlzc2luZycsICdVUkkgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFtYXRjaFsyXSAmJiBzY2hlbWEuZm9ybWF0ID09PSAndXJpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBsb2NhbGl6ZSgndXJpU2NoZW1lTWlzc2luZycsICdVUkkgd2l0aCBhIHNjaGVtZSBpcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCd1cmlGb3JtYXRXYXJuaW5nJywgJ1N0cmluZyBpcyBub3QgYSBVUkk6IHswfScsIGVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xvci1oZXgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gZm9ybWF0c1tzY2hlbWEuZm9ybWF0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnZhbHVlIHx8ICFmb3JtYXQucGF0dGVybi5leGVjKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGZvcm1hdC5lcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVBcnJheU5vZGUobm9kZSwgc2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSkge1xuICAgICAgICAgICAgdmFyIHN1YlNjaGVtYXMgPSBzY2hlbWEuaXRlbXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3ViU2NoZW1hcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViU2NoZW1hUmVmID0gc3ViU2NoZW1hc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHN1YlNjaGVtYSA9IGFzU2NoZW1hKHN1YlNjaGVtYVJlZik7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IG5vZGUuaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGl0ZW0sIHN1YlNjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKGl0ZW1WYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5pdGVtcy5sZW5ndGggPj0gc3ViU2NoZW1hcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaXRlbXMubGVuZ3RoID4gc3ViU2NoZW1hcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdWJTY2hlbWFzLmxlbmd0aDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLml0ZW1zW2ldLCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zLCBpdGVtVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKGl0ZW1WYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ2FkZGl0aW9uYWxJdGVtc1dhcm5pbmcnLCAnQXJyYXkgaGFzIHRvbyBtYW55IGl0ZW1zIGFjY29yZGluZyB0byBzY2hlbWEuIEV4cGVjdGVkIHswfSBvciBmZXdlci4nLCBzdWJTY2hlbWFzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl0ZW1TY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuaXRlbXMpO1xuICAgICAgICAgICAgaWYgKGl0ZW1TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbm9kZS5pdGVtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGl0ZW0sIGl0ZW1TY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChpdGVtVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250YWluc1NjaGVtYSA9IGFzU2NoZW1hKHNjaGVtYS5jb250YWlucyk7XG4gICAgICAgIGlmIChjb250YWluc1NjaGVtYSkge1xuICAgICAgICAgICAgdmFyIGRvZXNDb250YWluID0gbm9kZS5pdGVtcy5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShpdGVtLCBjb250YWluc1NjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIE5vT3BTY2hlbWFDb2xsZWN0b3IuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbVZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkb2VzQ29udGFpbikge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgncmVxdWlyZWRJdGVtTWlzc2luZ1dhcm5pbmcnLCAnQXJyYXkgZG9lcyBub3QgY29udGFpbiByZXF1aXJlZCBpdGVtLicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5JdGVtcykgJiYgbm9kZS5pdGVtcy5sZW5ndGggPCBzY2hlbWEubWluSXRlbXMpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdtaW5JdGVtc1dhcm5pbmcnLCAnQXJyYXkgaGFzIHRvbyBmZXcgaXRlbXMuIEV4cGVjdGVkIHswfSBvciBtb3JlLicsIHNjaGVtYS5taW5JdGVtcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4SXRlbXMpICYmIG5vZGUuaXRlbXMubGVuZ3RoID4gc2NoZW1hLm1heEl0ZW1zKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgnbWF4SXRlbXNXYXJuaW5nJywgJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcy4gRXhwZWN0ZWQgezB9IG9yIGZld2VyLicsIHNjaGVtYS5tYXhJdGVtcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEudW5pcXVlSXRlbXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNfMSA9IGdldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIHZhciBkdXBsaWNhdGVzID0gdmFsdWVzXzEuc29tZShmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSB2YWx1ZXNfMS5sYXN0SW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBsb2NhbGl6ZSgndW5pcXVlSXRlbXNXYXJuaW5nJywgJ0FycmF5IGhhcyBkdXBsaWNhdGUgaXRlbXMuJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVPYmplY3ROb2RlKG5vZGUsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKSB7XG4gICAgICAgIHZhciBzZWVuS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciB1bnByb2Nlc3NlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG5vZGUucHJvcGVydGllczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5vZGUgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcGVydHlOb2RlLmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICBzZWVuS2V5c1trZXldID0gcHJvcGVydHlOb2RlLnZhbHVlTm9kZTtcbiAgICAgICAgICAgIHVucHJvY2Vzc2VkUHJvcGVydGllcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHNjaGVtYS5yZXF1aXJlZDsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmICghc2VlbktleXNbcHJvcGVydHlOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5Tm9kZSA9IG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgbm9kZS5wYXJlbnQua2V5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0ga2V5Tm9kZSA/IHsgb2Zmc2V0OiBrZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBrZXlOb2RlLmxlbmd0aCB9IDogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdNaXNzaW5nUmVxdWlyZWRQcm9wV2FybmluZycsICdNaXNzaW5nIHByb3BlcnR5IFwiezB9XCIuJywgcHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnR5UHJvY2Vzc2VkID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHVucHJvY2Vzc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHVucHJvY2Vzc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVByb2Nlc3NlZChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVNjaGVtYSA9IHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihwcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOb2RlID0gY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCdEaXNhbGxvd2VkRXh0cmFQcm9wV2FybmluZycsICdQcm9wZXJ0eSB7MH0gaXMgbm90IGFsbG93ZWQuJywgcHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc1ZhbHVlTWF0Y2hlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSAwLCBfZyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7IF9mIDwgX2cubGVuZ3RoOyBfZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5UGF0dGVybiA9IF9nW19mXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChwcm9wZXJ0eVBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9oID0gMCwgX2ogPSB1bnByb2Nlc3NlZFByb3BlcnRpZXMuc2xpY2UoMCk7IF9oIDwgX2oubGVuZ3RoOyBfaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBfaltfaF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5UHJvY2Vzc2VkKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBzZWVuS2V5c1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5U2NoZW1hID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3Byb3BlcnR5UGF0dGVybl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihwcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5Tm9kZSA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCBsb2NhbGl6ZSgnRGlzYWxsb3dlZEV4dHJhUHJvcFdhcm5pbmcnLCAnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2gocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfayA9IDAsIHVucHJvY2Vzc2VkUHJvcGVydGllc18xID0gdW5wcm9jZXNzZWRQcm9wZXJ0aWVzOyBfayA8IHVucHJvY2Vzc2VkUHJvcGVydGllc18xLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSB1bnByb2Nlc3NlZFByb3BlcnRpZXNfMVtfa107XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGNoaWxkLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2gocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHVucHJvY2Vzc2VkUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2wgPSAwLCB1bnByb2Nlc3NlZFByb3BlcnRpZXNfMiA9IHVucHJvY2Vzc2VkUHJvcGVydGllczsgX2wgPCB1bnByb2Nlc3NlZFByb3BlcnRpZXNfMi5sZW5ndGg7IF9sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHVucHJvY2Vzc2VkUHJvcGVydGllc18yW19sXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlOb2RlID0gY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGxvY2FsaXplKCdEaXNhbGxvd2VkRXh0cmFQcm9wV2FybmluZycsICdQcm9wZXJ0eSB7MH0gaXMgbm90IGFsbG93ZWQuJywgcHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPiBzY2hlbWEubWF4UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ01heFByb3BXYXJuaW5nJywgJ09iamVjdCBoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gbGltaXQgb2YgezB9LicsIHNjaGVtYS5tYXhQcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnByb3BlcnRpZXMubGVuZ3RoIDwgc2NoZW1hLm1pblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGxvY2FsaXplKCdNaW5Qcm9wV2FybmluZycsICdPYmplY3QgaGFzIGZld2VyIHByb3BlcnRpZXMgdGhhbiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIHswfScsIHNjaGVtYS5taW5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbSA9IDAsIF9vID0gT2JqZWN0LmtleXMoc2NoZW1hLmRlcGVuZGVuY2llcyk7IF9tIDwgX28ubGVuZ3RoOyBfbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9vW19tXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHNlZW5LZXlzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5RGVwID0gc2NoZW1hLmRlcGVuZGVuY2llc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eURlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9wID0gMCwgcHJvcGVydHlEZXBfMSA9IHByb3BlcnR5RGVwOyBfcCA8IHByb3BlcnR5RGVwXzEubGVuZ3RoOyBfcCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVpcmVkUHJvcCA9IHByb3BlcnR5RGVwXzFbX3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VlbktleXNbcmVxdWlyZWRQcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbG9jYWxpemUoJ1JlcXVpcmVkRGVwZW5kZW50UHJvcFdhcm5pbmcnLCAnT2JqZWN0IGlzIG1pc3NpbmcgcHJvcGVydHkgezB9IHJlcXVpcmVkIGJ5IHByb3BlcnR5IHsxfS4nLCByZXF1aXJlZFByb3AsIGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlTY2hlbWEgPSBhc1NjaGVtYShwcm9wZXJ0eURlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBwcm9wZXJ0eVNjaGVtYSwgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZXMgPSBhc1NjaGVtYShzY2hlbWEucHJvcGVydHlOYW1lcyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfcSA9IDAsIF9yID0gbm9kZS5wcm9wZXJ0aWVzOyBfcSA8IF9yLmxlbmd0aDsgX3ErKykge1xuICAgICAgICAgICAgICAgIHZhciBmID0gX3JbX3FdO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBmLmtleU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShrZXksIHByb3BlcnR5TmFtZXMsIHZhbGlkYXRpb25SZXN1bHQsIE5vT3BTY2hlbWFDb2xsZWN0b3IuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0RG9jdW1lbnQsIGNvbmZpZykge1xuICAgIHZhciBwcm9ibGVtcyA9IFtdO1xuICAgIHZhciBsYXN0UHJvYmxlbU9mZnNldCA9IC0xO1xuICAgIHZhciB0ZXh0ID0gdGV4dERvY3VtZW50LmdldFRleHQoKTtcbiAgICB2YXIgc2Nhbm5lciA9IEpzb24uY3JlYXRlU2Nhbm5lcih0ZXh0LCBmYWxzZSk7XG4gICAgdmFyIGNvbW1lbnRSYW5nZXMgPSBjb25maWcgJiYgY29uZmlnLmNvbGxlY3RDb21tZW50cyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIF9zY2FuTmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbl8xID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgICAgICBfY2hlY2tTY2FuRXJyb3IoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW5fMSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBCbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1lbnRSYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50UmFuZ2VzLnB1c2goUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1IC8qIFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDE0IC8qIExpbmVCcmVha1RyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuXzE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2FjY2VwdCh0b2tlbikge1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSB0b2tlbikge1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lcnJvckF0UmFuZ2UobWVzc2FnZSwgY29kZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgc2V2ZXJpdHkpIHtcbiAgICAgICAgaWYgKHNldmVyaXR5ID09PSB2b2lkIDApIHsgc2V2ZXJpdHkgPSBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I7IH1cbiAgICAgICAgaWYgKHByb2JsZW1zLmxlbmd0aCA9PT0gMCB8fCBzdGFydE9mZnNldCAhPT0gbGFzdFByb2JsZW1PZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChzdGFydE9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGVuZE9mZnNldCkpO1xuICAgICAgICAgICAgcHJvYmxlbXMucHVzaChEaWFnbm9zdGljLmNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHRleHREb2N1bWVudC5sYW5ndWFnZUlkKSk7XG4gICAgICAgICAgICBsYXN0UHJvYmxlbU9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lcnJvcihtZXNzYWdlLCBjb2RlLCBub2RlLCBza2lwVW50aWxBZnRlciwgc2tpcFVudGlsKSB7XG4gICAgICAgIGlmIChub2RlID09PSB2b2lkIDApIHsgbm9kZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIgPT09IHZvaWQgMCkgeyBza2lwVW50aWxBZnRlciA9IFtdOyB9XG4gICAgICAgIGlmIChza2lwVW50aWwgPT09IHZvaWQgMCkgeyBza2lwVW50aWwgPSBbXTsgfVxuICAgICAgICB2YXIgc3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCk7XG4gICAgICAgIHZhciBlbmQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCk7XG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kICYmIHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgL1xccy8udGVzdCh0ZXh0LmNoYXJBdChzdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBfZXJyb3JBdFJhbmdlKG1lc3NhZ2UsIGNvZGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgX2ZpbmFsaXplKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIubGVuZ3RoICsgc2tpcFVudGlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciB0b2tlbl8yID0gc2Nhbm5lci5nZXRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuXzIgIT09IDE3IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChza2lwVW50aWxBZnRlci5pbmRleE9mKHRva2VuXzIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNraXBVbnRpbC5pbmRleE9mKHRva2VuXzIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW5fMiA9IF9zY2FuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY2hlY2tTY2FuRXJyb3IoKSB7XG4gICAgICAgIHN3aXRjaCAoc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkpIHtcbiAgICAgICAgICAgIGNhc2UgNCAvKiBJbnZhbGlkVW5pY29kZSAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0ludmFsaWRVbmljb2RlJywgJ0ludmFsaWQgdW5pY29kZSBzZXF1ZW5jZSBpbiBzdHJpbmcuJyksIEVycm9yQ29kZS5JbnZhbGlkVW5pY29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDUgLyogSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0ludmFsaWRFc2NhcGVDaGFyYWN0ZXInLCAnSW52YWxpZCBlc2NhcGUgY2hhcmFjdGVyIGluIHN0cmluZy4nKSwgRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFVuZXhwZWN0ZWRFbmRPZk51bWJlciAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ1VuZXhwZWN0ZWRFbmRPZk51bWJlcicsICdVbmV4cGVjdGVkIGVuZCBvZiBudW1iZXIuJyksIEVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdVbmV4cGVjdGVkRW5kT2ZDb21tZW50JywgJ1VuZXhwZWN0ZWQgZW5kIG9mIGNvbW1lbnQuJyksIEVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZDb21tZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBVbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdVbmV4cGVjdGVkRW5kT2ZTdHJpbmcnLCAnVW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nLicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgNiAvKiBJbnZhbGlkQ2hhcmFjdGVyICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnSW52YWxpZENoYXJhY3RlcicsICdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gc3RyaW5nLiBDb250cm9sIGNoYXJhY3RlcnMgbXVzdCBiZSBlc2NhcGVkLicpLCBFcnJvckNvZGUuSW52YWxpZENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZmluYWxpemUobm9kZSwgc2Nhbk5leHQpIHtcbiAgICAgICAgbm9kZS5sZW5ndGggPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgLSBub2RlLm9mZnNldDtcbiAgICAgICAgaWYgKHNjYW5OZXh0KSB7XG4gICAgICAgICAgICBfc2Nhbk5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlQXJyYXkocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDMgLyogT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBBcnJheUFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKTtcbiAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgT3BlbkJyYWNrZXRUb2tlblxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgbmVlZHNDb21tYSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSA0IC8qIENsb3NlQnJhY2tldFRva2VuICovICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIENvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdWYWx1ZUV4cGVjdGVkJywgJ1ZhbHVlIGV4cGVjdGVkJyksIEVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNvbW1hXG4gICAgICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yQXRSYW5nZShsb2NhbGl6ZSgnVHJhaWxpbmdDb21tYScsICdUcmFpbGluZyBjb21tYScpLCBFcnJvckNvZGUuVHJhaWxpbmdDb21tYSwgY29tbWFPZmZzZXQsIGNvbW1hT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnRXhwZWN0ZWRDb21tYScsICdFeHBlY3RlZCBjb21tYScpLCBFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9wYXJzZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdQcm9wZXJ0eUV4cGVjdGVkJywgJ1ZhbHVlIGV4cGVjdGVkJyksIEVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkLCB1bmRlZmluZWQsIFtdLCBbNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSA0IC8qIENsb3NlQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Vycm9yKGxvY2FsaXplKCdFeHBlY3RlZENsb3NlQnJhY2tldCcsICdFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNrZXQnKSwgRXJyb3JDb2RlLkNvbW1hT3JDbG9zZUJhY2tldEV4cGVjdGVkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICB2YXIga2V5UGxhY2Vob2xkZXIgPSBuZXcgU3RyaW5nQVNUTm9kZUltcGwodW5kZWZpbmVkLCAwLCAwKTtcbiAgICBmdW5jdGlvbiBfcGFyc2VQcm9wZXJ0eShwYXJlbnQsIGtleXNTZWVuKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IFByb3BlcnR5QVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIGtleVBsYWNlaG9sZGVyKTtcbiAgICAgICAgdmFyIGtleSA9IF9wYXJzZVN0cmluZyhub2RlKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDE2IC8qIFVua25vd24gKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBnaXZlIGEgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0RvdWJsZVF1b3Rlc0V4cGVjdGVkJywgJ1Byb3BlcnR5IGtleXMgbXVzdCBiZSBkb3VibGVxdW90ZWQnKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgdmFyIGtleU5vZGUgPSBuZXcgU3RyaW5nQVNUTm9kZUltcGwobm9kZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIGtleU5vZGUudmFsdWUgPSBzY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlOb2RlO1xuICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIFVua25vd25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5rZXlOb2RlID0ga2V5O1xuICAgICAgICB2YXIgc2VlbiA9IGtleXNTZWVuW2tleS52YWx1ZV07XG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBfZXJyb3JBdFJhbmdlKGxvY2FsaXplKCdEdXBsaWNhdGVLZXlXYXJuaW5nJywgXCJEdXBsaWNhdGUgb2JqZWN0IGtleVwiKSwgRXJyb3JDb2RlLkR1cGxpY2F0ZUtleSwgbm9kZS5rZXlOb2RlLm9mZnNldCwgbm9kZS5rZXlOb2RlLm9mZnNldCArIG5vZGUua2V5Tm9kZS5sZW5ndGgsIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3JBdFJhbmdlKGxvY2FsaXplKCdEdXBsaWNhdGVLZXlXYXJuaW5nJywgXCJEdXBsaWNhdGUgb2JqZWN0IGtleVwiKSwgRXJyb3JDb2RlLkR1cGxpY2F0ZUtleSwgc2Vlbi5rZXlOb2RlLm9mZnNldCwgc2Vlbi5rZXlOb2RlLm9mZnNldCArIHNlZW4ua2V5Tm9kZS5sZW5ndGgsIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleXNTZWVuW2tleS52YWx1ZV0gPSB0cnVlOyAvLyBpZiB0aGUgc2FtZSBrZXkgaXMgZHVwbGljYXRlIGFnYWluLCBhdm9pZCBkdXBsaWNhdGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXlzU2VlbltrZXkudmFsdWVdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA2IC8qIENvbG9uVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIG5vZGUuY29sb25PZmZzZXQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCk7XG4gICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBDb2xvblRva2VuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0NvbG9uRXhwZWN0ZWQnLCAnQ29sb24gZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLkNvbG9uRXhwZWN0ZWQpO1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMTAgLyogU3RyaW5nTGl0ZXJhbCAqLyAmJiB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChrZXkub2Zmc2V0ICsga2V5Lmxlbmd0aCkubGluZSA8IHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSkubGluZSkge1xuICAgICAgICAgICAgICAgIG5vZGUubGVuZ3RoID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBfcGFyc2VWYWx1ZShub2RlKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcihsb2NhbGl6ZSgnVmFsdWVFeHBlY3RlZCcsICdWYWx1ZSBleHBlY3RlZCcpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCwgbm9kZSwgW10sIFsyIC8qIENsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBDb21tYVRva2VuICovXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZU5vZGUgPSB2YWx1ZTtcbiAgICAgICAgbm9kZS5sZW5ndGggPSB2YWx1ZS5vZmZzZXQgKyB2YWx1ZS5sZW5ndGggLSBub2RlLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU9iamVjdChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMSAvKiBPcGVuQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBPYmplY3RBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIHZhciBrZXlzU2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIE9wZW5CcmFjZVRva2VuXG4gICAgICAgIHZhciBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChzY2FubmVyLmdldFRva2VuKCkgIT09IDIgLyogQ2xvc2VCcmFjZVRva2VuICovICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIENvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Vycm9yKGxvY2FsaXplKCdQcm9wZXJ0eUV4cGVjdGVkJywgJ1Byb3BlcnR5IGV4cGVjdGVkJyksIEVycm9yQ29kZS5Qcm9wZXJ0eUV4cGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNvbW1hXG4gICAgICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvckF0UmFuZ2UobG9jYWxpemUoJ1RyYWlsaW5nQ29tbWEnLCAnVHJhaWxpbmcgY29tbWEnKSwgRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEsIGNvbW1hT2Zmc2V0LCBjb21tYU9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0V4cGVjdGVkQ29tbWEnLCAnRXhwZWN0ZWQgY29tbWEnKSwgRXJyb3JDb2RlLkNvbW1hRXhwZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gX3BhcnNlUHJvcGVydHkobm9kZSwga2V5c1NlZW4pO1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcihsb2NhbGl6ZSgnUHJvcGVydHlFeHBlY3RlZCcsICdQcm9wZXJ0eSBleHBlY3RlZCcpLCBFcnJvckNvZGUuUHJvcGVydHlFeHBlY3RlZCwgdW5kZWZpbmVkLCBbXSwgWzIgLyogQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIENvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDIgLyogQ2xvc2VCcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gX2Vycm9yKGxvY2FsaXplKCdFeHBlY3RlZENsb3NlQnJhY2UnLCAnRXhwZWN0ZWQgY29tbWEgb3IgY2xvc2luZyBicmFjZScpLCBFcnJvckNvZGUuQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShub2RlLCB0cnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxMCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gbmV3IFN0cmluZ0FTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VOdW1iZXIocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDExIC8qIE51bWVyaWNMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gbmV3IE51bWJlckFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKTtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpID09PSAwIC8qIE5vbmUgKi8pIHtcbiAgICAgICAgICAgIHZhciB0b2tlblZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBudW1iZXJWYWx1ZSA9IEpTT04ucGFyc2UodG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihudW1iZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lcnJvcihsb2NhbGl6ZSgnSW52YWxpZE51bWJlckZvcm1hdCcsICdJbnZhbGlkIG51bWJlciBmb3JtYXQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXJyb3IobG9jYWxpemUoJ0ludmFsaWROdW1iZXJGb3JtYXQnLCAnSW52YWxpZCBudW1iZXIgZm9ybWF0LicpLCBFcnJvckNvZGUuVW5kZWZpbmVkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNJbnRlZ2VyID0gdG9rZW5WYWx1ZS5pbmRleE9mKCcuJykgPT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZUxpdGVyYWwocGFyZW50KSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW4oKSkge1xuICAgICAgICAgICAgY2FzZSA3IC8qIE51bGxLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBfZmluYWxpemUobmV3IE51bGxBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSksIHRydWUpO1xuICAgICAgICAgICAgY2FzZSA4IC8qIFRydWVLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBfZmluYWxpemUobmV3IEJvb2xlYW5BU1ROb2RlSW1wbChwYXJlbnQsIHRydWUsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSksIHRydWUpO1xuICAgICAgICAgICAgY2FzZSA5IC8qIEZhbHNlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCBmYWxzZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VBcnJheShwYXJlbnQpIHx8IF9wYXJzZU9iamVjdChwYXJlbnQpIHx8IF9wYXJzZVN0cmluZyhwYXJlbnQpIHx8IF9wYXJzZU51bWJlcihwYXJlbnQpIHx8IF9wYXJzZUxpdGVyYWwocGFyZW50KTtcbiAgICB9XG4gICAgdmFyIF9yb290ID0gdW5kZWZpbmVkO1xuICAgIHZhciB0b2tlbiA9IF9zY2FuTmV4dCgpO1xuICAgIGlmICh0b2tlbiAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgIF9yb290ID0gX3BhcnNlVmFsdWUoX3Jvb3QpO1xuICAgICAgICBpZiAoIV9yb290KSB7XG4gICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0ludmFsaWQgc3ltYm9sJywgJ0V4cGVjdGVkIGEgSlNPTiBvYmplY3QsIGFycmF5IG9yIGxpdGVyYWwuJyksIEVycm9yQ29kZS5VbmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgICAgICBfZXJyb3IobG9jYWxpemUoJ0VuZCBvZiBmaWxlIGV4cGVjdGVkJywgJ0VuZCBvZiBmaWxlIGV4cGVjdGVkLicpLCBFcnJvckNvZGUuVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEpTT05Eb2N1bWVudChfcm9vdCwgcHJvYmxlbXMsIGNvbW1lbnRSYW5nZXMpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iaiwgaW5kZW50LCBzdHJpbmdpZnlMaXRlcmFsKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgbmV3SW5kZW50ID0gaW5kZW50ICsgJ1xcdCc7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1tcXG4nO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbmV3SW5kZW50ICsgc3RyaW5naWZ5T2JqZWN0KG9ialtpXSwgbmV3SW5kZW50LCBzdHJpbmdpZnlMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG9iai5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnQgKyAnXSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJ3tcXG4nO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOiAnICsgc3RyaW5naWZ5T2JqZWN0KG9ialtrZXldLCBuZXdJbmRlbnQsIHN0cmluZ2lmeUxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnQgKyAnfSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlMaXRlcmFsKG9iaik7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIFBhcnNlciBmcm9tICcuLi9wYXJzZXIvanNvblBhcnNlci5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vLi4vLi4vanNvbmMtcGFyc2VyL21haW4uanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5T2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMvanNvbi5qcyc7XG5pbXBvcnQgeyBlbmRzV2l0aCwgZXh0ZW5kZWRSZWdFeHAgfSBmcm9tICcuLi91dGlscy9zdHJpbmdzLmpzJztcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL29iamVjdHMuanMnO1xuaW1wb3J0IHsgQ29tcGxldGlvbkl0ZW0sIENvbXBsZXRpb25JdGVtS2luZCwgUmFuZ2UsIFRleHRFZGl0LCBJbnNlcnRUZXh0Rm9ybWF0LCBNYXJrdXBLaW5kIH0gZnJvbSAnLi4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xuaW1wb3J0ICogYXMgbmxzIGZyb20gJy4vLi4vLi4vLi4vZmlsbGVycy92c2NvZGUtbmxzLmpzJztcbnZhciBsb2NhbGl6ZSA9IG5scy5sb2FkTWVzc2FnZUJ1bmRsZSgpO1xudmFyIHZhbHVlQ29tbWl0Q2hhcmFjdGVycyA9IFsnLCcsICd9JywgJ10nXTtcbnZhciBwcm9wZXJ0eUNvbW1pdENoYXJhY3RlcnMgPSBbJzonXTtcbnZhciBKU09OQ29tcGxldGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OQ29tcGxldGlvbihzY2hlbWFTZXJ2aWNlLCBjb250cmlidXRpb25zLCBwcm9taXNlQ29uc3RydWN0b3IsIGNsaWVudENhcGFiaWxpdGllcykge1xuICAgICAgICBpZiAoY29udHJpYnV0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbnRyaWJ1dGlvbnMgPSBbXTsgfVxuICAgICAgICBpZiAocHJvbWlzZUNvbnN0cnVjdG9yID09PSB2b2lkIDApIHsgcHJvbWlzZUNvbnN0cnVjdG9yID0gUHJvbWlzZTsgfVxuICAgICAgICBpZiAoY2xpZW50Q2FwYWJpbGl0aWVzID09PSB2b2lkIDApIHsgY2xpZW50Q2FwYWJpbGl0aWVzID0ge307IH1cbiAgICAgICAgdGhpcy5zY2hlbWFTZXJ2aWNlID0gc2NoZW1hU2VydmljZTtcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25zID0gY29udHJpYnV0aW9ucztcbiAgICAgICAgdGhpcy5wcm9taXNlQ29uc3RydWN0b3IgPSBwcm9taXNlQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzID0gY2xpZW50Q2FwYWJpbGl0aWVzO1xuICAgIH1cbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZG9SZXNvbHZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY29udHJpYnV0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVDb21wbGV0aW9uID0gdGhpcy5jb250cmlidXRpb25zW2ldLnJlc29sdmVDb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVyID0gcmVzb2x2ZUNvbXBsZXRpb24oaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoaXRlbSk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZG9Db21wbGV0ZSA9IGZ1bmN0aW9uIChkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgaXNJbmNvbXBsZXRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbkNvbW1lbnQoZG9jdW1lbnQsIG5vZGUgPyBub2RlLm9mZnNldCA6IDAsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAmJiAob2Zmc2V0ID09PSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0ZXh0W29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcgJiYgY2ggPT09ICd9JyB8fCBub2RlLnR5cGUgPT09ICdhcnJheScgJiYgY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIC8vIGFmdGVyIF0gb3IgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFdvcmQgPSB0aGlzLmdldEN1cnJlbnRXb3JkKGRvY3VtZW50LCBvZmZzZXQpO1xuICAgICAgICB2YXIgb3ZlcndyaXRlUmFuZ2U7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpKSB7XG4gICAgICAgICAgICBvdmVyd3JpdGVSYW5nZSA9IFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0KSwgZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3ZlcndyaXRlU3RhcnQgPSBvZmZzZXQgLSBjdXJyZW50V29yZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob3ZlcndyaXRlU3RhcnQgPiAwICYmIHRleHRbb3ZlcndyaXRlU3RhcnQgLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIG92ZXJ3cml0ZVN0YXJ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVyd3JpdGVSYW5nZSA9IFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG92ZXJ3cml0ZVN0YXJ0KSwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMgPSBmYWxzZTsgLy90aGlzLmRvZXNTdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMoKTsgZGlzYWJsZWQgZm9yIG5vdywgd2FpdGluZyBmb3IgbmV3IEFQSTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzQyNTQ0XG4gICAgICAgIHZhciBwcm9wb3NlZCA9IHt9O1xuICAgICAgICB2YXIgY29sbGVjdG9yID0ge1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoc3VnZ2VzdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHN1Z2dlc3Rpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gcHJvcG9zZWRbbGFiZWxdO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5yZXBsYWNlKC9bXFxuXS9nLCAn4oa1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGggPiA2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNob3J0ZW5kZWRMYWJlbCA9IGxhYmVsLnN1YnN0cigwLCA1NykudHJpbSgpICsgJy4uLic7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3Bvc2VkW3Nob3J0ZW5kZWRMYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHNob3J0ZW5kZWRMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlUmFuZ2UgJiYgc3VnZ2VzdGlvbi5pbnNlcnRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24udGV4dEVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKG92ZXJ3cml0ZVJhbmdlLCBzdWdnZXN0aW9uLmluc2VydFRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24uY29tbWl0Q2hhcmFjdGVycyA9IHN1Z2dlc3Rpb24ua2luZCA9PT0gQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID8gcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzIDogdmFsdWVDb21taXRDaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24ubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWRbbGFiZWxdID0gc3VnZ2VzdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lml0ZW1zLnB1c2goc3VnZ2VzdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRvY3VtZW50YXRpb24gPSBzdWdnZXN0aW9uLmRvY3VtZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZy5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRldGFpbCA9IHN1Z2dlc3Rpb24uZGV0YWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEFzSW5jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pc0luY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE51bWJlck9mUHJvcG9zYWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25Qcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50S2V5ID0gJyc7XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgcGFyZW50LmtleU5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhbHVlID0gIXBhcmVudC52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50S2V5ID0gdGV4dC5zdWJzdHIobm9kZS5vZmZzZXQgKyAxLCBub2RlLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcG9zYWxzIGZvciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3VnZ2VzdCBrZXlzIHdoZW4gdGhlIGN1cnNvciBpcyBqdXN0IGJlZm9yZSB0aGUgb3BlbmluZyBjdXJseSBicmFjZVxuICAgICAgICAgICAgICAgIGlmIChub2RlLm9mZnNldCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3QgcHJvcGVydGllcyB0aGF0IGFyZSBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvcGVydHkgfHwgY3VycmVudFByb3BlcnR5ICE9PSBwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NlZFtwLmtleU5vZGUudmFsdWVdID0gQ29tcGxldGlvbkl0ZW0uY3JlYXRlKCdfXycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvckFmdGVyXzEgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoYWRkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yQWZ0ZXJfMSA9IF90aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIGRvY3VtZW50Lm9mZnNldEF0KG92ZXJ3cml0ZVJhbmdlLmVuZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IHByb3Bvc2FscyB3aXRoIHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRQcm9wZXJ0eUNvbXBsZXRpb25zKHNjaGVtYSwgZG9jLCBub2RlLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXJfMSwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IHByb3Bvc2FscyB3aXRob3V0IHNjaGVtYVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyhkb2MsIG5vZGUsIGN1cnJlbnRLZXksIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbl8xID0gUGFyc2VyLmdldE5vZGVQYXRoKG5vZGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyaWJ1dGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0UHJvbWlzZSA9IGNvbnRyaWJ1dGlvbi5jb2xsZWN0UHJvcGVydHlDb21wbGV0aW9ucyhkb2N1bWVudC51cmksIGxvY2F0aW9uXzEsIGN1cnJlbnRXb3JkLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXJfMSA9PT0gJycsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCghc2NoZW1hICYmIGN1cnJlbnRXb3JkLmxlbmd0aCA+IDAgJiYgdGV4dC5jaGFyQXQob2Zmc2V0IC0gY3VycmVudFdvcmQubGVuZ3RoIC0gMSkgIT09ICdcIicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IF90aGlzLmdldExhYmVsRm9yVmFsdWUoY3VycmVudFdvcmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KGN1cnJlbnRXb3JkLCB1bmRlZmluZWQsIGZhbHNlLCBzZXBhcmF0b3JBZnRlcl8xKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCwgZG9jdW1lbnRhdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3Iuc2V0QXNJbmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcG9zYWxzIGZvciB2YWx1ZXNcbiAgICAgICAgICAgIHZhciB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHByb3Bvc2FscyB3aXRoIHNjaGVtYVxuICAgICAgICAgICAgICAgIF90aGlzLmdldFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgcHJvcG9zYWxzIHdpdGhvdXQgc2NoZW1hXG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0U2NoZW1hTGVzc1ZhbHVlQ29tcGxldGlvbnMoZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdldENvbnRyaWJ1dGVkVmFsdWVDb21wbGV0aW9ucyhkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgY29sbGVjdGlvblByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9taXNlQ29uc3RydWN0b3IuYWxsKGNvbGxlY3Rpb25Qcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rvci5nZXROdW1iZXJPZlByb3Bvc2FscygpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXRGb3JTZXBhcmF0b3IgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3JBZnRlciA9IF90aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZEZpbGxlclZhbHVlQ29tcGxldGlvbnModHlwZXMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldFByb3BlcnR5Q29tcGxldGlvbnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBkb2MsIG5vZGUsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtYXRjaGluZ1NjaGVtYXMgPSBkb2MuZ2V0TWF0Y2hpbmdTY2hlbWFzKHNjaGVtYS5zY2hlbWEsIG5vZGUub2Zmc2V0KTtcbiAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLm5vZGUgPT09IG5vZGUgJiYgIXMuaW52ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hUHJvcGVydGllc18xID0gcy5zY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydGllc18xKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYVByb3BlcnRpZXNfMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWFQcm9wZXJ0aWVzXzFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlTY2hlbWEgPT09ICdvYmplY3QnICYmICFwcm9wZXJ0eVNjaGVtYS5kZXByZWNhdGlvbk1lc3NhZ2UgJiYgIXByb3BlcnR5U2NoZW1hLmRvTm90U3VnZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiBfdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoa2V5LCBwcm9wZXJ0eVNjaGVtYSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiBfdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogX3RoaXMuZnJvbU1hcmt1cChwcm9wZXJ0eVNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBwcm9wZXJ0eVNjaGVtYS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5zdWdnZXN0U29ydFRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5zb3J0VGV4dCA9IHByb3BlcnR5U2NoZW1hLnN1Z2dlc3RTb3J0VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3Bvc2FsLmluc2VydFRleHQgJiYgZW5kc1dpdGgocHJvcG9zYWwuaW5zZXJ0VGV4dCwgXCIkMVwiICsgc2VwYXJhdG9yQWZ0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsLmNvbW1hbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1N1Z2dlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ2VkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQocHJvcG9zYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYVByb3BlcnR5TmFtZXNfMSA9IHMuc2NoZW1hLnByb3BlcnR5TmFtZXM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFQcm9wZXJ0eU5hbWVzXzEgPT09ICdvYmplY3QnICYmICFzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZGVwcmVjYXRpb25NZXNzYWdlICYmICFzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZG9Ob3RTdWdnZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWVDb21wbGV0aW9uSXRlbSA9IGZ1bmN0aW9uIChuYW1lLCBlbnVtRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnVtRGVzY3JpcHRpb24gPT09IHZvaWQgMCkgeyBlbnVtRGVzY3JpcHRpb24gPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KG5hbWUsIHVuZGVmaW5lZCwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogX3RoaXMuZ2V0RmlsdGVyVGV4dEZvclZhbHVlKG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IGVudW1EZXNjcmlwdGlvbiB8fCBfdGhpcy5mcm9tTWFya3VwKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5tYXJrZG93bkRlc2NyaXB0aW9uKSB8fCBzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5zdWdnZXN0U29ydFRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsLnNvcnRUZXh0ID0gc2NoZW1hUHJvcGVydHlOYW1lc18xLnN1Z2dlc3RTb3J0VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wb3NhbC5pbnNlcnRUZXh0ICYmIGVuZHNXaXRoKHByb3Bvc2FsLmluc2VydFRleHQsIFwiJDFcIiArIHNlcGFyYXRvckFmdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsLmNvbW1hbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU3VnZ2VzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHByb3Bvc2FsKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXNfMS5lbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudW1EZXNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lc18xLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucyAmJiBpIDwgc2NoZW1hUHJvcGVydHlOYW1lc18xLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bURlc2NyaXB0aW9uID0gX3RoaXMuZnJvbU1hcmt1cChzY2hlbWFQcm9wZXJ0eU5hbWVzXzEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hUHJvcGVydHlOYW1lc18xLmVudW1EZXNjcmlwdGlvbnMgJiYgaSA8IHNjaGVtYVByb3BlcnR5TmFtZXNfMS5lbnVtRGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtRGVzY3JpcHRpb24gPSBzY2hlbWFQcm9wZXJ0eU5hbWVzXzEuZW51bURlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0oc2NoZW1hUHJvcGVydHlOYW1lc18xLmVudW1baV0sIGVudW1EZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXNfMS5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0oc2NoZW1hUHJvcGVydHlOYW1lc18xLmNvbnN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0U2NoZW1hTGVzc1Byb3BlcnR5Q29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZG9jLCBub2RlLCBjdXJyZW50S2V5LCBjb2xsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBvYmoucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHAua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDoga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiBfdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoa2V5LCAnJyksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogX3RoaXMuZ2V0RmlsdGVyVGV4dEZvclZhbHVlKGtleSksXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgYSBwcm9wZXJ0eSB2YWx1ZSwgY2hlY2sgdGhlIHRyZWUgZm9yIG90aGVyIG9iamVjdHMgdGhhdCBoYW5nIHVuZGVyIGEgcHJvcGVydHkgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRLZXlfMSA9IG5vZGUucGFyZW50LmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZG9jLnZpc2l0KGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgbiAhPT0gbm9kZS5wYXJlbnQgJiYgbi5rZXlOb2RlLnZhbHVlID09PSBwYXJlbnRLZXlfMSAmJiBuLnZhbHVlTm9kZSAmJiBuLnZhbHVlTm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdChuLnZhbHVlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBpbiBhbiBhcnJheSwgdXNlIGFsbCBvdGhlciBhcnJheSBlbGVtZW50cyBhcyBzaW1pbGFyIG9iamVjdHNcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09ICdvYmplY3QnICYmIG4gIT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3Qobik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICckc2NoZW1hJyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eSgnJHNjaGVtYScsIHVuZGVmaW5lZCwgdHJ1ZSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCwgZG9jdW1lbnRhdGlvbjogJycsXG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoXCIkc2NoZW1hXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldFNjaGVtYUxlc3NWYWx1ZUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvZmZzZXRGb3JTZXBhcmF0b3IgPSBvZmZzZXQ7XG4gICAgICAgIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpKSB7XG4gICAgICAgICAgICBvZmZzZXRGb3JTZXBhcmF0b3IgPSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFbXB0eSBvYmplY3QnLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHt9LCAnJyksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ2FycmF5JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFbXB0eSBhcnJheScsXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoW10sICcnKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcbiAgICAgICAgdmFyIGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnBhcmVudCAmJiAhUGFyc2VyLmNvbnRhaW5zKHZhbHVlLnBhcmVudCwgb2Zmc2V0LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBfdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh2YWx1ZS50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IF90aGlzLmdldExhYmVsVGV4dEZvck1hdGNoaW5nTm9kZSh2YWx1ZSwgZG9jdW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiBfdGhpcy5nZXRJbnNlcnRUZXh0Rm9yTWF0Y2hpbmdOb2RlKHZhbHVlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbighdmFsdWUudmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gKG5vZGUuY29sb25PZmZzZXQgfHwgMCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSAmJiAob2Zmc2V0ID4gKHZhbHVlTm9kZS5vZmZzZXQgKyB2YWx1ZU5vZGUubGVuZ3RoKSB8fCB2YWx1ZU5vZGUudHlwZSA9PT0gJ29iamVjdCcgfHwgdmFsdWVOb2RlLnR5cGUgPT09ICdhcnJheScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdCB2YWx1ZXMgYXQgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEtleV8yID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvYy52aXNpdChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09PSAncHJvcGVydHknICYmIG4ua2V5Tm9kZS52YWx1ZSA9PT0gcGFyZW50S2V5XzIgJiYgbi52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyhuLnZhbHVlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEtleV8yID09PSAnJHNjaGVtYScgJiYgbm9kZS5wYXJlbnQgJiYgIW5vZGUucGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERvbGxhclNjaGVtYUNvbXBsZXRpb25zKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3QgaXRlbXMgb2YgYW4gYXJyYXkgYXQgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEtleV8zID0gbm9kZS5wYXJlbnQua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2MudmlzaXQoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ3Byb3BlcnR5JyAmJiBuLmtleU5vZGUudmFsdWUgPT09IHBhcmVudEtleV8zICYmIG4udmFsdWVOb2RlICYmIG4udmFsdWVOb2RlLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4udmFsdWVOb2RlLml0ZW1zLmZvckVhY2goY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3QgaXRlbXMgaW4gdGhlIHNhbWUgYXJyYXlcbiAgICAgICAgICAgICAgICBub2RlLml0ZW1zLmZvckVhY2goY29sbGVjdFN1Z2dlc3Rpb25zRm9yVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldFZhbHVlQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgdHlwZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldEZvclNlcGFyYXRvciA9IG9mZnNldDtcbiAgICAgICAgdmFyIHBhcmVudEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHZhbHVlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gJ3N0cmluZycgfHwgbm9kZS50eXBlID09PSAnbnVtYmVyJyB8fCBub2RlLnR5cGUgPT09ICdib29sZWFuJyB8fCBub2RlLnR5cGUgPT09ICdudWxsJykpIHtcbiAgICAgICAgICAgIG9mZnNldEZvclNlcGFyYXRvciA9IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYS5zY2hlbWEsICcnLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5JykgJiYgb2Zmc2V0ID4gKG5vZGUuY29sb25PZmZzZXQgfHwgMCkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZU5vZGVfMSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZV8xICYmIG9mZnNldCA+ICh2YWx1ZU5vZGVfMS5vZmZzZXQgKyB2YWx1ZU5vZGVfMS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZSBhcmUgcGFzdCB0aGUgdmFsdWUgbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50S2V5ID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICYmIChwYXJlbnRLZXkgIT09IHVuZGVmaW5lZCB8fCBub2RlLnR5cGUgPT09ICdhcnJheScpKSB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCwgdmFsdWVOb2RlKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbWF0Y2hpbmdTY2hlbWFzXzEgPSBtYXRjaGluZ1NjaGVtYXM7IF9pIDwgbWF0Y2hpbmdTY2hlbWFzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBtYXRjaGluZ1NjaGVtYXNfMVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHMubm9kZSA9PT0gbm9kZSAmJiAhcy5pbnZlcnRlZCAmJiBzLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknICYmIHMuc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzLnNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRJdGVtQXRPZmZzZXQobm9kZSwgZG9jdW1lbnQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcy5zY2hlbWEuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLnNjaGVtYS5pdGVtc1tpbmRleF0sIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocy5zY2hlbWEuaXRlbXMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5U2NoZW1hID0gcy5zY2hlbWEucHJvcGVydGllc1twYXJlbnRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocHJvcGVydHlTY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgJiYgIXByb3BlcnR5TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBPYmplY3Qua2V5cyhzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QocGFyZW50S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgIXByb3BlcnR5TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhwcm9wZXJ0eVNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudEtleSA9PT0gJyRzY2hlbWEnICYmICFub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9sbGFyU2NoZW1hQ29tcGxldGlvbnMoc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZXNbJ2Jvb2xlYW4nXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbih0cnVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24oZmFsc2UsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVzWydudWxsJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE51bGxWYWx1ZUNvbXBsZXRpb24oc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRDb250cmlidXRlZFZhbHVlQ29tcGxldGlvbnMgPSBmdW5jdGlvbiAoZG9jLCBub2RlLCBvZmZzZXQsIGRvY3VtZW50LCBjb2xsZWN0b3IsIGNvbGxlY3Rpb25Qcm9taXNlcykge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdERlZmF1bHRDb21wbGV0aW9ucyhkb2N1bWVudC51cmksIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAncHJvcGVydHknKSAmJiBvZmZzZXQgPiAobm9kZS5jb2xvbk9mZnNldCB8fCAwKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRLZXlfNCA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVOb2RlID0gbm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCghdmFsdWVOb2RlIHx8IG9mZnNldCA8PSAodmFsdWVOb2RlLm9mZnNldCArIHZhbHVlTm9kZS5sZW5ndGgpKSAmJiBub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25fMiA9IFBhcnNlci5nZXROb2RlUGF0aChub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0UHJvbWlzZSA9IGNvbnRyaWJ1dGlvbi5jb2xsZWN0VmFsdWVDb21wbGV0aW9ucyhkb2N1bWVudC51cmksIGxvY2F0aW9uXzIsIHBhcmVudEtleV80LCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblByb21pc2VzLnB1c2goY29sbGVjdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVudW1WYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLmFkZERlZmF1bHRWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RUeXBlcyhzY2hlbWEsIHR5cGVzKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuYWxsT2YuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gX3RoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5hbnlPZi5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBfdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLm9uZU9mLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF90aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmFkZERlZmF1bHRWYWx1ZUNvbXBsZXRpb25zID0gZnVuY3Rpb24gKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgYXJyYXlEZXB0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXJyYXlEZXB0aCA9PT0gdm9pZCAwKSB7IGFycmF5RGVwdGggPSAwOyB9XG4gICAgICAgIHZhciBoYXNQcm9wb3NhbHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY2hlbWEuZGVmYXVsdDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh0eXBlKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGxvY2FsaXplKCdqc29uLnN1Z2dlc3QuZGVmYXVsdCcsICdEZWZhdWx0IHZhbHVlJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFzUHJvcG9zYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZXhhbXBsZXMpKSB7XG4gICAgICAgICAgICBzY2hlbWEuZXhhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXhhbXBsZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogX3RoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5nZXRMYWJlbEZvclZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogX3RoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZGVmYXVsdFNuaXBwZXRzKSkge1xuICAgICAgICAgICAgc2NoZW1hLmRlZmF1bHRTbmlwcGV0cy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzLmJvZHk7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gcy5sYWJlbDtcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0VGV4dDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyVGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZV8xID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcnJheURlcHRoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlXzEgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQgPSBfdGhpcy5nZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQgPSBfdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbCB8fCBfdGhpcy5nZXRMYWJlbEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzLmJvZHlUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gJycsIHN1ZmZpeCA9ICcnLCBpbmRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFycmF5RGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCArIGluZGVudCArICdbXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeCArICdcXG4nICsgaW5kZW50ICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCA9IHByZWZpeCArIGluZGVudCArIHMuYm9keVRleHQuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBpbmRlbnQpICsgc3VmZml4ICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwgfHwgaW5zZXJ0VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHQgPSBpbnNlcnRUZXh0LnJlcGxhY2UoL1tcXG5dL2csICcnKTsgLy8gcmVtb3ZlIG5ldyBsaW5lc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogX3RoaXMuZ2V0U3VnZ2VzdGlvbktpbmQodHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogX3RoaXMuZnJvbU1hcmt1cChzLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IGluc2VydFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogZmlsdGVyVGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2FscyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc1Byb3Bvc2FscyAmJiB0eXBlb2Ygc2NoZW1hLml0ZW1zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpICYmIGFycmF5RGVwdGggPCA1IC8qIGJld2FyZSBvZiByZWN1cnNpb24gKi8pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLml0ZW1zLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCBhcnJheURlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5hZGRFbnVtVmFsdWVDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChzY2hlbWEsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHNjaGVtYS50eXBlKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKHNjaGVtYS5jb25zdCksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoc2NoZW1hLmNvbnN0LCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuZW51bSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzY2hlbWEuZW51bS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbm0gPSBzY2hlbWEuZW51bVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRhdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zLmxlbmd0aCAmJiB0aGlzLmRvZXNTdXBwb3J0TWFya2Rvd24oKSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uID0gdGhpcy5mcm9tTWFya3VwKHNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWEuZW51bURlc2NyaXB0aW9ucyAmJiBpIDwgc2NoZW1hLmVudW1EZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb24gPSBzY2hlbWEuZW51bURlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoc2NoZW1hLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKGVubSksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGVubSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmNvbGxlY3RUeXBlcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHR5cGVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSB8fCBpc0RlZmluZWQoc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICB0eXBlLmZvckVhY2goZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHR5cGVzW3RdID0gdHJ1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSkge1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuYWRkRmlsbGVyVmFsdWVDb21wbGV0aW9ucyA9IGZ1bmN0aW9uICh0eXBlcywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBpZiAodHlwZXNbJ29iamVjdCddKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdvYmplY3QnKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ3t9JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUoe30sIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiBsb2NhbGl6ZSgnZGVmYXVsdHMub2JqZWN0JywgJ05ldyBvYmplY3QnKSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzWydhcnJheSddKSB7XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdhcnJheScpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnW10nLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShbXSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGxvY2FsaXplKCdkZWZhdWx0cy5hcnJheScsICdOZXcgYXJyYXknKSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5hZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnYm9vbGVhbicpLFxuICAgICAgICAgICAgbGFiZWw6IHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5hZGROdWxsVmFsdWVDb21wbGV0aW9uID0gZnVuY3Rpb24gKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdudWxsJyksXG4gICAgICAgICAgICBsYWJlbDogJ251bGwnLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dDogJ251bGwnICsgc2VwYXJhdG9yQWZ0ZXIsXG4gICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5hZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyA9IGZ1bmN0aW9uIChzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzY2hlbWFJZHMgPSB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0UmVnaXN0ZXJlZFNjaGVtYUlkcyhmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEgPT09ICdodHRwJyB8fCBzY2hlbWEgPT09ICdodHRwcyc7IH0pO1xuICAgICAgICBzY2hlbWFJZHMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1hSWQpIHsgcmV0dXJuIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAga2luZDogQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSxcbiAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5nZXRMYWJlbEZvclZhbHVlKHNjaGVtYUlkKSxcbiAgICAgICAgICAgIGZpbHRlclRleHQ6IF90aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiBfdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoc2NoZW1hSWQsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IEluc2VydFRleHRGb3JtYXQuU25pcHBldCwgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldExhYmVsRm9yVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRGaWx0ZXJUZXh0Rm9yU25pcHBldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgJyQxJyk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0TGFiZWxGb3JTbmlwcGV0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICByZXR1cm4gbGFiZWwucmVwbGFjZSgvXFwkXFx7XFxkKzooW159XSspXFx9fFxcJFxcZCsvZywgJyQxJyk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1tcXFxcXFwkXFx9XS9nLCAnXFxcXCQmJyk7IC8vIGVzY2FwZSAkLCBcXCBhbmQgfSBcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsICdcXHQnKTtcbiAgICAgICAgaWYgKHRleHQgPT09ICd7fScpIHtcbiAgICAgICAgICAgIHJldHVybiAneyQxfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09PSAnW10nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1skMV0nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dCh0ZXh0ICsgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIHZhciByZXBsYWNlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUsICcnLCByZXBsYWNlcikgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBzZXBhcmF0b3JBZnRlcikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckezE6bnVsbH0nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICB2YXIgc25pcHBldFZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIHNuaXBwZXRWYWx1ZSA9IHNuaXBwZXRWYWx1ZS5zdWJzdHIoMSwgc25pcHBldFZhbHVlLmxlbmd0aCAtIDIpOyAvLyByZW1vdmUgcXVvdGVzXG4gICAgICAgICAgICAgICAgc25pcHBldFZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUGxhaW5UZXh0KHNuaXBwZXRWYWx1ZSk7IC8vIGVzY2FwZSBcXCBhbmQgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnXCIkezE6JyArIHNuaXBwZXRWYWx1ZSArICd9XCInICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICckezE6JyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICd9JyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldFN1Z2dlc3Rpb25LaW5kID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHR5cGU7XG4gICAgICAgICAgICB0eXBlID0gYXJyYXkubGVuZ3RoID4gMCA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBsZXRpb25JdGVtS2luZC5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWU7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZTtcbiAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5JzogcmV0dXJuIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5nZXRMYWJlbFRleHRGb3JNYXRjaGluZ05vZGUgPSBmdW5jdGlvbiAobm9kZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihub2RlLm9mZnNldCwgbm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZ2V0SW5zZXJ0VGV4dEZvck1hdGNoaW5nTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBkb2N1bWVudCwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoW10sIHNlcGFyYXRvckFmdGVyKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHt9LCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihub2RlLm9mZnNldCwgbm9kZS5sZW5ndGgpICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eSA9IGZ1bmN0aW9uIChrZXksIHByb3BlcnR5U2NoZW1hLCBhZGRWYWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5VGV4dCA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGtleSwgJycpO1xuICAgICAgICBpZiAoIWFkZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRUZXh0ID0gcHJvcGVydHlUZXh0ICsgJzogJztcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgblZhbHVlUHJvcG9zYWxzID0gMDtcbiAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hLmRlZmF1bHRTbmlwcGV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHNbMF0uYm9keTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChib2R5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUoYm9keSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0U25pcHBldHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BlcnR5U2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlICYmIHByb3BlcnR5U2NoZW1hLmVudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmVudW1bMF0sICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblZhbHVlUHJvcG9zYWxzICs9IHByb3BlcnR5U2NoZW1hLmVudW0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcm9wZXJ0eVNjaGVtYS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUocHJvcGVydHlTY2hlbWEuZGVmYXVsdCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLmV4YW1wbGVzKSAmJiBwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmV4YW1wbGVzWzBdLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoblZhbHVlUHJvcG9zYWxzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLnR5cGUpID8gcHJvcGVydHlTY2hlbWEudHlwZVswXSA6IHByb3BlcnR5U2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHlTY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyQxJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnXCIkMVwiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAneyQxfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnWyQxXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW50ZWdlcic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICckezE6MH0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJHsxOm51bGx9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBuVmFsdWVQcm9wb3NhbHMgPiAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICckMSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFRleHQgKyB2YWx1ZSArIHNlcGFyYXRvckFmdGVyO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmdldEN1cnJlbnRXb3JkID0gZnVuY3Rpb24gKGRvY3VtZW50LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGkgPSBvZmZzZXQgLSAxO1xuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiAnIFxcdFxcblxcclxcdlwiOntbLF19Jy5pbmRleE9mKHRleHQuY2hhckF0KGkpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoaSArIDEsIG9mZnNldCk7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuZXZhbHVhdGVTZXBhcmF0b3JBZnRlciA9IGZ1bmN0aW9uIChkb2N1bWVudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBzY2FubmVyID0gSnNvbi5jcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgdHJ1ZSk7XG4gICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24ob2Zmc2V0KTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgNSAvKiBDb21tYVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSAyIC8qIENsb3NlQnJhY2VUb2tlbiAqLzpcbiAgICAgICAgICAgIGNhc2UgNCAvKiBDbG9zZUJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgIGNhc2UgMTcgLyogRU9GICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcsJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmZpbmRJdGVtQXRPZmZzZXQgPSBmdW5jdGlvbiAobm9kZSwgZG9jdW1lbnQsIG9mZnNldCkge1xuICAgICAgICB2YXIgc2Nhbm5lciA9IEpzb24uY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLml0ZW1zO1xuICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNoaWxkLm9mZnNldCArIGNoaWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24oY2hpbGQub2Zmc2V0ICsgY2hpbGQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IDUgLyogQ29tbWFUb2tlbiAqLyAmJiBvZmZzZXQgPj0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvZmZzZXQgPj0gY2hpbGQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBKU09OQ29tcGxldGlvbi5wcm90b3R5cGUuaXNJbkNvbW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHNjYW5uZXIgPSBKc29uLmNyZWF0ZVNjYW5uZXIoZG9jdW1lbnQuZ2V0VGV4dCgpLCBmYWxzZSk7XG4gICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24oc3RhcnQpO1xuICAgICAgICB2YXIgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICE9PSAxNyAvKiBFT0YgKi8gJiYgKHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSA8IG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0b2tlbiA9PT0gMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgdG9rZW4gPT09IDEzIC8qIEJsb2NrQ29tbWVudFRyaXZpYSAqLykgJiYgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpIDw9IG9mZnNldDtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5mcm9tTWFya3VwID0gZnVuY3Rpb24gKG1hcmt1cFN0cmluZykge1xuICAgICAgICBpZiAobWFya3VwU3RyaW5nICYmIHRoaXMuZG9lc1N1cHBvcnRNYXJrZG93bigpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IE1hcmt1cEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcmt1cFN0cmluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSlNPTkNvbXBsZXRpb24ucHJvdG90eXBlLmRvZXNTdXBwb3J0TWFya2Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRoaXMuc3VwcG9ydHNNYXJrZG93bikpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV0aW9uID0gdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50ICYmIHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudC5jb21wbGV0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c01hcmtkb3duID0gY29tcGxldGlvbiAmJiBjb21wbGV0aW9uLmNvbXBsZXRpb25JdGVtICYmIEFycmF5LmlzQXJyYXkoY29tcGxldGlvbi5jb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uRm9ybWF0KSAmJiBjb21wbGV0aW9uLmNvbXBsZXRpb25JdGVtLmRvY3VtZW50YXRpb25Gb3JtYXQuaW5kZXhPZihNYXJrdXBLaW5kLk1hcmtkb3duKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNNYXJrZG93bjtcbiAgICB9O1xuICAgIEpTT05Db21wbGV0aW9uLnByb3RvdHlwZS5kb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycykpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV0aW9uID0gdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50ICYmIHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudC5jb21wbGV0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMgPSBjb21wbGV0aW9uICYmIGNvbXBsZXRpb24uY29tcGxldGlvbkl0ZW0gJiYgISFjb21wbGV0aW9uLmNvbXBsZXRpb25JdGVtLmNvbW1pdENoYXJhY3RlcnNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycztcbiAgICB9O1xuICAgIHJldHVybiBKU09OQ29tcGxldGlvbjtcbn0oKSk7XG5leHBvcnQgeyBKU09OQ29tcGxldGlvbiB9O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyL2pzb25QYXJzZXIuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9qc29uTGFuZ3VhZ2VUeXBlcy5qcyc7XG52YXIgSlNPTkhvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05Ib3ZlcihzY2hlbWFTZXJ2aWNlLCBjb250cmlidXRpb25zLCBwcm9taXNlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKGNvbnRyaWJ1dGlvbnMgPT09IHZvaWQgMCkgeyBjb250cmlidXRpb25zID0gW107IH1cbiAgICAgICAgdGhpcy5zY2hlbWFTZXJ2aWNlID0gc2NoZW1hU2VydmljZTtcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25zID0gY29udHJpYnV0aW9ucztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZUNvbnN0cnVjdG9yIHx8IFByb21pc2U7XG4gICAgfVxuICAgIEpTT05Ib3Zlci5wcm90b3R5cGUuZG9Ib3ZlciA9IGZ1bmN0aW9uIChkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQocG9zaXRpb24pO1xuICAgICAgICB2YXIgbm9kZSA9IGRvYy5nZXROb2RlRnJvbU9mZnNldChvZmZzZXQpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcgfHwgbm9kZS50eXBlID09PSAnYXJyYXknKSAmJiBvZmZzZXQgPiBub2RlLm9mZnNldCArIDEgJiYgb2Zmc2V0IDwgbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG92ZXJSYW5nZU5vZGUgPSBub2RlO1xuICAgICAgICAvLyB1c2UgdGhlIHByb3BlcnR5IGRlc2NyaXB0aW9uIHdoZW4gaG92ZXJpbmcgb3ZlciBhbiBvYmplY3Qga2V5XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvdmVyUmFuZ2UgPSBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChob3ZlclJhbmdlTm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KGhvdmVyUmFuZ2VOb2RlLm9mZnNldCArIGhvdmVyUmFuZ2VOb2RlLmxlbmd0aCkpO1xuICAgICAgICB2YXIgY3JlYXRlSG92ZXIgPSBmdW5jdGlvbiAoY29udGVudHMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudHM6IGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBob3ZlclJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gUGFyc2VyLmdldE5vZGVQYXRoKG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jb250cmlidXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgY29udHJpYnV0aW9uID0gdGhpcy5jb250cmlidXRpb25zW2ldO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBjb250cmlidXRpb24uZ2V0SW5mb0NvbnRyaWJ1dGlvbihkb2N1bWVudC51cmksIGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoaHRtbENvbnRlbnQpIHsgcmV0dXJuIGNyZWF0ZUhvdmVyKGh0bWxDb250ZW50KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZShkb2N1bWVudC51cmksIGRvYykudGhlbihmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICYmIG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hLCBub2RlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIHRpdGxlXzEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtkb3duRGVzY3JpcHRpb25fMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbl8xID0gdW5kZWZpbmVkLCBlbnVtVmFsdWVfMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMubm9kZSA9PT0gbm9kZSAmJiAhcy5pbnZlcnRlZCAmJiBzLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVfMSA9IHRpdGxlXzEgfHwgcy5zY2hlbWEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkRlc2NyaXB0aW9uXzEgPSBtYXJrZG93bkRlc2NyaXB0aW9uXzEgfHwgcy5zY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbiB8fCB0b01hcmtkb3duKHMuc2NoZW1hLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHMuc2NoZW1hLmVudW0uaW5kZXhPZihQYXJzZXIuZ2V0Tm9kZVZhbHVlKG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb25fMSA9IHMuc2NoZW1hLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzLnNjaGVtYS5lbnVtRGVzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb25fMSA9IHRvTWFya2Rvd24ocy5zY2hlbWEuZW51bURlc2NyaXB0aW9uc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWVfMSA9IHMuc2NoZW1hLmVudW1baWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnVtVmFsdWVfMSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1WYWx1ZV8xID0gSlNPTi5zdHJpbmdpZnkoZW51bVZhbHVlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodGl0bGVfMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0b01hcmtkb3duKHRpdGxlXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya2Rvd25EZXNjcmlwdGlvbl8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG1hcmtkb3duRGVzY3JpcHRpb25fMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImBcIiArIHRvTWFya2Rvd25Db2RlQmxvY2soZW51bVZhbHVlXzEpICsgXCJgOiBcIiArIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb25fMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUhvdmVyKFtyZXN1bHRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBKU09OSG92ZXI7XG59KCkpO1xuZXhwb3J0IHsgSlNPTkhvdmVyIH07XG5mdW5jdGlvbiB0b01hcmtkb3duKHBsYWluKSB7XG4gICAgaWYgKHBsYWluKSB7XG4gICAgICAgIHZhciByZXMgPSBwbGFpbi5yZXBsYWNlKC8oW15cXG5cXHJdKShcXHI/XFxuKShbXlxcblxccl0pL2dtLCAnJDFcXG5cXG4kMycpOyAvLyBzaW5nbGUgbmV3IGxpbmVzIHRvIFxcblxcbiAoTWFya2Rvd24gcGFyYWdyYXBoKVxuICAgICAgICByZXR1cm4gcmVzLnJlcGxhY2UoL1tcXFxcYCpfe31bXFxdKCkjK1xcLS4hXS9nLCBcIlxcXFwkJlwiKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdG9NYXJrZG93bkNvZGVCbG9jayhjb250ZW50KSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheCNwcmVjb2RlXG4gICAgaWYgKGNvbnRlbnQuaW5kZXhPZignYCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gJ2BgICcgKyBjb250ZW50ICsgJyBgYCc7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xufVxuIiwidmFyIExJQjtMSUI9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezQ3MDp0PT57ZnVuY3Rpb24gZSh0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0KSl9ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgcixuPVwiXCIsbz0wLGk9LTEsYT0wLGg9MDtoPD10Lmxlbmd0aDsrK2gpe2lmKGg8dC5sZW5ndGgpcj10LmNoYXJDb2RlQXQoaCk7ZWxzZXtpZig0Nz09PXIpYnJlYWs7cj00N31pZig0Nz09PXIpe2lmKGk9PT1oLTF8fDE9PT1hKTtlbHNlIGlmKGkhPT1oLTEmJjI9PT1hKXtpZihuLmxlbmd0aDwyfHwyIT09b3x8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTIpKWlmKG4ubGVuZ3RoPjIpe3ZhciBzPW4ubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT1uLmxlbmd0aC0xKXstMT09PXM/KG49XCJcIixvPTApOm89KG49bi5zbGljZSgwLHMpKS5sZW5ndGgtMS1uLmxhc3RJbmRleE9mKFwiL1wiKSxpPWgsYT0wO2NvbnRpbnVlfX1lbHNlIGlmKDI9PT1uLmxlbmd0aHx8MT09PW4ubGVuZ3RoKXtuPVwiXCIsbz0wLGk9aCxhPTA7Y29udGludWV9ZSYmKG4ubGVuZ3RoPjA/bis9XCIvLi5cIjpuPVwiLi5cIixvPTIpfWVsc2Ugbi5sZW5ndGg+MD9uKz1cIi9cIit0LnNsaWNlKGkrMSxoKTpuPXQuc2xpY2UoaSsxLGgpLG89aC1pLTE7aT1oLGE9MH1lbHNlIDQ2PT09ciYmLTEhPT1hPysrYTphPS0xfXJldHVybiBufXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LG49XCJcIixvPSExLGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhbztpLS0pe3ZhciBhO2k+PTA/YT1hcmd1bWVudHNbaV06KHZvaWQgMD09PXQmJih0PXByb2Nlc3MuY3dkKCkpLGE9dCksZShhKSwwIT09YS5sZW5ndGgmJihuPWErXCIvXCIrbixvPTQ3PT09YS5jaGFyQ29kZUF0KDApKX1yZXR1cm4gbj1yKG4sIW8pLG8/bi5sZW5ndGg+MD9cIi9cIituOlwiL1wiOm4ubGVuZ3RoPjA/bjpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO3ZhciBuPTQ3PT09dC5jaGFyQ29kZUF0KDApLG89NDc9PT10LmNoYXJDb2RlQXQodC5sZW5ndGgtMSk7cmV0dXJuIDAhPT0odD1yKHQsIW4pKS5sZW5ndGh8fG58fCh0PVwiLlwiKSx0Lmxlbmd0aD4wJiZvJiYodCs9XCIvXCIpLG4/XCIvXCIrdDp0fSxpc0Fic29sdXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlKHQpLHQubGVuZ3RoPjAmJjQ3PT09dC5jaGFyQ29kZUF0KDApfSxqb2luOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciB0LHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7KytyKXt2YXIgbz1hcmd1bWVudHNbcl07ZShvKSxvLmxlbmd0aD4wJiYodm9pZCAwPT09dD90PW86dCs9XCIvXCIrbyl9cmV0dXJuIHZvaWQgMD09PXQ/XCIuXCI6bi5ub3JtYWxpemUodCl9LHJlbGF0aXZlOmZ1bmN0aW9uKHQscil7aWYoZSh0KSxlKHIpLHQ9PT1yKXJldHVyblwiXCI7aWYoKHQ9bi5yZXNvbHZlKHQpKT09PShyPW4ucmVzb2x2ZShyKSkpcmV0dXJuXCJcIjtmb3IodmFyIG89MTtvPHQubGVuZ3RoJiY0Nz09PXQuY2hhckNvZGVBdChvKTsrK28pO2Zvcih2YXIgaT10Lmxlbmd0aCxhPWktbyxoPTE7aDxyLmxlbmd0aCYmNDc9PT1yLmNoYXJDb2RlQXQoaCk7KytoKTtmb3IodmFyIHM9ci5sZW5ndGgtaCxmPWE8cz9hOnMsdT0tMSxjPTA7Yzw9ZjsrK2Mpe2lmKGM9PT1mKXtpZihzPmYpe2lmKDQ3PT09ci5jaGFyQ29kZUF0KGgrYykpcmV0dXJuIHIuc2xpY2UoaCtjKzEpO2lmKDA9PT1jKXJldHVybiByLnNsaWNlKGgrYyl9ZWxzZSBhPmYmJig0Nz09PXQuY2hhckNvZGVBdChvK2MpP3U9YzowPT09YyYmKHU9MCkpO2JyZWFrfXZhciBsPXQuY2hhckNvZGVBdChvK2MpO2lmKGwhPT1yLmNoYXJDb2RlQXQoaCtjKSlicmVhazs0Nz09PWwmJih1PWMpfXZhciBwPVwiXCI7Zm9yKGM9byt1KzE7Yzw9aTsrK2MpYyE9PWkmJjQ3IT09dC5jaGFyQ29kZUF0KGMpfHwoMD09PXAubGVuZ3RoP3ArPVwiLi5cIjpwKz1cIi8uLlwiKTtyZXR1cm4gcC5sZW5ndGg+MD9wK3Iuc2xpY2UoaCt1KTooaCs9dSw0Nz09PXIuY2hhckNvZGVBdChoKSYmKytoLHIuc2xpY2UoaCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGRpcm5hbWU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciByPXQuY2hhckNvZGVBdCgwKSxuPTQ3PT09cixvPS0xLGk9ITAsYT10Lmxlbmd0aC0xO2E+PTE7LS1hKWlmKDQ3PT09KHI9dC5jaGFyQ29kZUF0KGEpKSl7aWYoIWkpe289YTticmVha319ZWxzZSBpPSExO3JldHVybi0xPT09bz9uP1wiL1wiOlwiLlwiOm4mJjE9PT1vP1wiLy9cIjp0LnNsaWNlKDAsbyl9LGJhc2VuYW1lOmZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZSh0KTt2YXIgbixvPTAsaT0tMSxhPSEwO2lmKHZvaWQgMCE9PXImJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD10Lmxlbmd0aCl7aWYoci5sZW5ndGg9PT10Lmxlbmd0aCYmcj09PXQpcmV0dXJuXCJcIjt2YXIgaD1yLmxlbmd0aC0xLHM9LTE7Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGY9dC5jaGFyQ29kZUF0KG4pO2lmKDQ3PT09Zil7aWYoIWEpe289bisxO2JyZWFrfX1lbHNlLTE9PT1zJiYoYT0hMSxzPW4rMSksaD49MCYmKGY9PT1yLmNoYXJDb2RlQXQoaCk/LTE9PS0taCYmKGk9bik6KGg9LTEsaT1zKSl9cmV0dXJuIG89PT1pP2k9czotMT09PWkmJihpPXQubGVuZ3RoKSx0LnNsaWNlKG8saSl9Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbilpZig0Nz09PXQuY2hhckNvZGVBdChuKSl7aWYoIWEpe289bisxO2JyZWFrfX1lbHNlLTE9PT1pJiYoYT0hMSxpPW4rMSk7cmV0dXJuLTE9PT1pP1wiXCI6dC5zbGljZShvLGkpfSxleHRuYW1lOmZ1bmN0aW9uKHQpe2UodCk7Zm9yKHZhciByPS0xLG49MCxvPS0xLGk9ITAsYT0wLGg9dC5sZW5ndGgtMTtoPj0wOy0taCl7dmFyIHM9dC5jaGFyQ29kZUF0KGgpO2lmKDQ3IT09cyktMT09PW8mJihpPSExLG89aCsxKSw0Nj09PXM/LTE9PT1yP3I9aDoxIT09YSYmKGE9MSk6LTEhPT1yJiYoYT0tMSk7ZWxzZSBpZighaSl7bj1oKzE7YnJlYWt9fXJldHVybi0xPT09cnx8LTE9PT1vfHwwPT09YXx8MT09PWEmJnI9PT1vLTEmJnI9PT1uKzE/XCJcIjp0LnNsaWNlKHIsbyl9LGZvcm1hdDpmdW5jdGlvbih0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kaXJ8fGUucm9vdCxuPWUuYmFzZXx8KGUubmFtZXx8XCJcIikrKGUuZXh0fHxcIlwiKTtyZXR1cm4gcj9yPT09ZS5yb290P3IrbjpyK1wiL1wiK246bn0oMCx0KX0scGFyc2U6ZnVuY3Rpb24odCl7ZSh0KTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gcjt2YXIgbixvPXQuY2hhckNvZGVBdCgwKSxpPTQ3PT09bztpPyhyLnJvb3Q9XCIvXCIsbj0xKTpuPTA7Zm9yKHZhciBhPS0xLGg9MCxzPS0xLGY9ITAsdT10Lmxlbmd0aC0xLGM9MDt1Pj1uOy0tdSlpZig0NyE9PShvPXQuY2hhckNvZGVBdCh1KSkpLTE9PT1zJiYoZj0hMSxzPXUrMSksNDY9PT1vPy0xPT09YT9hPXU6MSE9PWMmJihjPTEpOi0xIT09YSYmKGM9LTEpO2Vsc2UgaWYoIWYpe2g9dSsxO2JyZWFrfXJldHVybi0xPT09YXx8LTE9PT1zfHwwPT09Y3x8MT09PWMmJmE9PT1zLTEmJmE9PT1oKzE/LTEhPT1zJiYoci5iYXNlPXIubmFtZT0wPT09aCYmaT90LnNsaWNlKDEscyk6dC5zbGljZShoLHMpKTooMD09PWgmJmk/KHIubmFtZT10LnNsaWNlKDEsYSksci5iYXNlPXQuc2xpY2UoMSxzKSk6KHIubmFtZT10LnNsaWNlKGgsYSksci5iYXNlPXQuc2xpY2UoaCxzKSksci5leHQ9dC5zbGljZShhLHMpKSxoPjA/ci5kaXI9dC5zbGljZSgwLGgtMSk6aSYmKHIuZGlyPVwiL1wiKSxyfSxzZXA6XCIvXCIsZGVsaW1pdGVyOlwiOlwiLHdpbjMyOm51bGwscG9zaXg6bnVsbH07bi5wb3NpeD1uLHQuZXhwb3J0cz1ufSw0NDc6KHQsZSxyKT0+e3ZhciBuO2lmKHIucihlKSxyLmQoZSx7VVJJOigpPT5nLFV0aWxzOigpPT5PfSksXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3Mpbj1cIndpbjMyXCI9PT1wcm9jZXNzLnBsYXRmb3JtO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvcil7dmFyIG89bmF2aWdhdG9yLnVzZXJBZ2VudDtuPW8uaW5kZXhPZihcIldpbmRvd3NcIik+PTB9dmFyIGksYSxoPShpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKGk9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pfSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWkodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihyLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgcil9KSxzPS9eXFx3W1xcd1xcZCsuLV0qJC8sZj0vXlxcLy8sdT0vXlxcL1xcLy8sYz1cIlwiLGw9XCIvXCIscD0vXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LyxnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixuLG8saSl7dm9pZCAwPT09aSYmKGk9ITEpLFwib2JqZWN0XCI9PXR5cGVvZiB0Pyh0aGlzLnNjaGVtZT10LnNjaGVtZXx8Yyx0aGlzLmF1dGhvcml0eT10LmF1dGhvcml0eXx8Yyx0aGlzLnBhdGg9dC5wYXRofHxjLHRoaXMucXVlcnk9dC5xdWVyeXx8Yyx0aGlzLmZyYWdtZW50PXQuZnJhZ21lbnR8fGMpOih0aGlzLnNjaGVtZT1mdW5jdGlvbih0LGUpe3JldHVybiB0fHxlP3Q6XCJmaWxlXCJ9KHQsaSksdGhpcy5hdXRob3JpdHk9ZXx8Yyx0aGlzLnBhdGg9ZnVuY3Rpb24odCxlKXtzd2l0Y2godCl7Y2FzZVwiaHR0cHNcIjpjYXNlXCJodHRwXCI6Y2FzZVwiZmlsZVwiOmU/ZVswXSE9PWwmJihlPWwrZSk6ZT1sfXJldHVybiBlfSh0aGlzLnNjaGVtZSxyfHxjKSx0aGlzLnF1ZXJ5PW58fGMsdGhpcy5mcmFnbWVudD1vfHxjLGZ1bmN0aW9uKHQsZSl7aWYoIXQuc2NoZW1lJiZlKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCInK3QuYXV0aG9yaXR5KydcIiwgcGF0aDogXCInK3QucGF0aCsnXCIsIHF1ZXJ5OiBcIicrdC5xdWVyeSsnXCIsIGZyYWdtZW50OiBcIicrdC5mcmFnbWVudCsnXCJ9Jyk7aWYodC5zY2hlbWUmJiFzLnRlc3QodC5zY2hlbWUpKXRocm93IG5ldyBFcnJvcihcIltVcmlFcnJvcl06IFNjaGVtZSBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMuXCIpO2lmKHQucGF0aClpZih0LmF1dGhvcml0eSl7aWYoIWYudGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnQgbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIHNsYXNoIChcIi9cIikgY2hhcmFjdGVyJyl9ZWxzZSBpZih1LnRlc3QodC5wYXRoKSl0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpfSh0aGlzLGkpKX1yZXR1cm4gdC5pc1VyaT1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHR8fCEhZSYmXCJzdHJpbmdcIj09dHlwZW9mIGUuYXV0aG9yaXR5JiZcInN0cmluZ1wiPT10eXBlb2YgZS5mcmFnbWVudCYmXCJzdHJpbmdcIj09dHlwZW9mIGUucGF0aCYmXCJzdHJpbmdcIj09dHlwZW9mIGUucXVlcnkmJlwic3RyaW5nXCI9PXR5cGVvZiBlLnNjaGVtZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mc1BhdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUud2l0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS50b1N0cmluZ30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZnNQYXRoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBDKHRoaXMsITEpfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLndpdGg9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIHRoaXM7dmFyIGU9dC5zY2hlbWUscj10LmF1dGhvcml0eSxuPXQucGF0aCxvPXQucXVlcnksaT10LmZyYWdtZW50O3JldHVybiB2b2lkIDA9PT1lP2U9dGhpcy5zY2hlbWU6bnVsbD09PWUmJihlPWMpLHZvaWQgMD09PXI/cj10aGlzLmF1dGhvcml0eTpudWxsPT09ciYmKHI9Yyksdm9pZCAwPT09bj9uPXRoaXMucGF0aDpudWxsPT09biYmKG49Yyksdm9pZCAwPT09bz9vPXRoaXMucXVlcnk6bnVsbD09PW8mJihvPWMpLHZvaWQgMD09PWk/aT10aGlzLmZyYWdtZW50Om51bGw9PT1pJiYoaT1jKSxlPT09dGhpcy5zY2hlbWUmJnI9PT10aGlzLmF1dGhvcml0eSYmbj09PXRoaXMucGF0aCYmbz09PXRoaXMucXVlcnkmJmk9PT10aGlzLmZyYWdtZW50P3RoaXM6bmV3IHYoZSxyLG4sbyxpKX0sdC5wYXJzZT1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj1wLmV4ZWModCk7cmV0dXJuIHI/bmV3IHYoclsyXXx8Yyx4KHJbNF18fGMpLHgocls1XXx8YykseChyWzddfHxjKSx4KHJbOV18fGMpLGUpOm5ldyB2KGMsYyxjLGMsYyl9LHQuZmlsZT1mdW5jdGlvbih0KXt2YXIgZT1jO2lmKG4mJih0PXQucmVwbGFjZSgvXFxcXC9nLGwpKSx0WzBdPT09bCYmdFsxXT09PWwpe3ZhciByPXQuaW5kZXhPZihsLDIpOy0xPT09cj8oZT10LnN1YnN0cmluZygyKSx0PWwpOihlPXQuc3Vic3RyaW5nKDIsciksdD10LnN1YnN0cmluZyhyKXx8bCl9cmV0dXJuIG5ldyB2KFwiZmlsZVwiLGUsdCxjLGMpfSx0LmZyb209ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB2KHQuc2NoZW1lLHQuYXV0aG9yaXR5LHQucGF0aCx0LnF1ZXJ5LHQuZnJhZ21lbnQpfSx0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLEEodGhpcyx0KX0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHQucmV2aXZlPWZ1bmN0aW9uKGUpe2lmKGUpe2lmKGUgaW5zdGFuY2VvZiB0KXJldHVybiBlO3ZhciByPW5ldyB2KGUpO3JldHVybiByLl9mb3JtYXR0ZWQ9ZS5leHRlcm5hbCxyLl9mc1BhdGg9ZS5fc2VwPT09ZD9lLmZzUGF0aDpudWxsLHJ9cmV0dXJuIGV9LHR9KCksZD1uPzE6dm9pZCAwLHY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5fZm9ybWF0dGVkPW51bGwsZS5fZnNQYXRoPW51bGwsZX1yZXR1cm4gaChlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImZzUGF0aFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZnNQYXRofHwodGhpcy5fZnNQYXRoPUModGhpcywhMSkpLHRoaXMuX2ZzUGF0aH0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLHQ/QSh0aGlzLCEwKToodGhpcy5fZm9ybWF0dGVkfHwodGhpcy5fZm9ybWF0dGVkPUEodGhpcywhMSkpLHRoaXMuX2Zvcm1hdHRlZCl9LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3ZhciB0PXskbWlkOjF9O3JldHVybiB0aGlzLl9mc1BhdGgmJih0LmZzUGF0aD10aGlzLl9mc1BhdGgsdC5fc2VwPWQpLHRoaXMuX2Zvcm1hdHRlZCYmKHQuZXh0ZXJuYWw9dGhpcy5fZm9ybWF0dGVkKSx0aGlzLnBhdGgmJih0LnBhdGg9dGhpcy5wYXRoKSx0aGlzLnNjaGVtZSYmKHQuc2NoZW1lPXRoaXMuc2NoZW1lKSx0aGlzLmF1dGhvcml0eSYmKHQuYXV0aG9yaXR5PXRoaXMuYXV0aG9yaXR5KSx0aGlzLnF1ZXJ5JiYodC5xdWVyeT10aGlzLnF1ZXJ5KSx0aGlzLmZyYWdtZW50JiYodC5mcmFnbWVudD10aGlzLmZyYWdtZW50KSx0fSxlfShnKSxtPSgoYT17fSlbNThdPVwiJTNBXCIsYVs0N109XCIlMkZcIixhWzYzXT1cIiUzRlwiLGFbMzVdPVwiJTIzXCIsYVs5MV09XCIlNUJcIixhWzkzXT1cIiU1RFwiLGFbNjRdPVwiJTQwXCIsYVszM109XCIlMjFcIixhWzM2XT1cIiUyNFwiLGFbMzhdPVwiJTI2XCIsYVszOV09XCIlMjdcIixhWzQwXT1cIiUyOFwiLGFbNDFdPVwiJTI5XCIsYVs0Ml09XCIlMkFcIixhWzQzXT1cIiUyQlwiLGFbNDRdPVwiJTJDXCIsYVs1OV09XCIlM0JcIixhWzYxXT1cIiUzRFwiLGFbMzJdPVwiJTIwXCIsYSk7ZnVuY3Rpb24geSh0LGUpe2Zvcih2YXIgcj12b2lkIDAsbj0tMSxvPTA7bzx0Lmxlbmd0aDtvKyspe3ZhciBpPXQuY2hhckNvZGVBdChvKTtpZihpPj05NyYmaTw9MTIyfHxpPj02NSYmaTw9OTB8fGk+PTQ4JiZpPD01N3x8NDU9PT1pfHw0Nj09PWl8fDk1PT09aXx8MTI2PT09aXx8ZSYmNDc9PT1pKS0xIT09biYmKHIrPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhuLG8pKSxuPS0xKSx2b2lkIDAhPT1yJiYocis9dC5jaGFyQXQobykpO2Vsc2V7dm9pZCAwPT09ciYmKHI9dC5zdWJzdHIoMCxvKSk7dmFyIGE9bVtpXTt2b2lkIDAhPT1hPygtMSE9PW4mJihyKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcobixvKSksbj0tMSkscis9YSk6LTE9PT1uJiYobj1vKX19cmV0dXJuLTEhPT1uJiYocis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKG4pKSksdm9pZCAwIT09cj9yOnR9ZnVuY3Rpb24gYih0KXtmb3IodmFyIGU9dm9pZCAwLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dC5jaGFyQ29kZUF0KHIpOzM1PT09bnx8NjM9PT1uPyh2b2lkIDA9PT1lJiYoZT10LnN1YnN0cigwLHIpKSxlKz1tW25dKTp2b2lkIDAhPT1lJiYoZSs9dFtyXSl9cmV0dXJuIHZvaWQgMCE9PWU/ZTp0fWZ1bmN0aW9uIEModCxlKXt2YXIgcjtyZXR1cm4gcj10LmF1dGhvcml0eSYmdC5wYXRoLmxlbmd0aD4xJiZcImZpbGVcIj09PXQuc2NoZW1lP1wiLy9cIit0LmF1dGhvcml0eSt0LnBhdGg6NDc9PT10LnBhdGguY2hhckNvZGVBdCgwKSYmKHQucGF0aC5jaGFyQ29kZUF0KDEpPj02NSYmdC5wYXRoLmNoYXJDb2RlQXQoMSk8PTkwfHx0LnBhdGguY2hhckNvZGVBdCgxKT49OTcmJnQucGF0aC5jaGFyQ29kZUF0KDEpPD0xMjIpJiY1OD09PXQucGF0aC5jaGFyQ29kZUF0KDIpP2U/dC5wYXRoLnN1YnN0cigxKTp0LnBhdGhbMV0udG9Mb3dlckNhc2UoKSt0LnBhdGguc3Vic3RyKDIpOnQucGF0aCxuJiYocj1yLnJlcGxhY2UoL1xcLy9nLFwiXFxcXFwiKSkscn1mdW5jdGlvbiBBKHQsZSl7dmFyIHI9ZT9iOnksbj1cIlwiLG89dC5zY2hlbWUsaT10LmF1dGhvcml0eSxhPXQucGF0aCxoPXQucXVlcnkscz10LmZyYWdtZW50O2lmKG8mJihuKz1vLG4rPVwiOlwiKSwoaXx8XCJmaWxlXCI9PT1vKSYmKG4rPWwsbis9bCksaSl7dmFyIGY9aS5pbmRleE9mKFwiQFwiKTtpZigtMSE9PWYpe3ZhciB1PWkuc3Vic3RyKDAsZik7aT1pLnN1YnN0cihmKzEpLC0xPT09KGY9dS5pbmRleE9mKFwiOlwiKSk/bis9cih1LCExKToobis9cih1LnN1YnN0cigwLGYpLCExKSxuKz1cIjpcIixuKz1yKHUuc3Vic3RyKGYrMSksITEpKSxuKz1cIkBcIn0tMT09PShmPShpPWkudG9Mb3dlckNhc2UoKSkuaW5kZXhPZihcIjpcIikpP24rPXIoaSwhMSk6KG4rPXIoaS5zdWJzdHIoMCxmKSwhMSksbis9aS5zdWJzdHIoZikpfWlmKGEpe2lmKGEubGVuZ3RoPj0zJiY0Nz09PWEuY2hhckNvZGVBdCgwKSYmNTg9PT1hLmNoYXJDb2RlQXQoMikpKGM9YS5jaGFyQ29kZUF0KDEpKT49NjUmJmM8PTkwJiYoYT1cIi9cIitTdHJpbmcuZnJvbUNoYXJDb2RlKGMrMzIpK1wiOlwiK2Euc3Vic3RyKDMpKTtlbHNlIGlmKGEubGVuZ3RoPj0yJiY1OD09PWEuY2hhckNvZGVBdCgxKSl7dmFyIGM7KGM9YS5jaGFyQ29kZUF0KDApKT49NjUmJmM8PTkwJiYoYT1TdHJpbmcuZnJvbUNoYXJDb2RlKGMrMzIpK1wiOlwiK2Euc3Vic3RyKDIpKX1uKz1yKGEsITApfXJldHVybiBoJiYobis9XCI/XCIsbis9cihoLCExKSkscyYmKG4rPVwiI1wiLG4rPWU/czp5KHMsITEpKSxufWZ1bmN0aW9uIHcodCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodCl9Y2F0Y2goZSl7cmV0dXJuIHQubGVuZ3RoPjM/dC5zdWJzdHIoMCwzKSt3KHQuc3Vic3RyKDMpKTp0fX12YXIgXz0vKCVbMC05QS1aYS16XVswLTlBLVphLXpdKSsvZztmdW5jdGlvbiB4KHQpe3JldHVybiB0Lm1hdGNoKF8pP3QucmVwbGFjZShfLChmdW5jdGlvbih0KXtyZXR1cm4gdyh0KX0pKTp0fXZhciBPLFA9cig0NzApLGo9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTAscj1hcmd1bWVudHMubGVuZ3RoO2U8cjtlKyspdCs9YXJndW1lbnRzW2VdLmxlbmd0aDt2YXIgbj1BcnJheSh0KSxvPTA7Zm9yKGU9MDtlPHI7ZSsrKWZvcih2YXIgaT1hcmd1bWVudHNbZV0sYT0wLGg9aS5sZW5ndGg7YTxoO2ErKyxvKyspbltvXT1pW2FdO3JldHVybiBufSxVPVAucG9zaXh8fFA7IWZ1bmN0aW9uKHQpe3Quam9pblBhdGg9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWVbci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIHQud2l0aCh7cGF0aDpVLmpvaW4uYXBwbHkoVSxqKFt0LnBhdGhdLGUpKX0pfSx0LnJlc29sdmVQYXRoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO3ZhciBuPXQucGF0aHx8XCIvXCI7cmV0dXJuIHQud2l0aCh7cGF0aDpVLnJlc29sdmUuYXBwbHkoVSxqKFtuXSxlKSl9KX0sdC5kaXJuYW1lPWZ1bmN0aW9uKHQpe3ZhciBlPVUuZGlybmFtZSh0LnBhdGgpO3JldHVybiAxPT09ZS5sZW5ndGgmJjQ2PT09ZS5jaGFyQ29kZUF0KDApP3Q6dC53aXRoKHtwYXRoOmV9KX0sdC5iYXNlbmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gVS5iYXNlbmFtZSh0LnBhdGgpfSx0LmV4dG5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIFUuZXh0bmFtZSh0LnBhdGgpfX0oT3x8KE89e30pKX19LGU9e307ZnVuY3Rpb24gcihuKXtpZihlW25dKXJldHVybiBlW25dLmV4cG9ydHM7dmFyIG89ZVtuXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbbl0obyxvLmV4cG9ydHMsciksby5leHBvcnRzfXJldHVybiByLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlyLm8oZSxuKSYmIXIubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksci5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyKDQ0Nyl9KSgpO2V4cG9ydCBjb25zdHtVUkksVXRpbHN9PUxJQjtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgQ29weXJpZ2h0IChjKSAyMDEzLCBOaWNrIEZpdHpnZXJhbGRcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTkNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWdleChnbG9iLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICAgIH1cbiAgICB2YXIgc3RyID0gU3RyaW5nKGdsb2IpO1xuICAgIC8vIFRoZSByZWdleHAgd2UgYXJlIGJ1aWxkaW5nLCBhcyBhIHN0cmluZy5cbiAgICB2YXIgcmVTdHIgPSBcIlwiO1xuICAgIC8vIFdoZXRoZXIgd2UgYXJlIG1hdGNoaW5nIHNvIGNhbGxlZCBcImV4dGVuZGVkXCIgZ2xvYnMgKGxpa2UgYmFzaCkgYW5kIHNob3VsZFxuICAgIC8vIHN1cHBvcnQgc2luZ2xlIGNoYXJhY3RlciBtYXRjaGluZywgbWF0Y2hpbmcgcmFuZ2VzIG9mIGNoYXJhY3RlcnMsIGdyb3VwXG4gICAgLy8gbWF0Y2hpbmcsIGV0Yy5cbiAgICB2YXIgZXh0ZW5kZWQgPSBvcHRzID8gISFvcHRzLmV4dGVuZGVkIDogZmFsc2U7XG4gICAgLy8gV2hlbiBnbG9ic3RhciBpcyBfZmFsc2VfIChkZWZhdWx0KSwgJy9mb28vKicgaXMgdHJhbnNsYXRlZCBhIHJlZ2V4cCBsaWtlXG4gICAgLy8gJ15cXC9mb29cXC8uKiQnIHdoaWNoIHdpbGwgbWF0Y2ggYW55IHN0cmluZyBiZWdpbm5pbmcgd2l0aCAnL2Zvby8nXG4gICAgLy8gV2hlbiBnbG9ic3RhciBpcyBfdHJ1ZV8sICcvZm9vLyonIGlzIHRyYW5zbGF0ZWQgdG8gcmVnZXhwIGxpa2VcbiAgICAvLyAnXlxcL2Zvb1xcL1teL10qJCcgd2hpY2ggd2lsbCBtYXRjaCBhbnkgc3RyaW5nIGJlZ2lubmluZyB3aXRoICcvZm9vLycgQlVUXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgaGF2ZSBhICcvJyB0byB0aGUgcmlnaHQgb2YgaXQuXG4gICAgLy8gRS5nLiB3aXRoICcvZm9vLyonIHRoZXNlIHdpbGwgbWF0Y2g6ICcvZm9vL2JhcicsICcvZm9vL2Jhci50eHQnIGJ1dFxuICAgIC8vIHRoZXNlIHdpbGwgbm90ICcvZm9vL2Jhci9iYXonLCAnL2Zvby9iYXIvYmF6LnR4dCdcbiAgICAvLyBMYXN0ZWx5LCB3aGVuIGdsb2JzdGFyIGlzIF90cnVlXywgJy9mb28vKionIGlzIGVxdWl2ZWxhbnQgdG8gJy9mb28vKicgd2hlblxuICAgIC8vIGdsb2JzdGFyIGlzIF9mYWxzZV9cbiAgICB2YXIgZ2xvYnN0YXIgPSBvcHRzID8gISFvcHRzLmdsb2JzdGFyIDogZmFsc2U7XG4gICAgLy8gSWYgd2UgYXJlIGRvaW5nIGV4dGVuZGVkIG1hdGNoaW5nLCB0aGlzIGJvb2xlYW4gaXMgdHJ1ZSB3aGVuIHdlIGFyZSBpbnNpZGVcbiAgICAvLyBhIGdyb3VwIChlZyB7Ki5odG1sLCouanN9KSwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICB2YXIgaW5Hcm91cCA9IGZhbHNlO1xuICAgIC8vIFJlZ0V4cCBmbGFncyAoZWcgXCJpXCIgKSB0byBwYXNzIGluIHRvIFJlZ0V4cCBjb25zdHJ1Y3Rvci5cbiAgICB2YXIgZmxhZ3MgPSBvcHRzICYmIHR5cGVvZiAob3B0cy5mbGFncykgPT09IFwic3RyaW5nXCIgPyBvcHRzLmZsYWdzIDogXCJcIjtcbiAgICB2YXIgYztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGMgPSBzdHJbaV07XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgICAgICAgICByZVN0ciArPSBcIlxcXFxcIiArIGM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcIi5cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcIihcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Hcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgICAgICBpZiAoaW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcInxcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiXFxcXFwiICsgYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgLy8gTW92ZSBvdmVyIGFsbCBjb25zZWN1dGl2ZSBcIipcIidzLlxuICAgICAgICAgICAgICAgIC8vIEFsc28gc3RvcmUgdGhlIHByZXZpb3VzIGFuZCBuZXh0IGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICB2YXIgcHJldkNoYXIgPSBzdHJbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFyQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJbaSArIDFdID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBzdHJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghZ2xvYnN0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgaXMgZGlzYWJsZWQsIHNvIHRyZWF0IGFueSBudW1iZXIgb2YgXCIqXCIgYXMgb25lXG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiLipcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdsb2JzdGFyIGlzIGVuYWJsZWQsIHNvIGRldGVybWluZSBpZiB0aGlzIGlzIGEgZ2xvYnN0YXIgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNHbG9ic3RhciA9IHN0YXJDb3VudCA+IDEgLy8gbXVsdGlwbGUgXCIqXCInc1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHByZXZDaGFyID09PSBcIi9cIiB8fCBwcmV2Q2hhciA9PT0gdW5kZWZpbmVkIHx8IHByZXZDaGFyID09PSAneycgfHwgcHJldkNoYXIgPT09ICcsJykgLy8gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChuZXh0Q2hhciA9PT0gXCIvXCIgfHwgbmV4dENoYXIgPT09IHVuZGVmaW5lZCB8fCBuZXh0Q2hhciA9PT0gJywnIHx8IG5leHRDaGFyID09PSAnfScpOyAvLyB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0dsb2JzdGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrOyAvLyBtb3ZlIG92ZXIgdGhlIFwiL1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2Q2hhciA9PT0gJy8nICYmIHJlU3RyLmVuZHNXaXRoKCdcXFxcLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVTdHIgPSByZVN0ci5zdWJzdHIoMCwgcmVTdHIubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgZ2xvYnN0YXIsIHNvIG1hdGNoIHplcm8gb3IgbW9yZSBwYXRoIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcIigoPzpbXi9dKig/OlxcL3wkKSkqKVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgYSBnbG9ic3Rhciwgc28gb25seSBtYXRjaCBvbmUgcGF0aCBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICByZVN0ciArPSBcIihbXi9dKilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVTdHIgKz0gYztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXaGVuIHJlZ2V4cCAnZycgZmxhZyBpcyBzcGVjaWZpZWQgZG9uJ3RcbiAgICAvLyBjb25zdHJhaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIF4gJiAkXG4gICAgaWYgKCFmbGFncyB8fCAhfmZsYWdzLmluZGV4T2YoJ2cnKSkge1xuICAgICAgICByZVN0ciA9IFwiXlwiICsgcmVTdHIgKyBcIiRcIjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVTdHIsIGZsYWdzKTtcbn1cbjtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuLy4uLy4uL2pzb25jLXBhcnNlci9tYWluLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4vLi4vLi4vdnNjb2RlLXVyaS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBTdHJpbmdzIGZyb20gJy4uL3V0aWxzL3N0cmluZ3MuanMnO1xuaW1wb3J0ICogYXMgUGFyc2VyIGZyb20gJy4uL3BhcnNlci9qc29uUGFyc2VyLmpzJztcbmltcG9ydCAqIGFzIG5scyBmcm9tICcuLy4uLy4uLy4uL2ZpbGxlcnMvdnNjb2RlLW5scy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZWdleCB9IGZyb20gJy4uL3V0aWxzL2dsb2IuanMnO1xudmFyIGxvY2FsaXplID0gbmxzLmxvYWRNZXNzYWdlQnVuZGxlKCk7XG52YXIgQkFORyA9ICchJztcbnZhciBQQVRIX1NFUCA9ICcvJztcbnZhciBGaWxlUGF0dGVybkFzc29jaWF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ocGF0dGVybiwgdXJpcykge1xuICAgICAgICB0aGlzLmdsb2JXcmFwcGVycyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXR0ZXJuXzEgPSBwYXR0ZXJuOyBfaSA8IHBhdHRlcm5fMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVyblN0cmluZyA9IHBhdHRlcm5fMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGluY2x1ZGUgPSBwYXR0ZXJuU3RyaW5nWzBdICE9PSBCQU5HO1xuICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RyaW5nID0gcGF0dGVyblN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5TdHJpbmdbMF0gPT09IFBBVEhfU0VQKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RyaW5nID0gcGF0dGVyblN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iV3JhcHBlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleHA6IGNyZWF0ZVJlZ2V4KCcqKi8nICsgcGF0dGVyblN0cmluZywgeyBleHRlbmRlZDogdHJ1ZSwgZ2xvYnN0YXI6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiBpbmNsdWRlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLnVyaXMgPSB1cmlzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JXcmFwcGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy51cmlzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbi5wcm90b3R5cGUubWF0Y2hlc1BhdHRlcm4gPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmdsb2JXcmFwcGVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwgcmVnZXhwID0gX2IucmVnZXhwLCBpbmNsdWRlID0gX2IuaW5jbHVkZTtcbiAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGluY2x1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH07XG4gICAgRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbi5wcm90b3R5cGUuZ2V0VVJJcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJpcztcbiAgICB9O1xuICAgIHJldHVybiBGaWxlUGF0dGVybkFzc29jaWF0aW9uO1xufSgpKTtcbnZhciBTY2hlbWFIYW5kbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NoZW1hSGFuZGxlKHNlcnZpY2UsIHVybCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0ge307XG4gICAgICAgIGlmICh1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdGhpcy5zZXJ2aWNlLnByb21pc2UucmVzb2x2ZShuZXcgVW5yZXNvbHZlZFNjaGVtYSh1bnJlc29sdmVkU2NoZW1hQ29udGVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNjaGVtYUhhbmRsZS5wcm90b3R5cGUuZ2V0VW5yZXNvbHZlZFNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVucmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5sb2FkU2NoZW1hKHRoaXMudXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bnJlc29sdmVkU2NoZW1hO1xuICAgIH07XG4gICAgU2NoZW1hSGFuZGxlLnByb3RvdHlwZS5nZXRSZXNvbHZlZFNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkU2NoZW1hID0gdGhpcy5nZXRVbnJlc29sdmVkU2NoZW1hKCkudGhlbihmdW5jdGlvbiAodW5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJ2aWNlLnJlc29sdmVTY2hlbWFDb250ZW50KHVucmVzb2x2ZWQsIF90aGlzLnVybCwgX3RoaXMuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkU2NoZW1hO1xuICAgIH07XG4gICAgU2NoZW1hSGFuZGxlLnByb3RvdHlwZS5jbGVhclNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy51bnJlc29sdmVkU2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IHt9O1xuICAgIH07XG4gICAgcmV0dXJuIFNjaGVtYUhhbmRsZTtcbn0oKSk7XG52YXIgVW5yZXNvbHZlZFNjaGVtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnJlc29sdmVkU2NoZW1hKHNjaGVtYSwgZXJyb3JzKSB7XG4gICAgICAgIGlmIChlcnJvcnMgPT09IHZvaWQgMCkgeyBlcnJvcnMgPSBbXTsgfVxuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBVbnJlc29sdmVkU2NoZW1hO1xufSgpKTtcbmV4cG9ydCB7IFVucmVzb2x2ZWRTY2hlbWEgfTtcbnZhciBSZXNvbHZlZFNjaGVtYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvbHZlZFNjaGVtYShzY2hlbWEsIGVycm9ycykge1xuICAgICAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHsgZXJyb3JzID0gW107IH1cbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICBSZXNvbHZlZFNjaGVtYS5wcm90b3R5cGUuZ2V0U2VjdGlvbiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBzY2hlbWFSZWYgPSB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgdGhpcy5zY2hlbWEpO1xuICAgICAgICBpZiAoc2NoZW1hUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VyLmFzU2NoZW1hKHNjaGVtYVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFJlc29sdmVkU2NoZW1hLnByb3RvdHlwZS5nZXRTZWN0aW9uUmVjdXJzaXZlID0gZnVuY3Rpb24gKHBhdGgsIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXNjaGVtYSB8fCB0eXBlb2Ygc2NoZW1hID09PSAnYm9vbGVhbicgfHwgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLnByb3BlcnRpZXNbbmV4dF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gU3RyaW5ncy5leHRlbmRlZFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV4dC5tYXRjaCgnWzAtOV0rJykpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChuZXh0LCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihpbmRleCkgJiYgc2NoZW1hLml0ZW1zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5pdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc29sdmVkU2NoZW1hO1xufSgpKTtcbmV4cG9ydCB7IFJlc29sdmVkU2NoZW1hIH07XG52YXIgSlNPTlNjaGVtYVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlNjaGVtYVNlcnZpY2UocmVxdWVzdFNlcnZpY2UsIGNvbnRleHRTZXJ2aWNlLCBwcm9taXNlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0U2VydmljZSA9IGNvbnRleHRTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJlcXVlc3RTZXJ2aWNlID0gcmVxdWVzdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yID0gcHJvbWlzZUNvbnN0cnVjdG9yIHx8IFByb21pc2U7XG4gICAgICAgIHRoaXMuY2FsbE9uRGlzcG9zZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250cmlidXRpb25Bc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHMgPSB7fTtcbiAgICB9XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmdldFJlZ2lzdGVyZWRTY2hlbWFJZHMgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1lID0gVVJJLnBhcnNlKGlkKS5zY2hlbWU7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1lICE9PSAnc2NoZW1hc2VydmljZScgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKHNjaGVtZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUsIFwicHJvbWlzZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNhbGxPbkRpc3Bvc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsT25EaXNwb3NlLnBvcCgpKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5vblJlc291cmNlQ2hhbmdlID0gZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB1cmkgPSBub3JtYWxpemVJZCh1cmkpO1xuICAgICAgICB2YXIgdG9XYWxrID0gW3VyaV07XG4gICAgICAgIHZhciBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLnNjaGVtYXNCeUlkKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMuc2NoZW1hc0J5SWRba2V5XTsgfSk7XG4gICAgICAgIHdoaWxlICh0b1dhbGsubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY3VyciA9IHRvV2Fsay5wb3AoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFsbFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlICYmIChoYW5kbGUudXJsID09PSBjdXJyIHx8IGhhbmRsZS5kZXBlbmRlbmNpZXNbY3Vycl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUudXJsICE9PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChoYW5kbGUudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2xlYXJTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZXM7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUuc2V0U2NoZW1hQ29udHJpYnV0aW9ucyA9IGZ1bmN0aW9uIChzY2hlbWFDb250cmlidXRpb25zKSB7XG4gICAgICAgIGlmIChzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFzID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzO1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gc2NoZW1hcykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkSWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cmlidXRpb25TY2hlbWFzW25vcm1hbGl6ZWRJZF0gPSB0aGlzLmFkZFNjaGVtYUhhbmRsZShub3JtYWxpemVkSWQsIHNjaGVtYXNbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYUFzc29jaWF0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFBc3NvY2lhdGlvbnMgPSBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYUFzc29jaWF0aW9ucztcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2NoZW1hQXNzb2NpYXRpb25zXzEgPSBzY2hlbWFBc3NvY2lhdGlvbnM7IF9pIDwgc2NoZW1hQXNzb2NpYXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYUFzc29jaWF0aW9uID0gc2NoZW1hQXNzb2NpYXRpb25zXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciB1cmlzID0gc2NoZW1hQXNzb2NpYXRpb24udXJpcy5tYXAobm9ybWFsaXplSWQpO1xuICAgICAgICAgICAgICAgIHZhciBhc3NvY2lhdGlvbiA9IHRoaXMuYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihzY2hlbWFBc3NvY2lhdGlvbi5wYXR0ZXJuLCB1cmlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbkFzc29jaWF0aW9ucy5wdXNoKGFzc29jaWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmFkZFNjaGVtYUhhbmRsZSA9IGZ1bmN0aW9uIChpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHNjaGVtYUhhbmRsZSA9IG5ldyBTY2hlbWFIYW5kbGUodGhpcywgaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KTtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSBzY2hlbWFIYW5kbGU7XG4gICAgICAgIHJldHVybiBzY2hlbWFIYW5kbGU7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUuZ2V0T3JBZGRTY2hlbWFIYW5kbGUgPSBmdW5jdGlvbiAoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYXNCeUlkW2lkXSB8fCB0aGlzLmFkZFNjaGVtYUhhbmRsZShpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpO1xuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmFkZEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24gPSBmdW5jdGlvbiAocGF0dGVybiwgdXJpcykge1xuICAgICAgICB2YXIgZnBhID0gbmV3IEZpbGVQYXR0ZXJuQXNzb2NpYXRpb24ocGF0dGVybiwgdXJpcyk7XG4gICAgICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMucHVzaChmcGEpO1xuICAgICAgICByZXR1cm4gZnBhO1xuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEgPSBmdW5jdGlvbiAodXJpLCBmaWxlUGF0dGVybnMsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHZhciBpZCA9IG5vcm1hbGl6ZUlkKHVyaSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGZpbGVQYXR0ZXJucykge1xuICAgICAgICAgICAgdGhpcy5hZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uKGZpbGVQYXR0ZXJucywgW3VyaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnJlc29sdmVkU2NoZW1hQ29udGVudCA/IHRoaXMuYWRkU2NoZW1hSGFuZGxlKGlkLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkgOiB0aGlzLmdldE9yQWRkU2NoZW1hSGFuZGxlKGlkKTtcbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5jbGVhckV4dGVybmFsU2NoZW1hcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFzQnlJZCA9IHt9O1xuICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFNjaGVtYXNJZHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jb250cmlidXRpb25TY2hlbWFzKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYXNCeUlkW2lkXSA9IHRoaXMuY29udHJpYnV0aW9uU2NoZW1hc1tpZF07XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRTY2hlbWFzSWRzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNvbnRyaWJ1dGlvbkFzc29jaWF0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5maWxlUGF0dGVybkFzc29jaWF0aW9ucy5wdXNoKGNvbnRyaWJ1dGlvbkFzc29jaWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmdldFJlc29sdmVkU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYUlkKSB7XG4gICAgICAgIHZhciBpZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYUlkKTtcbiAgICAgICAgdmFyIHNjaGVtYUhhbmRsZSA9IHRoaXMuc2NoZW1hc0J5SWRbaWRdO1xuICAgICAgICBpZiAoc2NoZW1hSGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hSGFuZGxlLmdldFJlc29sdmVkU2NoZW1hKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUubG9hZFNjaGVtYSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RTZXJ2aWNlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gbG9jYWxpemUoJ2pzb24uc2NoZW1hLm5vcmVxdWVzdHNlcnZpY2UnLCAnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnLiBObyBzY2hlbWEgcmVxdWVzdCBzZXJ2aWNlIGF2YWlsYWJsZScsIHRvRGlzcGxheVN0cmluZyh1cmwpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShuZXcgVW5yZXNvbHZlZFNjaGVtYSh7fSwgW2Vycm9yTWVzc2FnZV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U2VydmljZSh1cmwpLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBsb2NhbGl6ZSgnanNvbi5zY2hlbWEubm9jb250ZW50JywgJ1VuYWJsZSB0byBsb2FkIHNjaGVtYSBmcm9tIFxcJ3swfVxcJzogTm8gY29udGVudC4nLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHt9LCBbZXJyb3JNZXNzYWdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NoZW1hQ29udGVudCA9IHt9O1xuICAgICAgICAgICAgdmFyIGpzb25FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHNjaGVtYUNvbnRlbnQgPSBKc29uLnBhcnNlKGNvbnRlbnQsIGpzb25FcnJvcnMpO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IGpzb25FcnJvcnMubGVuZ3RoID8gW2xvY2FsaXplKCdqc29uLnNjaGVtYS5pbnZhbGlkRm9ybWF0JywgJ1VuYWJsZSB0byBwYXJzZSBjb250ZW50IGZyb20gXFwnezB9XFwnOiBQYXJzZSBlcnJvciBhdCBvZmZzZXQgezF9LicsIHRvRGlzcGxheVN0cmluZyh1cmwpLCBqc29uRXJyb3JzWzBdLm9mZnNldCldIDogW107XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVucmVzb2x2ZWRTY2hlbWEoc2NoZW1hQ29udGVudCwgZXJyb3JzKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBlcnJvclNwbGl0ID0gZXJyb3IudG9TdHJpbmcoKS5zcGxpdCgnRXJyb3I6ICcpO1xuICAgICAgICAgICAgaWYgKGVycm9yU3BsaXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIG1vcmUgY29uY2lzZSBlcnJvciBtZXNzYWdlLCBVUkwgYW5kIGNvbnRleHQgYXJlIGF0dGFjaGVkIGJ5IGNhbGxlciBhbnl3YXlzXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JTcGxpdFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTdHJpbmdzLmVuZHNXaXRoKGVycm9yTWVzc2FnZSwgJy4nKSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZS5zdWJzdHIoMCwgZXJyb3JNZXNzYWdlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHt9LCBbbG9jYWxpemUoJ2pzb24uc2NoZW1hLm5vY29udGVudCcsICdVbmFibGUgdG8gbG9hZCBzY2hlbWEgZnJvbSBcXCd7MH1cXCc6IHsxfS4nLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSwgZXJyb3JNZXNzYWdlKV0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlU2NoZW1hQ29udGVudCA9IGZ1bmN0aW9uIChzY2hlbWFUb1Jlc29sdmUsIHNjaGVtYVVSTCwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXNvbHZlRXJyb3JzID0gc2NoZW1hVG9SZXNvbHZlLmVycm9ycy5zbGljZSgwKTtcbiAgICAgICAgdmFyIHNjaGVtYSA9IHNjaGVtYVRvUmVzb2x2ZS5zY2hlbWE7XG4gICAgICAgIGlmIChzY2hlbWEuJHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIGlkID0gbm9ybWFsaXplSWQoc2NoZW1hLiRzY2hlbWEpO1xuICAgICAgICAgICAgaWYgKGlkID09PSAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wMy9zY2hlbWEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKG5ldyBSZXNvbHZlZFNjaGVtYSh7fSwgW2xvY2FsaXplKCdqc29uLnNjaGVtYS5kcmFmdDAzLm5vdHN1cHBvcnRlZCcsIFwiRHJhZnQtMDMgc2NoZW1hcyBhcmUgbm90IHN1cHBvcnRlZC5cIildKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ2h0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMTktMDkvc2NoZW1hJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVFcnJvcnMucHVzaChsb2NhbGl6ZSgnanNvbi5zY2hlbWEuZHJhZnQyMDE5MDkubm90c3VwcG9ydGVkJywgXCJEcmFmdCAyMDE5LTA5IHNjaGVtYXMgYXJlIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHRTZXJ2aWNlID0gdGhpcy5jb250ZXh0U2VydmljZTtcbiAgICAgICAgdmFyIGZpbmRTZWN0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gc2NoZW1hO1xuICAgICAgICAgICAgaWYgKHBhdGhbMF0gPT09ICcvJykge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGguc3BsaXQoJy8nKS5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IHBhcnQucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdO1xuICAgICAgICAgICAgICAgIHJldHVybiAhY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZVJvb3QsIHNvdXJjZVVSSSwgcmVmU2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSByZWZTZWdtZW50ID8gZGVjb2RlVVJJQ29tcG9uZW50KHJlZlNlZ21lbnQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBmaW5kU2VjdGlvbihzb3VyY2VSb290LCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb24uaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc2VjdGlvbltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUVycm9ycy5wdXNoKGxvY2FsaXplKCdqc29uLnNjaGVtYS5pbnZhbGlkcmVmJywgJyRyZWYgXFwnezB9XFwnIGluIFxcJ3sxfVxcJyBjYW4gbm90IGJlIHJlc29sdmVkLicsIHBhdGgsIHNvdXJjZVVSSSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzb2x2ZUV4dGVybmFsTGluayA9IGZ1bmN0aW9uIChub2RlLCB1cmksIHJlZlNlZ21lbnQsIHBhcmVudFNjaGVtYVVSTCwgcGFyZW50U2NoZW1hRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFNlcnZpY2UgJiYgIS9eW0EtWmEtel1bQS1aYS16MC05K1xcLS4rXSo6XFwvXFwvLiovLnRlc3QodXJpKSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IGNvbnRleHRTZXJ2aWNlLnJlc29sdmVSZWxhdGl2ZVBhdGgodXJpLCBwYXJlbnRTY2hlbWFVUkwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJpID0gbm9ybWFsaXplSWQodXJpKTtcbiAgICAgICAgICAgIHZhciByZWZlcmVuY2VkSGFuZGxlID0gX3RoaXMuZ2V0T3JBZGRTY2hlbWFIYW5kbGUodXJpKTtcbiAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VkSGFuZGxlLmdldFVucmVzb2x2ZWRTY2hlbWEoKS50aGVuKGZ1bmN0aW9uICh1bnJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50U2NoZW1hRGVwZW5kZW5jaWVzW3VyaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkU2NoZW1hLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvYyA9IHJlZlNlZ21lbnQgPyB1cmkgKyAnIycgKyByZWZTZWdtZW50IDogdXJpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlRXJyb3JzLnB1c2gobG9jYWxpemUoJ2pzb24uc2NoZW1hLnByb2JsZW1sb2FkaW5ncmVmJywgJ1Byb2JsZW1zIGxvYWRpbmcgcmVmZXJlbmNlIFxcJ3swfVxcJzogezF9JywgbG9jLCB1bnJlc29sdmVkU2NoZW1hLmVycm9yc1swXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXJnZShub2RlLCB1bnJlc29sdmVkU2NoZW1hLnNjaGVtYSwgdXJpLCByZWZTZWdtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZnMobm9kZSwgdW5yZXNvbHZlZFNjaGVtYS5zY2hlbWEsIHVyaSwgcmVmZXJlbmNlZEhhbmRsZS5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNvbHZlUmVmcyA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnRTY2hlbWEsIHBhcmVudFNjaGVtYVVSTCwgcGFyZW50U2NoZW1hRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b1dhbGsgPSBbbm9kZV07XG4gICAgICAgICAgICB2YXIgc2VlbiA9IFtdO1xuICAgICAgICAgICAgdmFyIG9wZW5Qcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvbGxlY3RFbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9hIDwgZW50cmllc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzXzFbX2FdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0TWFwRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBtYXBzXzEgPSBtYXBzOyBfYSA8IG1hcHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IG1hcHNfMVtfYV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBtYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0QXJyYXlFbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcnJheXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBhcnJheXNfMSA9IGFycmF5czsgX2EgPCBhcnJheXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzXzFbX2FdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgYXJyYXlfMSA9IGFycmF5OyBfYiA8IGFycmF5XzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gYXJyYXlfMVtfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgaGFuZGxlUmVmID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VlblJlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dC4kcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBuZXh0LiRyZWY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHJlZi5zcGxpdCgnIycsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbmV4dC4kcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlblByb21pc2VzLnB1c2gocmVzb2x2ZUV4dGVybmFsTGluayhuZXh0LCBzZWdtZW50c1swXSwgc2VnbWVudHNbMV0sIHBhcmVudFNjaGVtYVVSTCwgcGFyZW50U2NoZW1hRGVwZW5kZW5jaWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VlblJlZnMuaW5kZXhPZihyZWYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlKG5leHQsIHBhcmVudFNjaGVtYSwgcGFyZW50U2NoZW1hVVJMLCBzZWdtZW50c1sxXSk7IC8vIGNhbiBzZXQgbmV4dC4kcmVmIGFnYWluLCB1c2Ugc2VlblJlZnMgdG8gYXZvaWQgY2lyY2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlblJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3RFbnRyaWVzKG5leHQuaXRlbXMsIG5leHQuYWRkaXRpb25hbEl0ZW1zLCBuZXh0LmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBuZXh0Lm5vdCwgbmV4dC5jb250YWlucywgbmV4dC5wcm9wZXJ0eU5hbWVzLCBuZXh0LmlmLCBuZXh0LnRoZW4sIG5leHQuZWxzZSk7XG4gICAgICAgICAgICAgICAgY29sbGVjdE1hcEVudHJpZXMobmV4dC5kZWZpbml0aW9ucywgbmV4dC5wcm9wZXJ0aWVzLCBuZXh0LnBhdHRlcm5Qcm9wZXJ0aWVzLCBuZXh0LmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgY29sbGVjdEFycmF5RW50cmllcyhuZXh0LmFueU9mLCBuZXh0LmFsbE9mLCBuZXh0Lm9uZU9mLCBuZXh0Lml0ZW1zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAodG9XYWxrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdG9XYWxrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZVJlZihuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9taXNlLmFsbChvcGVuUHJvbWlzZXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZnMoc2NoZW1hLCBzY2hlbWEsIHNjaGVtYVVSTCwgZGVwZW5kZW5jaWVzKS50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBuZXcgUmVzb2x2ZWRTY2hlbWEoc2NoZW1hLCByZXNvbHZlRXJyb3JzKTsgfSk7XG4gICAgfTtcbiAgICBKU09OU2NoZW1hU2VydmljZS5wcm90b3R5cGUuZ2V0U2NoZW1hRm9yUmVzb3VyY2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGRvY3VtZW50KSB7XG4gICAgICAgIC8vIGZpcnN0IHVzZSAkc2NoZW1hIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LnJvb3QgJiYgZG9jdW1lbnQucm9vdC50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIHNjaGVtYVByb3BlcnRpZXMgPSBkb2N1bWVudC5yb290LnByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiAocC5rZXlOb2RlLnZhbHVlID09PSAnJHNjaGVtYScpICYmIHAudmFsdWVOb2RlICYmIHAudmFsdWVOb2RlLnR5cGUgPT09ICdzdHJpbmcnOyB9KTtcbiAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVOb2RlID0gc2NoZW1hUHJvcGVydGllc1swXS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSAmJiB2YWx1ZU5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjaGVtZUlkID0gUGFyc2VyLmdldE5vZGVWYWx1ZSh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lSWQgJiYgU3RyaW5ncy5zdGFydHNXaXRoKHNjaGVtZUlkLCAnLicpICYmIHRoaXMuY29udGV4dFNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZUlkID0gdGhpcy5jb250ZXh0U2VydmljZS5yZXNvbHZlUmVsYXRpdmVQYXRoKHNjaGVtZUlkLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBub3JtYWxpemVJZChzY2hlbWVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShpZCkuZ2V0UmVzb2x2ZWRTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSAmJiB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlLnJlc291cmNlID09PSByZXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UucmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgc2NoZW1hcyA9IFtdO1xuICAgICAgICB2YXIgbm9ybWFsaXplZFJlc291cmNlID0gbm9ybWFsaXplUmVzb3VyY2VGb3JNYXRjaGluZyhyZXNvdXJjZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKGVudHJ5Lm1hdGNoZXNQYXR0ZXJuKG5vcm1hbGl6ZWRSZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZW50cnkuZ2V0VVJJcygpOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hSWQgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlbltzY2hlbWFJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYXMucHVzaChzY2hlbWFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW3NjaGVtYUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc29sdmVkU2NoZW1hID0gc2NoZW1hcy5sZW5ndGggPiAwID8gdGhpcy5jcmVhdGVDb21iaW5lZFNjaGVtYShyZXNvdXJjZSwgc2NoZW1hcykuZ2V0UmVzb2x2ZWRTY2hlbWEoKSA6IHRoaXMucHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB7IHJlc291cmNlOiByZXNvdXJjZSwgcmVzb2x2ZWRTY2hlbWE6IHJlc29sdmVkU2NoZW1hIH07XG4gICAgICAgIHJldHVybiByZXNvbHZlZFNjaGVtYTtcbiAgICB9O1xuICAgIEpTT05TY2hlbWFTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVDb21iaW5lZFNjaGVtYSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgc2NoZW1hSWRzKSB7XG4gICAgICAgIGlmIChzY2hlbWFJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShzY2hlbWFJZHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkU2NoZW1hSWQgPSAnc2NoZW1hc2VydmljZTovL2NvbWJpbmVkU2NoZW1hLycgKyBlbmNvZGVVUklDb21wb25lbnQocmVzb3VyY2UpO1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkU2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGFsbE9mOiBzY2hlbWFJZHMubWFwKGZ1bmN0aW9uIChzY2hlbWFJZCkgeyByZXR1cm4gKHsgJHJlZjogc2NoZW1hSWQgfSk7IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2NoZW1hSGFuZGxlKGNvbWJpbmVkU2NoZW1hSWQsIGNvbWJpbmVkU2NoZW1hKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTlNjaGVtYVNlcnZpY2UucHJvdG90eXBlLmdldE1hdGNoaW5nU2NoZW1hcyA9IGZ1bmN0aW9uIChkb2N1bWVudCwganNvbkRvY3VtZW50LCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIGlkID0gc2NoZW1hLmlkIHx8ICgnc2NoZW1hc2VydmljZTovL3VudGl0bGVkL21hdGNoaW5nU2NoZW1hcy8nICsgaWRDb3VudGVyKyspO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVNjaGVtYUNvbnRlbnQobmV3IFVucmVzb2x2ZWRTY2hlbWEoc2NoZW1hKSwgaWQsIHt9KS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uRG9jdW1lbnQuZ2V0TWF0Y2hpbmdTY2hlbWFzKHJlc29sdmVkU2NoZW1hLnNjaGVtYSkuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAhcy5pbnZlcnRlZDsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY2hlbWFGb3JSZXNvdXJjZShkb2N1bWVudC51cmksIGpzb25Eb2N1bWVudCkudGhlbihmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25Eb2N1bWVudC5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSkuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAhcy5pbnZlcnRlZDsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05TY2hlbWFTZXJ2aWNlO1xufSgpKTtcbmV4cG9ydCB7IEpTT05TY2hlbWFTZXJ2aWNlIH07XG52YXIgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nICcjJywgbm9ybWFsaXplIGRyaXZlIGNhcGl0YWxpemF0aW9uXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFVSSS5wYXJzZShpZCkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlc291cmNlRm9yTWF0Y2hpbmcocmVzb3VyY2UpIHtcbiAgICAvLyByZW1vdmUgcXVlcmllcyBhbmQgZnJhZ21lbnRzLCBub3JtYWxpemUgZHJpdmUgY2FwaXRhbGl6YXRpb25cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHJlc291cmNlKS53aXRoKHsgZnJhZ21lbnQ6IG51bGwsIHF1ZXJ5OiBudWxsIH0pLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0Rpc3BsYXlTdHJpbmcodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHVyaSA9IFVSSS5wYXJzZSh1cmwpO1xuICAgICAgICBpZiAodXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpLmZzUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgVW5yZXNvbHZlZFNjaGVtYSB9IGZyb20gJy4vanNvblNjaGVtYVNlcnZpY2UuanMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBEaWFnbm9zdGljLCBEaWFnbm9zdGljU2V2ZXJpdHksIFJhbmdlIH0gZnJvbSAnLi4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xuaW1wb3J0ICogYXMgbmxzIGZyb20gJy4vLi4vLi4vLi4vZmlsbGVycy92c2NvZGUtbmxzLmpzJztcbmltcG9ydCB7IGlzQm9vbGVhbiB9IGZyb20gJy4uL3V0aWxzL29iamVjdHMuanMnO1xudmFyIGxvY2FsaXplID0gbmxzLmxvYWRNZXNzYWdlQnVuZGxlKCk7XG52YXIgSlNPTlZhbGlkYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlZhbGlkYXRpb24oanNvblNjaGVtYVNlcnZpY2UsIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlID0ganNvblNjaGVtYVNlcnZpY2U7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIEpTT05WYWxpZGF0aW9uLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkVuYWJsZWQgPSByYXcudmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb21tZW50U2V2ZXJpdHkgPSByYXcuYWxsb3dDb21tZW50cyA/IHVuZGVmaW5lZCA6IERpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTlZhbGlkYXRpb24ucHJvdG90eXBlLmRvVmFsaWRhdGlvbiA9IGZ1bmN0aW9uICh0ZXh0RG9jdW1lbnQsIGpzb25Eb2N1bWVudCwgZG9jdW1lbnRTZXR0aW5ncywgc2NoZW1hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlhZ25vc3RpY3MgPSBbXTtcbiAgICAgICAgdmFyIGFkZGVkID0ge307XG4gICAgICAgIHZhciBhZGRQcm9ibGVtID0gZnVuY3Rpb24gKHByb2JsZW0pIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVkIG1lc3NhZ2VzXG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gcHJvYmxlbS5yYW5nZS5zdGFydC5saW5lICsgJyAnICsgcHJvYmxlbS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgKyAnICcgKyBwcm9ibGVtLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIWFkZGVkW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgICBhZGRlZFtzaWduYXR1cmVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKHByb2JsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0RGlhZ25vc3RpY3MgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgdHJhaWxpbmdDb21tYVNldmVyaXR5ID0gKGRvY3VtZW50U2V0dGluZ3MgPT09IG51bGwgfHwgZG9jdW1lbnRTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnRTZXR0aW5ncy50cmFpbGluZ0NvbW1hcykgPyB0b0RpYWdub3N0aWNTZXZlcml0eShkb2N1bWVudFNldHRpbmdzLnRyYWlsaW5nQ29tbWFzKSA6IERpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgICAgIHZhciBjb21tZW50U2V2ZXJpdHkgPSAoZG9jdW1lbnRTZXR0aW5ncyA9PT0gbnVsbCB8fCBkb2N1bWVudFNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudFNldHRpbmdzLmNvbW1lbnRzKSA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3MuY29tbWVudHMpIDogX3RoaXMuY29tbWVudFNldmVyaXR5O1xuICAgICAgICAgICAgdmFyIHNjaGVtYVZhbGlkYXRpb24gPSAoZG9jdW1lbnRTZXR0aW5ncyA9PT0gbnVsbCB8fCBkb2N1bWVudFNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudFNldHRpbmdzLnNjaGVtYVZhbGlkYXRpb24pID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5zY2hlbWFWYWxpZGF0aW9uKSA6IERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICAgICAgdmFyIHNjaGVtYVJlcXVlc3QgPSAoZG9jdW1lbnRTZXR0aW5ncyA9PT0gbnVsbCB8fCBkb2N1bWVudFNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2N1bWVudFNldHRpbmdzLnNjaGVtYVJlcXVlc3QpID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5zY2hlbWFSZXF1ZXN0KSA6IERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuZXJyb3JzLmxlbmd0aCAmJiBqc29uRG9jdW1lbnQucm9vdCAmJiBzY2hlbWFSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3RSb290ID0ganNvbkRvY3VtZW50LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFzdFJvb3QudHlwZSA9PT0gJ29iamVjdCcgPyBhc3RSb290LnByb3BlcnRpZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSAnJHNjaGVtYScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcHJvcGVydHkudmFsdWVOb2RlIHx8IHByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUHJvYmxlbShEaWFnbm9zdGljLmNyZWF0ZShyYW5nZSwgc2NoZW1hLmVycm9yc1swXSwgc2NoZW1hUmVxdWVzdCwgRXJyb3JDb2RlLlNjaGVtYVJlc29sdmVFcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGFzdFJvb3Qub2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoYXN0Um9vdC5vZmZzZXQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKERpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBzY2hlbWEuZXJyb3JzWzBdLCBzY2hlbWFSZXF1ZXN0LCBFcnJvckNvZGUuU2NoZW1hUmVzb2x2ZUVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VtYW50aWNFcnJvcnMgPSBqc29uRG9jdW1lbnQudmFsaWRhdGUodGV4dERvY3VtZW50LCBzY2hlbWEuc2NoZW1hLCBzY2hlbWFWYWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbWFudGljRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW1hbnRpY0Vycm9ycy5mb3JFYWNoKGFkZFByb2JsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFBbGxvd3NDb21tZW50cyhzY2hlbWEuc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50U2V2ZXJpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFBbGxvd3NUcmFpbGluZ0NvbW1hcyhzY2hlbWEuc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1hU2V2ZXJpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGpzb25Eb2N1bWVudC5zeW50YXhFcnJvcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHAuY29kZSA9PT0gRXJyb3JDb2RlLlRyYWlsaW5nQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFpbGluZ0NvbW1hU2V2ZXJpdHkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwLnNldmVyaXR5ID0gdHJhaWxpbmdDb21tYVNldmVyaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tZW50U2V2ZXJpdHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VfMSA9IGxvY2FsaXplKCdJbnZhbGlkQ29tbWVudFRva2VuJywgJ0NvbW1lbnRzIGFyZSBub3QgcGVybWl0dGVkIGluIEpTT04uJyk7XG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50LmNvbW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUHJvYmxlbShEaWFnbm9zdGljLmNyZWF0ZShjLCBtZXNzYWdlXzEsIGNvbW1lbnRTZXZlcml0eSwgRXJyb3JDb2RlLkNvbW1lbnROb3RQZXJtaXR0ZWQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIGlkID0gc2NoZW1hLmlkIHx8ICgnc2NoZW1hc2VydmljZTovL3VudGl0bGVkLycgKyBpZENvdW50ZXIrKyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5qc29uU2NoZW1hU2VydmljZS5yZXNvbHZlU2NoZW1hQ29udGVudChuZXcgVW5yZXNvbHZlZFNjaGVtYShzY2hlbWEpLCBpZCwge30pLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldERpYWdub3N0aWNzKHJlc29sdmVkU2NoZW1hKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlLmdldFNjaGVtYUZvclJlc291cmNlKHRleHREb2N1bWVudC51cmksIGpzb25Eb2N1bWVudCkudGhlbihmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGlhZ25vc3RpY3Moc2NoZW1hKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTlZhbGlkYXRpb247XG59KCkpO1xuZXhwb3J0IHsgSlNPTlZhbGlkYXRpb24gfTtcbnZhciBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc2NoZW1hQWxsb3dzQ29tbWVudHMoc2NoZW1hUmVmKSB7XG4gICAgaWYgKHNjaGVtYVJlZiAmJiB0eXBlb2Ygc2NoZW1hUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYVJlZi5hbGxvd0NvbW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFSZWYuYWxsT2YpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzY2hlbWFSZWYuYWxsT2Y7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsb3cgPSBzY2hlbWFBbGxvd3NDb21tZW50cyhzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4oYWxsb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYVJlZikge1xuICAgIGlmIChzY2hlbWFSZWYgJiYgdHlwZW9mIHNjaGVtYVJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihzY2hlbWFSZWYuYWxsb3dUcmFpbGluZ0NvbW1hcykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWFSZWYuYWxsb3dUcmFpbGluZ0NvbW1hcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwclNjaGVtYVJlZiA9IHNjaGVtYVJlZjtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihkZXByU2NoZW1hUmVmWydhbGxvd3NUcmFpbGluZ0NvbW1hcyddKSkgeyAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByZXR1cm4gZGVwclNjaGVtYVJlZlsnYWxsb3dzVHJhaWxpbmdDb21tYXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hUmVmLmFsbE9mKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc2NoZW1hUmVmLmFsbE9mOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzY2hlbWEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGFsbG93ID0gc2NoZW1hQWxsb3dzVHJhaWxpbmdDb21tYXMoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCb29sZWFuKGFsbG93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eUxldmVsKSB7XG4gICAgc3dpdGNoIChzZXZlcml0eUxldmVsKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzogcmV0dXJuIERpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgY2FzZSAnd2FybmluZyc6IHJldHVybiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgY2FzZSAnaWdub3JlJzogcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIERpZ2l0MCA9IDQ4O1xudmFyIERpZ2l0OSA9IDU3O1xudmFyIEEgPSA2NTtcbnZhciBhID0gOTc7XG52YXIgZiA9IDEwMjtcbmV4cG9ydCBmdW5jdGlvbiBoZXhEaWdpdChjaGFyQ29kZSkge1xuICAgIGlmIChjaGFyQ29kZSA8IERpZ2l0MCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlIDw9IERpZ2l0OSkge1xuICAgICAgICByZXR1cm4gY2hhckNvZGUgLSBEaWdpdDA7XG4gICAgfVxuICAgIGlmIChjaGFyQ29kZSA8IGEpIHtcbiAgICAgICAgY2hhckNvZGUgKz0gKGEgLSBBKTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlID49IGEgJiYgY2hhckNvZGUgPD0gZikge1xuICAgICAgICByZXR1cm4gY2hhckNvZGUgLSBhICsgMTA7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yRnJvbUhleCh0ZXh0KSB7XG4gICAgaWYgKHRleHRbMF0gIT09ICcjJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVkOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDEpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgZ3JlZW46IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMikpICogMHgxMSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDMpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYWxwaGE6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVkOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDEpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgZ3JlZW46IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMikpICogMHgxMSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDMpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYWxwaGE6IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNCkpICogMHgxMSkgLyAyNTUuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVkOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDEpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDMpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNCkpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGJsdWU6IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNSkpICogMHgxMCArIGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCg2KSkpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYWxwaGE6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVkOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDEpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoMikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDMpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNCkpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGJsdWU6IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNSkpICogMHgxMCArIGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCg2KSkpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYWxwaGE6IChoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNykpICogMHgxMCArIGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCg4KSkpIC8gMjU1LjBcbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY29sb3JGcm9tMjU2UkdCKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAxLjA7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IHJlZCAvIDI1NS4wLFxuICAgICAgICBncmVlbjogZ3JlZW4gLyAyNTUuMCxcbiAgICAgICAgYmx1ZTogYmx1ZSAvIDI1NS4wLFxuICAgICAgICBhbHBoYTogYWxwaGFcbiAgICB9O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyL2pzb25QYXJzZXIuanMnO1xuaW1wb3J0ICogYXMgU3RyaW5ncyBmcm9tICcuLi91dGlscy9zdHJpbmdzLmpzJztcbmltcG9ydCB7IGNvbG9yRnJvbUhleCB9IGZyb20gJy4uL3V0aWxzL2NvbG9ycy5qcyc7XG5pbXBvcnQgeyBSYW5nZSwgVGV4dEVkaXQsIFN5bWJvbEtpbmQsIExvY2F0aW9uIH0gZnJvbSBcIi4uL2pzb25MYW5ndWFnZVR5cGVzLmpzXCI7XG52YXIgSlNPTkRvY3VtZW50U3ltYm9scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09ORG9jdW1lbnRTeW1ib2xzKHNjaGVtYVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFTZXJ2aWNlID0gc2NoZW1hU2VydmljZTtcbiAgICB9XG4gICAgSlNPTkRvY3VtZW50U3ltYm9scy5wcm90b3R5cGUuZmluZERvY3VtZW50U3ltYm9scyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgZG9jLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IHsgcmVzdWx0TGltaXQ6IE51bWJlci5NQVhfVkFMVUUgfTsgfVxuICAgICAgICB2YXIgcm9vdCA9IGRvYy5yb290O1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGltaXQgPSBjb250ZXh0LnJlc3VsdExpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGtleSBiaW5kaW5nc1xuICAgICAgICB2YXIgcmVzb3VyY2VTdHJpbmcgPSBkb2N1bWVudC51cmk7XG4gICAgICAgIGlmICgocmVzb3VyY2VTdHJpbmcgPT09ICd2c2NvZGU6Ly9kZWZhdWx0c2V0dGluZ3Mva2V5YmluZGluZ3MuanNvbicpIHx8IFN0cmluZ3MuZW5kc1dpdGgocmVzb3VyY2VTdHJpbmcudG9Mb3dlckNhc2UoKSwgJy91c2VyL2tleWJpbmRpbmdzLmpzb24nKSkge1xuICAgICAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSByb290Lml0ZW1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBpdGVtLnByb3BlcnRpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSAna2V5JyAmJiBwcm9wZXJ0eS52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEucHVzaCh7IG5hbWU6IFBhcnNlci5nZXROb2RlVmFsdWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogU3ltYm9sS2luZC5GdW5jdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b1Zpc2l0ID0gW1xuICAgICAgICAgICAgeyBub2RlOiByb290LCBjb250YWluZXJOYW1lOiAnJyB9XG4gICAgICAgIF07XG4gICAgICAgIHZhciBuZXh0VG9WaXNpdCA9IDA7XG4gICAgICAgIHZhciBsaW1pdEV4Y2VlZGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGNvbGxlY3RPdXRsaW5lRW50cmllcyA9IGZ1bmN0aW9uIChub2RlLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyBub2RlOiBub2RlLCBjb250YWluZXJOYW1lOiBjb250YWluZXJOYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU5vZGUgPSBwcm9wZXJ0eS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IExvY2F0aW9uLmNyZWF0ZShkb2N1bWVudC51cmksIGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lID8gY29udGFpbmVyTmFtZSArICcuJyArIHByb3BlcnR5LmtleU5vZGUudmFsdWUgOiBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogX3RoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiBfdGhpcy5nZXRTeW1ib2xLaW5kKHZhbHVlTm9kZS50eXBlKSwgbG9jYXRpb246IGxvY2F0aW9uLCBjb250YWluZXJOYW1lOiBjb250YWluZXJOYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IG5vZGU6IHZhbHVlTm9kZSwgY29udGFpbmVyTmFtZTogY2hpbGRDb250YWluZXJOYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gYnJlYXRoIGZpcnN0IHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobmV4dFRvVmlzaXQgPCB0b1Zpc2l0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0b1Zpc2l0W25leHRUb1Zpc2l0KytdO1xuICAgICAgICAgICAgY29sbGVjdE91dGxpbmVFbnRyaWVzKG5leHQubm9kZSwgbmV4dC5jb250YWluZXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXRFeGNlZWRlZCAmJiBjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudFN5bWJvbHMucHJvdG90eXBlLmZpbmREb2N1bWVudFN5bWJvbHMyID0gZnVuY3Rpb24gKGRvY3VtZW50LCBkb2MsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0geyByZXN1bHRMaW1pdDogTnVtYmVyLk1BWF9WQUxVRSB9OyB9XG4gICAgICAgIHZhciByb290ID0gZG9jLnJvb3Q7XG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW1pdCA9IGNvbnRleHQucmVzdWx0TGltaXQgfHwgTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3Iga2V5IGJpbmRpbmdzXG4gICAgICAgIHZhciByZXNvdXJjZVN0cmluZyA9IGRvY3VtZW50LnVyaTtcbiAgICAgICAgaWYgKChyZXNvdXJjZVN0cmluZyA9PT0gJ3ZzY29kZTovL2RlZmF1bHRzZXR0aW5ncy9rZXliaW5kaW5ncy5qc29uJykgfHwgU3RyaW5ncy5lbmRzV2l0aChyZXNvdXJjZVN0cmluZy50b0xvd2VyQ2FzZSgpLCAnL3VzZXIva2V5YmluZGluZ3MuanNvbicpKSB7XG4gICAgICAgICAgICBpZiAocm9vdC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8yID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHJvb3QuaXRlbXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGl0ZW0ucHJvcGVydGllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LmtleU5vZGUudmFsdWUgPT09ICdrZXknICYmIHByb3BlcnR5LnZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eS5rZXlOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzIucHVzaCh7IG5hbWU6IFBhcnNlci5nZXROb2RlVmFsdWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogU3ltYm9sS2luZC5GdW5jdGlvbiwgcmFuZ2U6IHJhbmdlLCBzZWxlY3Rpb25SYW5nZTogc2VsZWN0aW9uUmFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKHJlc291cmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdG9WaXNpdCA9IFtcbiAgICAgICAgICAgIHsgbm9kZTogcm9vdCwgcmVzdWx0OiByZXN1bHQgfVxuICAgICAgICBdO1xuICAgICAgICB2YXIgbmV4dFRvVmlzaXQgPSAwO1xuICAgICAgICB2YXIgbGltaXRFeGNlZWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgY29sbGVjdE91dGxpbmVFbnRyaWVzID0gZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHsgbmFtZTogbmFtZSwga2luZDogX3RoaXMuZ2V0U3ltYm9sS2luZChub2RlLnR5cGUpLCByYW5nZTogcmFuZ2UsIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZSwgY2hpbGRyZW46IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyByZXN1bHQ6IHN5bWJvbC5jaGlsZHJlbiwgbm9kZTogbm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZU5vZGUgPSBwcm9wZXJ0eS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5LmtleU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSB7IG5hbWU6IF90aGlzLmdldEtleUxhYmVsKHByb3BlcnR5KSwga2luZDogX3RoaXMuZ2V0U3ltYm9sS2luZCh2YWx1ZU5vZGUudHlwZSksIHJhbmdlOiByYW5nZSwgc2VsZWN0aW9uUmFuZ2U6IHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbjogY2hpbGRyZW4sIGRldGFpbDogX3RoaXMuZ2V0RGV0YWlsKHZhbHVlTm9kZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvVmlzaXQucHVzaCh7IHJlc3VsdDogY2hpbGRyZW4sIG5vZGU6IHZhbHVlTm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGJyZWF0aCBmaXJzdCB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5leHRUb1Zpc2l0IDwgdG9WaXNpdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcbiAgICAgICAgICAgIGNvbGxlY3RPdXRsaW5lRW50cmllcyhuZXh0Lm5vZGUsIG5leHQucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXRFeGNlZWRlZCAmJiBjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudFN5bWJvbHMucHJvdG90eXBlLmdldFN5bWJvbEtpbmQgPSBmdW5jdGlvbiAobm9kZVR5cGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5Nb2R1bGU7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2xLaW5kLlN0cmluZztcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuTnVtYmVyO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2xLaW5kLkFycmF5O1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuQm9vbGVhbjtcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vICdudWxsJ1xuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2xLaW5kLlZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09ORG9jdW1lbnRTeW1ib2xzLnByb3RvdHlwZS5nZXRLZXlMYWJlbCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BlcnR5LmtleU5vZGUudmFsdWU7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bXFxuXS9nLCAn4oa1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIjtcbiAgICB9O1xuICAgIEpTT05Eb2N1bWVudFN5bWJvbHMucHJvdG90eXBlLmdldERldGFpbCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVtYmVyJyB8fCBub2RlLnR5cGUgPT09ICdudWxsJyB8fCBub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IHVuZGVmaW5lZCA6ICdbXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID8gdW5kZWZpbmVkIDogJ3t9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgSlNPTkRvY3VtZW50U3ltYm9scy5wcm90b3R5cGUuZmluZERvY3VtZW50Q29sb3JzID0gZnVuY3Rpb24gKGRvY3VtZW50LCBkb2MsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hU2VydmljZS5nZXRTY2hlbWFGb3JSZXNvdXJjZShkb2N1bWVudC51cmksIGRvYykudGhlbihmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5yZXN1bHRMaW1pdCA9PT0gJ251bWJlcicgPyBjb250ZXh0LnJlc3VsdExpbWl0IDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaXRlZE5vZGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hdGNoaW5nU2NoZW1hc18xID0gbWF0Y2hpbmdTY2hlbWFzOyBfaSA8IG1hdGNoaW5nU2NoZW1hc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG1hdGNoaW5nU2NoZW1hc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzLmludmVydGVkICYmIHMuc2NoZW1hICYmIChzLnNjaGVtYS5mb3JtYXQgPT09ICdjb2xvcicgfHwgcy5zY2hlbWEuZm9ybWF0ID09PSAnY29sb3ItaGV4JykgJiYgcy5ub2RlICYmIHMubm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVJZCA9IFN0cmluZyhzLm5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZE5vZGVbbm9kZUlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGNvbG9yRnJvbUhleChQYXJzZXIuZ2V0Tm9kZVZhbHVlKHMubm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcy5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBjb2xvcjogY29sb3IsIHJhbmdlOiByYW5nZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZE5vZGVbbm9kZUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSlNPTkRvY3VtZW50U3ltYm9scy5wcm90b3R5cGUuZ2V0Q29sb3JQcmVzZW50YXRpb25zID0gZnVuY3Rpb24gKGRvY3VtZW50LCBkb2MsIGNvbG9yLCByYW5nZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciByZWQyNTYgPSBNYXRoLnJvdW5kKGNvbG9yLnJlZCAqIDI1NSksIGdyZWVuMjU2ID0gTWF0aC5yb3VuZChjb2xvci5ncmVlbiAqIDI1NSksIGJsdWUyNTYgPSBNYXRoLnJvdW5kKGNvbG9yLmJsdWUgKiAyNTUpO1xuICAgICAgICBmdW5jdGlvbiB0b1R3b0RpZ2l0SGV4KG4pIHtcbiAgICAgICAgICAgIHZhciByID0gbi50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gci5sZW5ndGggIT09IDIgPyAnMCcgKyByIDogcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFiZWw7XG4gICAgICAgIGlmIChjb2xvci5hbHBoYSA9PT0gMSkge1xuICAgICAgICAgICAgbGFiZWwgPSBcIiNcIiArIHRvVHdvRGlnaXRIZXgocmVkMjU2KSArIHRvVHdvRGlnaXRIZXgoZ3JlZW4yNTYpICsgdG9Ud29EaWdpdEhleChibHVlMjU2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gXCIjXCIgKyB0b1R3b0RpZ2l0SGV4KHJlZDI1NikgKyB0b1R3b0RpZ2l0SGV4KGdyZWVuMjU2KSArIHRvVHdvRGlnaXRIZXgoYmx1ZTI1NikgKyB0b1R3b0RpZ2l0SGV4KE1hdGgucm91bmQoY29sb3IuYWxwaGEgKiAyNTUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7IGxhYmVsOiBsYWJlbCwgdGV4dEVkaXQ6IFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIEpTT04uc3RyaW5naWZ5KGxhYmVsKSkgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkRvY3VtZW50U3ltYm9scztcbn0oKSk7XG5leHBvcnQgeyBKU09ORG9jdW1lbnRTeW1ib2xzIH07XG5mdW5jdGlvbiBnZXRSYW5nZShkb2N1bWVudCwgbm9kZSkge1xuICAgIHJldHVybiBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBubHMgZnJvbSAnLi8uLi8uLi8uLi9maWxsZXJzL3ZzY29kZS1ubHMuanMnO1xudmFyIGxvY2FsaXplID0gbmxzLmxvYWRNZXNzYWdlQnVuZGxlKCk7XG5leHBvcnQgdmFyIHNjaGVtYUNvbnRyaWJ1dGlvbnMgPSB7XG4gICAgc2NoZW1hQXNzb2NpYXRpb25zOiBbXSxcbiAgICBzY2hlbWFzOiB7XG4gICAgICAgIC8vIHJlZmVyIHRvIHRoZSBsYXRlc3Qgc2NoZW1hXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAkcmVmOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJ1xuICAgICAgICB9LFxuICAgICAgICAvLyBidW5kbGUgdGhlIHNjaGVtYS1zY2hlbWEgdG8gaW5jbHVkZSAobG9jYWxpemVkKSBkZXNjcmlwdGlvbnNcbiAgICAgICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIyc6IHtcbiAgICAgICAgICAgICd0aXRsZSc6IGxvY2FsaXplKCdzY2hlbWEuanNvbicsICdEZXNjcmliZXMgYSBKU09OIGZpbGUgdXNpbmcgYSBzY2hlbWEuIFNlZSBqc29uLXNjaGVtYS5vcmcgZm9yIG1vcmUgaW5mby4nKSxcbiAgICAgICAgICAgICckc2NoZW1hJzogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIycsXG4gICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgJ3NjaGVtYUFycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwb3NpdGl2ZUludGVnZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwb3NpdGl2ZUludGVnZXJEZWZhdWx0MCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3NpbXBsZVR5cGVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZW51bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3N0cmluZ0FycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ2lkJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckc2NoZW1hJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0aXRsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9LFxuICAgICAgICAgICAgICAgICdtdWx0aXBsZU9mJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAnbWluaW11bSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNYXhpbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pbmltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heExlbmd0aCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluTGVuZ3RoJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm4nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAncmVnZXgnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbEl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heEl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDAnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVwZW5kZW5jaWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2VudW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtYXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0ZS10aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VyaScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbWFpbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdob3N0bmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpcHY0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lwdjYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVnZXgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhbGxPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhbnlPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdvbmVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdub3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZXBlbmRlbmNpZXMnOiB7XG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICdtYXhpbXVtJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgIH0sXG4gICAgICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSMnOiB7XG4gICAgICAgICAgICAndGl0bGUnOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24nLCAnRGVzY3JpYmVzIGEgSlNPTiBmaWxlIHVzaW5nIGEgc2NoZW1hLiBTZWUganNvbi1zY2hlbWEub3JnIGZvciBtb3JlIGluZm8uJyksXG4gICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgJ3NjaGVtYUFycmF5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHsgJyRyZWYnOiAnIycgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vbk5lZ2F0aXZlSW50ZWdlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJzogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyAnZGVmYXVsdCc6IDAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc2ltcGxlVHlwZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc3RyaW5nQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogeyAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3R5cGUnOiBbJ29iamVjdCcsICdib29sZWFuJ10sXG4gICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAnJGlkJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaS1yZWZlcmVuY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHNjaGVtYSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJHJlZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICd1cmktcmVmZXJlbmNlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyRjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndGl0bGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdyZWFkT25seSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGFtcGxlcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbXVsdGlwbGVPZic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4aW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heExlbmd0aCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXInIH0sXG4gICAgICAgICAgICAgICAgJ21pbkxlbmd0aCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAncGF0dGVybic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICdyZWdleCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsSXRlbXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4SXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MCcgfSxcbiAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnY29udGFpbnMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ21heFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyJyB9LFxuICAgICAgICAgICAgICAgICdtaW5Qcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJyB9LFxuICAgICAgICAgICAgICAgICdyZXF1aXJlZCc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2RlZmluaXRpb25zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYXR0ZXJuUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzogeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlOYW1lcyc6IHsgJ2Zvcm1hdCc6ICdyZWdleCcgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2RlcGVuZGVuY2llcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXknIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnR5TmFtZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2NvbnN0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZW51bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHlwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmb3JtYXQnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnY29udGVudE1lZGlhVHlwZSc6IHsgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICdjb250ZW50RW5jb2RpbmcnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAnaWYnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ3RoZW4nOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgJ2FsbE9mJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5JyB9LFxuICAgICAgICAgICAgICAgICdhbnlPZic6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnb25lT2YnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH0sXG4gICAgICAgICAgICAgICAgJ25vdCc6IHsgJyRyZWYnOiAnIycgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWZhdWx0JzogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufTtcbnZhciBkZXNjcmlwdGlvbnMgPSB7XG4gICAgaWQ6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5pZCcsIFwiQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVtYS5cIiksXG4gICAgJHNjaGVtYTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLiRzY2hlbWEnLCBcIlRoZSBzY2hlbWEgdG8gdmVyaWZ5IHRoaXMgZG9jdW1lbnQgYWdhaW5zdC5cIiksXG4gICAgdGl0bGU6IGxvY2FsaXplKCdzY2hlbWEuanNvbi50aXRsZScsIFwiQSBkZXNjcmlwdGl2ZSB0aXRsZSBvZiB0aGUgZWxlbWVudC5cIiksXG4gICAgZGVzY3JpcHRpb246IGxvY2FsaXplKCdzY2hlbWEuanNvbi5kZXNjcmlwdGlvbicsIFwiQSBsb25nIGRlc2NyaXB0aW9uIG9mIHRoZSBlbGVtZW50LiBVc2VkIGluIGhvdmVyIG1lbnVzIGFuZCBzdWdnZXN0aW9ucy5cIiksXG4gICAgZGVmYXVsdDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmRlZmF1bHQnLCBcIkEgZGVmYXVsdCB2YWx1ZS4gVXNlZCBieSBzdWdnZXN0aW9ucy5cIiksXG4gICAgbXVsdGlwbGVPZjogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm11bHRpcGxlT2YnLCBcIkEgbnVtYmVyIHRoYXQgc2hvdWxkIGNsZWFubHkgZGl2aWRlIHRoZSBjdXJyZW50IHZhbHVlIChpLmUuIGhhdmUgbm8gcmVtYWluZGVyKS5cIiksXG4gICAgbWF4aW11bTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm1heGltdW0nLCBcIlRoZSBtYXhpbXVtIG51bWVyaWNhbCB2YWx1ZSwgaW5jbHVzaXZlIGJ5IGRlZmF1bHQuXCIpLFxuICAgIGV4Y2x1c2l2ZU1heGltdW06IGxvY2FsaXplKCdzY2hlbWEuanNvbi5leGNsdXNpdmVNYXhpbXVtJywgXCJNYWtlcyB0aGUgbWF4aW11bSBwcm9wZXJ0eSBleGNsdXNpdmUuXCIpLFxuICAgIG1pbmltdW06IGxvY2FsaXplKCdzY2hlbWEuanNvbi5taW5pbXVtJywgXCJUaGUgbWluaW11bSBudW1lcmljYWwgdmFsdWUsIGluY2x1c2l2ZSBieSBkZWZhdWx0LlwiKSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uZXhjbHVzaXZlTWluaW51bScsIFwiTWFrZXMgdGhlIG1pbmltdW0gcHJvcGVydHkgZXhjbHVzaXZlLlwiKSxcbiAgICBtYXhMZW5ndGg6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5tYXhMZW5ndGgnLCBcIlRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIHN0cmluZy5cIiksXG4gICAgbWluTGVuZ3RoOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ubWluTGVuZ3RoJywgXCJUaGUgbWluaW11bSBsZW5ndGggb2YgYSBzdHJpbmcuXCIpLFxuICAgIHBhdHRlcm46IGxvY2FsaXplKCdzY2hlbWEuanNvbi5wYXR0ZXJuJywgXCJBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgc3RyaW5nIGFnYWluc3QuIEl0IGlzIG5vdCBpbXBsaWNpdGx5IGFuY2hvcmVkLlwiKSxcbiAgICBhZGRpdGlvbmFsSXRlbXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5hZGRpdGlvbmFsSXRlbXMnLCBcIkZvciBhcnJheXMsIG9ubHkgd2hlbiBpdGVtcyBpcyBzZXQgYXMgYW4gYXJyYXkuIElmIGl0IGlzIGEgc2NoZW1hLCB0aGVuIHRoaXMgc2NoZW1hIHZhbGlkYXRlcyBpdGVtcyBhZnRlciB0aGUgb25lcyBzcGVjaWZpZWQgYnkgdGhlIGl0ZW1zIGFycmF5LiBJZiBpdCBpcyBmYWxzZSwgdGhlbiBhZGRpdGlvbmFsIGl0ZW1zIHdpbGwgY2F1c2UgdmFsaWRhdGlvbiB0byBmYWlsLlwiKSxcbiAgICBpdGVtczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLml0ZW1zJywgXCJGb3IgYXJyYXlzLiBDYW4gZWl0aGVyIGJlIGEgc2NoZW1hIHRvIHZhbGlkYXRlIGV2ZXJ5IGVsZW1lbnQgYWdhaW5zdCBvciBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHZhbGlkYXRlIGVhY2ggaXRlbSBhZ2FpbnN0IGluIG9yZGVyICh0aGUgZmlyc3Qgc2NoZW1hIHdpbGwgdmFsaWRhdGUgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBzZWNvbmQgc2NoZW1hIHdpbGwgdmFsaWRhdGUgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXCIpLFxuICAgIG1heEl0ZW1zOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ubWF4SXRlbXMnLCBcIlRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbnNpZGUgYW4gYXJyYXkuIEluY2x1c2l2ZS5cIiksXG4gICAgbWluSXRlbXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5taW5JdGVtcycsIFwiVGhlIG1pbmltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIGluc2lkZSBhbiBhcnJheS4gSW5jbHVzaXZlLlwiKSxcbiAgICB1bmlxdWVJdGVtczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLnVuaXF1ZUl0ZW1zJywgXCJJZiBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBtdXN0IGJlIHVuaXF1ZS4gRGVmYXVsdHMgdG8gZmFsc2UuXCIpLFxuICAgIG1heFByb3BlcnRpZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5tYXhQcm9wZXJ0aWVzJywgXCJUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgY2FuIGhhdmUuIEluY2x1c2l2ZS5cIiksXG4gICAgbWluUHJvcGVydGllczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm1pblByb3BlcnRpZXMnLCBcIlRoZSBtaW5pbXVtIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFuIG9iamVjdCBjYW4gaGF2ZS4gSW5jbHVzaXZlLlwiKSxcbiAgICByZXF1aXJlZDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLnJlcXVpcmVkJywgXCJBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgbGlzdHMgdGhlIG5hbWVzIG9mIGFsbCBwcm9wZXJ0aWVzIHJlcXVpcmVkIG9uIHRoaXMgb2JqZWN0LlwiKSxcbiAgICBhZGRpdGlvbmFsUHJvcGVydGllczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzJywgXCJFaXRoZXIgYSBzY2hlbWEgb3IgYSBib29sZWFuLiBJZiBhIHNjaGVtYSwgdGhlbiB1c2VkIHRvIHZhbGlkYXRlIGFsbCBwcm9wZXJ0aWVzIG5vdCBtYXRjaGVkIGJ5ICdwcm9wZXJ0aWVzJyBvciAncGF0dGVyblByb3BlcnRpZXMnLiBJZiBmYWxzZSwgdGhlbiBhbnkgcHJvcGVydGllcyBub3QgbWF0Y2hlZCBieSBlaXRoZXIgd2lsbCBjYXVzZSB0aGlzIHNjaGVtYSB0byBmYWlsLlwiKSxcbiAgICBkZWZpbml0aW9uczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmRlZmluaXRpb25zJywgXCJOb3QgdXNlZCBmb3IgdmFsaWRhdGlvbi4gUGxhY2Ugc3Vic2NoZW1hcyBoZXJlIHRoYXQgeW91IHdpc2ggdG8gcmVmZXJlbmNlIGlubGluZSB3aXRoICRyZWYuXCIpLFxuICAgIHByb3BlcnRpZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5wcm9wZXJ0aWVzJywgXCJBIG1hcCBvZiBwcm9wZXJ0eSBuYW1lcyB0byBzY2hlbWFzIGZvciBlYWNoIHByb3BlcnR5LlwiKSxcbiAgICBwYXR0ZXJuUHJvcGVydGllczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLnBhdHRlcm5Qcm9wZXJ0aWVzJywgXCJBIG1hcCBvZiByZWd1bGFyIGV4cHJlc3Npb25zIG9uIHByb3BlcnR5IG5hbWVzIHRvIHNjaGVtYXMgZm9yIG1hdGNoaW5nIHByb3BlcnRpZXMuXCIpLFxuICAgIGRlcGVuZGVuY2llczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmRlcGVuZGVuY2llcycsIFwiQSBtYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gZWl0aGVyIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9yIGEgc2NoZW1hLiBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBtZWFucyB0aGUgcHJvcGVydHkgbmFtZWQgaW4gdGhlIGtleSBkZXBlbmRzIG9uIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBhcnJheSBiZWluZyBwcmVzZW50IGluIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gYmUgdmFsaWQuIElmIHRoZSB2YWx1ZSBpcyBhIHNjaGVtYSwgdGhlbiB0aGUgc2NoZW1hIGlzIG9ubHkgYXBwbGllZCB0byB0aGUgb2JqZWN0IGlmIHRoZSBwcm9wZXJ0eSBpbiB0aGUga2V5IGV4aXN0cyBvbiB0aGUgb2JqZWN0LlwiKSxcbiAgICBlbnVtOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uZW51bScsIFwiVGhlIHNldCBvZiBsaXRlcmFsIHZhbHVlcyB0aGF0IGFyZSB2YWxpZC5cIiksXG4gICAgdHlwZTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLnR5cGUnLCBcIkVpdGhlciBhIHN0cmluZyBvZiBvbmUgb2YgdGhlIGJhc2ljIHNjaGVtYSB0eXBlcyAobnVtYmVyLCBpbnRlZ2VyLCBudWxsLCBhcnJheSwgb2JqZWN0LCBib29sZWFuLCBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3Mgc3BlY2lmeWluZyBhIHN1YnNldCBvZiB0aG9zZSB0eXBlcy5cIiksXG4gICAgZm9ybWF0OiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uZm9ybWF0JywgXCJEZXNjcmliZXMgdGhlIGZvcm1hdCBleHBlY3RlZCBmb3IgdGhlIHZhbHVlLlwiKSxcbiAgICBhbGxPZjogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmFsbE9mJywgXCJBbiBhcnJheSBvZiBzY2hlbWFzLCBhbGwgb2Ygd2hpY2ggbXVzdCBtYXRjaC5cIiksXG4gICAgYW55T2Y6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5hbnlPZicsIFwiQW4gYXJyYXkgb2Ygc2NoZW1hcywgd2hlcmUgYXQgbGVhc3Qgb25lIG11c3QgbWF0Y2guXCIpLFxuICAgIG9uZU9mOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ub25lT2YnLCBcIkFuIGFycmF5IG9mIHNjaGVtYXMsIGV4YWN0bHkgb25lIG9mIHdoaWNoIG11c3QgbWF0Y2guXCIpLFxuICAgIG5vdDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLm5vdCcsIFwiQSBzY2hlbWEgd2hpY2ggbXVzdCBub3QgbWF0Y2guXCIpLFxuICAgICRpZDogbG9jYWxpemUoJ3NjaGVtYS5qc29uLiRpZCcsIFwiQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVtYS5cIiksXG4gICAgJHJlZjogbG9jYWxpemUoJ3NjaGVtYS5qc29uLiRyZWYnLCBcIlJlZmVyZW5jZSBhIGRlZmluaXRpb24gaG9zdGVkIG9uIGFueSBsb2NhdGlvbi5cIiksXG4gICAgJGNvbW1lbnQ6IGxvY2FsaXplKCdzY2hlbWEuanNvbi4kY29tbWVudCcsIFwiQ29tbWVudHMgZnJvbSBzY2hlbWEgYXV0aG9ycyB0byByZWFkZXJzIG9yIG1haW50YWluZXJzIG9mIHRoZSBzY2hlbWEuXCIpLFxuICAgIHJlYWRPbmx5OiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24ucmVhZE9ubHknLCBcIkluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgaW5zdGFuY2UgaXMgbWFuYWdlZCBleGNsdXNpdmVseSBieSB0aGUgb3duaW5nIGF1dGhvcml0eS5cIiksXG4gICAgZXhhbXBsZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5leGFtcGxlcycsIFwiU2FtcGxlIEpTT04gdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgc2NoZW1hLCBmb3IgdGhlIHB1cnBvc2Ugb2YgaWxsdXN0cmF0aW5nIHVzYWdlLlwiKSxcbiAgICBjb250YWluczogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmNvbnRhaW5zJywgXCJBbiBhcnJheSBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFxcXCJjb250YWluc1xcXCIgaWYgYXQgbGVhc3Qgb25lIG9mIGl0cyBlbGVtZW50cyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBnaXZlbiBzY2hlbWEuXCIpLFxuICAgIHByb3BlcnR5TmFtZXM6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5wcm9wZXJ0eU5hbWVzJywgXCJJZiB0aGUgaW5zdGFuY2UgaXMgYW4gb2JqZWN0LCB0aGlzIGtleXdvcmQgdmFsaWRhdGVzIGlmIGV2ZXJ5IHByb3BlcnR5IG5hbWUgaW4gdGhlIGluc3RhbmNlIHZhbGlkYXRlcyBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWEuXCIpLFxuICAgIGNvbnN0OiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uY29uc3QnLCBcIkFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRzIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiB0aGUga2V5d29yZC5cIiksXG4gICAgY29udGVudE1lZGlhVHlwZTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmNvbnRlbnRNZWRpYVR5cGUnLCBcIkRlc2NyaWJlcyB0aGUgbWVkaWEgdHlwZSBvZiBhIHN0cmluZyBwcm9wZXJ0eS5cIiksXG4gICAgY29udGVudEVuY29kaW5nOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uY29udGVudEVuY29kaW5nJywgXCJEZXNjcmliZXMgdGhlIGNvbnRlbnQgZW5jb2Rpbmcgb2YgYSBzdHJpbmcgcHJvcGVydHkuXCIpLFxuICAgIGlmOiBsb2NhbGl6ZSgnc2NoZW1hLmpzb24uaWYnLCBcIlRoZSB2YWxpZGF0aW9uIG91dGNvbWUgb2YgdGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIGNvbnRyb2xzIHdoaWNoIG9mIHRoZSBcXFwidGhlblxcXCIgb3IgXFxcImVsc2VcXFwiIGtleXdvcmRzIGFyZSBldmFsdWF0ZWQuXCIpLFxuICAgIHRoZW46IGxvY2FsaXplKCdzY2hlbWEuanNvbi50aGVuJywgXCJUaGUgXFxcImlmXFxcIiBzdWJzY2hlbWEgaXMgdXNlZCBmb3IgdmFsaWRhdGlvbiB3aGVuIHRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBzdWNjZWVkcy5cIiksXG4gICAgZWxzZTogbG9jYWxpemUoJ3NjaGVtYS5qc29uLmVsc2UnLCBcIlRoZSBcXFwiZWxzZVxcXCIgc3Vic2NoZW1hIGlzIHVzZWQgZm9yIHZhbGlkYXRpb24gd2hlbiB0aGUgXFxcImlmXFxcIiBzdWJzY2hlbWEgZmFpbHMuXCIpXG59O1xuZm9yICh2YXIgc2NoZW1hTmFtZSBpbiBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXMpIHtcbiAgICB2YXIgc2NoZW1hID0gc2NoZW1hQ29udHJpYnV0aW9ucy5zY2hlbWFzW3NjaGVtYU5hbWVdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU9iamVjdCA9IHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eU9iamVjdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eU9iamVjdCA9IHNjaGVtYS5wcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcHJvcGVydHlPYmplY3RbJ2Rlc2NyaXB0aW9uJ10gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHByb3BlcnR5ICsgXCI6IGxvY2FsaXplKCdzY2hlbWEuanNvbi5cIiArIHByb3BlcnR5ICsgXCInLCBcXFwiXFxcIilcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGNyZWF0ZVNjYW5uZXIgfSBmcm9tICcuLy4uLy4uL2pzb25jLXBhcnNlci9tYWluLmpzJztcbmltcG9ydCB7IEZvbGRpbmdSYW5nZUtpbmQsIFBvc2l0aW9uIH0gZnJvbSAnLi4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbGRpbmdSYW5nZXMoZG9jdW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgdmFyIG5lc3RpbmdMZXZlbHMgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgcHJldlN0YXJ0ID0gLTE7XG4gICAgdmFyIHNjYW5uZXIgPSBjcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgZmFsc2UpO1xuICAgIHZhciB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgbmVzdGluZ0xldmVscy5wdXNoKHN0YWNrLmxlbmd0aCk7XG4gICAgfVxuICAgIHdoaWxlICh0b2tlbiAhPT0gMTcgLyogRU9GICovKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBPcGVuQnJhY2VUb2tlbiAqLzpcbiAgICAgICAgICAgIGNhc2UgMyAvKiBPcGVuQnJhY2tldFRva2VuICovOiB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHsgc3RhcnRMaW5lOiBzdGFydExpbmUsIGVuZExpbmU6IHN0YXJ0TGluZSwga2luZDogdG9rZW4gPT09IDEgLyogT3BlbkJyYWNlVG9rZW4gKi8gPyAnb2JqZWN0JyA6ICdhcnJheScgfTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMiAvKiBDbG9zZUJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogQ2xvc2VCcmFja2V0VG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IHRva2VuID09PSAyIC8qIENsb3NlQnJhY2VUb2tlbiAqLyA/ICdvYmplY3QnIDogJ2FycmF5JztcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5raW5kID09PSBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgbGluZSA+IHJhbmdlLnN0YXJ0TGluZSArIDEgJiYgcHJldlN0YXJ0ICE9PSByYW5nZS5zdGFydExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZExpbmUgPSBsaW5lIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTdGFydCA9IHJhbmdlLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTMgLyogQmxvY2tDb21tZW50VHJpdmlhICovOiB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpLmxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpID09PSAxIC8qIFVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi8gJiYgc3RhcnRMaW5lICsgMSA8IGRvY3VtZW50LmxpbmVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKGRvY3VtZW50Lm9mZnNldEF0KFBvc2l0aW9uLmNyZWF0ZShzdGFydExpbmUgKyAxLCAwKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0TGluZSA8IGVuZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlKHsgc3RhcnRMaW5lOiBzdGFydExpbmUsIGVuZExpbmU6IGVuZExpbmUsIGtpbmQ6IEZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTIgLyogTGluZUNvbW1lbnRUcml2aWEgKi86IHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKS5zdWJzdHIoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIHZhciBtID0gdGV4dC5tYXRjaCgvXlxcL1xcL1xccyojKHJlZ2lvblxcYil8KGVuZHJlZ2lvblxcYikvKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgICAgICBpZiAobVsxXSkgeyAvLyBzdGFydCBwYXR0ZXJuIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB7IHN0YXJ0TGluZTogbGluZSwgZW5kTGluZTogbGluZSwga2luZDogRm9sZGluZ1JhbmdlS2luZC5SZWdpb24gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBzdGFja1tpXS5raW5kICE9PSBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lID4gcmFuZ2Uuc3RhcnRMaW5lICYmIHByZXZTdGFydCAhPT0gcmFuZ2Uuc3RhcnRMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZExpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTdGFydCA9IHJhbmdlLnN0YXJ0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICB9XG4gICAgdmFyIHJhbmdlTGltaXQgPSBjb250ZXh0ICYmIGNvbnRleHQucmFuZ2VMaW1pdDtcbiAgICBpZiAodHlwZW9mIHJhbmdlTGltaXQgIT09ICdudW1iZXInIHx8IHJhbmdlcy5sZW5ndGggPD0gcmFuZ2VMaW1pdCkge1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmFuZ2VMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgIGNvbnRleHQub25SYW5nZUxpbWl0RXhjZWVkZWQoZG9jdW1lbnQudXJpKTtcbiAgICB9XG4gICAgdmFyIGNvdW50cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgbmVzdGluZ0xldmVsc18xID0gbmVzdGluZ0xldmVsczsgX2kgPCBuZXN0aW5nTGV2ZWxzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IG5lc3RpbmdMZXZlbHNfMVtfaV07XG4gICAgICAgIGlmIChsZXZlbCA8IDMwKSB7XG4gICAgICAgICAgICBjb3VudHNbbGV2ZWxdID0gKGNvdW50c1tsZXZlbF0gfHwgMCkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBlbnRyaWVzID0gMDtcbiAgICB2YXIgbWF4TGV2ZWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gY291bnRzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgaWYgKG4gKyBlbnRyaWVzID4gcmFuZ2VMaW1pdCkge1xuICAgICAgICAgICAgICAgIG1heExldmVsID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMgKz0gbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxldmVsID0gbmVzdGluZ0xldmVsc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IG1heExldmVsIHx8IChsZXZlbCA9PT0gbWF4TGV2ZWwgJiYgZW50cmllcysrIDwgcmFuZ2VMaW1pdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyYW5nZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IFJhbmdlLCBTZWxlY3Rpb25SYW5nZSB9IGZyb20gJy4uL2pzb25MYW5ndWFnZVR5cGVzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVNjYW5uZXIgfSBmcm9tICcuLy4uLy4uL2pzb25jLXBhcnNlci9tYWluLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZXMoZG9jdW1lbnQsIHBvc2l0aW9ucywgZG9jKSB7XG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2UocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgICAgICAvLyByYW5nZSB3aXRob3V0IFwiLCBbIG9yIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNTdGFydCA9IG5vZGUub2Zmc2V0ICsgMSwgY0VuZCA9IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY1N0YXJ0IDwgY0VuZCAmJiBvZmZzZXQgPj0gY1N0YXJ0ICYmIG9mZnNldCA8PSBjRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShjU3RhcnQsIGNFbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShub2RlLm9mZnNldCwgbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAncHJvcGVydHknIHx8IG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJDb21tYU9mZnNldCA9IGdldE9mZnNldEFmdGVyTmV4dFRva2VuKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgsIDUgLyogQ29tbWFUb2tlbiAqLyk7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyQ29tbWFPZmZzZXQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1JhbmdlKG5vZGUub2Zmc2V0LCBhZnRlckNvbW1hT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IHJlc3VsdC5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHJlc3VsdFtpbmRleF0sIGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudCA9IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShSYW5nZS5jcmVhdGUocG9zaXRpb24sIHBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5ld1JhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KHN0YXJ0KSwgZG9jdW1lbnQucG9zaXRpb25BdChlbmQpKTtcbiAgICB9XG4gICAgdmFyIHNjYW5uZXIgPSBjcmVhdGVTY2FubmVyKGRvY3VtZW50LmdldFRleHQoKSwgdHJ1ZSk7XG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0QWZ0ZXJOZXh0VG9rZW4ob2Zmc2V0LCBleHBlY3RlZFRva2VuKSB7XG4gICAgICAgIHNjYW5uZXIuc2V0UG9zaXRpb24ob2Zmc2V0KTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gZXhwZWN0ZWRUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbnMubWFwKGdldFNlbGVjdGlvblJhbmdlKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuLi9qc29uTGFuZ3VhZ2VUeXBlcy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZmluZExpbmtzKGRvY3VtZW50LCBkb2MpIHtcbiAgICB2YXIgbGlua3MgPSBbXTtcbiAgICBkb2MudmlzaXQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInByb3BlcnR5XCIgJiYgbm9kZS5rZXlOb2RlLnZhbHVlID09PSBcIiRyZWZcIiAmJiAoKF9hID0gbm9kZS52YWx1ZU5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gbm9kZS52YWx1ZU5vZGUudmFsdWU7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGZpbmRUYXJnZXROb2RlKGRvYywgcGF0aCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQb3MgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHRhcmdldE5vZGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBkb2N1bWVudC51cmkgKyBcIiNcIiArICh0YXJnZXRQb3MubGluZSArIDEpICsgXCIsXCIgKyAodGFyZ2V0UG9zLmNoYXJhY3RlciArIDEpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogY3JlYXRlUmFuZ2UoZG9jdW1lbnQsIG5vZGUudmFsdWVOb2RlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGlua3MpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZG9jdW1lbnQsIG5vZGUpIHtcbiAgICByZXR1cm4gUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyAxKSwgZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMSkpO1xufVxuZnVuY3Rpb24gZmluZFRhcmdldE5vZGUoZG9jLCBwYXRoKSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlSlNPTlBvaW50ZXIocGF0aCk7XG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaW5kTm9kZSh0b2tlbnMsIGRvYy5yb290KTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlKHBvaW50ZXIsIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmFyIHRva2VuID0gcG9pbnRlci5zaGlmdCgpO1xuICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5Tm9kZSA9IG5vZGUucHJvcGVydGllcy5maW5kKGZ1bmN0aW9uIChwcm9wZXJ0eU5vZGUpIHsgcmV0dXJuIHByb3BlcnR5Tm9kZS5rZXlOb2RlLnZhbHVlID09PSB0b2tlbjsgfSk7XG4gICAgICAgIGlmICghcHJvcGVydHlOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZE5vZGUocG9pbnRlciwgcHJvcGVydHlOb2RlLnZhbHVlTm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIGlmICh0b2tlbi5tYXRjaCgvXigwfFsxLTldWzAtOV0qKSQvKSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KHRva2VuKTtcbiAgICAgICAgICAgIHZhciBhcnJheUl0ZW0gPSBub2RlLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghYXJyYXlJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluZE5vZGUocG9pbnRlciwgYXJyYXlJdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlSlNPTlBvaW50ZXIocGF0aCkge1xuICAgIGlmIChwYXRoID09PSBcIiNcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChwYXRoWzBdICE9PSAnIycgfHwgcGF0aFsxXSAhPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcoMikuc3BsaXQoL1xcLy8pLm1hcCh1bmVzY2FwZSk7XG59XG5mdW5jdGlvbiB1bmVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgSlNPTkNvbXBsZXRpb24gfSBmcm9tICcuL3NlcnZpY2VzL2pzb25Db21wbGV0aW9uLmpzJztcbmltcG9ydCB7IEpTT05Ib3ZlciB9IGZyb20gJy4vc2VydmljZXMvanNvbkhvdmVyLmpzJztcbmltcG9ydCB7IEpTT05WYWxpZGF0aW9uIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uVmFsaWRhdGlvbi5qcyc7XG5pbXBvcnQgeyBKU09ORG9jdW1lbnRTeW1ib2xzIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uRG9jdW1lbnRTeW1ib2xzLmpzJztcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlSlNPTiwgbmV3SlNPTkRvY3VtZW50IH0gZnJvbSAnLi9wYXJzZXIvanNvblBhcnNlci5qcyc7XG5pbXBvcnQgeyBzY2hlbWFDb250cmlidXRpb25zIH0gZnJvbSAnLi9zZXJ2aWNlcy9jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IEpTT05TY2hlbWFTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uU2NoZW1hU2VydmljZS5qcyc7XG5pbXBvcnQgeyBnZXRGb2xkaW5nUmFuZ2VzIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uRm9sZGluZy5qcyc7XG5pbXBvcnQgeyBnZXRTZWxlY3Rpb25SYW5nZXMgfSBmcm9tICcuL3NlcnZpY2VzL2pzb25TZWxlY3Rpb25SYW5nZXMuanMnO1xuaW1wb3J0IHsgZm9ybWF0IGFzIGZvcm1hdEpTT04gfSBmcm9tICcuLy4uL2pzb25jLXBhcnNlci9tYWluLmpzJztcbmltcG9ydCB7IFJhbmdlLCBUZXh0RWRpdCB9IGZyb20gJy4vanNvbkxhbmd1YWdlVHlwZXMuanMnO1xuaW1wb3J0IHsgZmluZExpbmtzIH0gZnJvbSAnLi9zZXJ2aWNlcy9qc29uTGlua3MuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9qc29uTGFuZ3VhZ2VUeXBlcy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VTZXJ2aWNlKHBhcmFtcykge1xuICAgIHZhciBwcm9taXNlID0gcGFyYW1zLnByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgIHZhciBqc29uU2NoZW1hU2VydmljZSA9IG5ldyBKU09OU2NoZW1hU2VydmljZShwYXJhbXMuc2NoZW1hUmVxdWVzdFNlcnZpY2UsIHBhcmFtcy53b3Jrc3BhY2VDb250ZXh0LCBwcm9taXNlKTtcbiAgICBqc29uU2NoZW1hU2VydmljZS5zZXRTY2hlbWFDb250cmlidXRpb25zKHNjaGVtYUNvbnRyaWJ1dGlvbnMpO1xuICAgIHZhciBqc29uQ29tcGxldGlvbiA9IG5ldyBKU09OQ29tcGxldGlvbihqc29uU2NoZW1hU2VydmljZSwgcGFyYW1zLmNvbnRyaWJ1dGlvbnMsIHByb21pc2UsIHBhcmFtcy5jbGllbnRDYXBhYmlsaXRpZXMpO1xuICAgIHZhciBqc29uSG92ZXIgPSBuZXcgSlNPTkhvdmVyKGpzb25TY2hlbWFTZXJ2aWNlLCBwYXJhbXMuY29udHJpYnV0aW9ucywgcHJvbWlzZSk7XG4gICAgdmFyIGpzb25Eb2N1bWVudFN5bWJvbHMgPSBuZXcgSlNPTkRvY3VtZW50U3ltYm9scyhqc29uU2NoZW1hU2VydmljZSk7XG4gICAgdmFyIGpzb25WYWxpZGF0aW9uID0gbmV3IEpTT05WYWxpZGF0aW9uKGpzb25TY2hlbWFTZXJ2aWNlLCBwcm9taXNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAganNvblNjaGVtYVNlcnZpY2UuY2xlYXJFeHRlcm5hbFNjaGVtYXMoKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2NoZW1hcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICBqc29uU2NoZW1hU2VydmljZS5yZWdpc3RlckV4dGVybmFsU2NoZW1hKHNldHRpbmdzLnVyaSwgc2V0dGluZ3MuZmlsZU1hdGNoLCBzZXR0aW5ncy5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAganNvblZhbGlkYXRpb24uY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRTY2hlbWE6IGZ1bmN0aW9uICh1cmkpIHsgcmV0dXJuIGpzb25TY2hlbWFTZXJ2aWNlLm9uUmVzb3VyY2VDaGFuZ2UodXJpKTsgfSxcbiAgICAgICAgZG9WYWxpZGF0aW9uOiBqc29uVmFsaWRhdGlvbi5kb1ZhbGlkYXRpb24uYmluZChqc29uVmFsaWRhdGlvbiksXG4gICAgICAgIHBhcnNlSlNPTkRvY3VtZW50OiBmdW5jdGlvbiAoZG9jdW1lbnQpIHsgcmV0dXJuIHBhcnNlSlNPTihkb2N1bWVudCwgeyBjb2xsZWN0Q29tbWVudHM6IHRydWUgfSk7IH0sXG4gICAgICAgIG5ld0pTT05Eb2N1bWVudDogZnVuY3Rpb24gKHJvb3QsIGRpYWdub3N0aWNzKSB7IHJldHVybiBuZXdKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MpOyB9LFxuICAgICAgICBnZXRNYXRjaGluZ1NjaGVtYXM6IGpzb25TY2hlbWFTZXJ2aWNlLmdldE1hdGNoaW5nU2NoZW1hcy5iaW5kKGpzb25TY2hlbWFTZXJ2aWNlKSxcbiAgICAgICAgZG9SZXNvbHZlOiBqc29uQ29tcGxldGlvbi5kb1Jlc29sdmUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGRvQ29tcGxldGU6IGpzb25Db21wbGV0aW9uLmRvQ29tcGxldGUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGZpbmREb2N1bWVudFN5bWJvbHM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9scy5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRTeW1ib2xzMjoganNvbkRvY3VtZW50U3ltYm9scy5maW5kRG9jdW1lbnRTeW1ib2xzMi5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRDb2xvcnM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50Q29sb3JzLmJpbmQoanNvbkRvY3VtZW50U3ltYm9scyksXG4gICAgICAgIGdldENvbG9yUHJlc2VudGF0aW9uczoganNvbkRvY3VtZW50U3ltYm9scy5nZXRDb2xvclByZXNlbnRhdGlvbnMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcbiAgICAgICAgZG9Ib3ZlcjoganNvbkhvdmVyLmRvSG92ZXIuYmluZChqc29uSG92ZXIpLFxuICAgICAgICBnZXRGb2xkaW5nUmFuZ2VzOiBnZXRGb2xkaW5nUmFuZ2VzLFxuICAgICAgICBnZXRTZWxlY3Rpb25SYW5nZXM6IGdldFNlbGVjdGlvblJhbmdlcyxcbiAgICAgICAgZmluZERlZmluaXRpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7IH0sXG4gICAgICAgIGZpbmRMaW5rczogZmluZExpbmtzLFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChkLCByLCBvKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkLm9mZnNldEF0KHIuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBkLm9mZnNldEF0KHIuZW5kKSAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHsgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsgdGFiU2l6ZTogbyA/IG8udGFiU2l6ZSA6IDQsIGluc2VydFNwYWNlczogKG8gPT09IG51bGwgfHwgbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogby5pbnNlcnRTcGFjZXMpID09PSB0cnVlLCBpbnNlcnRGaW5hbE5ld2xpbmU6IChvID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8uaW5zZXJ0RmluYWxOZXdsaW5lKSA9PT0gdHJ1ZSwgZW9sOiAnXFxuJyB9O1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEpTT04oZC5nZXRUZXh0KCksIHJhbmdlLCBvcHRpb25zKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVGV4dEVkaXQucmVwbGFjZShSYW5nZS5jcmVhdGUoZC5wb3NpdGlvbkF0KGUub2Zmc2V0KSwgZC5wb3NpdGlvbkF0KGUub2Zmc2V0ICsgZS5sZW5ndGgpKSwgZS5jb250ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXHJcbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufTtcclxuaW1wb3J0ICogYXMganNvblNlcnZpY2UgZnJvbSAnLi9fZGVwcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvanNvbkxhbmd1YWdlU2VydmljZS5qcyc7XHJcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4vX2RlcHMvdnNjb2RlLXVyaS9pbmRleC5qcyc7XHJcbnZhciBkZWZhdWx0U2NoZW1hUmVxdWVzdFNlcnZpY2U7XHJcbmlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBkZWZhdWx0U2NoZW1hUmVxdWVzdFNlcnZpY2UgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbnZhciBKU09OV29ya2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSlNPTldvcmtlcihjdHgsIGNyZWF0ZURhdGEpIHtcclxuICAgICAgICB0aGlzLl9jdHggPSBjdHg7XHJcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VTZXR0aW5ncyA9IGNyZWF0ZURhdGEubGFuZ3VhZ2VTZXR0aW5ncztcclxuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gY3JlYXRlRGF0YS5sYW5ndWFnZUlkO1xyXG4gICAgICAgIHRoaXMuX2xhbmd1YWdlU2VydmljZSA9IGpzb25TZXJ2aWNlLmdldExhbmd1YWdlU2VydmljZSh7XHJcbiAgICAgICAgICAgIHdvcmtzcGFjZUNvbnRleHQ6IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVSZWxhdGl2ZVBhdGg6IGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIHJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSByZXNvdXJjZS5zdWJzdHIoMCwgcmVzb3VyY2UubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlUGF0aChiYXNlLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzY2hlbWFSZXF1ZXN0U2VydmljZTogY3JlYXRlRGF0YS5lbmFibGVTY2hlbWFSZXF1ZXN0ICYmIGRlZmF1bHRTY2hlbWFSZXF1ZXN0U2VydmljZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xhbmd1YWdlU2VydmljZS5jb25maWd1cmUodGhpcy5fbGFuZ3VhZ2VTZXR0aW5ncyk7XHJcbiAgICB9XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5kb1ZhbGlkYXRpb24gPSBmdW5jdGlvbiAodXJpKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnQsIGpzb25Eb2N1bWVudDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQgPSB0aGlzLl9nZXRUZXh0RG9jdW1lbnQodXJpKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpzb25Eb2N1bWVudCA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5wYXJzZUpTT05Eb2N1bWVudChkb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2xhbmd1YWdlU2VydmljZS5kb1ZhbGlkYXRpb24oZG9jdW1lbnQsIGpzb25Eb2N1bWVudCwgdGhpcy5fbGFuZ3VhZ2VTZXR0aW5ncyldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVzb2x2ZShbXSldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5kb0NvbXBsZXRlID0gZnVuY3Rpb24gKHVyaSwgcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCwganNvbkRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24sIGpzb25Eb2N1bWVudCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5kb1Jlc29sdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2xhbmd1YWdlU2VydmljZS5kb1Jlc29sdmUoaXRlbSldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5kb0hvdmVyID0gZnVuY3Rpb24gKHVyaSwgcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCwganNvbkRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24sIGpzb25Eb2N1bWVudCldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAodXJpLCByYW5nZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRvY3VtZW50LCB0ZXh0RWRpdHM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gdGhpcy5fZ2V0VGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0RWRpdHMgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZm9ybWF0KGRvY3VtZW50LCByYW5nZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZXNvbHZlKHRleHRFZGl0cyldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5yZXNldFNjaGVtYSA9IGZ1bmN0aW9uICh1cmkpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUodGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnJlc2V0U2NoZW1hKHVyaSkpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSlNPTldvcmtlci5wcm90b3R5cGUuZmluZERvY3VtZW50U3ltYm9scyA9IGZ1bmN0aW9uICh1cmkpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCwganNvbkRvY3VtZW50LCBzeW1ib2xzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UuZmluZERvY3VtZW50U3ltYm9scyhkb2N1bWVudCwganNvbkRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUoc3ltYm9scyldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5maW5kRG9jdW1lbnRDb2xvcnMgPSBmdW5jdGlvbiAodXJpKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnQsIGpzb25Eb2N1bWVudCwgY29sb3JTeW1ib2xzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbG9yU3ltYm9scyA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5maW5kRG9jdW1lbnRDb2xvcnMoZG9jdW1lbnQsIGpzb25Eb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZXNvbHZlKGNvbG9yU3ltYm9scyldO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKU09OV29ya2VyLnByb3RvdHlwZS5nZXRDb2xvclByZXNlbnRhdGlvbnMgPSBmdW5jdGlvbiAodXJpLCBjb2xvciwgcmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCwganNvbkRvY3VtZW50LCBjb2xvclByZXNlbnRhdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gdGhpcy5fZ2V0VGV4dERvY3VtZW50KHVyaSk7XHJcbiAgICAgICAgICAgICAgICBqc29uRG9jdW1lbnQgPSB0aGlzLl9sYW5ndWFnZVNlcnZpY2UucGFyc2VKU09ORG9jdW1lbnQoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgY29sb3JQcmVzZW50YXRpb25zID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmdldENvbG9yUHJlc2VudGF0aW9ucyhkb2N1bWVudCwganNvbkRvY3VtZW50LCBjb2xvciwgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVzb2x2ZShjb2xvclByZXNlbnRhdGlvbnMpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSlNPTldvcmtlci5wcm90b3R5cGUuZ2V0Rm9sZGluZ1JhbmdlcyA9IGZ1bmN0aW9uICh1cmksIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkb2N1bWVudCwgcmFuZ2VzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VzID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLmdldEZvbGRpbmdSYW5nZXMoZG9jdW1lbnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVzb2x2ZShyYW5nZXMpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSlNPTldvcmtlci5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uUmFuZ2VzID0gZnVuY3Rpb24gKHVyaSwgcG9zaXRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnQsIGpzb25Eb2N1bWVudCwgcmFuZ2VzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuX2dldFRleHREb2N1bWVudCh1cmkpO1xyXG4gICAgICAgICAgICAgICAganNvbkRvY3VtZW50ID0gdGhpcy5fbGFuZ3VhZ2VTZXJ2aWNlLnBhcnNlSlNPTkRvY3VtZW50KGRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJhbmdlcyA9IHRoaXMuX2xhbmd1YWdlU2VydmljZS5nZXRTZWxlY3Rpb25SYW5nZXMoZG9jdW1lbnQsIHBvc2l0aW9ucywganNvbkRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBQcm9taXNlLnJlc29sdmUocmFuZ2VzKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEpTT05Xb3JrZXIucHJvdG90eXBlLl9nZXRUZXh0RG9jdW1lbnQgPSBmdW5jdGlvbiAodXJpKSB7XHJcbiAgICAgICAgdmFyIG1vZGVscyA9IHRoaXMuX2N0eC5nZXRNaXJyb3JNb2RlbHMoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1vZGVsc18xID0gbW9kZWxzOyBfaSA8IG1vZGVsc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBtb2RlbHNfMVtfaV07XHJcbiAgICAgICAgICAgIGlmIChtb2RlbC51cmkudG9TdHJpbmcoKSA9PT0gdXJpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNlcnZpY2UuVGV4dERvY3VtZW50LmNyZWF0ZSh1cmksIHRoaXMuX2xhbmd1YWdlSWQsIG1vZGVsLnZlcnNpb24sIG1vZGVsLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBKU09OV29ya2VyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBKU09OV29ya2VyIH07XHJcbi8vIFVSSSBwYXRoIHV0aWxpdGllcywgd2lsbCAoaG9wZWZ1bGx5KSBtb3ZlIHRvIHZzY29kZS11cmlcclxudmFyIFNsYXNoID0gJy8nLmNoYXJDb2RlQXQoMCk7XHJcbnZhciBEb3QgPSAnLicuY2hhckNvZGVBdCgwKTtcclxuZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gU2xhc2g7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodXJpU3RyaW5nLCBwYXRoKSB7XHJcbiAgICBpZiAoaXNBYnNvbHV0ZVBhdGgocGF0aCkpIHtcclxuICAgICAgICB2YXIgdXJpID0gVVJJLnBhcnNlKHVyaVN0cmluZyk7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIHJldHVybiB1cmkud2l0aCh7IHBhdGg6IG5vcm1hbGl6ZVBhdGgocGFydHMpIH0pLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gam9pblBhdGgodXJpU3RyaW5nLCBwYXRoKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhcnRzKSB7XHJcbiAgICB2YXIgbmV3UGFydHMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c18xW19pXTtcclxuICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDAgfHwgKHBhcnQubGVuZ3RoID09PSAxICYmIHBhcnQuY2hhckNvZGVBdCgwKSA9PT0gRG90KSkge1xyXG4gICAgICAgICAgICAvLyBpZ25vcmVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT09IDIgJiYgcGFydC5jaGFyQ29kZUF0KDApID09PSBEb3QgJiYgcGFydC5jaGFyQ29kZUF0KDEpID09PSBEb3QpIHtcclxuICAgICAgICAgICAgbmV3UGFydHMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHBhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIG5ld1BhcnRzLnB1c2goJycpO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlcyA9IG5ld1BhcnRzLmpvaW4oJy8nKTtcclxuICAgIGlmIChwYXJ0c1swXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXMgPSAnLycgKyByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGpvaW5QYXRoKHVyaVN0cmluZykge1xyXG4gICAgdmFyIHBhdGhzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBhdGhzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIHVyaSA9IFVSSS5wYXJzZSh1cmlTdHJpbmcpO1xyXG4gICAgdmFyIHBhcnRzID0gdXJpLnBhdGguc3BsaXQoJy8nKTtcclxuICAgIGZvciAodmFyIF9hID0gMCwgcGF0aHNfMSA9IHBhdGhzOyBfYSA8IHBhdGhzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc18xW19hXTtcclxuICAgICAgICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwYXRoLnNwbGl0KCcvJykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVyaS53aXRoKHsgcGF0aDogbm9ybWFsaXplUGF0aChwYXJ0cykgfSkudG9TdHJpbmcoKTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGN0eCwgY3JlYXRlRGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyBKU09OV29ya2VyKGN0eCwgY3JlYXRlRGF0YSk7XHJcbn1cclxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cclxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmltcG9ydCAqIGFzIHdvcmtlciBmcm9tICcuLi8uLi9lZGl0b3IvZWRpdG9yLndvcmtlci5qcyc7XHJcbmltcG9ydCB7IEpTT05Xb3JrZXIgfSBmcm9tICcuL2pzb25Xb3JrZXIuanMnO1xyXG5zZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIGlnbm9yZSB0aGUgZmlyc3QgbWVzc2FnZVxyXG4gICAgd29ya2VyLmluaXRpYWxpemUoZnVuY3Rpb24gKGN0eCwgY3JlYXRlRGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSlNPTldvcmtlcihjdHgsIGNyZWF0ZURhdGEpO1xyXG4gICAgfSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///412\n")}},__webpack_require__={};__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}();var __webpack_exports__={};__webpack_modules__[412](0,__webpack_exports__,__webpack_require__)})();