(self.webpackChunk_cos_ui_apps_cos_ui=self.webpackChunk_cos_ui_apps_cos_ui||[]).push([[6614,7017,129],{36614:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "AutoField": () => (/* reexport */ es6_AutoField),\n  "AutoFields": () => (/* reexport */ AutoFields),\n  "AutoForm": () => (/* reexport */ AutoForm),\n  "BaseForm": () => (/* reexport */ BaseForm),\n  "BoolField": () => (/* reexport */ BoolField),\n  "DateField": () => (/* reexport */ es6_DateField),\n  "ErrorField": () => (/* reexport */ ErrorField),\n  "ErrorsField": () => (/* reexport */ es6_ErrorsField),\n  "HiddenField": () => (/* reexport */ HiddenField),\n  "ListAddField": () => (/* reexport */ ListAddField),\n  "ListDelField": () => (/* reexport */ ListDelField),\n  "ListField": () => (/* reexport */ es6_ListField),\n  "ListItemField": () => (/* reexport */ ListItemField),\n  "LongTextField": () => (/* reexport */ LongTextField),\n  "NestField": () => (/* reexport */ NestField),\n  "NumField": () => (/* reexport */ NumField),\n  "QuickForm": () => (/* reexport */ QuickForm),\n  "RadioField": () => (/* reexport */ RadioField),\n  "SelectField": () => (/* reexport */ es6_SelectField),\n  "SubmitField": () => (/* reexport */ es6_SubmitField),\n  "TextField": () => (/* reexport */ TextField),\n  "ValidatedForm": () => (/* reexport */ ValidatedForm),\n  "ValidatedQuickForm": () => (/* reexport */ ValidatedQuickForm)\n});\n\n// EXTERNAL MODULE: ../../../../uniforms-patternfly/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(7017);\n// EXTERNAL MODULE: consume shared module (default) react@^16.13.1 (singleton) (fallback: ../../../../uniforms-patternfly/node_modules/react/index.js) (eager)\nvar index_js_eager_ = __webpack_require__(27603);\nvar index_js_eager_default = /*#__PURE__*/__webpack_require__.n(index_js_eager_);\n// EXTERNAL MODULE: consume shared module (default) uniforms@^3.5.1 (strict) (fallback: ../../../../uniforms-patternfly/node_modules/uniforms/es6/index.js)\nvar index_js_ = __webpack_require__(55291);\n// EXTERNAL MODULE: ../../../../uniforms-patternfly/node_modules/invariant/browser.js\nvar browser = __webpack_require__(32033);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n// EXTERNAL MODULE: consume shared module (default) @patternfly/react-core@^4.106.2 (strict) (fallback: ../../../../uniforms-patternfly/node_modules/@patternfly/react-core/dist/esm/index.js)\nvar esm_index_js_ = __webpack_require__(98238);\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/wrapField.js\n\n\n\n\nindex_js_.filterDOMProps.register(\'decimal\', \'minCount\', \'autoValue\', \'isDisabled\', \'exclusiveMaximum\', \'exclusiveMinimum\');\nfunction wrapField(_a, children) {\n    var { id, label, type, disabled, error, errorMessage, showInlineError, help, required } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["id", "label", "type", "disabled", "error", "errorMessage", "showInlineError", "help", "required"]);\n    return (index_js_eager_default().createElement(esm_index_js_.FormGroup, Object.assign({ fieldId: id, label: label, isRequired: required, validated: error ? \'error\' : \'default\', type: type, helperText: help, helperTextInvalid: errorMessage }, (0,index_js_.filterDOMProps)(props)), children));\n}\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/BoolField.js\n\n\n\n\n\nvar ComponentType;\n(function (ComponentType) {\n    ComponentType["checkbox"] = "checkbox";\n    ComponentType["switch"] = "switch";\n})(ComponentType || (ComponentType = {}));\nfunction Bool(_a) {\n    var { appearance, disabled, id, inputRef, label, name, onChange, value } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["appearance", "disabled", "id", "inputRef", "label", "name", "onChange", "value"]);\n    const Component = appearance === ComponentType.switch ? esm_index_js_.Switch : esm_index_js_.Checkbox;\n    return wrapField(Object.assign({ id }, props), index_js_eager_default().createElement(Component, { isChecked: value || false, isDisabled: disabled, id: id, name: name, onChange: () => disabled || onChange(!value), ref: inputRef, label: label }));\n}\nBool.defaultProps = { appearance: ComponentType.checkbox };\n/* harmony default export */ const BoolField = ((0,index_js_.connectField)(Bool));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/DateField.js\n\n\n\n\nconst DateConstructor = (typeof __webpack_require__.g === \'object\' ? __webpack_require__.g : window).Date;\nfunction DateField(props) {\n    var _a, _b;\n    const parseDate = (0,index_js_eager_.useCallback)(() => {\n        if (!props.value) {\n            return \'\';\n        }\n        return props.value.toISOString().slice(0, -14);\n    }, [props.value]);\n    const parseTime = (0,index_js_eager_.useCallback)(() => {\n        if (!props.value) {\n            return \'\';\n        }\n        return `${props.value.getUTCHours()}:${props.value.getUTCMinutes()}`;\n    }, [props.value]);\n    const onDateChange = (0,index_js_eager_.useCallback)((value, date) => {\n        var _a;\n        if (!date) {\n            props.onChange(date);\n        }\n        else {\n            const newDate = new DateConstructor(date);\n            const time = parseTime();\n            if (time !== \'\') {\n                newDate.setUTCHours(parseInt(time === null || time === void 0 ? void 0 : time.split(\':\')[0]));\n                newDate.setUTCMinutes(parseInt((_a = time === null || time === void 0 ? void 0 : time.split(\':\')[1]) === null || _a === void 0 ? void 0 : _a.split(\' \')[0]));\n            }\n            else {\n                newDate.setUTCHours(0);\n                newDate.setUTCMinutes(0);\n            }\n            props.onChange(newDate);\n        }\n    }, [props.onChange, parseTime]);\n    const isInvalid = (0,index_js_eager_.useMemo)(() => {\n        if (props.value) {\n            if (props.min) {\n                const minDate = new Date(props.min);\n                if (minDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (props.value < minDate) {\n                    return `Should be after ${minDate.toISOString()}`;\n                }\n            }\n            if (props.max) {\n                const maxDate = new Date(props.max);\n                if (maxDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (props.value > maxDate) {\n                    return `Should be before ${maxDate.toISOString()}`;\n                }\n            }\n        }\n        return false;\n    }, [props.value]);\n    const onTimeChange = (0,index_js_eager_.useCallback)((time, hours, minutes) => {\n        var _a;\n        if (props.value) {\n            const newDate = new DateConstructor(props.value);\n            if (hours && minutes) {\n                newDate.setUTCHours(hours);\n                newDate.setUTCMinutes(minutes);\n            }\n            else if (time !== \'\') {\n                const localeHours = parseInt(time === null || time === void 0 ? void 0 : time.split(\':\')[0]);\n                const localeMinutes = parseInt((_a = time === null || time === void 0 ? void 0 : time.split(\':\')[1]) === null || _a === void 0 ? void 0 : _a.split(\' \')[0]);\n                if (!isNaN(localeHours) && !isNaN(localeMinutes)) {\n                    newDate.setUTCHours(localeHours);\n                    newDate.setUTCMinutes(localeMinutes);\n                }\n            }\n            else {\n                newDate.setUTCHours(0);\n                newDate.setUTCMinutes(0);\n            }\n            props.onChange(newDate);\n        }\n    }, [props.onChange, props.value]);\n    return wrapField(props, index_js_eager_default().createElement(esm_index_js_.Flex, { style: { margin: 0 }, direction: { default: \'column\' }, id: props.id, name: props.name, ref: props.inputRef },\n        index_js_eager_default().createElement(esm_index_js_.FlexItem, { style: { margin: 0 } },\n            index_js_eager_default().createElement(esm_index_js_.InputGroup, { style: { background: \'transparent\' } },\n                index_js_eager_default().createElement(esm_index_js_.DatePicker, { id: `date-picker-${props.id}`, "data-testid": `date-picker`, isDisabled: props.disabled, name: props.name, onChange: onDateChange, value: (_a = parseDate()) !== null && _a !== void 0 ? _a : \'\' }),\n                index_js_eager_default().createElement(esm_index_js_.TimePicker, { id: `time-picker-${props.id}`, "data-testid": `time-picker`, isDisabled: props.disabled || !props.value, name: props.name, onChange: onTimeChange, style: { width: \'120px\' }, value: (_b = parseTime()) !== null && _b !== void 0 ? _b : \'\', is24Hour: true }))),\n        isInvalid && (index_js_eager_default().createElement("div", { id: `${props.id}-invalid-date-time`, style: {\n                fontSize: \'0.875rem\',\n                color: \'#c9190b\',\n                marginTop: \'0.25rem\',\n            } }, isInvalid))));\n}\n/* harmony default export */ const es6_DateField = ((0,index_js_.connectField)(DateField));\n\n// EXTERNAL MODULE: consume shared module (default) @patternfly/react-icons@^4.7.11 (strict) (fallback: ../../../../uniforms-patternfly/node_modules/@patternfly/react-icons/dist/esm/index.js)\nvar dist_esm_index_js_ = __webpack_require__(35152);\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ListDelField.js\n\n\n\n\n\nfunction ListDel(_a) {\n    var { name, disabled } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["name", "disabled"]);\n    const nameParts = (0,index_js_.joinName)(null, name);\n    const nameIndex = +nameParts[nameParts.length - 1];\n    const parentName = (0,index_js_.joinName)(nameParts.slice(0, -1));\n    const parent = (0,index_js_.useField)(parentName, {}, { absoluteName: true })[0];\n    const limitNotReached = !disabled && !(parent.minCount >= parent.value.length);\n    return (index_js_eager_default().createElement(esm_index_js_.Button, Object.assign({ disabled: !limitNotReached || disabled, variant: "plain", style: { paddingLeft: \'0\', paddingRight: \'0\' }, onClick: () => {\n            const value = parent.value.slice();\n            value.splice(nameIndex, 1);\n            !disabled && limitNotReached && parent.onChange(value);\n        } }, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(dist_esm_index_js_.MinusCircleIcon, { color: "#cc0000" })));\n}\n/* harmony default export */ const ListDelField = ((0,index_js_.connectField)(ListDel, {\n    initialValue: false,\n    kind: \'leaf\',\n}));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ListItemField.js\n\n\n\n\nfunction ListItem({ children = index_js_eager_default().createElement(es6_AutoField, { label: null, name: \'\' }), }) {\n    return (index_js_eager_default().createElement("div", { style: {\n            marginBottom: \'1rem\',\n            display: \'flex\',\n            justifyContent: \'space-between\',\n        } },\n        index_js_eager_default().createElement("div", { style: { width: \'100%\', marginRight: \'10px\' } }, children),\n        index_js_eager_default().createElement("div", null,\n            index_js_eager_default().createElement(ListDelField, { name: \'\' }))));\n}\n/* harmony default export */ const ListItemField = ((0,index_js_.connectField)(ListItem, {\n    initialValue: false,\n}));\n\n// EXTERNAL MODULE: ../../../../uniforms-patternfly/node_modules/lodash/cloneDeep.js\nvar cloneDeep = __webpack_require__(52183);\nvar cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ListAddField.js\n\n\n\n\n\n\nfunction ListAdd(_a) {\n    var { disabled = false, name, value } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["disabled", "name", "value"]);\n    const nameParts = (0,index_js_.joinName)(null, name);\n    const parentName = (0,index_js_.joinName)(nameParts.slice(0, -1));\n    const parent = (0,index_js_.useField)(parentName, {}, { absoluteName: true })[0];\n    const limitNotReached = !disabled && !(parent.maxCount <= parent.value.length);\n    return (index_js_eager_default().createElement(esm_index_js_.Button, Object.assign({ variant: "plain", style: { paddingLeft: \'0\', paddingRight: \'0\' }, disabled: !limitNotReached, onClick: () => {\n            !disabled &&\n                limitNotReached &&\n                parent.onChange(parent.value.concat([cloneDeep_default()(value)]));\n        } }, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(dist_esm_index_js_.PlusCircleIcon, { color: "#0088ce" })));\n}\n/* harmony default export */ const ListAddField = ((0,index_js_.connectField)(ListAdd, {\n    initialValue: false,\n    kind: \'leaf\',\n}));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ListField.js\n\n\n\n\n\n\n\nindex_js_.filterDOMProps.register(\'minCount\', \'wrapperCol\', \'labelCol\');\nfunction ListField(_a) {\n    var { children = index_js_eager_default().createElement(ListItemField, { name: "$" }), error, errorMessage, info, initialCount, itemProps, label, name, value, showInlineError } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["children", "error", "errorMessage", "info", "initialCount", "itemProps", "label", "name", "value", "showInlineError"]);\n    return (index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(esm_index_js_.Split, { hasGutter: true },\n            index_js_eager_default().createElement(esm_index_js_.SplitItem, null, label && (index_js_eager_default().createElement("label", null,\n                label,\n                !!info && (index_js_eager_default().createElement("span", null,\n                    "\\u00A0",\n                    index_js_eager_default().createElement(esm_index_js_.Tooltip, { content: info },\n                        index_js_eager_default().createElement(dist_esm_index_js_.OutlinedQuestionCircleIcon, null))))))),\n            index_js_eager_default().createElement(esm_index_js_.SplitItem, { isFilled: true }),\n            index_js_eager_default().createElement(esm_index_js_.SplitItem, null,\n                index_js_eager_default().createElement(ListAddField, { name: \'$\', initialCount: initialCount }))),\n        index_js_eager_default().createElement("div", null, value === null || value === void 0 ? void 0 : value.map((item, itemIndex) => index_js_eager_.Children.map(children, (child, childIndex) => {\n            var _a;\n            return (0,index_js_eager_.isValidElement)(child)\n                ? (0,index_js_eager_.cloneElement)(child, Object.assign({ key: `${itemIndex}-${childIndex}`, name: (_a = child.props.name) === null || _a === void 0 ? void 0 : _a.replace(\'$\', \'\' + itemIndex) }, itemProps))\n                : child;\n        })))));\n}\n/* harmony default export */ const es6_ListField = ((0,index_js_.connectField)(ListField));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/NestField.js\n\n\n\n\n\nconst Nest = (_a) => {\n    var { children, error, errorMessage, fields, itemProps, label, name, showInlineError, disabled } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["children", "error", "errorMessage", "fields", "itemProps", "label", "name", "showInlineError", "disabled"]);\n    return (index_js_eager_default().createElement(esm_index_js_.Card, Object.assign({}, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(esm_index_js_.CardBody, { className: "pf-c-form" },\n            label && (index_js_eager_default().createElement("label", null,\n                index_js_eager_default().createElement("b", null, label))),\n            children || (fields === null || fields === void 0 ? void 0 : fields.map((field) => (index_js_eager_default().createElement(es6_AutoField, Object.assign({ key: field, disabled: disabled, name: field }, itemProps))))))));\n};\n/* harmony default export */ const NestField = ((0,index_js_.connectField)(Nest));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/NumField.js\n\n\n\n\nconst Num = (props) => {\n    var _a;\n    const onChange = (value, event) => {\n        const parse = props.decimal ? parseFloat : parseInt;\n        const v = parse(event.target.value);\n        props.onChange(isNaN(v) ? undefined : v);\n    };\n    return wrapField(props, index_js_eager_default().createElement(esm_index_js_.TextInput, { name: props.name, isDisabled: props.disabled, id: props.id, max: props.max, min: props.min, onChange: onChange, placeholder: props.placeholder, ref: props.inputRef, step: props.decimal ? 0.01 : 1, type: "number", value: (_a = props.value) !== null && _a !== void 0 ? _a : \'\', validated: props.error ? \'error\' : \'default\' }));\n};\n/* harmony default export */ const NumField = ((0,index_js_.connectField)(Num));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/RadioField.js\n\n\n\n\nconst Radio = (props) => {\n    var _a;\n    index_js_.filterDOMProps.register(\'checkboxes\', \'decimal\');\n    return wrapField(props, index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)), (_a = props.allowedValues) === null || _a === void 0 ? void 0 : _a.map((item) => (index_js_eager_default().createElement((index_js_eager_default()).Fragment, { key: item },\n        index_js_eager_default().createElement(esm_index_js_.Radio, { isChecked: item === props.value, isDisabled: props.disabled, id: `${props.id}`, name: props.name, label: props.transform ? props.transform(item) : item, "aria-label": props.name, onChange: () => props.onChange(item) }))))));\n};\n/* harmony default export */ const RadioField = ((0,index_js_.connectField)(Radio));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/SelectField.js\n\n\n\n\nfunction xor(item, array) {\n    const index = array.indexOf(item);\n    if (index === -1) {\n        return array.concat([item]);\n    }\n    return array.slice(0, index).concat(array.slice(index + 1));\n}\nindex_js_.filterDOMProps.register(\'autoValue\');\nfunction isSelectOptionObject(toBeDetermined) {\n    return toBeDetermined.toString !== undefined;\n}\nfunction SelectField(props) {\n    if (props.checkboxes) {\n        const Group = (0,index_js_eager_.useMemo)(() => (props.fieldType === Array ? esm_index_js_.Checkbox : esm_index_js_.Radio), [props]);\n        return (index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)),\n            props.label && index_js_eager_default().createElement("label", null, props.label),\n            props.allowedValues.map((item, index) => {\n                return (index_js_eager_default().createElement((index_js_eager_default()).Fragment, { key: index },\n                    index_js_eager_default().createElement("label", { htmlFor: props.id }, props.transform ? props.transform(item) : item),\n                    index_js_eager_default().createElement(Group, { id: `${props.id}-${item}`, isDisabled: props.disabled, name: props.name, "aria-label": props.name, value: props.value, isChecked: props.fieldType === Array && Array.isArray(props.value)\n                            ? props.value.includes(item)\n                            : props.value === item, onChange: () => {\n                            props.onChange(props.fieldType === Array && Array.isArray(props.value)\n                                ? xor(item, props.value)\n                                : item);\n                        } })));\n            })));\n    }\n    const [expanded, setExpanded] = (0,index_js_eager_.useState)(false);\n    const [selected, setSelected] = (0,index_js_eager_.useState)([]);\n    (0,index_js_eager_.useEffect)(() => {\n        if (!props.value) {\n            setSelected([]);\n            setExpanded(false);\n        }\n        else if (Array.isArray(props.value)) {\n            setSelected([...props.value]);\n            setExpanded(false);\n        }\n        else {\n            setSelected(props.value);\n            setExpanded(false);\n        }\n    }, [props.value]);\n    const parseInput = (0,index_js_eager_.useCallback)((selection, fieldType) => {\n        const parsedSelection = isSelectOptionObject(selection)\n            ? selection.toString()\n            : selection;\n        if (fieldType !== Array) {\n            return parsedSelection !== \'\' ? parsedSelection : \'\';\n        }\n        if (Array.isArray(selected)) {\n            if (selected.includes(parsedSelection)) {\n                return selected.filter((s) => s !== parsedSelection);\n            }\n            return [parsedSelection, ...selected];\n        }\n        return [parsedSelection, selected];\n    }, [selected]);\n    const handleSelect = (0,index_js_eager_.useCallback)((event, selection) => {\n        if (selection === props.placeholder) {\n            props.onChange(undefined);\n        }\n        else {\n            const items = parseInput(selection, props.fieldType);\n            props.onChange(items);\n        }\n    }, [parseInput, props]);\n    const selectedOptions = (0,index_js_eager_.useMemo)(() => props.allowedValues.map((value) => (index_js_eager_default().createElement(esm_index_js_.SelectOption, { key: value, value: value }, props.transform ? props.transform(value) : value))), [props]);\n    (0,index_js_eager_.useEffect)(() => {\n        if (props.placeholder)\n            selectedOptions.unshift(index_js_eager_default().createElement(esm_index_js_.SelectOption, { key: props.allowedValues.length, isPlaceholder: true, value: props.placeholder }));\n    }, [props.placeholder, selectedOptions]);\n    return wrapField(props, index_js_eager_default().createElement(esm_index_js_.Select, { isDisabled: props.disabled, id: props.id, variant: props.fieldType === Array\n            ? esm_index_js_.SelectVariant.typeaheadMulti\n            : esm_index_js_.SelectVariant.single, name: props.name, placeholderText: props.placeholder, isOpen: expanded, selections: selected, onToggle: () => setExpanded(!expanded), onSelect: handleSelect, value: props.value || (props.fieldType === Array ? [] : undefined) }, selectedOptions));\n}\n/* harmony default export */ const es6_SelectField = ((0,index_js_.connectField)(SelectField));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/TextField.js\n\n\n\n\nconst timeRgx = /^([0-1]?[0-9]|2[0-3]):([0-5][0-9])(:[0-5][0-9])?/;\nconst Text = (props) => {\n    var _a, _b, _c, _d, _e, _f;\n    const isDateInvalid = (0,index_js_eager_.useMemo)(() => {\n        var _a;\n        if (typeof props.value === \'string\' &&\n            (props.type === \'date\' || ((_a = props.field) === null || _a === void 0 ? void 0 : _a.format) === \'date\')) {\n            const date = new Date(props.value);\n            if (typeof props.min === \'string\') {\n                const minDate = new Date(props.min);\n                if (minDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (date.toISOString() < minDate.toISOString()) {\n                    return props.errorMessage && props.errorMessage.trim().length > 0\n                        ? props.errorMessage\n                        : `Should be after ${props.min}`;\n                }\n            }\n            if (typeof props.max === \'string\') {\n                const maxDate = new Date(props.max);\n                if (maxDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (date.toISOString() > maxDate.toISOString()) {\n                    return props.errorMessage && props.errorMessage.trim().length > 0\n                        ? props.errorMessage\n                        : `Should be before ${props.max}`;\n                }\n            }\n        }\n        return false;\n    }, [props.value, props.max, props.min, props.errorMessage]);\n    const parseTime = (0,index_js_eager_.useCallback)((time) => {\n        const parsedTime = timeRgx.exec(time);\n        const date = new Date();\n        // @ts-ignore\n        if (!parsedTime) {\n            return undefined;\n        }\n        date.setUTCHours(Number(parsedTime[1]), Number(parsedTime[2]));\n        return date;\n    }, []);\n    const isTimeInvalid = (0,index_js_eager_.useMemo)(() => {\n        var _a;\n        if (typeof props.value === \'string\' &&\n            (props.type === \'time\' || ((_a = props.field) === null || _a === void 0 ? void 0 : _a.format) === \'time\')) {\n            const parsedTime = parseTime(props.value);\n            if (parsedTime &&\n                typeof props.min === \'string\' &&\n                timeRgx.exec(props.min)) {\n                const parsedMin = parseTime(props.min);\n                if (parsedTime < parsedMin) {\n                    return `Should be after ${parsedMin.getUTCHours()}:${parsedMin.getUTCMinutes()}`;\n                }\n            }\n            if (parsedTime &&\n                typeof props.max === \'string\' &&\n                timeRgx.exec(props.max)) {\n                const parsedMax = parseTime(props.max);\n                if (parsedTime > parsedMax) {\n                    return `Should be before ${parsedMax.getUTCHours()}:${parsedMax.getUTCMinutes()}`;\n                }\n            }\n        }\n        return false;\n    }, [props.type, props.field, props.value, props.max, props.min]);\n    const onDateChange = (0,index_js_eager_.useCallback)((value) => {\n        props.onChange(value);\n    }, [props.disabled, props.onChange]);\n    const onTimeChange = (0,index_js_eager_.useCallback)((time) => {\n        const parsedTime = time.split(\':\');\n        if (parsedTime.length === 2) {\n            props.onChange([...parsedTime, \'00\'].join(\':\'));\n        }\n        else {\n            props.onChange(time);\n        }\n    }, [props.disabled, props.onChange]);\n    return wrapField(props, props.type === \'date\' || ((_a = props.field) === null || _a === void 0 ? void 0 : _a.format) === \'date\' ? (index_js_eager_default().createElement((index_js_eager_default()).Fragment, null,\n        index_js_eager_default().createElement(esm_index_js_.DatePicker, Object.assign({ name: props.name, isDisabled: props.disabled, onChange: onDateChange, value: (_b = props.value) !== null && _b !== void 0 ? _b : \'\' }, (0,index_js_.filterDOMProps)(props))),\n        isDateInvalid && (index_js_eager_default().createElement("div", { style: {\n                fontSize: \'0.875rem\',\n                color: \'#c9190b\',\n                marginTop: \'0.25rem\',\n            } }, isDateInvalid)))) : props.type === \'time\' || ((_c = props.field) === null || _c === void 0 ? void 0 : _c.format) === \'time\' ? (index_js_eager_default().createElement((index_js_eager_default()).Fragment, null,\n        index_js_eager_default().createElement(esm_index_js_.TimePicker, { name: props.name, isDisabled: props.disabled, onChange: onTimeChange, is24Hour: true, value: (_d = props.value) !== null && _d !== void 0 ? _d : \'\' }),\n        isTimeInvalid && (index_js_eager_default().createElement("div", { style: {\n                fontSize: \'0.875rem\',\n                color: \'#c9190b\',\n                marginTop: \'0.25rem\',\n            } }, isTimeInvalid)))) : (index_js_eager_default().createElement(esm_index_js_.TextInput, Object.assign({ name: props.name, isDisabled: props.disabled, validated: props.error ? \'error\' : \'default\', onChange: (value, event) => props.onChange(event.target.value), placeholder: props.placeholder, ref: props.inputRef, type: (_e = props.type) !== null && _e !== void 0 ? _e : \'text\', value: (_f = props.value) !== null && _f !== void 0 ? _f : \'\' }, (0,index_js_.filterDOMProps)(props)))));\n};\n/* harmony default export */ const TextField = ((0,index_js_.connectField)(Text));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/AutoField.js\n\n\n\n\n\n\n\n\n\n\nconst AutoField = (0,index_js_.createAutoField)(props => {\n    if (props.allowedValues) {\n        return props.checkboxes && props.fieldType !== Array\n            ? RadioField\n            : es6_SelectField;\n    }\n    switch (props.fieldType) {\n        case Array:\n            return es6_ListField;\n        case Boolean:\n            return BoolField;\n        case Date:\n            return es6_DateField;\n        case Number:\n            return NumField;\n        case Object:\n            return NestField;\n        case String:\n            return TextField;\n    }\n    return browser_default()(false, \'Unsupported field type: %s\', props.fieldType);\n});\n/* harmony default export */ const es6_AutoField = (AutoField);\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/AutoFields.js\n\n\n\n\nfunction AutoFields(_a) {\n    var { autoField = es6_AutoField, element = \'div\', fields, omitFields = [] } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["autoField", "element", "fields", "omitFields"]);\n    const { schema } = (0,index_js_.useForm)();\n    return (0,index_js_eager_.createElement)(element, props, (fields !== null && fields !== void 0 ? fields : schema.getSubfields())\n        .filter((field) => !omitFields.includes(field))\n        .map((field) => (0,index_js_eager_.createElement)(autoField, { key: field, name: field })));\n}\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/BaseForm.js\n\n\n\nfunction Patternfly(parent) {\n    class _ extends parent {\n        render() {\n            return (index_js_eager_default().createElement(index_js_.context.Provider, { value: this.getContext() },\n                index_js_eager_default().createElement(esm_index_js_.Form, Object.assign({}, this.getNativeFormProps()))));\n        }\n    }\n    _.Patternfly = Patternfly;\n    _.displayName = `Patternfly${parent.displayName}`;\n    return _;\n}\n/* harmony default export */ const BaseForm = (Patternfly(index_js_.BaseForm));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ErrorsField.js\n\n\n\nfunction ErrorsField(_a) {\n    var { children } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["children"]);\n    const { error, schema } = (0,index_js_.useForm)();\n    return !error && !children ? null : (index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)),\n        children,\n        index_js_eager_default().createElement("ul", null, schema.getErrorMessages(error).map((message, index) => (index_js_eager_default().createElement("li", { key: index, style: { margin: \'3px\' } }, message))))));\n}\nErrorsField.defaultProps = {\n    style: {\n        backgroundColor: \'rgba(255, 85, 0, 0.2)\',\n        border: \'1px solid rgb(255, 85, 0)\',\n        borderRadius: \'7px\',\n        margin: \'20px 0px\',\n        padding: \'10px\',\n    },\n};\n/* harmony default export */ const es6_ErrorsField = (ErrorsField);\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/SubmitField.js\n\n\n\n\nfunction SubmitField(_a) {\n    var { disabled, inputRef, value } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["disabled", "inputRef", "value"]);\n    const { error, state } = (0,index_js_.useForm)();\n    return (index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(esm_index_js_.Button, { isDisabled: disabled === undefined ? !!(error || state.disabled) : disabled, type: "submit", ref: inputRef, variant: "primary" }, value)));\n}\nSubmitField.defaultProps = { value: \'Submit\' };\n/* harmony default export */ const es6_SubmitField = (SubmitField);\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/QuickForm.js\n\n\n\n\n\nfunction Quick(parent) {\n    class _ extends index_js_.QuickForm.Quick(parent) {\n        getAutoField() {\n            return es6_AutoField;\n        }\n        getErrorsField() {\n            return es6_ErrorsField;\n        }\n        getSubmitField() {\n            return es6_SubmitField;\n        }\n    }\n    _.Quick = Quick;\n    return _;\n}\n/* harmony default export */ const QuickForm = (Quick(BaseForm));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ValidatedForm.js\n\n\nfunction Validated(parent) {\n    class _ extends index_js_.ValidatedForm.Validated(parent) {\n    }\n    _.Validated = Validated;\n    return _;\n}\n/* harmony default export */ const ValidatedForm = (Validated(BaseForm));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ValidatedQuickForm.js\n\n\n\n/* harmony default export */ const ValidatedQuickForm = (ValidatedForm.Validated(QuickForm.Quick(BaseForm)));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/AutoForm.js\n\n\nfunction Auto(parent) {\n    class _ extends index_js_.AutoForm.Auto(parent) {\n    }\n    _.Auto = Auto;\n    return _;\n}\n/* harmony default export */ const AutoForm = (Auto(ValidatedQuickForm));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/ErrorField.js\n\n\n\nconst Error = (_a) => {\n    var { children, error, errorMessage } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["children", "error", "errorMessage"]);\n    return !error ? null : (index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)), children ? (children) : (index_js_eager_default().createElement("div", { style: { margin: \'3px\' } }, errorMessage))));\n};\nError.defaultProps = {\n    style: {\n        backgroundColor: \'rgba(255, 85, 0, 0.2)\',\n        border: \'1px solid rgb(255, 85, 0)\',\n        borderRadius: \'7px\',\n        margin: \'20px 0px\',\n        padding: \'10px\',\n    },\n};\n/* harmony default export */ const ErrorField = ((0,index_js_.connectField)(Error, { initialValue: false }));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/HiddenField.js\n\n\n\nfunction HiddenField(_a) {\n    var _b;\n    var { value } = _a, rawProps = (0,tslib_es6/* __rest */._T)(_a, ["value"]);\n    const props = (0,index_js_.useField)(rawProps.name, rawProps, { initialValue: false })[0];\n    (0,index_js_eager_.useEffect)(() => {\n        if (value !== undefined && value !== props.value)\n            props.onChange(value);\n    });\n    return props.noDOM ? null : (index_js_eager_default().createElement("input", Object.assign({ disabled: props.disabled, id: props.id, name: props.name, ref: props.inputRef, type: "hidden", value: (_b = value !== null && value !== void 0 ? value : props.value) !== null && _b !== void 0 ? _b : \'\' }, (0,index_js_.filterDOMProps)(props))));\n}\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/LongTextField.js\n\n\n\n\nconst LongText = (_a) => {\n    var { disabled, id, inputRef, label, name, onChange, placeholder, value } = _a, props = (0,tslib_es6/* __rest */._T)(_a, ["disabled", "id", "inputRef", "label", "name", "onChange", "placeholder", "value"]);\n    return (index_js_eager_default().createElement("div", Object.assign({}, (0,index_js_.filterDOMProps)(props)),\n        label && index_js_eager_default().createElement("label", { htmlFor: id }, label),\n        index_js_eager_default().createElement(esm_index_js_.TextArea, { id: id, disabled: disabled, name: name, "aria-label": name, onChange: (value, event) => onChange(event.target.value), placeholder: placeholder, ref: inputRef, value: value !== null && value !== void 0 ? value : \'\' })));\n};\n/* harmony default export */ const LongTextField = ((0,index_js_.connectField)(LongText));\n\n;// CONCATENATED MODULE: ../../../../uniforms-patternfly/es6/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L3dyYXBGaWVsZC5qcz80MzcwIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvQm9vbEZpZWxkLmpzP2I2NTQiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9EYXRlRmllbGQuanM/NmJhZSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L0xpc3REZWxGaWVsZC5qcz9mM2FhIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvTGlzdEl0ZW1GaWVsZC5qcz9mOTkzIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvTGlzdEFkZEZpZWxkLmpzPzM2ZmQiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9MaXN0RmllbGQuanM/NDI3OCIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L05lc3RGaWVsZC5qcz8yZjA5Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvTnVtRmllbGQuanM/ZWFhMiIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L1JhZGlvRmllbGQuanM/MWVlYyIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L1NlbGVjdEZpZWxkLmpzPzhmMjMiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9UZXh0RmllbGQuanM/NDIyYSIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L0F1dG9GaWVsZC5qcz9mZGE2Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvQXV0b0ZpZWxkcy5qcz9lNmUxIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvQmFzZUZvcm0uanM/NTE0NiIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L0Vycm9yc0ZpZWxkLmpzPzIyMDgiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9TdWJtaXRGaWVsZC5qcz9jYzM5Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvUXVpY2tGb3JtLmpzPzYwZTUiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9WYWxpZGF0ZWRGb3JtLmpzPzU5ODIiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9WYWxpZGF0ZWRRdWlja0Zvcm0uanM/ZGIyMyIsIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvZXM2L0F1dG9Gb3JtLmpzP2M5ZWIiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9FcnJvckZpZWxkLmpzP2NmZTYiLCJ3ZWJwYWNrOi8vQGNvcy11aS1hcHBzL2Nvcy11aS8uLi91bmlmb3Jtcy1wYXR0ZXJuZmx5L2VzNi9IaWRkZW5GaWVsZC5qcz83MTE0Iiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvTG9uZ1RleHRGaWVsZC5qcz82ZDRjIiwid2VicGFjazovL0Bjb3MtdWktYXBwcy9jb3MtdWkvLi4vdW5pZm9ybXMtcGF0dGVybmZseS9lczYvaW5kZXguanM/MThkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0w7QUFDeUI7QUFDVDtBQUMxQyxpQ0FBdUI7QUFDUjtBQUNmLFNBQVMsa0ZBQWtGLGVBQWUsNEJBQU07QUFDaEgsWUFBWSxzQ0FBbUIsQ0FBQyx1QkFBUyxpQkFBaUIseUpBQXlKLEVBQUUsNEJBQWM7QUFDbk87OztBQ1IrQjtBQUNMO0FBQ2lDO0FBQ25CO0FBQ0o7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBLFNBQVMsbUVBQW1FLGVBQWUsNEJBQU07QUFDakcsNERBQTRELG9CQUFNLEdBQUcsc0JBQVE7QUFDN0UsV0FBVyxTQUFTLGdCQUFnQixLQUFLLFVBQVUsc0NBQW1CLGFBQWEsaUpBQWlKO0FBQ3BPO0FBQ0EscUJBQXFCO0FBQ3JCLGdEQUFlLDBCQUFZLE1BQU0sRUFBQzs7O0FDaEJrQjtBQUNaO0FBQ3FEO0FBQ3pEO0FBQ3BDLGdDQUFnQyxxQkFBTSxnQkFBZ0IscUJBQU07QUFDNUQ7QUFDQTtBQUNBLHNCQUFzQiwrQkFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsK0JBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQixHQUFHLDRCQUE0QjtBQUMzRSxLQUFLO0FBQ0wseUJBQXlCLCtCQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QSwrQ0FBZSxLQUFLLGtCQUFrQixDQUFDLEVBQUM7OztBQ1JUO0FBQ0w7QUFDOEI7QUFDeEQ7QUFDQSxTQUFTLGdDQUFnQyxlQUFlLDRCQUFNO0FBQzlELDRCQUE0QixzQ0FBbUIsd0JBQXdCLEVBQUUsNEJBQWMsbUNBQW1DLHNDQUFtQixTQUFTLFNBQVMsZ0JBQWdCLEVBQUU7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFlLDBCQUFZLFNBQVMsc0JBQXNCLENBQUMsRUFBQzs7O0FDaEI3QjtBQUNVO0FBQ1c7QUFDckM7QUFDZjtBQUNBLFNBQVMsUUFBUSxrQkFBa0IsNEJBQU07QUFDekMsa0JBQWtCLHNCQUFRLDJCQUEyQixzQkFBc0I7QUFDM0UsSUFBSSw2QkFBUztBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLHNDQUFtQix5QkFBeUIsNE1BQTRNLEVBQUUsNEJBQWM7QUFDelM7OztBQ1orQjtBQUNMO0FBQ3dCO0FBQ007QUFDeEQ7QUFDQSxTQUFTLG9FQUFvRSxlQUFlLDRCQUFNO0FBQ2xHLFlBQVksc0NBQW1CLHdCQUF3QixFQUFFLDRCQUFjO0FBQ3ZFLGlCQUFpQixzQ0FBbUIsV0FBVyxjQUFjO0FBQzdELFFBQVEsc0NBQW1CLENBQUMsc0JBQVEsR0FBRyx3TkFBd047QUFDL1A7QUFDQSxvREFBZSwwQkFBWSxVQUFVLEVBQUM7OztBQ1ZlO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDTjtBQUNRO0FBQ0E7QUFDUjtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDSjtBQUNRO0FBQ1UiLCJmaWxlIjoiMzY2MTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuZmlsdGVyRE9NUHJvcHMucmVnaXN0ZXIoJ2RlY2ltYWwnLCAnbWluQ291bnQnLCAnYXV0b1ZhbHVlJywgJ2lzRGlzYWJsZWQnLCAnZXhjbHVzaXZlTWF4aW11bScsICdleGNsdXNpdmVNaW5pbXVtJyk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3cmFwRmllbGQoX2EsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHsgaWQsIGxhYmVsLCB0eXBlLCBkaXNhYmxlZCwgZXJyb3IsIGVycm9yTWVzc2FnZSwgc2hvd0lubGluZUVycm9yLCBoZWxwLCByZXF1aXJlZCB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJpZFwiLCBcImxhYmVsXCIsIFwidHlwZVwiLCBcImRpc2FibGVkXCIsIFwiZXJyb3JcIiwgXCJlcnJvck1lc3NhZ2VcIiwgXCJzaG93SW5saW5lRXJyb3JcIiwgXCJoZWxwXCIsIFwicmVxdWlyZWRcIl0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtR3JvdXAsIE9iamVjdC5hc3NpZ24oeyBmaWVsZElkOiBpZCwgbGFiZWw6IGxhYmVsLCBpc1JlcXVpcmVkOiByZXF1aXJlZCwgdmFsaWRhdGVkOiBlcnJvciA/ICdlcnJvcicgOiAnZGVmYXVsdCcsIHR5cGU6IHR5cGUsIGhlbHBlclRleHQ6IGhlbHAsIGhlbHBlclRleHRJbnZhbGlkOiBlcnJvck1lc3NhZ2UgfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSwgY2hpbGRyZW4pKTtcbn1cbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENoZWNrYm94LCBTd2l0Y2gsIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgd3JhcEZpZWxkIGZyb20gJy4vd3JhcEZpZWxkJztcbnZhciBDb21wb25lbnRUeXBlO1xuKGZ1bmN0aW9uIChDb21wb25lbnRUeXBlKSB7XG4gICAgQ29tcG9uZW50VHlwZVtcImNoZWNrYm94XCJdID0gXCJjaGVja2JveFwiO1xuICAgIENvbXBvbmVudFR5cGVbXCJzd2l0Y2hcIl0gPSBcInN3aXRjaFwiO1xufSkoQ29tcG9uZW50VHlwZSB8fCAoQ29tcG9uZW50VHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBCb29sKF9hKSB7XG4gICAgdmFyIHsgYXBwZWFyYW5jZSwgZGlzYWJsZWQsIGlkLCBpbnB1dFJlZiwgbGFiZWwsIG5hbWUsIG9uQ2hhbmdlLCB2YWx1ZSB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJhcHBlYXJhbmNlXCIsIFwiZGlzYWJsZWRcIiwgXCJpZFwiLCBcImlucHV0UmVmXCIsIFwibGFiZWxcIiwgXCJuYW1lXCIsIFwib25DaGFuZ2VcIiwgXCJ2YWx1ZVwiXSk7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gYXBwZWFyYW5jZSA9PT0gQ29tcG9uZW50VHlwZS5zd2l0Y2ggPyBTd2l0Y2ggOiBDaGVja2JveDtcbiAgICByZXR1cm4gd3JhcEZpZWxkKE9iamVjdC5hc3NpZ24oeyBpZCB9LCBwcm9wcyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IGlzQ2hlY2tlZDogdmFsdWUgfHwgZmFsc2UsIGlzRGlzYWJsZWQ6IGRpc2FibGVkLCBpZDogaWQsIG5hbWU6IG5hbWUsIG9uQ2hhbmdlOiAoKSA9PiBkaXNhYmxlZCB8fCBvbkNoYW5nZSghdmFsdWUpLCByZWY6IGlucHV0UmVmLCBsYWJlbDogbGFiZWwgfSkpO1xufVxuQm9vbC5kZWZhdWx0UHJvcHMgPSB7IGFwcGVhcmFuY2U6IENvbXBvbmVudFR5cGUuY2hlY2tib3ggfTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChCb29sKTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCB9IGZyb20gJ3VuaWZvcm1zJztcbmltcG9ydCB7IERhdGVQaWNrZXIsIEZsZXgsIEZsZXhJdGVtLCBJbnB1dEdyb3VwLCBUaW1lUGlja2VyLCB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHdyYXBGaWVsZCBmcm9tICcuL3dyYXBGaWVsZCc7XG5jb25zdCBEYXRlQ29uc3RydWN0b3IgPSAodHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgPyBnbG9iYWwgOiB3aW5kb3cpLkRhdGU7XG5mdW5jdGlvbiBEYXRlRmllbGQocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHBhcnNlRGF0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcy52YWx1ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xNCk7XG4gICAgfSwgW3Byb3BzLnZhbHVlXSk7XG4gICAgY29uc3QgcGFyc2VUaW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3Byb3BzLnZhbHVlLmdldFVUQ0hvdXJzKCl9OiR7cHJvcHMudmFsdWUuZ2V0VVRDTWludXRlcygpfWA7XG4gICAgfSwgW3Byb3BzLnZhbHVlXSk7XG4gICAgY29uc3Qgb25EYXRlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHZhbHVlLCBkYXRlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkNoYW5nZShkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZUNvbnN0cnVjdG9yKGRhdGUpO1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IHBhcnNlVGltZSgpO1xuICAgICAgICAgICAgaWYgKHRpbWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENIb3VycyhwYXJzZUludCh0aW1lID09PSBudWxsIHx8IHRpbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWUuc3BsaXQoJzonKVswXSkpO1xuICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0VVRDTWludXRlcyhwYXJzZUludCgoX2EgPSB0aW1lID09PSBudWxsIHx8IHRpbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWUuc3BsaXQoJzonKVsxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCcgJylbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0VVRDSG91cnMoMCk7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UobmV3RGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMub25DaGFuZ2UsIHBhcnNlVGltZV0pO1xuICAgIGNvbnN0IGlzSW52YWxpZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5taW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5EYXRlID0gbmV3IERhdGUocHJvcHMubWluKTtcbiAgICAgICAgICAgICAgICBpZiAobWluRGF0ZS50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLnZhbHVlIDwgbWluRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFNob3VsZCBiZSBhZnRlciAke21pbkRhdGUudG9JU09TdHJpbmcoKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhEYXRlID0gbmV3IERhdGUocHJvcHMubWF4KTtcbiAgICAgICAgICAgICAgICBpZiAobWF4RGF0ZS50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLnZhbHVlID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFNob3VsZCBiZSBiZWZvcmUgJHttYXhEYXRlLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtwcm9wcy52YWx1ZV0pO1xuICAgIGNvbnN0IG9uVGltZUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0aW1lLCBob3VycywgbWludXRlcykgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlQ29uc3RydWN0b3IocHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGhvdXJzICYmIG1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRlLnNldFVUQ0hvdXJzKGhvdXJzKTtcbiAgICAgICAgICAgICAgICBuZXdEYXRlLnNldFVUQ01pbnV0ZXMobWludXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZUhvdXJzID0gcGFyc2VJbnQodGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lLnNwbGl0KCc6JylbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZU1pbnV0ZXMgPSBwYXJzZUludCgoX2EgPSB0aW1lID09PSBudWxsIHx8IHRpbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWUuc3BsaXQoJzonKVsxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCcgJylbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obG9jYWxlSG91cnMpICYmICFpc05hTihsb2NhbGVNaW51dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRlLnNldFVUQ0hvdXJzKGxvY2FsZUhvdXJzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKGxvY2FsZU1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0VVRDSG91cnMoMCk7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UobmV3RGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMub25DaGFuZ2UsIHByb3BzLnZhbHVlXSk7XG4gICAgcmV0dXJuIHdyYXBGaWVsZChwcm9wcywgUmVhY3QuY3JlYXRlRWxlbWVudChGbGV4LCB7IHN0eWxlOiB7IG1hcmdpbjogMCB9LCBkaXJlY3Rpb246IHsgZGVmYXVsdDogJ2NvbHVtbicgfSwgaWQ6IHByb3BzLmlkLCBuYW1lOiBwcm9wcy5uYW1lLCByZWY6IHByb3BzLmlucHV0UmVmIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxleEl0ZW0sIHsgc3R5bGU6IHsgbWFyZ2luOiAwIH0gfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRHcm91cCwgeyBzdHlsZTogeyBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnIH0gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGVQaWNrZXIsIHsgaWQ6IGBkYXRlLXBpY2tlci0ke3Byb3BzLmlkfWAsIFwiZGF0YS10ZXN0aWRcIjogYGRhdGUtcGlja2VyYCwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIG5hbWU6IHByb3BzLm5hbWUsIG9uQ2hhbmdlOiBvbkRhdGVDaGFuZ2UsIHZhbHVlOiAoX2EgPSBwYXJzZURhdGUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUaW1lUGlja2VyLCB7IGlkOiBgdGltZS1waWNrZXItJHtwcm9wcy5pZH1gLCBcImRhdGEtdGVzdGlkXCI6IGB0aW1lLXBpY2tlcmAsIGlzRGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIHx8ICFwcm9wcy52YWx1ZSwgbmFtZTogcHJvcHMubmFtZSwgb25DaGFuZ2U6IG9uVGltZUNoYW5nZSwgc3R5bGU6IHsgd2lkdGg6ICcxMjBweCcgfSwgdmFsdWU6IChfYiA9IHBhcnNlVGltZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgaXMyNEhvdXI6IHRydWUgfSkpKSxcbiAgICAgICAgaXNJbnZhbGlkICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaWQ6IGAke3Byb3BzLmlkfS1pbnZhbGlkLWRhdGUtdGltZWAsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjg3NXJlbScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjYzkxOTBiJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6ICcwLjI1cmVtJyxcbiAgICAgICAgICAgIH0gfSwgaXNJbnZhbGlkKSkpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChEYXRlRmllbGQpO1xuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBNaW51c0NpcmNsZUljb24gfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1pY29ucyc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzLCBqb2luTmFtZSwgdXNlRmllbGQsIH0gZnJvbSAndW5pZm9ybXMnO1xuZnVuY3Rpb24gTGlzdERlbChfYSkge1xuICAgIHZhciB7IG5hbWUsIGRpc2FibGVkIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcIm5hbWVcIiwgXCJkaXNhYmxlZFwiXSk7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gam9pbk5hbWUobnVsbCwgbmFtZSk7XG4gICAgY29uc3QgbmFtZUluZGV4ID0gK25hbWVQYXJ0c1tuYW1lUGFydHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcGFyZW50TmFtZSA9IGpvaW5OYW1lKG5hbWVQYXJ0cy5zbGljZSgwLCAtMSkpO1xuICAgIGNvbnN0IHBhcmVudCA9IHVzZUZpZWxkKHBhcmVudE5hbWUsIHt9LCB7IGFic29sdXRlTmFtZTogdHJ1ZSB9KVswXTtcbiAgICBjb25zdCBsaW1pdE5vdFJlYWNoZWQgPSAhZGlzYWJsZWQgJiYgIShwYXJlbnQubWluQ291bnQgPj0gcGFyZW50LnZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgT2JqZWN0LmFzc2lnbih7IGRpc2FibGVkOiAhbGltaXROb3RSZWFjaGVkIHx8IGRpc2FibGVkLCB2YXJpYW50OiBcInBsYWluXCIsIHN0eWxlOiB7IHBhZGRpbmdMZWZ0OiAnMCcsIHBhZGRpbmdSaWdodDogJzAnIH0sIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyZW50LnZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB2YWx1ZS5zcGxpY2UobmFtZUluZGV4LCAxKTtcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJiBsaW1pdE5vdFJlYWNoZWQgJiYgcGFyZW50Lm9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfSB9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1pbnVzQ2lyY2xlSWNvbiwgeyBjb2xvcjogXCIjY2MwMDAwXCIgfSkpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChMaXN0RGVsLCB7XG4gICAgaW5pdGlhbFZhbHVlOiBmYWxzZSxcbiAgICBraW5kOiAnbGVhZicsXG59KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgQXV0b0ZpZWxkIGZyb20gJy4vQXV0b0ZpZWxkJztcbmltcG9ydCBMaXN0RGVsRmllbGQgZnJvbSAnLi9MaXN0RGVsRmllbGQnO1xuZnVuY3Rpb24gTGlzdEl0ZW0oeyBjaGlsZHJlbiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0b0ZpZWxkLCB7IGxhYmVsOiBudWxsLCBuYW1lOiAnJyB9KSwgfSkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcxcmVtJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgIH0gfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScsIG1hcmdpblJpZ2h0OiAnMTBweCcgfSB9LCBjaGlsZHJlbiksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdERlbEZpZWxkLCB7IG5hbWU6ICcnIH0pKSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKExpc3RJdGVtLCB7XG4gICAgaW5pdGlhbFZhbHVlOiBmYWxzZSxcbn0pO1xuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsb25lRGVlcCBmcm9tICdsb2Rhc2gvY2xvbmVEZWVwJztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgUGx1c0NpcmNsZUljb24gfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1pY29ucyc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzLCBqb2luTmFtZSwgdXNlRmllbGQsIH0gZnJvbSAndW5pZm9ybXMnO1xuZnVuY3Rpb24gTGlzdEFkZChfYSkge1xuICAgIHZhciB7IGRpc2FibGVkID0gZmFsc2UsIG5hbWUsIHZhbHVlIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImRpc2FibGVkXCIsIFwibmFtZVwiLCBcInZhbHVlXCJdKTtcbiAgICBjb25zdCBuYW1lUGFydHMgPSBqb2luTmFtZShudWxsLCBuYW1lKTtcbiAgICBjb25zdCBwYXJlbnROYW1lID0gam9pbk5hbWUobmFtZVBhcnRzLnNsaWNlKDAsIC0xKSk7XG4gICAgY29uc3QgcGFyZW50ID0gdXNlRmllbGQocGFyZW50TmFtZSwge30sIHsgYWJzb2x1dGVOYW1lOiB0cnVlIH0pWzBdO1xuICAgIGNvbnN0IGxpbWl0Tm90UmVhY2hlZCA9ICFkaXNhYmxlZCAmJiAhKHBhcmVudC5tYXhDb3VudCA8PSBwYXJlbnQudmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCBPYmplY3QuYXNzaWduKHsgdmFyaWFudDogXCJwbGFpblwiLCBzdHlsZTogeyBwYWRkaW5nTGVmdDogJzAnLCBwYWRkaW5nUmlnaHQ6ICcwJyB9LCBkaXNhYmxlZDogIWxpbWl0Tm90UmVhY2hlZCwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgIWRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgbGltaXROb3RSZWFjaGVkICYmXG4gICAgICAgICAgICAgICAgcGFyZW50Lm9uQ2hhbmdlKHBhcmVudC52YWx1ZS5jb25jYXQoW2Nsb25lRGVlcCh2YWx1ZSldKSk7XG4gICAgICAgIH0gfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQbHVzQ2lyY2xlSWNvbiwgeyBjb2xvcjogXCIjMDA4OGNlXCIgfSkpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChMaXN0QWRkLCB7XG4gICAgaW5pdGlhbFZhbHVlOiBmYWxzZSxcbiAgICBraW5kOiAnbGVhZicsXG59KTtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0LCB7IENoaWxkcmVuLCBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50LCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNwbGl0LCBTcGxpdEl0ZW0sIFRvb2x0aXAgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IE91dGxpbmVkUXVlc3Rpb25DaXJjbGVJY29uIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkLCBmaWx0ZXJET01Qcm9wcyB9IGZyb20gJ3VuaWZvcm1zJztcbmltcG9ydCBMaXN0SXRlbUZpZWxkIGZyb20gJy4vTGlzdEl0ZW1GaWVsZCc7XG5pbXBvcnQgTGlzdEFkZEZpZWxkIGZyb20gJy4vTGlzdEFkZEZpZWxkJztcbmZpbHRlckRPTVByb3BzLnJlZ2lzdGVyKCdtaW5Db3VudCcsICd3cmFwcGVyQ29sJywgJ2xhYmVsQ29sJyk7XG5mdW5jdGlvbiBMaXN0RmllbGQoX2EpIHtcbiAgICB2YXIgeyBjaGlsZHJlbiA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEl0ZW1GaWVsZCwgeyBuYW1lOiBcIiRcIiB9KSwgZXJyb3IsIGVycm9yTWVzc2FnZSwgaW5mbywgaW5pdGlhbENvdW50LCBpdGVtUHJvcHMsIGxhYmVsLCBuYW1lLCB2YWx1ZSwgc2hvd0lubGluZUVycm9yIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZXJyb3JcIiwgXCJlcnJvck1lc3NhZ2VcIiwgXCJpbmZvXCIsIFwiaW5pdGlhbENvdW50XCIsIFwiaXRlbVByb3BzXCIsIFwibGFiZWxcIiwgXCJuYW1lXCIsIFwidmFsdWVcIiwgXCJzaG93SW5saW5lRXJyb3JcIl0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNwbGl0LCB7IGhhc0d1dHRlcjogdHJ1ZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTcGxpdEl0ZW0sIG51bGwsIGxhYmVsICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICAhIWluZm8gJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFwiXFx1MDBBMFwiLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIHsgY29udGVudDogaW5mbyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsaW5lZFF1ZXN0aW9uQ2lyY2xlSWNvbiwgbnVsbCkpKSkpKSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNwbGl0SXRlbSwgeyBpc0ZpbGxlZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3BsaXRJdGVtLCBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEFkZEZpZWxkLCB7IG5hbWU6ICckJywgaW5pdGlhbENvdW50OiBpbml0aWFsQ291bnQgfSkpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBjaGlsZEluZGV4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZEVsZW1lbnQoY2hpbGQpXG4gICAgICAgICAgICAgICAgPyBjbG9uZUVsZW1lbnQoY2hpbGQsIE9iamVjdC5hc3NpZ24oeyBrZXk6IGAke2l0ZW1JbmRleH0tJHtjaGlsZEluZGV4fWAsIG5hbWU6IChfYSA9IGNoaWxkLnByb3BzLm5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKCckJywgJycgKyBpdGVtSW5kZXgpIH0sIGl0ZW1Qcm9wcykpXG4gICAgICAgICAgICAgICAgOiBjaGlsZDtcbiAgICAgICAgfSkpKSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKExpc3RGaWVsZCk7XG4iLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IHsgQ2FyZCwgQ2FyZEJvZHkgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCBBdXRvRmllbGQgZnJvbSAnLi9BdXRvRmllbGQnO1xuY29uc3QgTmVzdCA9IChfYSkgPT4ge1xuICAgIHZhciB7IGNoaWxkcmVuLCBlcnJvciwgZXJyb3JNZXNzYWdlLCBmaWVsZHMsIGl0ZW1Qcm9wcywgbGFiZWwsIG5hbWUsIHNob3dJbmxpbmVFcnJvciwgZGlzYWJsZWQgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJlcnJvclwiLCBcImVycm9yTWVzc2FnZVwiLCBcImZpZWxkc1wiLCBcIml0ZW1Qcm9wc1wiLCBcImxhYmVsXCIsIFwibmFtZVwiLCBcInNob3dJbmxpbmVFcnJvclwiLCBcImRpc2FibGVkXCJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwgT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkQm9keSwgeyBjbGFzc05hbWU6IFwicGYtYy1mb3JtXCIgfSxcbiAgICAgICAgICAgIGxhYmVsICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYlwiLCBudWxsLCBsYWJlbCkpKSxcbiAgICAgICAgICAgIGNoaWxkcmVuIHx8IChmaWVsZHMgPT09IG51bGwgfHwgZmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZHMubWFwKChmaWVsZCkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0b0ZpZWxkLCBPYmplY3QuYXNzaWduKHsga2V5OiBmaWVsZCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBuYW1lOiBmaWVsZCB9LCBpdGVtUHJvcHMpKSkpKSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0RmllbGQoTmVzdCk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGV4dElucHV0IH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgd3JhcEZpZWxkIGZyb20gJy4vd3JhcEZpZWxkJztcbmNvbnN0IE51bSA9IChwcm9wcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvbkNoYW5nZSA9ICh2YWx1ZSwgZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2UgPSBwcm9wcy5kZWNpbWFsID8gcGFyc2VGbG9hdCA6IHBhcnNlSW50O1xuICAgICAgICBjb25zdCB2ID0gcGFyc2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UoaXNOYU4odikgPyB1bmRlZmluZWQgOiB2KTtcbiAgICB9O1xuICAgIHJldHVybiB3cmFwRmllbGQocHJvcHMsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCB7IG5hbWU6IHByb3BzLm5hbWUsIGlzRGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLCBpZDogcHJvcHMuaWQsIG1heDogcHJvcHMubWF4LCBtaW46IHByb3BzLm1pbiwgb25DaGFuZ2U6IG9uQ2hhbmdlLCBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIsIHJlZjogcHJvcHMuaW5wdXRSZWYsIHN0ZXA6IHByb3BzLmRlY2ltYWwgPyAwLjAxIDogMSwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IChfYSA9IHByb3BzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgdmFsaWRhdGVkOiBwcm9wcy5lcnJvciA/ICdlcnJvcicgOiAnZGVmYXVsdCcgfSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChOdW0pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJhZGlvIGFzIFJhZGlvRmllbGQgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCwgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgd3JhcEZpZWxkIGZyb20gJy4vd3JhcEZpZWxkJztcbmNvbnN0IFJhZGlvID0gKHByb3BzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGZpbHRlckRPTVByb3BzLnJlZ2lzdGVyKCdjaGVja2JveGVzJywgJ2RlY2ltYWwnKTtcbiAgICByZXR1cm4gd3JhcEZpZWxkKHByb3BzLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIGZpbHRlckRPTVByb3BzKHByb3BzKSksIChfYSA9IHByb3BzLmFsbG93ZWRWYWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGl0ZW0pID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaXRlbSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJhZGlvRmllbGQsIHsgaXNDaGVja2VkOiBpdGVtID09PSBwcm9wcy52YWx1ZSwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIGlkOiBgJHtwcm9wcy5pZH1gLCBuYW1lOiBwcm9wcy5uYW1lLCBsYWJlbDogcHJvcHMudHJhbnNmb3JtID8gcHJvcHMudHJhbnNmb3JtKGl0ZW0pIDogaXRlbSwgXCJhcmlhLWxhYmVsXCI6IHByb3BzLm5hbWUsIG9uQ2hhbmdlOiAoKSA9PiBwcm9wcy5vbkNoYW5nZShpdGVtKSB9KSkpKSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChSYWRpbyk7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGVja2JveCwgUmFkaW8sIFNlbGVjdCwgU2VsZWN0T3B0aW9uLCBTZWxlY3RWYXJpYW50LCB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkLCBmaWx0ZXJET01Qcm9wcyB9IGZyb20gJ3VuaWZvcm1zJztcbmltcG9ydCB3cmFwRmllbGQgZnJvbSAnLi93cmFwRmllbGQnO1xuZnVuY3Rpb24geG9yKGl0ZW0sIGFycmF5KSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmNvbmNhdChbaXRlbV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdChhcnJheS5zbGljZShpbmRleCArIDEpKTtcbn1cbmZpbHRlckRPTVByb3BzLnJlZ2lzdGVyKCdhdXRvVmFsdWUnKTtcbmZ1bmN0aW9uIGlzU2VsZWN0T3B0aW9uT2JqZWN0KHRvQmVEZXRlcm1pbmVkKSB7XG4gICAgcmV0dXJuIHRvQmVEZXRlcm1pbmVkLnRvU3RyaW5nICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBTZWxlY3RGaWVsZChwcm9wcykge1xuICAgIGlmIChwcm9wcy5jaGVja2JveGVzKSB7XG4gICAgICAgIGNvbnN0IEdyb3VwID0gdXNlTWVtbygoKSA9PiAocHJvcHMuZmllbGRUeXBlID09PSBBcnJheSA/IENoZWNrYm94IDogUmFkaW8pLCBbcHJvcHNdKTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIGZpbHRlckRPTVByb3BzKHByb3BzKSksXG4gICAgICAgICAgICBwcm9wcy5sYWJlbCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCwgcHJvcHMubGFiZWwpLFxuICAgICAgICAgICAgcHJvcHMuYWxsb3dlZFZhbHVlcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgaHRtbEZvcjogcHJvcHMuaWQgfSwgcHJvcHMudHJhbnNmb3JtID8gcHJvcHMudHJhbnNmb3JtKGl0ZW0pIDogaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXAsIHsgaWQ6IGAke3Byb3BzLmlkfS0ke2l0ZW19YCwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIG5hbWU6IHByb3BzLm5hbWUsIFwiYXJpYS1sYWJlbFwiOiBwcm9wcy5uYW1lLCB2YWx1ZTogcHJvcHMudmFsdWUsIGlzQ2hlY2tlZDogcHJvcHMuZmllbGRUeXBlID09PSBBcnJheSAmJiBBcnJheS5pc0FycmF5KHByb3BzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcHMudmFsdWUuaW5jbHVkZXMoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHByb3BzLnZhbHVlID09PSBpdGVtLCBvbkNoYW5nZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKHByb3BzLmZpZWxkVHlwZSA9PT0gQXJyYXkgJiYgQXJyYXkuaXNBcnJheShwcm9wcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB4b3IoaXRlbSwgcHJvcHMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICBjb25zdCBbZXhwYW5kZWQsIHNldEV4cGFuZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZChbXSk7XG4gICAgICAgICAgICBzZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKFsuLi5wcm9wcy52YWx1ZV0pO1xuICAgICAgICAgICAgc2V0RXhwYW5kZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWQocHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgc2V0RXhwYW5kZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW3Byb3BzLnZhbHVlXSk7XG4gICAgY29uc3QgcGFyc2VJbnB1dCA9IHVzZUNhbGxiYWNrKChzZWxlY3Rpb24sIGZpZWxkVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRTZWxlY3Rpb24gPSBpc1NlbGVjdE9wdGlvbk9iamVjdChzZWxlY3Rpb24pXG4gICAgICAgICAgICA/IHNlbGVjdGlvbi50b1N0cmluZygpXG4gICAgICAgICAgICA6IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGZpZWxkVHlwZSAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRTZWxlY3Rpb24gIT09ICcnID8gcGFyc2VkU2VsZWN0aW9uIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQuaW5jbHVkZXMocGFyc2VkU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZC5maWx0ZXIoKHMpID0+IHMgIT09IHBhcnNlZFNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3BhcnNlZFNlbGVjdGlvbiwgLi4uc2VsZWN0ZWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcGFyc2VkU2VsZWN0aW9uLCBzZWxlY3RlZF07XG4gICAgfSwgW3NlbGVjdGVkXSk7XG4gICAgY29uc3QgaGFuZGxlU2VsZWN0ID0gdXNlQ2FsbGJhY2soKGV2ZW50LCBzZWxlY3Rpb24pID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHBhcnNlSW5wdXQoc2VsZWN0aW9uLCBwcm9wcy5maWVsZFR5cGUpO1xuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UoaXRlbXMpO1xuICAgICAgICB9XG4gICAgfSwgW3BhcnNlSW5wdXQsIHByb3BzXSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0gdXNlTWVtbygoKSA9PiBwcm9wcy5hbGxvd2VkVmFsdWVzLm1hcCgodmFsdWUpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdE9wdGlvbiwgeyBrZXk6IHZhbHVlLCB2YWx1ZTogdmFsdWUgfSwgcHJvcHMudHJhbnNmb3JtID8gcHJvcHMudHJhbnNmb3JtKHZhbHVlKSA6IHZhbHVlKSkpLCBbcHJvcHNdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMucGxhY2Vob2xkZXIpXG4gICAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMudW5zaGlmdChSZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdE9wdGlvbiwgeyBrZXk6IHByb3BzLmFsbG93ZWRWYWx1ZXMubGVuZ3RoLCBpc1BsYWNlaG9sZGVyOiB0cnVlLCB2YWx1ZTogcHJvcHMucGxhY2Vob2xkZXIgfSkpO1xuICAgIH0sIFtwcm9wcy5wbGFjZWhvbGRlciwgc2VsZWN0ZWRPcHRpb25zXSk7XG4gICAgcmV0dXJuIHdyYXBGaWVsZChwcm9wcywgUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3QsIHsgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIGlkOiBwcm9wcy5pZCwgdmFyaWFudDogcHJvcHMuZmllbGRUeXBlID09PSBBcnJheVxuICAgICAgICAgICAgPyBTZWxlY3RWYXJpYW50LnR5cGVhaGVhZE11bHRpXG4gICAgICAgICAgICA6IFNlbGVjdFZhcmlhbnQuc2luZ2xlLCBuYW1lOiBwcm9wcy5uYW1lLCBwbGFjZWhvbGRlclRleHQ6IHByb3BzLnBsYWNlaG9sZGVyLCBpc09wZW46IGV4cGFuZGVkLCBzZWxlY3Rpb25zOiBzZWxlY3RlZCwgb25Ub2dnbGU6ICgpID0+IHNldEV4cGFuZGVkKCFleHBhbmRlZCksIG9uU2VsZWN0OiBoYW5kbGVTZWxlY3QsIHZhbHVlOiBwcm9wcy52YWx1ZSB8fCAocHJvcHMuZmllbGRUeXBlID09PSBBcnJheSA/IFtdIDogdW5kZWZpbmVkKSB9LCBzZWxlY3RlZE9wdGlvbnMpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChTZWxlY3RGaWVsZCk7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEYXRlUGlja2VyLCBUZXh0SW5wdXQsIFRpbWVQaWNrZXIsIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IHdyYXBGaWVsZCBmcm9tICcuL3dyYXBGaWVsZCc7XG5jb25zdCB0aW1lUmd4ID0gL14oWzAtMV0/WzAtOV18MlswLTNdKTooWzAtNV1bMC05XSkoOlswLTVdWzAtOV0pPy87XG5jb25zdCBUZXh0ID0gKHByb3BzKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgY29uc3QgaXNEYXRlSW52YWxpZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHMudmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAocHJvcHMudHlwZSA9PT0gJ2RhdGUnIHx8ICgoX2EgPSBwcm9wcy5maWVsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcm1hdCkgPT09ICdkYXRlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwcm9wcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BzLm1pbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5EYXRlID0gbmV3IERhdGUocHJvcHMubWluKTtcbiAgICAgICAgICAgICAgICBpZiAobWluRGF0ZS50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGUudG9JU09TdHJpbmcoKSA8IG1pbkRhdGUudG9JU09TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZXJyb3JNZXNzYWdlICYmIHByb3BzLmVycm9yTWVzc2FnZS50cmltKCkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9wcy5lcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYFNob3VsZCBiZSBhZnRlciAke3Byb3BzLm1pbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHMubWF4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heERhdGUgPSBuZXcgRGF0ZShwcm9wcy5tYXgpO1xuICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlLnRvU3RyaW5nKCkgPT09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZS50b0lTT1N0cmluZygpID4gbWF4RGF0ZS50b0lTT1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5lcnJvck1lc3NhZ2UgJiYgcHJvcHMuZXJyb3JNZXNzYWdlLnRyaW0oKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgU2hvdWxkIGJlIGJlZm9yZSAke3Byb3BzLm1heH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3Byb3BzLnZhbHVlLCBwcm9wcy5tYXgsIHByb3BzLm1pbiwgcHJvcHMuZXJyb3JNZXNzYWdlXSk7XG4gICAgY29uc3QgcGFyc2VUaW1lID0gdXNlQ2FsbGJhY2soKHRpbWUpID0+IHtcbiAgICAgICAgY29uc3QgcGFyc2VkVGltZSA9IHRpbWVSZ3guZXhlYyh0aW1lKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFwYXJzZWRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGRhdGUuc2V0VVRDSG91cnMoTnVtYmVyKHBhcnNlZFRpbWVbMV0pLCBOdW1iZXIocGFyc2VkVGltZVsyXSkpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaXNUaW1lSW52YWxpZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHMudmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAocHJvcHMudHlwZSA9PT0gJ3RpbWUnIHx8ICgoX2EgPSBwcm9wcy5maWVsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcm1hdCkgPT09ICd0aW1lJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFRpbWUgPSBwYXJzZVRpbWUocHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcHMubWluID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIHRpbWVSZ3guZXhlYyhwcm9wcy5taW4pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkTWluID0gcGFyc2VUaW1lKHByb3BzLm1pbik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUgPCBwYXJzZWRNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBTaG91bGQgYmUgYWZ0ZXIgJHtwYXJzZWRNaW4uZ2V0VVRDSG91cnMoKX06JHtwYXJzZWRNaW4uZ2V0VVRDTWludXRlcygpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcHMubWF4ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIHRpbWVSZ3guZXhlYyhwcm9wcy5tYXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkTWF4ID0gcGFyc2VUaW1lKHByb3BzLm1heCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUgPiBwYXJzZWRNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBTaG91bGQgYmUgYmVmb3JlICR7cGFyc2VkTWF4LmdldFVUQ0hvdXJzKCl9OiR7cGFyc2VkTWF4LmdldFVUQ01pbnV0ZXMoKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3Byb3BzLnR5cGUsIHByb3BzLmZpZWxkLCBwcm9wcy52YWx1ZSwgcHJvcHMubWF4LCBwcm9wcy5taW5dKTtcbiAgICBjb25zdCBvbkRhdGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IHtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICAgIH0sIFtwcm9wcy5kaXNhYmxlZCwgcHJvcHMub25DaGFuZ2VdKTtcbiAgICBjb25zdCBvblRpbWVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodGltZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gdGltZS5zcGxpdCgnOicpO1xuICAgICAgICBpZiAocGFyc2VkVGltZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKFsuLi5wYXJzZWRUaW1lLCAnMDAnXS5qb2luKCc6JykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMuZGlzYWJsZWQsIHByb3BzLm9uQ2hhbmdlXSk7XG4gICAgcmV0dXJuIHdyYXBGaWVsZChwcm9wcywgcHJvcHMudHlwZSA9PT0gJ2RhdGUnIHx8ICgoX2EgPSBwcm9wcy5maWVsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcm1hdCkgPT09ICdkYXRlJyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGVQaWNrZXIsIE9iamVjdC5hc3NpZ24oeyBuYW1lOiBwcm9wcy5uYW1lLCBpc0Rpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCwgb25DaGFuZ2U6IG9uRGF0ZUNoYW5nZSwgdmFsdWU6IChfYiA9IHByb3BzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyB9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpKSxcbiAgICAgICAgaXNEYXRlSW52YWxpZCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjg3NXJlbScsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjYzkxOTBiJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6ICcwLjI1cmVtJyxcbiAgICAgICAgICAgIH0gfSwgaXNEYXRlSW52YWxpZCkpKSkgOiBwcm9wcy50eXBlID09PSAndGltZScgfHwgKChfYyA9IHByb3BzLmZpZWxkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZm9ybWF0KSA9PT0gJ3RpbWUnID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZVBpY2tlciwgeyBuYW1lOiBwcm9wcy5uYW1lLCBpc0Rpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCwgb25DaGFuZ2U6IG9uVGltZUNoYW5nZSwgaXMyNEhvdXI6IHRydWUsIHZhbHVlOiAoX2QgPSBwcm9wcy52YWx1ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycgfSksXG4gICAgICAgIGlzVGltZUludmFsaWQgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC44NzVyZW0nLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2M5MTkwYicsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnMC4yNXJlbScsXG4gICAgICAgICAgICB9IH0sIGlzVGltZUludmFsaWQpKSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCBPYmplY3QuYXNzaWduKHsgbmFtZTogcHJvcHMubmFtZSwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIHZhbGlkYXRlZDogcHJvcHMuZXJyb3IgPyAnZXJyb3InIDogJ2RlZmF1bHQnLCBvbkNoYW5nZTogKHZhbHVlLCBldmVudCkgPT4gcHJvcHMub25DaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKSwgcGxhY2Vob2xkZXI6IHByb3BzLnBsYWNlaG9sZGVyLCByZWY6IHByb3BzLmlucHV0UmVmLCB0eXBlOiAoX2UgPSBwcm9wcy50eXBlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAndGV4dCcsIHZhbHVlOiAoX2YgPSBwcm9wcy52YWx1ZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogJycgfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0RmllbGQoVGV4dCk7XG4iLCJpbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVBdXRvRmllbGQgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgQm9vbEZpZWxkIGZyb20gJy4vQm9vbEZpZWxkJztcbmltcG9ydCBEYXRlRmllbGQgZnJvbSAnLi9EYXRlRmllbGQnO1xuaW1wb3J0IExpc3RGaWVsZCBmcm9tICcuL0xpc3RGaWVsZCc7XG5pbXBvcnQgTmVzdEZpZWxkIGZyb20gJy4vTmVzdEZpZWxkJztcbmltcG9ydCBOdW1GaWVsZCBmcm9tICcuL051bUZpZWxkJztcbmltcG9ydCBSYWRpb0ZpZWxkIGZyb20gJy4vUmFkaW9GaWVsZCc7XG5pbXBvcnQgU2VsZWN0RmllbGQgZnJvbSAnLi9TZWxlY3RGaWVsZCc7XG5pbXBvcnQgVGV4dEZpZWxkIGZyb20gJy4vVGV4dEZpZWxkJztcbmNvbnN0IEF1dG9GaWVsZCA9IGNyZWF0ZUF1dG9GaWVsZChwcm9wcyA9PiB7XG4gICAgaWYgKHByb3BzLmFsbG93ZWRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoZWNrYm94ZXMgJiYgcHJvcHMuZmllbGRUeXBlICE9PSBBcnJheVxuICAgICAgICAgICAgPyBSYWRpb0ZpZWxkXG4gICAgICAgICAgICA6IFNlbGVjdEZpZWxkO1xuICAgIH1cbiAgICBzd2l0Y2ggKHByb3BzLmZpZWxkVHlwZSkge1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgcmV0dXJuIExpc3RGaWVsZDtcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuIEJvb2xGaWVsZDtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgcmV0dXJuIERhdGVGaWVsZDtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICByZXR1cm4gTnVtRmllbGQ7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgcmV0dXJuIE5lc3RGaWVsZDtcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gVGV4dEZpZWxkO1xuICAgIH1cbiAgICByZXR1cm4gaW52YXJpYW50KGZhbHNlLCAnVW5zdXBwb3J0ZWQgZmllbGQgdHlwZTogJXMnLCBwcm9wcy5maWVsZFR5cGUpO1xufSk7XG5leHBvcnQgZGVmYXVsdCBBdXRvRmllbGQ7XG4iLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGb3JtIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IEF1dG9GaWVsZCBmcm9tICcuL0F1dG9GaWVsZCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBdXRvRmllbGRzKF9hKSB7XG4gICAgdmFyIHsgYXV0b0ZpZWxkID0gQXV0b0ZpZWxkLCBlbGVtZW50ID0gJ2RpdicsIGZpZWxkcywgb21pdEZpZWxkcyA9IFtdIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImF1dG9GaWVsZFwiLCBcImVsZW1lbnRcIiwgXCJmaWVsZHNcIiwgXCJvbWl0RmllbGRzXCJdKTtcbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gdXNlRm9ybSgpO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGVsZW1lbnQsIHByb3BzLCAoZmllbGRzICE9PSBudWxsICYmIGZpZWxkcyAhPT0gdm9pZCAwID8gZmllbGRzIDogc2NoZW1hLmdldFN1YmZpZWxkcygpKVxuICAgICAgICAuZmlsdGVyKChmaWVsZCkgPT4gIW9taXRGaWVsZHMuaW5jbHVkZXMoZmllbGQpKVxuICAgICAgICAubWFwKChmaWVsZCkgPT4gY3JlYXRlRWxlbWVudChhdXRvRmllbGQsIHsga2V5OiBmaWVsZCwgbmFtZTogZmllbGQgfSkpKTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGb3JtIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBCYXNlRm9ybSwgY29udGV4dCB9IGZyb20gJ3VuaWZvcm1zJztcbmZ1bmN0aW9uIFBhdHRlcm5mbHkocGFyZW50KSB7XG4gICAgY2xhc3MgXyBleHRlbmRzIHBhcmVudCB7XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmdldENvbnRleHQoKSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybSwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXROYXRpdmVGb3JtUHJvcHMoKSkpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXy5QYXR0ZXJuZmx5ID0gUGF0dGVybmZseTtcbiAgICBfLmRpc3BsYXlOYW1lID0gYFBhdHRlcm5mbHkke3BhcmVudC5kaXNwbGF5TmFtZX1gO1xuICAgIHJldHVybiBfO1xufVxuZXhwb3J0IGRlZmF1bHQgUGF0dGVybmZseShCYXNlRm9ybSk7XG4iLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGb3JtLCBmaWx0ZXJET01Qcm9wcyB9IGZyb20gJ3VuaWZvcm1zJztcbmZ1bmN0aW9uIEVycm9yc0ZpZWxkKF9hKSB7XG4gICAgdmFyIHsgY2hpbGRyZW4gfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIl0pO1xuICAgIGNvbnN0IHsgZXJyb3IsIHNjaGVtYSB9ID0gdXNlRm9ybSgpO1xuICAgIHJldHVybiAhZXJyb3IgJiYgIWNoaWxkcmVuID8gbnVsbCA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIGZpbHRlckRPTVByb3BzKHByb3BzKSksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgc2NoZW1hLmdldEVycm9yTWVzc2FnZXMoZXJyb3IpLm1hcCgobWVzc2FnZSwgaW5kZXgpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgeyBrZXk6IGluZGV4LCBzdHlsZTogeyBtYXJnaW46ICczcHgnIH0gfSwgbWVzc2FnZSkpKSkpKTtcbn1cbkVycm9yc0ZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgODUsIDAsIDAuMiknLFxuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgcmdiKDI1NSwgODUsIDApJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnN3B4JyxcbiAgICAgICAgbWFyZ2luOiAnMjBweCAwcHgnLFxuICAgICAgICBwYWRkaW5nOiAnMTBweCcsXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBFcnJvcnNGaWVsZDtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgZmlsdGVyRE9NUHJvcHMsIHVzZUZvcm0gfSBmcm9tICd1bmlmb3Jtcyc7XG5mdW5jdGlvbiBTdWJtaXRGaWVsZChfYSkge1xuICAgIHZhciB7IGRpc2FibGVkLCBpbnB1dFJlZiwgdmFsdWUgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiZGlzYWJsZWRcIiwgXCJpbnB1dFJlZlwiLCBcInZhbHVlXCJdKTtcbiAgICBjb25zdCB7IGVycm9yLCBzdGF0ZSB9ID0gdXNlRm9ybSgpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyBpc0Rpc2FibGVkOiBkaXNhYmxlZCA9PT0gdW5kZWZpbmVkID8gISEoZXJyb3IgfHwgc3RhdGUuZGlzYWJsZWQpIDogZGlzYWJsZWQsIHR5cGU6IFwic3VibWl0XCIsIHJlZjogaW5wdXRSZWYsIHZhcmlhbnQ6IFwicHJpbWFyeVwiIH0sIHZhbHVlKSkpO1xufVxuU3VibWl0RmllbGQuZGVmYXVsdFByb3BzID0geyB2YWx1ZTogJ1N1Ym1pdCcgfTtcbmV4cG9ydCBkZWZhdWx0IFN1Ym1pdEZpZWxkO1xuIiwiaW1wb3J0IHsgUXVpY2tGb3JtIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IEF1dG9GaWVsZCBmcm9tICcuL0F1dG9GaWVsZCc7XG5pbXBvcnQgQmFzZUZvcm0gZnJvbSAnLi9CYXNlRm9ybSc7XG5pbXBvcnQgRXJyb3JzRmllbGQgZnJvbSAnLi9FcnJvcnNGaWVsZCc7XG5pbXBvcnQgU3VibWl0RmllbGQgZnJvbSAnLi9TdWJtaXRGaWVsZCc7XG5mdW5jdGlvbiBRdWljayhwYXJlbnQpIHtcbiAgICBjbGFzcyBfIGV4dGVuZHMgUXVpY2tGb3JtLlF1aWNrKHBhcmVudCkge1xuICAgICAgICBnZXRBdXRvRmllbGQoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXV0b0ZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yc0ZpZWxkKCkge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yc0ZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIGdldFN1Ym1pdEZpZWxkKCkge1xuICAgICAgICAgICAgcmV0dXJuIFN1Ym1pdEZpZWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIF8uUXVpY2sgPSBRdWljaztcbiAgICByZXR1cm4gXztcbn1cbmV4cG9ydCBkZWZhdWx0IFF1aWNrKEJhc2VGb3JtKTtcbiIsImltcG9ydCB7IFZhbGlkYXRlZEZvcm0gfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgQmFzZUZvcm0gZnJvbSAnLi9CYXNlRm9ybSc7XG5mdW5jdGlvbiBWYWxpZGF0ZWQocGFyZW50KSB7XG4gICAgY2xhc3MgXyBleHRlbmRzIFZhbGlkYXRlZEZvcm0uVmFsaWRhdGVkKHBhcmVudCkge1xuICAgIH1cbiAgICBfLlZhbGlkYXRlZCA9IFZhbGlkYXRlZDtcbiAgICByZXR1cm4gXztcbn1cbmV4cG9ydCBkZWZhdWx0IFZhbGlkYXRlZChCYXNlRm9ybSk7XG4iLCJpbXBvcnQgQmFzZUZvcm0gZnJvbSAnLi9CYXNlRm9ybSc7XG5pbXBvcnQgUXVpY2tGb3JtIGZyb20gJy4vUXVpY2tGb3JtJztcbmltcG9ydCBWYWxpZGF0ZWRGb3JtIGZyb20gJy4vVmFsaWRhdGVkRm9ybSc7XG5leHBvcnQgZGVmYXVsdCBWYWxpZGF0ZWRGb3JtLlZhbGlkYXRlZChRdWlja0Zvcm0uUXVpY2soQmFzZUZvcm0pKTtcbiIsImltcG9ydCB7IEF1dG9Gb3JtIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IFZhbGlkYXRlZFF1aWNrRm9ybSBmcm9tICcuL1ZhbGlkYXRlZFF1aWNrRm9ybSc7XG5mdW5jdGlvbiBBdXRvKHBhcmVudCkge1xuICAgIGNsYXNzIF8gZXh0ZW5kcyBBdXRvRm9ybS5BdXRvKHBhcmVudCkge1xuICAgIH1cbiAgICBfLkF1dG8gPSBBdXRvO1xuICAgIHJldHVybiBfO1xufVxuZXhwb3J0IGRlZmF1bHQgQXV0byhWYWxpZGF0ZWRRdWlja0Zvcm0pO1xuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkLCBmaWx0ZXJET01Qcm9wcyB9IGZyb20gJ3VuaWZvcm1zJztcbmNvbnN0IEVycm9yID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgY2hpbGRyZW4sIGVycm9yLCBlcnJvck1lc3NhZ2UgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJlcnJvclwiLCBcImVycm9yTWVzc2FnZVwiXSk7XG4gICAgcmV0dXJuICFlcnJvciA/IG51bGwgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpLCBjaGlsZHJlbiA/IChjaGlsZHJlbikgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpbjogJzNweCcgfSB9LCBlcnJvck1lc3NhZ2UpKSkpO1xufTtcbkVycm9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgODUsIDAsIDAuMiknLFxuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgcmdiKDI1NSwgODUsIDApJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnN3B4JyxcbiAgICAgICAgbWFyZ2luOiAnMjBweCAwcHgnLFxuICAgICAgICBwYWRkaW5nOiAnMTBweCcsXG4gICAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0RmllbGQoRXJyb3IsIHsgaW5pdGlhbFZhbHVlOiBmYWxzZSB9KTtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZpZWxkLCBmaWx0ZXJET01Qcm9wcyB9IGZyb20gJ3VuaWZvcm1zJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhpZGRlbkZpZWxkKF9hKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB7IHZhbHVlIH0gPSBfYSwgcmF3UHJvcHMgPSBfX3Jlc3QoX2EsIFtcInZhbHVlXCJdKTtcbiAgICBjb25zdCBwcm9wcyA9IHVzZUZpZWxkKHJhd1Byb3BzLm5hbWUsIHJhd1Byb3BzLCB7IGluaXRpYWxWYWx1ZTogZmFsc2UgfSlbMF07XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHByb3BzLnZhbHVlKVxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9wcy5ub0RPTSA/IG51bGwgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIE9iamVjdC5hc3NpZ24oeyBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIGlkOiBwcm9wcy5pZCwgbmFtZTogcHJvcHMubmFtZSwgcmVmOiBwcm9wcy5pbnB1dFJlZiwgdHlwZTogXCJoaWRkZW5cIiwgdmFsdWU6IChfYiA9IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHByb3BzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyB9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpKSk7XG59XG4iLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0QXJlYSB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkLCBmaWx0ZXJET01Qcm9wcyB9IGZyb20gJ3VuaWZvcm1zJztcbmNvbnN0IExvbmdUZXh0ID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgZGlzYWJsZWQsIGlkLCBpbnB1dFJlZiwgbGFiZWwsIG5hbWUsIG9uQ2hhbmdlLCBwbGFjZWhvbGRlciwgdmFsdWUgfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiZGlzYWJsZWRcIiwgXCJpZFwiLCBcImlucHV0UmVmXCIsIFwibGFiZWxcIiwgXCJuYW1lXCIsIFwib25DaGFuZ2VcIiwgXCJwbGFjZWhvbGRlclwiLCBcInZhbHVlXCJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgbGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgaHRtbEZvcjogaWQgfSwgbGFiZWwpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRBcmVhLCB7IGlkOiBpZCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBuYW1lOiBuYW1lLCBcImFyaWEtbGFiZWxcIjogbmFtZSwgb25DaGFuZ2U6ICh2YWx1ZSwgZXZlbnQpID0+IG9uQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSksIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgcmVmOiBpbnB1dFJlZiwgdmFsdWU6IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6ICcnIH0pKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKExvbmdUZXh0KTtcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgQXV0b0ZpZWxkcyB9IGZyb20gJy4vQXV0b0ZpZWxkcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1dG9GaWVsZCB9IGZyb20gJy4vQXV0b0ZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXV0b0Zvcm0gfSBmcm9tICcuL0F1dG9Gb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFzZUZvcm0gfSBmcm9tICcuL0Jhc2VGb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm9vbEZpZWxkIH0gZnJvbSAnLi9Cb29sRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVycm9yRmllbGQgfSBmcm9tICcuL0Vycm9yRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFcnJvcnNGaWVsZCB9IGZyb20gJy4vRXJyb3JzRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIaWRkZW5GaWVsZCB9IGZyb20gJy4vSGlkZGVuRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0QWRkRmllbGQgfSBmcm9tICcuL0xpc3RBZGRGaWVsZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpc3REZWxGaWVsZCB9IGZyb20gJy4vTGlzdERlbEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEZpZWxkIH0gZnJvbSAnLi9MaXN0RmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0SXRlbUZpZWxkIH0gZnJvbSAnLi9MaXN0SXRlbUZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9uZ1RleHRGaWVsZCB9IGZyb20gJy4vTG9uZ1RleHRGaWVsZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5lc3RGaWVsZCB9IGZyb20gJy4vTmVzdEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTnVtRmllbGQgfSBmcm9tICcuL051bUZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUXVpY2tGb3JtIH0gZnJvbSAnLi9RdWlja0Zvcm0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSYWRpb0ZpZWxkIH0gZnJvbSAnLi9SYWRpb0ZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0RmllbGQgfSBmcm9tICcuL1NlbGVjdEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3VibWl0RmllbGQgfSBmcm9tICcuL1N1Ym1pdEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWYWxpZGF0ZWRGb3JtIH0gZnJvbSAnLi9WYWxpZGF0ZWRGb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmFsaWRhdGVkUXVpY2tGb3JtIH0gZnJvbSAnLi9WYWxpZGF0ZWRRdWlja0Zvcm0nO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36614\n')},7017:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "_T": () => (/* binding */ __rest)\n/* harmony export */ });\n/* unused harmony exports __extends, __assign, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== "function" && b !== null)\r\n        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError("Generator is already executing.");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === "number") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i["return"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume("next", value); }\r\n    function reject(value) { resume("throw", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o["default"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AY29zLXVpLWFwcHMvY29zLXVpLy4uLy4uLy4uLy4uL3VuaWZvcm1zLXBhdHRlcm5mbHkvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz9mMjViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDbkYseUJBQXlCLDhFQUE4RTtBQUN2RztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVPO0FBQ1A7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBOztBQUVPO0FBQ1AsbUNBQW1DLG9DQUFvQztBQUN2RTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMOztBQUVPO0FBQ1AsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtDQUFrQyxvQ0FBb0MsYUFBYSxFQUFFLEVBQUU7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1AsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQLGlEQUFpRCxRQUFRO0FBQ3pELHdDQUF3QyxRQUFRO0FBQ2hELHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFTztBQUNQLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHNGQUFzRixhQUFhLEVBQUU7QUFDdEgsc0JBQXNCLGdDQUFnQyxxQ0FBcUMsMENBQTBDLEVBQUUsRUFBRSxHQUFHO0FBQzVJLDJCQUEyQixNQUFNLGVBQWUsRUFBRSxZQUFZLG9CQUFvQixFQUFFO0FBQ3BGLHNCQUFzQixvR0FBb0c7QUFDMUgsNkJBQTZCLHVCQUF1QjtBQUNwRCw0QkFBNEIsd0JBQXdCO0FBQ3BELDJCQUEyQix5REFBeUQ7QUFDcEY7O0FBRU87QUFDUDtBQUNBLGlCQUFpQiw0Q0FBNEMsU0FBUyxFQUFFLHFEQUFxRCxhQUFhLEVBQUU7QUFDNUkseUJBQXlCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGdCQUFnQixFQUFFLEtBQUs7QUFDako7O0FBRU87QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHNGQUFzRixhQUFhLEVBQUU7QUFDaE4sc0JBQXNCLDhCQUE4QixnREFBZ0QsdURBQXVELEVBQUUsRUFBRSxHQUFHO0FBQ2xLLDRDQUE0QyxzQ0FBc0MsVUFBVSxvQkFBb0IsRUFBRSxFQUFFLFVBQVU7QUFDOUg7O0FBRU87QUFDUCxnQ0FBZ0MsdUNBQXVDLGFBQWEsRUFBRSxFQUFFLE9BQU8sa0JBQWtCO0FBQ2pIO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsNkJBQTZCO0FBQ3RFLENBQUM7QUFDRDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsNENBQTRDO0FBQzVDOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcwMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSkge1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZnJvbS5sZW5ndGgsIGogPSB0by5sZW5ndGg7IGkgPCBpbDsgaSsrLCBqKyspXHJcbiAgICAgICAgdG9bal0gPSBmcm9tW2ldO1xyXG4gICAgcmV0dXJuIHRvO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7017\n')}}]);