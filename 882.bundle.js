"use strict";(self.webpackChunkcos_ui=self.webpackChunkcos_ui||[]).push([[882],{64158:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = true;\n__webpack_require__(16383);\nexports.Z = {\n  "calendarMonth": "pf-c-calendar-month",\n  "calendarMonthCalendar": "pf-c-calendar-month__calendar",\n  "calendarMonthDate": "pf-c-calendar-month__date",\n  "calendarMonthDatesCell": "pf-c-calendar-month__dates-cell",\n  "calendarMonthDatesRow": "pf-c-calendar-month__dates-row",\n  "calendarMonthDay": "pf-c-calendar-month__day",\n  "calendarMonthDays": "pf-c-calendar-month__days",\n  "calendarMonthHeader": "pf-c-calendar-month__header",\n  "calendarMonthHeaderMonth": "pf-c-calendar-month__header-month",\n  "calendarMonthHeaderNavControl": "pf-c-calendar-month__header-nav-control",\n  "calendarMonthHeaderYear": "pf-c-calendar-month__header-year",\n  "modifiers": {\n    "prevMonth": "pf-m-prev-month",\n    "nextMonth": "pf-m-next-month",\n    "current": "pf-m-current",\n    "inRange": "pf-m-in-range",\n    "startRange": "pf-m-start-range",\n    "endRange": "pf-m-end-range",\n    "adjacentMonth": "pf-m-adjacent-month",\n    "selected": "pf-m-selected",\n    "disabled": "pf-m-disabled",\n    "hover": "pf-m-hover",\n    "focus": "pf-m-focus"\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQxNTguanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IseUJBQWtCO0FBQ2xCLG1CQUFPLENBQUMsS0FBc0I7QUFDOUIsU0FBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvY29tcG9uZW50cy9DYWxlbmRhck1vbnRoL2NhbGVuZGFyLW1vbnRoLmpzPzVkNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xucmVxdWlyZSgnLi9jYWxlbmRhci1tb250aC5jc3MnKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgXCJjYWxlbmRhck1vbnRoXCI6IFwicGYtYy1jYWxlbmRhci1tb250aFwiLFxuICBcImNhbGVuZGFyTW9udGhDYWxlbmRhclwiOiBcInBmLWMtY2FsZW5kYXItbW9udGhfX2NhbGVuZGFyXCIsXG4gIFwiY2FsZW5kYXJNb250aERhdGVcIjogXCJwZi1jLWNhbGVuZGFyLW1vbnRoX19kYXRlXCIsXG4gIFwiY2FsZW5kYXJNb250aERhdGVzQ2VsbFwiOiBcInBmLWMtY2FsZW5kYXItbW9udGhfX2RhdGVzLWNlbGxcIixcbiAgXCJjYWxlbmRhck1vbnRoRGF0ZXNSb3dcIjogXCJwZi1jLWNhbGVuZGFyLW1vbnRoX19kYXRlcy1yb3dcIixcbiAgXCJjYWxlbmRhck1vbnRoRGF5XCI6IFwicGYtYy1jYWxlbmRhci1tb250aF9fZGF5XCIsXG4gIFwiY2FsZW5kYXJNb250aERheXNcIjogXCJwZi1jLWNhbGVuZGFyLW1vbnRoX19kYXlzXCIsXG4gIFwiY2FsZW5kYXJNb250aEhlYWRlclwiOiBcInBmLWMtY2FsZW5kYXItbW9udGhfX2hlYWRlclwiLFxuICBcImNhbGVuZGFyTW9udGhIZWFkZXJNb250aFwiOiBcInBmLWMtY2FsZW5kYXItbW9udGhfX2hlYWRlci1tb250aFwiLFxuICBcImNhbGVuZGFyTW9udGhIZWFkZXJOYXZDb250cm9sXCI6IFwicGYtYy1jYWxlbmRhci1tb250aF9faGVhZGVyLW5hdi1jb250cm9sXCIsXG4gIFwiY2FsZW5kYXJNb250aEhlYWRlclllYXJcIjogXCJwZi1jLWNhbGVuZGFyLW1vbnRoX19oZWFkZXIteWVhclwiLFxuICBcIm1vZGlmaWVyc1wiOiB7XG4gICAgXCJwcmV2TW9udGhcIjogXCJwZi1tLXByZXYtbW9udGhcIixcbiAgICBcIm5leHRNb250aFwiOiBcInBmLW0tbmV4dC1tb250aFwiLFxuICAgIFwiY3VycmVudFwiOiBcInBmLW0tY3VycmVudFwiLFxuICAgIFwiaW5SYW5nZVwiOiBcInBmLW0taW4tcmFuZ2VcIixcbiAgICBcInN0YXJ0UmFuZ2VcIjogXCJwZi1tLXN0YXJ0LXJhbmdlXCIsXG4gICAgXCJlbmRSYW5nZVwiOiBcInBmLW0tZW5kLXJhbmdlXCIsXG4gICAgXCJhZGphY2VudE1vbnRoXCI6IFwicGYtbS1hZGphY2VudC1tb250aFwiLFxuICAgIFwic2VsZWN0ZWRcIjogXCJwZi1tLXNlbGVjdGVkXCIsXG4gICAgXCJkaXNhYmxlZFwiOiBcInBmLW0tZGlzYWJsZWRcIixcbiAgICBcImhvdmVyXCI6IFwicGYtbS1ob3ZlclwiLFxuICAgIFwiZm9jdXNcIjogXCJwZi1tLWZvY3VzXCJcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64158\n')},26410:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = true;\n__webpack_require__(97500);\nexports.Z = {\n  "datePicker": "pf-c-date-picker",\n  "datePickerCalendar": "pf-c-date-picker__calendar",\n  "datePickerHelperText": "pf-c-date-picker__helper-text",\n  "datePickerInput": "pf-c-date-picker__input",\n  "formControl": "pf-c-form-control",\n  "modifiers": {\n    "error": "pf-m-error",\n    "alignRight": "pf-m-align-right",\n    "top": "pf-m-top"\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY0MTAuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IseUJBQWtCO0FBQ2xCLG1CQUFPLENBQUMsS0FBbUI7QUFDM0IsU0FBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzL2Nzcy9jb21wb25lbnRzL0RhdGVQaWNrZXIvZGF0ZS1waWNrZXIuanM/M2Y3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5yZXF1aXJlKCcuL2RhdGUtcGlja2VyLmNzcycpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBcImRhdGVQaWNrZXJcIjogXCJwZi1jLWRhdGUtcGlja2VyXCIsXG4gIFwiZGF0ZVBpY2tlckNhbGVuZGFyXCI6IFwicGYtYy1kYXRlLXBpY2tlcl9fY2FsZW5kYXJcIixcbiAgXCJkYXRlUGlja2VySGVscGVyVGV4dFwiOiBcInBmLWMtZGF0ZS1waWNrZXJfX2hlbHBlci10ZXh0XCIsXG4gIFwiZGF0ZVBpY2tlcklucHV0XCI6IFwicGYtYy1kYXRlLXBpY2tlcl9faW5wdXRcIixcbiAgXCJmb3JtQ29udHJvbFwiOiBcInBmLWMtZm9ybS1jb250cm9sXCIsXG4gIFwibW9kaWZpZXJzXCI6IHtcbiAgICBcImVycm9yXCI6IFwicGYtbS1lcnJvclwiLFxuICAgIFwiYWxpZ25SaWdodFwiOiBcInBmLW0tYWxpZ24tcmlnaHRcIixcbiAgICBcInRvcFwiOiBcInBmLW0tdG9wXCJcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26410\n')},35890:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = true;\n__webpack_require__(31213);\nexports.Z = {\n  "modifiers": {\n    "reverse": "pf-m-reverse",\n    "off": "pf-m-off",\n    "on": "pf-m-on"\n  },\n  "switch": "pf-c-switch",\n  "switchInput": "pf-c-switch__input",\n  "switchLabel": "pf-c-switch__label",\n  "switchToggle": "pf-c-switch__toggle",\n  "switchToggleIcon": "pf-c-switch__toggle-icon"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU4OTAuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IseUJBQWtCO0FBQ2xCLG1CQUFPLENBQUMsS0FBYztBQUN0QixTQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvY29tcG9uZW50cy9Td2l0Y2gvc3dpdGNoLmpzPzExOWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xucmVxdWlyZSgnLi9zd2l0Y2guY3NzJyk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIFwibW9kaWZpZXJzXCI6IHtcbiAgICBcInJldmVyc2VcIjogXCJwZi1tLXJldmVyc2VcIixcbiAgICBcIm9mZlwiOiBcInBmLW0tb2ZmXCIsXG4gICAgXCJvblwiOiBcInBmLW0tb25cIlxuICB9LFxuICBcInN3aXRjaFwiOiBcInBmLWMtc3dpdGNoXCIsXG4gIFwic3dpdGNoSW5wdXRcIjogXCJwZi1jLXN3aXRjaF9faW5wdXRcIixcbiAgXCJzd2l0Y2hMYWJlbFwiOiBcInBmLWMtc3dpdGNoX19sYWJlbFwiLFxuICBcInN3aXRjaFRvZ2dsZVwiOiBcInBmLWMtc3dpdGNoX190b2dnbGVcIixcbiAgXCJzd2l0Y2hUb2dnbGVJY29uXCI6IFwicGYtYy1zd2l0Y2hfX3RvZ2dsZS1pY29uXCJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///35890\n')},48271:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = true;\n__webpack_require__(34712);\nexports.Z = {\n  "modifiers": {\n    "wrap": "pf-m-wrap",\n    "fill": "pf-m-fill",\n    "gutter": "pf-m-gutter"\n  },\n  "split": "pf-l-split",\n  "splitItem": "pf-l-split__item"\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgyNzEuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IseUJBQWtCO0FBQ2xCLG1CQUFPLENBQUMsS0FBYTtBQUNyQixTQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvbGF5b3V0cy9TcGxpdC9zcGxpdC5qcz81NTQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnJlcXVpcmUoJy4vc3BsaXQuY3NzJyk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIFwibW9kaWZpZXJzXCI6IHtcbiAgICBcIndyYXBcIjogXCJwZi1tLXdyYXBcIixcbiAgICBcImZpbGxcIjogXCJwZi1tLWZpbGxcIixcbiAgICBcImd1dHRlclwiOiBcInBmLW0tZ3V0dGVyXCJcbiAgfSxcbiAgXCJzcGxpdFwiOiBcInBmLWwtc3BsaXRcIixcbiAgXCJzcGxpdEl0ZW1cIjogXCJwZi1sLXNwbGl0X19pdGVtXCJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///48271\n')},16383:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzODMuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvY29tcG9uZW50cy9DYWxlbmRhck1vbnRoL2NhbGVuZGFyLW1vbnRoLmNzcz80YTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16383\n")},97500:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc1MDAuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvY29tcG9uZW50cy9EYXRlUGlja2VyL2RhdGUtcGlja2VyLmNzcz84NTc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///97500\n")},31213:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEyMTMuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvY29tcG9uZW50cy9Td2l0Y2gvc3dpdGNoLmNzcz82ZmYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31213\n")},34712:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ3MTIuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvbGF5b3V0cy9TcGxpdC9zcGxpdC5jc3M/MGJjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34712\n")},22882:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "AutoField": () => (/* reexport */ esm_AutoField),\n  "AutoFields": () => (/* reexport */ AutoFields),\n  "AutoForm": () => (/* reexport */ AutoForm),\n  "BaseForm": () => (/* reexport */ BaseForm),\n  "BoolField": () => (/* reexport */ BoolField),\n  "DateField": () => (/* reexport */ esm_DateField),\n  "ErrorField": () => (/* reexport */ ErrorField),\n  "ErrorsField": () => (/* reexport */ esm_ErrorsField),\n  "HiddenField": () => (/* reexport */ HiddenField),\n  "ListAddField": () => (/* reexport */ ListAddField),\n  "ListDelField": () => (/* reexport */ ListDelField),\n  "ListField": () => (/* reexport */ esm_ListField),\n  "ListItemField": () => (/* reexport */ ListItemField),\n  "LongTextField": () => (/* reexport */ LongTextField),\n  "NestField": () => (/* reexport */ NestField),\n  "NumField": () => (/* reexport */ NumField),\n  "QuickForm": () => (/* reexport */ QuickForm),\n  "RadioField": () => (/* reexport */ RadioField),\n  "SelectField": () => (/* reexport */ esm_SelectField),\n  "SubmitField": () => (/* reexport */ esm_SubmitField),\n  "TextField": () => (/* reexport */ TextField),\n  "ValidatedForm": () => (/* reexport */ ValidatedForm),\n  "ValidatedQuickForm": () => (/* reexport */ ValidatedQuickForm)\n});\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(70655);\n// EXTERNAL MODULE: consume shared module (default) react@^17.0.0 || ^16.8.0 (singleton) (fallback: ./node_modules/react/index.js) (eager)\nvar index_js_eager_ = __webpack_require__(59322);\nvar index_js_eager_default = /*#__PURE__*/__webpack_require__.n(index_js_eager_);\n// EXTERNAL MODULE: consume shared module (default) uniforms@=3.6.0 (strict) (fallback: ./node_modules/uniforms/esm/index.js)\nvar index_js_ = __webpack_require__(79199);\n// EXTERNAL MODULE: ./node_modules/invariant/browser.js\nvar browser = __webpack_require__(41143);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n// EXTERNAL MODULE: consume shared module (default) react@^16.8.0 || ^17.0.0 (singleton) (fallback: ./node_modules/react/index.js) (eager)\nvar react_index_js_eager_ = __webpack_require__(45052);\nvar react_index_js_eager_default = /*#__PURE__*/__webpack_require__.n(react_index_js_eager_);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/components/Switch/switch.js\nvar Switch_switch = __webpack_require__(35890);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/dist/esm/index.js\nvar esm = __webpack_require__(38296);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/check-icon.js\nvar check_icon = __webpack_require__(98614);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/helpers/util.js\nvar util = __webpack_require__(80164);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/helpers/OUIA/ouia.js\nvar ouia = __webpack_require__(62472);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Switch/Switch.js\n\n\n\n\n\n\n\nclass Switch extends react_index_js_eager_.Component {\n    constructor(props) {\n        super(props);\n        if (!props.label && !props[\'aria-label\']) {\n            // eslint-disable-next-line no-console\n            console.error(\'Switch: Switch requires either a label or an aria-label to be specified\');\n        }\n        this.id = props.id || (0,util/* getUniqueId */.Ki)();\n        this.state = {\n            ouiaStateId: (0,ouia/* getDefaultOUIAId */.ql)(Switch.displayName)\n        };\n    }\n    render() {\n        const _a = this.props, { \n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        id, className, label, labelOff, isChecked, isDisabled, onChange, isReversed, ouiaId, ouiaSafe } = _a, props = (0,tslib_es6.__rest)(_a, ["id", "className", "label", "labelOff", "isChecked", "isDisabled", "onChange", "isReversed", "ouiaId", "ouiaSafe"]);\n        const isAriaLabelledBy = props[\'aria-label\'] === \'\';\n        return (react_index_js_eager_.createElement("label", Object.assign({ className: (0,esm/* css */.i)(Switch_switch/* default.switch */.Z["switch"], isReversed && Switch_switch/* default.modifiers.reverse */.Z.modifiers.reverse, className), htmlFor: this.id }, (0,ouia/* getOUIAProps */.dp)(Switch.displayName, ouiaId !== undefined ? ouiaId : this.state.ouiaStateId, ouiaSafe)),\n            react_index_js_eager_.createElement("input", Object.assign({ id: this.id, className: (0,esm/* css */.i)(Switch_switch/* default.switchInput */.Z.switchInput), type: "checkbox", onChange: event => onChange(event.target.checked, event), checked: isChecked, disabled: isDisabled, "aria-labelledby": isAriaLabelledBy ? `${this.id}-on` : null }, props)),\n            label !== undefined ? (react_index_js_eager_.createElement(react_index_js_eager_.Fragment, null,\n                react_index_js_eager_.createElement("span", { className: (0,esm/* css */.i)(Switch_switch/* default.switchToggle */.Z.switchToggle) }),\n                react_index_js_eager_.createElement("span", { className: (0,esm/* css */.i)(Switch_switch/* default.switchLabel */.Z.switchLabel, Switch_switch/* default.modifiers.on */.Z.modifiers.on), id: isAriaLabelledBy ? `${this.id}-on` : null, "aria-hidden": "true" }, label),\n                react_index_js_eager_.createElement("span", { className: (0,esm/* css */.i)(Switch_switch/* default.switchLabel */.Z.switchLabel, Switch_switch/* default.modifiers.off */.Z.modifiers.off), id: isAriaLabelledBy ? `${this.id}-off` : null, "aria-hidden": "true" }, labelOff !== undefined ? labelOff : label))) : (react_index_js_eager_.createElement("span", { className: (0,esm/* css */.i)(Switch_switch/* default.switchToggle */.Z.switchToggle) },\n                react_index_js_eager_.createElement("div", { className: (0,esm/* css */.i)(Switch_switch/* default.switchToggleIcon */.Z.switchToggleIcon), "aria-hidden": "true" },\n                    react_index_js_eager_.createElement(check_icon/* default */.ZP, { noVerticalAlign: true }))))));\n    }\n}\nSwitch.displayName = \'Switch\';\nSwitch.defaultProps = {\n    isChecked: true,\n    isDisabled: false,\n    isReversed: false,\n    \'aria-label\': \'\',\n    onChange: () => undefined\n};\n//# sourceMappingURL=Switch.js.map\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Checkbox/Checkbox.js\nvar Checkbox = __webpack_require__(93149);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Form/FormGroup.js + 1 modules\nvar FormGroup = __webpack_require__(43627);\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/wrapField.js\n\n\n\n\nindex_js_.filterDOMProps.register(\'decimal\', \'minCount\', \'autoValue\', \'isDisabled\', \'exclusiveMaximum\', \'exclusiveMinimum\');\nfunction wrapField(_a, children) {\n    var id = _a.id, label = _a.label, type = _a.type, disabled = _a.disabled, error = _a.error, errorMessage = _a.errorMessage, showInlineError = _a.showInlineError, help = _a.help, required = _a.required, props = (0,tslib_es6.__rest)(_a, ["id", "label", "type", "disabled", "error", "errorMessage", "showInlineError", "help", "required"]);\n    return (index_js_eager_default().createElement(FormGroup/* FormGroup */.c, (0,tslib_es6.__assign)({ fieldId: id, label: label, isRequired: required, validated: error ? \'error\' : \'default\', type: type, helperText: help, helperTextInvalid: errorMessage }, (0,index_js_.filterDOMProps)(props)), children));\n}\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/BoolField.js\n\n\n\n\n\nvar ComponentType;\n(function (ComponentType) {\n    ComponentType["checkbox"] = "checkbox";\n    ComponentType["switch"] = "switch";\n})(ComponentType || (ComponentType = {}));\nfunction Bool(_a) {\n    var appearance = _a.appearance, disabled = _a.disabled, id = _a.id, inputRef = _a.inputRef, label = _a.label, name = _a.name, onChange = _a.onChange, value = _a.value, props = (0,tslib_es6.__rest)(_a, ["appearance", "disabled", "id", "inputRef", "label", "name", "onChange", "value"]);\n    var Component = appearance === ComponentType.switch ? Switch : Checkbox/* Checkbox */.X;\n    return wrapField((0,tslib_es6.__assign)({ id: id }, props), index_js_eager_default().createElement(Component, { isChecked: value || false, isDisabled: disabled, id: id, name: name, onChange: function () { return disabled || onChange(!value); }, ref: inputRef, label: label }));\n}\nBool.defaultProps = { appearance: ComponentType.checkbox };\n/* harmony default export */ const BoolField = ((0,index_js_.connectField)(Bool));\n\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/layouts/Flex/Flex.js\nvar Flex = __webpack_require__(28191);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/layouts/Flex/FlexItem.js\nvar FlexItem = __webpack_require__(92298);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/InputGroup/InputGroup.js + 1 modules\nvar InputGroup = __webpack_require__(82011);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/components/DatePicker/date-picker.js\nvar date_picker = __webpack_require__(26410);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/components/Button/button.js\nvar Button_button = __webpack_require__(83318);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js\nvar TextInput = __webpack_require__(92607);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js + 8 modules\nvar Popover = __webpack_require__(37377);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-icons/dist/esm/createIcon.js\nvar createIcon = __webpack_require__(40400);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/outlined-calendar-alt-icon.js\n\n\nconst OutlinedCalendarAltIconConfig = {\n  name: \'OutlinedCalendarAltIcon\',\n  height: 512,\n  width: 448,\n  svgPath: \'M148 288h-40c-6.6 0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z\',\n  yOffset: 0,\n  xOffset: 0,\n};\n\nconst OutlinedCalendarAltIcon = (0,createIcon/* createIcon */.IU)(OutlinedCalendarAltIconConfig);\n\n/* harmony default export */ const outlined_calendar_alt_icon = (OutlinedCalendarAltIcon);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js\nvar Button = __webpack_require__(47173);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Select/Select.js + 5 modules\nvar Select = __webpack_require__(1211);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Select/SelectOption.js\nvar SelectOption = __webpack_require__(92694);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/arrow-left-icon.js\n\n\nconst ArrowLeftIconConfig = {\n  name: \'ArrowLeftIcon\',\n  height: 512,\n  width: 448,\n  svgPath: \'M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z\',\n  yOffset: 0,\n  xOffset: 0,\n};\n\nconst ArrowLeftIcon = (0,createIcon/* createIcon */.IU)(ArrowLeftIconConfig);\n\n/* harmony default export */ const arrow_left_icon = (ArrowLeftIcon);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/arrow-right-icon.js\n\n\nconst ArrowRightIconConfig = {\n  name: \'ArrowRightIcon\',\n  height: 512,\n  width: 448,\n  svgPath: \'M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z\',\n  yOffset: 0,\n  xOffset: 0,\n};\n\nconst ArrowRightIcon = (0,createIcon/* createIcon */.IU)(ArrowRightIconConfig);\n\n/* harmony default export */ const arrow_right_icon = (ArrowRightIcon);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/components/CalendarMonth/calendar-month.js\nvar calendar_month = __webpack_require__(64158);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/CalendarMonth/CalendarMonth.js\n\n\n\n\n\n\n\n\n\n\nvar Weekday;\n(function (Weekday) {\n    Weekday[Weekday["Sunday"] = 0] = "Sunday";\n    Weekday[Weekday["Monday"] = 1] = "Monday";\n    Weekday[Weekday["Tuesday"] = 2] = "Tuesday";\n    Weekday[Weekday["Wednesday"] = 3] = "Wednesday";\n    Weekday[Weekday["Thursday"] = 4] = "Thursday";\n    Weekday[Weekday["Friday"] = 5] = "Friday";\n    Weekday[Weekday["Saturday"] = 6] = "Saturday";\n})(Weekday || (Weekday = {}));\n// Must be numeric given current header design\nconst yearFormat = (date) => date.getFullYear();\nconst buildCalendar = (year, month, weekStart, validators) => {\n    const selectedDate = new Date(year, month);\n    const firstDayOfWeek = new Date(selectedDate);\n    firstDayOfWeek.setDate(firstDayOfWeek.getDate() - firstDayOfWeek.getDay() + weekStart);\n    // We will always show 6 weeks like google calendar\n    // Assume we just want the numbers for now...\n    const calendarWeeks = [];\n    for (let i = 0; i < 6; i++) {\n        const week = [];\n        for (let j = 0; j < 7; j++) {\n            const date = new Date(firstDayOfWeek);\n            week.push({\n                date,\n                isValid: validators.every(validator => validator(date))\n            });\n            firstDayOfWeek.setDate(firstDayOfWeek.getDate() + 1);\n        }\n        calendarWeeks.push(week);\n    }\n    return calendarWeeks;\n};\nconst isSameDate = (d1, d2) => d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();\nconst isValidDate = (date) => Boolean(date && !isNaN(date));\nconst today = new Date();\nconst CalendarMonth = (_a) => {\n    var { date: dateProp = today, locale = undefined, monthFormat = date => date.toLocaleDateString(locale, { month: \'long\' }), weekdayFormat = date => date.toLocaleDateString(locale, { weekday: \'narrow\' }), longWeekdayFormat = date => date.toLocaleDateString(locale, { weekday: \'long\' }), dayFormat = date => date.getDate(), weekStart = 0, // Use the American Sunday as a default\n    onChange = () => { }, validators = [() => true], className, onSelectToggle = () => { }, rangeStart, prevMonthAriaLabel = \'Previous month\', nextMonthAriaLabel = \'Next month\', yearInputAriaLabel = \'Select year\', cellAriaLabel } = _a, props = (0,tslib_es6.__rest)(_a, ["date", "locale", "monthFormat", "weekdayFormat", "longWeekdayFormat", "dayFormat", "weekStart", "onChange", "validators", "className", "onSelectToggle", "rangeStart", "prevMonthAriaLabel", "nextMonthAriaLabel", "yearInputAriaLabel", "cellAriaLabel"]);\n    const longMonths = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(monthNum => new Date(1990, monthNum)).map(monthFormat);\n    const [isSelectOpen, setIsSelectOpen] = react_index_js_eager_default().useState(false);\n    // eslint-disable-next-line prefer-const\n    let [focusedDate, setFocusedDate] = react_index_js_eager_default().useState(new Date(dateProp));\n    if (!isValidDate(focusedDate)) {\n        focusedDate = today;\n    }\n    const [hoveredDate, setHoveredDate] = react_index_js_eager_default().useState(new Date(focusedDate));\n    const focusRef = react_index_js_eager_default().useRef();\n    const [hiddenMonthId] = react_index_js_eager_default().useState((0,util/* getUniqueId */.Ki)(\'hidden-month-span\'));\n    const [shouldFocus, setShouldFocus] = react_index_js_eager_default().useState(true);\n    const isValidated = (date) => validators.every(validator => validator(date));\n    const focusedDateValidated = isValidated(focusedDate);\n    (0,react_index_js_eager_.useEffect)(() => {\n        if (!(isValidDate(dateProp) && isSameDate(focusedDate, dateProp))) {\n            setFocusedDate(dateProp);\n        }\n    }, [dateProp]);\n    (0,react_index_js_eager_.useEffect)(() => {\n        // When using header controls don\'t move focus\n        if (shouldFocus) {\n            if (focusRef.current && focusedDateValidated) {\n                focusRef.current.focus();\n            }\n        }\n        else {\n            setShouldFocus(true);\n        }\n    }, [focusedDate]);\n    const onMonthClick = (newDate) => {\n        setFocusedDate(newDate);\n        setHoveredDate(newDate);\n        setShouldFocus(false);\n    };\n    const onKeyDown = (ev) => {\n        const newDate = new Date(focusedDate);\n        if (ev.key === \'ArrowUp\') {\n            newDate.setDate(newDate.getDate() - 7);\n        }\n        else if (ev.key === \'ArrowRight\') {\n            newDate.setDate(newDate.getDate() + 1);\n        }\n        else if (ev.key === \'ArrowDown\') {\n            newDate.setDate(newDate.getDate() + 7);\n        }\n        else if (ev.key === \'ArrowLeft\') {\n            newDate.setDate(newDate.getDate() - 1);\n        }\n        if (newDate.getTime() !== focusedDate.getTime() && isValidated(newDate)) {\n            ev.preventDefault();\n            setFocusedDate(newDate);\n            setHoveredDate(newDate);\n            setShouldFocus(true);\n        }\n    };\n    const addMonth = (toAdd) => {\n        const newDate = new Date(focusedDate);\n        newDate.setMonth(newDate.getMonth() + toAdd);\n        return newDate;\n    };\n    const prevMonth = addMonth(-1);\n    const nextMonth = addMonth(1);\n    const focusedYear = focusedDate.getFullYear();\n    const focusedMonth = focusedDate.getMonth();\n    const calendar = react_index_js_eager_default().useMemo(() => buildCalendar(focusedYear, focusedMonth, weekStart, validators), [\n        focusedYear,\n        focusedMonth,\n        weekStart,\n        validators\n    ]);\n    if (!focusedDateValidated) {\n        const toFocus = calendar\n            .reduce((acc, cur) => [...acc, ...cur], [])\n            .filter(({ date, isValid }) => isValid && date.getMonth() === focusedMonth)\n            .map(({ date }) => ({ date, days: Math.abs(focusedDate.getTime() - date.getTime()) }))\n            .sort((o1, o2) => o1.days - o2.days)\n            .map(({ date }) => date)[0];\n        if (toFocus) {\n            setFocusedDate(toFocus);\n            setHoveredDate(toFocus);\n        }\n    }\n    const isHoveredDateValid = isValidated(hoveredDate);\n    const monthFormatted = monthFormat(focusedDate);\n    const yearFormatted = yearFormat(focusedDate);\n    return (react_index_js_eager_default().createElement("div", Object.assign({ className: (0,esm/* css */.i)(calendar_month/* default.calendarMonth */.Z.calendarMonth, className) }, props),\n        react_index_js_eager_default().createElement("div", { className: calendar_month/* default.calendarMonthHeader */.Z.calendarMonthHeader },\n            react_index_js_eager_default().createElement("div", { className: (0,esm/* css */.i)(calendar_month/* default.calendarMonthHeaderNavControl */.Z.calendarMonthHeaderNavControl, calendar_month/* default.modifiers.prevMonth */.Z.modifiers.prevMonth) },\n                react_index_js_eager_default().createElement(Button/* Button */.zx, { variant: "plain", "aria-label": prevMonthAriaLabel, onClick: () => onMonthClick(prevMonth) },\n                    react_index_js_eager_default().createElement(arrow_left_icon, { "aria-hidden": true }))),\n            react_index_js_eager_default().createElement("div", { className: calendar_month/* default.calendarMonthHeaderMonth */.Z.calendarMonthHeaderMonth },\n                react_index_js_eager_default().createElement("span", { id: hiddenMonthId, hidden: true }, "Month"),\n                react_index_js_eager_default().createElement(Select/* Select */.P\n                // Max width with "September"\n                , { \n                    // Max width with "September"\n                    width: "140px", "aria-labelledby": hiddenMonthId, isOpen: isSelectOpen, onToggle: () => {\n                        setIsSelectOpen(!isSelectOpen);\n                        onSelectToggle(!isSelectOpen);\n                    }, onSelect: (_ev, monthNum) => {\n                        // When we put CalendarMonth in a Popover we want the Popover\'s onDocumentClick\n                        // to see the SelectOption as a child so it doesn\'t close the Popover.\n                        setTimeout(() => {\n                            setIsSelectOpen(false);\n                            onSelectToggle(false);\n                            const newDate = new Date(focusedDate);\n                            newDate.setMonth(Number(monthNum));\n                            setFocusedDate(newDate);\n                            setHoveredDate(newDate);\n                            setShouldFocus(false);\n                        }, 0);\n                    }, variant: "single", selections: monthFormatted }, longMonths.map((longMonth, index) => (react_index_js_eager_default().createElement(SelectOption/* SelectOption */.$, { key: index, value: index, isSelected: longMonth === monthFormatted }, longMonth))))),\n            react_index_js_eager_default().createElement("div", { className: calendar_month/* default.calendarMonthHeaderYear */.Z.calendarMonthHeaderYear },\n                react_index_js_eager_default().createElement(TextInput/* TextInput */.oi, { "aria-label": yearInputAriaLabel, type: "number", value: yearFormatted, onChange: year => {\n                        const newDate = new Date(focusedDate);\n                        newDate.setFullYear(+year);\n                        setFocusedDate(newDate);\n                        setHoveredDate(newDate);\n                        setShouldFocus(false);\n                    } })),\n            react_index_js_eager_default().createElement("div", { className: (0,esm/* css */.i)(calendar_month/* default.calendarMonthHeaderNavControl */.Z.calendarMonthHeaderNavControl, calendar_month/* default.modifiers.nextMonth */.Z.modifiers.nextMonth) },\n                react_index_js_eager_default().createElement(Button/* Button */.zx, { variant: "plain", "aria-label": nextMonthAriaLabel, onClick: () => onMonthClick(nextMonth) },\n                    react_index_js_eager_default().createElement(arrow_right_icon, { "aria-hidden": true })))),\n        react_index_js_eager_default().createElement("table", { className: calendar_month/* default.calendarMonthCalendar */.Z.calendarMonthCalendar },\n            react_index_js_eager_default().createElement("thead", { className: calendar_month/* default.calendarMonthDays */.Z.calendarMonthDays },\n                react_index_js_eager_default().createElement("tr", null, calendar[0].map(({ date }, index) => (react_index_js_eager_default().createElement("th", { key: index, className: calendar_month/* default.calendarMonthDay */.Z.calendarMonthDay, scope: "col" },\n                    react_index_js_eager_default().createElement("span", { className: "pf-screen-reader" }, longWeekdayFormat(date)),\n                    react_index_js_eager_default().createElement("span", { "aria-hidden": true }, weekdayFormat(date))))))),\n            react_index_js_eager_default().createElement("tbody", { onKeyDown: onKeyDown }, calendar.map((week, index) => (react_index_js_eager_default().createElement("tr", { key: index, className: calendar_month/* default.calendarMonthDatesRow */.Z.calendarMonthDatesRow }, week.map(({ date, isValid }, index) => {\n                const dayFormatted = dayFormat(date);\n                const isToday = isSameDate(date, today);\n                const isSelected = isValidDate(dateProp) && isSameDate(date, dateProp);\n                const isFocused = isSameDate(date, focusedDate);\n                const isAdjacentMonth = date.getMonth() !== focusedDate.getMonth();\n                let isInRange = false;\n                let isRangeStart = false;\n                let isRangeEnd = false;\n                if (isValidDate(rangeStart) && isHoveredDateValid) {\n                    if (hoveredDate > rangeStart || isSameDate(hoveredDate, rangeStart)) {\n                        isInRange = date > rangeStart && date < hoveredDate;\n                        isRangeStart = isSameDate(date, rangeStart);\n                        isRangeEnd = isSameDate(date, hoveredDate);\n                    }\n                    // Don\'t handle focused dates before start dates for now.\n                    // Core would likely need new styles\n                }\n                return (react_index_js_eager_default().createElement("td", { key: index, className: (0,esm/* css */.i)(calendar_month/* default.calendarMonthDatesCell */.Z.calendarMonthDatesCell, isAdjacentMonth && calendar_month/* default.modifiers.adjacentMonth */.Z.modifiers.adjacentMonth, isToday && calendar_month/* default.modifiers.current */.Z.modifiers.current, (isSelected || isRangeStart) && calendar_month/* default.modifiers.selected */.Z.modifiers.selected, !isValid && calendar_month/* default.modifiers.disabled */.Z.modifiers.disabled, (isInRange || isRangeStart || isRangeEnd) && calendar_month/* default.modifiers.inRange */.Z.modifiers.inRange, isRangeStart && calendar_month/* default.modifiers.startRange */.Z.modifiers.startRange, isRangeEnd && calendar_month/* default.modifiers.endRange */.Z.modifiers.endRange) },\n                    react_index_js_eager_default().createElement("button", Object.assign({ className: (0,esm/* css */.i)(calendar_month/* default.calendarMonthDate */.Z.calendarMonthDate, isRangeEnd && calendar_month/* default.modifiers.hover */.Z.modifiers.hover, !isValid && calendar_month/* default.modifiers.disabled */.Z.modifiers.disabled), type: "button", onClick: () => onChange(date), onMouseOver: () => setHoveredDate(date), tabIndex: isFocused ? 0 : -1, disabled: !isValid, "aria-label": cellAriaLabel ? cellAriaLabel(date) : `${dayFormatted} ${monthFormatted} ${yearFormatted}` }, (isFocused && { ref: focusRef })), dayFormatted)));\n            }))))))));\n};\n//# sourceMappingURL=CalendarMonth.js.map\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/DatePicker/DatePicker.js\n\n\n\n\n\n\n\n\n\n\nconst yyyyMMddFormat = (date) => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, \'0\')}-${date\n    .getDate()\n    .toString()\n    .padStart(2, \'0\')}`;\nconst DatePicker = (_a) => {\n    var { className, locale = undefined, dateFormat = yyyyMMddFormat, dateParse = (val) => val.split(\'-\').length === 3 && new Date(`${val}T00:00:00`), isDisabled = false, placeholder = \'YYYY-MM-DD\', value: valueProp = \'\', \'aria-label\': ariaLabel = \'Date picker\', buttonAriaLabel = \'Toggle date picker\', onChange = () => undefined, invalidFormatText = \'Invalid date\', helperText, appendTo, popoverProps, monthFormat, weekdayFormat, longWeekdayFormat, dayFormat, weekStart, validators = [], rangeStart, style: styleProps = {}, inputProps = {} } = _a, props = (0,tslib_es6.__rest)(_a, ["className", "locale", "dateFormat", "dateParse", "isDisabled", "placeholder", "value", \'aria-label\', "buttonAriaLabel", "onChange", "invalidFormatText", "helperText", "appendTo", "popoverProps", "monthFormat", "weekdayFormat", "longWeekdayFormat", "dayFormat", "weekStart", "validators", "rangeStart", "style", "inputProps"]);\n    const [value, setValue] = react_index_js_eager_.useState(valueProp);\n    const [valueDate, setValueDate] = react_index_js_eager_.useState(dateParse(value));\n    const [errorText, setErrorText] = react_index_js_eager_.useState(\'\');\n    const [popoverOpen, setPopoverOpen] = react_index_js_eager_.useState(false);\n    const [selectOpen, setSelectOpen] = react_index_js_eager_.useState(false);\n    const [pristine, setPristine] = react_index_js_eager_.useState(true);\n    const widthChars = react_index_js_eager_.useMemo(() => Math.max(dateFormat(new Date()).length, placeholder.length), [dateFormat]);\n    const style = Object.assign({ \'--pf-c-date-picker__input--c-form-control--width-chars\': widthChars }, styleProps);\n    const buttonRef = react_index_js_eager_.useRef();\n    react_index_js_eager_.useEffect(() => {\n        setValue(valueProp);\n        setValueDate(dateParse(valueProp));\n    }, [valueProp]);\n    const setError = (date) => setErrorText(validators.map(validator => validator(date)).join(\'\\n\') || \'\');\n    const onTextInput = (value) => {\n        setPristine(false);\n        setValue(value);\n        setErrorText(\'\');\n        const newValueDate = dateParse(value);\n        setValueDate(newValueDate);\n        if (isValidDate(newValueDate)) {\n            onChange(value, new Date(newValueDate));\n        }\n        else {\n            onChange(value);\n        }\n    };\n    const onInputBlur = () => {\n        if (pristine) {\n            return;\n        }\n        const newValueDate = dateParse(value);\n        if (isValidDate(newValueDate)) {\n            setError(newValueDate);\n        }\n        else {\n            setErrorText(invalidFormatText);\n        }\n    };\n    const onDateClick = (newValueDate) => {\n        const newValue = dateFormat(newValueDate);\n        setValue(newValue);\n        setValueDate(newValueDate);\n        setError(newValueDate);\n        setPopoverOpen(false);\n        onChange(newValue, new Date(newValueDate));\n    };\n    const onKeyPress = (ev) => {\n        if (ev.key === \'Enter\' && value) {\n            if (isValidDate(valueDate)) {\n                setError(valueDate);\n            }\n            else {\n                setErrorText(invalidFormatText);\n            }\n        }\n    };\n    return (react_index_js_eager_.createElement("div", Object.assign({ className: (0,esm/* css */.i)(date_picker/* default.datePicker */.Z.datePicker, className), style: style }, props),\n        react_index_js_eager_.createElement(Popover/* Popover */.J, Object.assign({ position: "bottom", bodyContent: react_index_js_eager_.createElement(CalendarMonth, { date: valueDate, onChange: onDateClick, locale: locale, \n                // Use truthy values of strings\n                validators: validators.map(validator => (date) => !validator(date)), onSelectToggle: open => setSelectOpen(open), monthFormat: monthFormat, weekdayFormat: weekdayFormat, longWeekdayFormat: longWeekdayFormat, dayFormat: dayFormat, weekStart: weekStart, rangeStart: rangeStart }), showClose: false, isVisible: popoverOpen, shouldClose: (_1, _2, event) => {\n                event = event;\n                // Let the select menu close\n                if (event.keyCode && event.keyCode === 27 && selectOpen) {\n                    return false;\n                }\n                // Let our button handle toggling\n                if (buttonRef.current && buttonRef.current.contains(event.target)) {\n                    return false;\n                }\n                setPopoverOpen(false);\n                return true;\n            }, withFocusTrap: true, hasNoPadding: true, hasAutoWidth: true, appendTo: appendTo }, popoverProps),\n            react_index_js_eager_.createElement("div", { className: date_picker/* default.datePickerInput */.Z.datePickerInput },\n                react_index_js_eager_.createElement(InputGroup/* InputGroup */.B, null,\n                    react_index_js_eager_.createElement(TextInput/* TextInput */.oi, Object.assign({ isDisabled: isDisabled, "aria-label": ariaLabel, placeholder: placeholder, validated: errorText ? \'error\' : \'default\', value: value, onChange: onTextInput, onBlur: onInputBlur, onKeyPress: onKeyPress }, inputProps)),\n                    react_index_js_eager_.createElement("button", { ref: buttonRef, className: (0,esm/* css */.i)(Button_button/* default.button */.Z.button, Button_button/* default.modifiers.control */.Z.modifiers.control), "aria-label": buttonAriaLabel, type: "button", onClick: () => setPopoverOpen(!popoverOpen), disabled: isDisabled },\n                        react_index_js_eager_.createElement(outlined_calendar_alt_icon, null))))),\n        helperText && react_index_js_eager_.createElement("div", { className: date_picker/* default.datePickerHelperText */.Z.datePickerHelperText }, helperText),\n        errorText.trim() && react_index_js_eager_.createElement("div", { className: (0,esm/* css */.i)(date_picker/* default.datePickerHelperText */.Z.datePickerHelperText, date_picker/* default.modifiers.error */.Z.modifiers.error) }, errorText)));\n};\nDatePicker.displayName = \'DatePicker\';\n//# sourceMappingURL=DatePicker.js.map\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/components/Select/select.js\nvar Select_select = __webpack_require__(25774);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/components/FormControl/form-control.js\nvar form_control = __webpack_require__(13973);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js + 53 modules\nvar Popper = __webpack_require__(30595);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/TimePicker/TimeOption.js\n\n\n\n\nconst TimeOption = (_a) => {\n    var { className = \'\', value = \'\', onSelect = () => { }, children, id, isFocused } = _a, props = (0,tslib_es6.__rest)(_a, ["className", "value", "onSelect", "children", "id", "isFocused"]);\n    return (react_index_js_eager_.createElement("li", Object.assign({ role: "presentation", className: (0,esm/* css */.i)(Select_select/* default.selectMenuWrapper */.Z.selectMenuWrapper, isFocused && Select_select/* default.modifiers.focus */.Z.modifiers.focus, className) }, props),\n        react_index_js_eager_.createElement("button", { className: (0,esm/* css */.i)(Select_select/* default.selectMenuItem */.Z.selectMenuItem), onClick: event => {\n                onSelect(value, event);\n            }, role: "option", type: "button", id: id }, children || value.toString())));\n};\nTimeOption.displayName = \'TimeOption\';\n//# sourceMappingURL=TimeOption.js.map\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Select/selectConstants.js\nvar selectConstants = __webpack_require__(64403);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/TimePicker/TimePickerUtils.js\nconst amSuffix = \' AM\';\nconst pmSuffix = \' PM\';\nconst makeTimeOptions = (stepMinutes, hour12, delimiter) => {\n    const res = [];\n    const iter = new Date(new Date().setHours(0, 0, 0, 0));\n    const iterDay = iter.getDay();\n    while (iter.getDay() === iterDay) {\n        let hour = iter.getHours();\n        let suffix = amSuffix;\n        if (hour12) {\n            if (hour === 0) {\n                hour = 12; // 12am\n            }\n            else if (hour >= 12) {\n                suffix = pmSuffix;\n            }\n            if (hour > 12) {\n                hour %= 12;\n            }\n        }\n        res.push((hour12 ? hour.toString() : hour.toString().padStart(2, \'0\')) +\n            delimiter +\n            iter\n                .getMinutes()\n                .toString()\n                .padStart(2, \'0\') +\n            (hour12 ? suffix : \'\'));\n        iter.setMinutes(iter.getMinutes() + stepMinutes);\n    }\n    return res;\n};\nconst parseTime = (time, timeRegex, delimiter, is12Hour) => {\n    const date = new Date(time);\n    // if default time is a ISO 8601 formatted date string, we parse it to hh:mm(am/pm) format\n    if (!isNaN(date.getDate()) && (time instanceof Date || time.includes(\'T\'))) {\n        const hours = is12Hour\n            ? `${date.getHours() > 12 ? date.getHours() - 12 : date.getHours()}`\n            : `${date.getHours()}`.padStart(2, \'0\');\n        const minutes = `${date.getMinutes()}`.padStart(2, \'0\');\n        let ampm = \'\';\n        if (is12Hour && date.getHours() > 11) {\n            ampm = pmSuffix;\n        }\n        else if (is12Hour) {\n            ampm = amSuffix;\n        }\n        return `${hours}${delimiter}${minutes}${ampm}`;\n    }\n    else if (typeof time === \'string\') {\n        time = time.trim();\n        if (is12Hour && time !== \'\' && validateTime(time, timeRegex, delimiter, is12Hour)) {\n            // Format AM/PM according to design\n            let ampm = \'\';\n            if (time.toUpperCase().includes(amSuffix.toUpperCase().trim())) {\n                time = time\n                    .toUpperCase()\n                    .replace(amSuffix.toUpperCase().trim(), \'\')\n                    .trim();\n                ampm = amSuffix;\n            }\n            else if (time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n                time = time\n                    .toUpperCase()\n                    .replace(pmSuffix.toUpperCase().trim(), \'\')\n                    .trim();\n                ampm = pmSuffix;\n            }\n            else {\n                // if this 12 hour time is missing am/pm but otherwise valid,\n                // append am/pm depending on time of day\n                ampm = new Date().getHours() > 11 ? pmSuffix : amSuffix;\n            }\n            return `${time}${ampm}`;\n        }\n    }\n    return time.toString();\n};\nconst validateTime = (time, timeRegex, delimiter, is12Hour) => {\n    // ISO 8601 format is valid\n    const date = new Date(time);\n    if (!isNaN(date.getDate()) && time.includes(\'T\')) {\n        return true;\n    }\n    // hours only valid if they are [0-23] or [1-12]\n    const hours = parseInt(time.split(delimiter)[0]);\n    const validHours = hours >= (is12Hour ? 1 : 0) && hours <= (is12Hour ? 12 : 23);\n    // minutes verified by timeRegex\n    // empty string is valid\n    return time === \'\' || (timeRegex.test(time) && validHours);\n};\nconst getHours = (time, timeRegex) => {\n    const parts = time.match(timeRegex);\n    if (parts && parts.length) {\n        if (/pm/i.test(parts[3])) {\n            return parseInt(parts[1]) === 12 ? parseInt(parts[1]) : parseInt(parts[1]) + 12;\n        }\n        if (/am/i.test(parts[3])) {\n            return parseInt(parts[1]) === 12 ? 0 : parseInt(parts[1]);\n        }\n        return parseInt(parts[1]);\n    }\n    return null;\n};\nconst getMinutes = (time, timeRegex) => {\n    const parts = time.match(timeRegex);\n    return parts && parts.length ? parseInt(parts[2]) : null;\n};\n//# sourceMappingURL=TimePickerUtils.js.map\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/TimePicker/TimePicker.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TimePicker extends react_index_js_eager_.Component {\n    constructor(props) {\n        super(props);\n        this.parentRef = react_index_js_eager_.createRef();\n        this.toggleRef = react_index_js_eager_.createRef();\n        this.inputRef = react_index_js_eager_.createRef();\n        this.menuRef = react_index_js_eager_.createRef();\n        this.onDocClick = (event) => {\n            const clickedOnToggle = this.parentRef && this.parentRef.current && this.parentRef.current.contains(event.target);\n            const clickedWithinMenu = this.menuRef &&\n                this.menuRef.current &&\n                this.menuRef.current.contains &&\n                this.menuRef.current.contains(event.target);\n            if (this.state.isOpen && !(clickedOnToggle || clickedWithinMenu)) {\n                this.onToggle(false);\n            }\n        };\n        this.handleGlobalKeys = (event) => {\n            const { isOpen, focusedIndex } = this.state;\n            // keyboard pressed while focus on toggle\n            if (this.inputRef && this.inputRef.current && this.inputRef.current.contains(event.target)) {\n                if (!isOpen && event.key !== selectConstants/* KeyTypes.Tab */.yu.Tab) {\n                    this.onToggle(true);\n                }\n                else if (isOpen) {\n                    if (event.key === selectConstants/* KeyTypes.Escape */.yu.Escape) {\n                        this.onToggle(false);\n                    }\n                    else if (event.key === selectConstants/* KeyTypes.Tab */.yu.Tab) {\n                        this.onToggle(false);\n                    }\n                    else if (event.key === selectConstants/* KeyTypes.Enter */.yu.Enter) {\n                        if (focusedIndex !== null) {\n                            this.onSelect(this.getOptions()[focusedIndex].innerText);\n                            event.stopPropagation();\n                        }\n                        else {\n                            this.onToggle(false);\n                        }\n                    }\n                    else if (event.key === selectConstants/* KeyTypes.ArrowDown */.yu.ArrowDown) {\n                        this.updateFocusedIndex(1);\n                        event.preventDefault();\n                    }\n                    else if (event.key === selectConstants/* KeyTypes.ArrowUp */.yu.ArrowUp) {\n                        this.updateFocusedIndex(-1);\n                        event.preventDefault();\n                    }\n                }\n            }\n        };\n        this.updateFocusedIndex = (increment) => {\n            this.setState(prevState => {\n                const maxIndex = this.getOptions().length - 1;\n                let nextIndex = prevState.focusedIndex !== null ? prevState.focusedIndex + increment : prevState.scrollIndex;\n                if (nextIndex < 0) {\n                    nextIndex = maxIndex;\n                }\n                else if (nextIndex > maxIndex) {\n                    nextIndex = 0;\n                }\n                this.scrollToIndex(nextIndex);\n                return {\n                    focusedIndex: nextIndex\n                };\n            });\n        };\n        this.scrollToIndex = (index) => {\n            this.getOptions()[index].offsetParent.scrollTop = this.getOptions()[index].offsetTop;\n        };\n        this.scrollToSelection = (time) => {\n            const { delimiter, is24Hour } = this.props;\n            let splitTime = time.split(this.props.delimiter);\n            let focusedIndex = null;\n            // build out the rest of the time assuming hh:00 if it\'s a partial time\n            if (splitTime.length < 2) {\n                time = `${time}${delimiter}00`;\n                splitTime = time.split(delimiter);\n            }\n            // for 12hr variant, autoscroll to pm if it\'s currently the afternoon, otherwise autoscroll to am\n            if (!is24Hour && splitTime.length > 1 && splitTime[1].length < 2) {\n                const minutes = splitTime[1].length === 0 ? \'00\' : splitTime[1] + \'0\';\n                time = `${splitTime[0]}${delimiter}${minutes}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n            }\n            else if (!is24Hour &&\n                splitTime.length > 1 &&\n                splitTime[1].length === 2 &&\n                !time.toUpperCase().includes(amSuffix.toUpperCase().trim()) &&\n                !time.toUpperCase().includes(pmSuffix.toUpperCase().trim())) {\n                time = `${time}${new Date().getHours() > 11 ? pmSuffix : amSuffix}`;\n            }\n            let scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n            // if we found an exact match, scroll to match and return index of match for focus\n            if (scrollIndex !== -1) {\n                this.scrollToIndex(scrollIndex);\n                focusedIndex = scrollIndex;\n            }\n            else if (splitTime.length === 2) {\n                // no exact match, scroll to closest hour but don\'t return index for focus\n                let amPm = \'\';\n                if (!is24Hour) {\n                    if (splitTime[1].toUpperCase().includes(\'P\')) {\n                        amPm = pmSuffix;\n                    }\n                    else if (splitTime[1].toUpperCase().includes(\'A\')) {\n                        amPm = amSuffix;\n                    }\n                }\n                time = `${splitTime[0]}${delimiter}00${amPm}`;\n                scrollIndex = this.getOptions().findIndex(option => option.innerText === time);\n                if (scrollIndex !== -1) {\n                    this.scrollToIndex(scrollIndex);\n                }\n            }\n            this.setState({\n                focusedIndex,\n                scrollIndex\n            });\n        };\n        this.getRegExp = () => this.props.is24Hour\n            ? new RegExp(`^\\\\s*(\\\\d\\\\d?)${this.props.delimiter}([0-5]\\\\d)\\\\s*$`)\n            : new RegExp(`^\\\\s*(\\\\d\\\\d?)${this.props.delimiter}([0-5]\\\\d)\\\\s*([AaPp][Mm])?\\\\s*$`);\n        this.getOptions = () => (this.menuRef && this.menuRef.current ? Array.from(this.menuRef.current.children) : []);\n        this.isValid = (time) => {\n            if (this.props.validateTime) {\n                return this.props.validateTime(time);\n            }\n            const { delimiter, is24Hour } = this.props;\n            return validateTime(time, this.state.timeRegex, delimiter, !is24Hour);\n        };\n        this.onToggle = (isOpen) => {\n            // on close, parse and validate input\n            this.setState(prevState => {\n                const { timeRegex, isInvalid } = prevState;\n                const { delimiter, is24Hour } = this.props;\n                const time = parseTime(prevState.timeState, timeRegex, delimiter, !is24Hour);\n                return {\n                    isOpen,\n                    timeState: time,\n                    isInvalid: isOpen ? isInvalid : !this.isValid(time)\n                };\n            });\n        };\n        this.onSelect = (selection) => {\n            const { timeRegex, timeState } = this.state;\n            const { delimiter, is24Hour } = this.props;\n            const time = parseTime(selection, timeRegex, delimiter, !is24Hour);\n            if (time !== timeState) {\n                this.onInputChange(time);\n            }\n            this.setState({\n                isOpen: false\n            });\n        };\n        this.onInputFocus = (e) => {\n            if (!this.state.isOpen) {\n                this.onToggle(true);\n            }\n            e.stopPropagation();\n        };\n        this.onInputChange = (newTime) => {\n            if (this.props.onChange) {\n                this.props.onChange(newTime, getHours(newTime, this.state.timeRegex), getMinutes(newTime, this.state.timeRegex), this.isValid(newTime));\n            }\n            this.scrollToSelection(newTime);\n            this.setState({\n                timeState: newTime,\n                isInvalid: !this.isValid(newTime)\n            });\n        };\n        this.onBlur = (event) => {\n            const { timeRegex } = this.state;\n            const { delimiter, is24Hour } = this.props;\n            const time = parseTime(event.currentTarget.value, timeRegex, delimiter, !is24Hour);\n            this.setState({\n                isInvalid: !this.isValid(time)\n            });\n        };\n        const { is24Hour, delimiter, time } = this.props;\n        const timeRegex = this.getRegExp();\n        this.state = {\n            isInvalid: false,\n            isOpen: false,\n            timeState: parseTime(time, timeRegex, delimiter, !is24Hour),\n            focusedIndex: null,\n            scrollIndex: 0,\n            timeRegex\n        };\n    }\n    componentDidMount() {\n        document.addEventListener(\'mousedown\', this.onDocClick);\n        document.addEventListener(\'touchstart\', this.onDocClick);\n        document.addEventListener(\'keydown\', this.handleGlobalKeys);\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\'mousedown\', this.onDocClick);\n        document.removeEventListener(\'touchstart\', this.onDocClick);\n        document.removeEventListener(\'keydown\', this.handleGlobalKeys);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        const { timeState, isOpen, isInvalid, timeRegex } = this.state;\n        const { time, is24Hour, delimiter } = this.props;\n        if (isOpen && !prevState.isOpen && timeState && !isInvalid) {\n            this.scrollToSelection(timeState);\n        }\n        if (delimiter !== prevProps.delimiter) {\n            this.setState({\n                timeRegex: this.getRegExp()\n            });\n        }\n        if (time !== \'\' && time !== prevProps.time) {\n            this.setState({\n                timeState: parseTime(time, timeRegex, delimiter, !is24Hour)\n            });\n        }\n    }\n    render() {\n        const _a = this.props, { \'aria-label\': ariaLabel, isDisabled, className, placeholder, id, menuAppendTo, is24Hour, invalidFormatErrorMessage, direction, stepMinutes, width, delimiter, \n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        onChange, time, validateTime, inputProps } = _a, props = (0,tslib_es6.__rest)(_a, [\'aria-label\', "isDisabled", "className", "placeholder", "id", "menuAppendTo", "is24Hour", "invalidFormatErrorMessage", "direction", "stepMinutes", "width", "delimiter", "onChange", "time", "validateTime", "inputProps"]);\n        const { timeState, isOpen, isInvalid, focusedIndex } = this.state;\n        const style = { \'--pf-c-date-picker__input--c-form-control--Width\': width };\n        const options = makeTimeOptions(stepMinutes, !is24Hour, delimiter);\n        const randomId = id || (0,util/* getUniqueId */.Ki)(\'time-picker\');\n        const menuContainer = (react_index_js_eager_.createElement("ul", { ref: this.menuRef, className: (0,esm/* css */.i)(Select_select/* default.selectMenu */.Z.selectMenu), role: "listbox", "aria-labelledby": `${id}-input`, style: { maxHeight: \'200px\', overflowY: \'auto\' } }, options.map((option, index) => (react_index_js_eager_.createElement(TimeOption, { key: index, value: option, index: index, onSelect: this.onSelect, isFocused: index === focusedIndex, id: `${id}-option-${index}` })))));\n        const inputAndToggle = (react_index_js_eager_.createElement("div", Object.assign({ className: (0,esm/* css */.i)(date_picker/* default.datePickerInput */.Z.datePickerInput), style: style }, props),\n            react_index_js_eager_.createElement(InputGroup/* InputGroup */.B, null,\n                react_index_js_eager_.createElement("div", { className: (0,esm/* css */.i)(Select_select/* default.select */.Z.select, isOpen && Select_select/* default.modifiers.expanded */.Z.modifiers.expanded, direction === selectConstants/* SelectDirection.up */.$4.up && Select_select/* default.modifiers.top */.Z.modifiers.top, className), id: randomId, ref: this.parentRef },\n                    react_index_js_eager_.createElement("div", { ref: this.toggleRef, className: (0,esm/* css */.i)(Select_select/* default.selectToggle */.Z.selectToggle, isDisabled && Select_select/* default.modifiers.disabled */.Z.modifiers.disabled, Select_select/* default.modifiers.typeahead */.Z.modifiers.typeahead), style: { paddingLeft: \'0\' } },\n                        react_index_js_eager_.createElement(TextInput/* TextInput */.oi, Object.assign({ className: (0,esm/* css */.i)(form_control/* default.formControl */.Z.formControl, Select_select/* default.selectToggleTypeahead */.Z.selectToggleTypeahead), id: `${randomId}-input`, "aria-label": ariaLabel, validated: isInvalid ? \'error\' : \'default\', placeholder: placeholder, value: timeState || \'\', type: "text", iconVariant: "clock", onClick: this.onInputFocus, onFocus: this.onInputFocus, onChange: this.onInputChange, onBlur: this.onBlur, autoComplete: "off", isDisabled: isDisabled, ref: this.inputRef }, inputProps))),\n                    isOpen && menuAppendTo === \'inline\' && menuContainer)),\n            isInvalid && (react_index_js_eager_.createElement("div", { className: (0,esm/* css */.i)(date_picker/* default.datePickerHelperText */.Z.datePickerHelperText, date_picker/* default.modifiers.error */.Z.modifiers.error) }, invalidFormatErrorMessage))));\n        const popperContainer = (react_index_js_eager_.createElement("div", { className: (0,esm/* css */.i)(Select_select/* default.select */.Z.select, isOpen && Select_select/* default.modifiers.expanded */.Z.modifiers.expanded, direction === selectConstants/* SelectDirection.up */.$4.up && Select_select/* default.modifiers.top */.Z.modifiers.top, className) }, isOpen && menuContainer));\n        return (react_index_js_eager_.createElement("div", { className: (0,esm/* css */.i)(date_picker/* default.datePicker */.Z.datePicker, className) }, menuAppendTo === \'inline\' ? (inputAndToggle) : (react_index_js_eager_.createElement(Popper/* Popper */.r, { trigger: inputAndToggle, popper: popperContainer, direction: direction, appendTo: menuAppendTo, isVisible: isOpen }))));\n    }\n}\nTimePicker.displayName = \'TimePicker\';\nTimePicker.defaultProps = {\n    className: \'\',\n    isDisabled: false,\n    time: \'\',\n    is24Hour: false,\n    invalidFormatErrorMessage: \'Invalid time format\',\n    placeholder: \'hh:mm\',\n    delimiter: \':\',\n    \'aria-label\': \'Time picker\',\n    menuAppendTo: \'inline\',\n    direction: \'down\',\n    width: 150,\n    stepMinutes: 30,\n    inputProps: {}\n};\n//# sourceMappingURL=TimePicker.js.map\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/DateField.js\n\n\n\n\nvar DateConstructor = (typeof __webpack_require__.g === \'object\' ? __webpack_require__.g : window).Date;\nfunction DateField(props) {\n    var _a, _b;\n    var parseDate = (0,index_js_eager_.useCallback)(function () {\n        if (!props.value) {\n            return \'\';\n        }\n        return props.value.toISOString().slice(0, -14);\n    }, [props.value]);\n    var parseTime = (0,index_js_eager_.useCallback)(function () {\n        if (!props.value) {\n            return \'\';\n        }\n        return props.value.getUTCHours() + ":" + props.value.getUTCMinutes();\n    }, [props.value]);\n    var onDateChange = (0,index_js_eager_.useCallback)(function (value, date) {\n        var _a;\n        if (!date) {\n            props.onChange(date);\n        }\n        else {\n            var newDate = new DateConstructor(date);\n            var time = parseTime();\n            if (time !== \'\') {\n                newDate.setUTCHours(parseInt(time === null || time === void 0 ? void 0 : time.split(\':\')[0]));\n                newDate.setUTCMinutes(parseInt((_a = time === null || time === void 0 ? void 0 : time.split(\':\')[1]) === null || _a === void 0 ? void 0 : _a.split(\' \')[0]));\n            }\n            else {\n                newDate.setUTCHours(0);\n                newDate.setUTCMinutes(0);\n            }\n            props.onChange(newDate);\n        }\n    }, [props.onChange, parseTime]);\n    var isInvalid = (0,index_js_eager_.useMemo)(function () {\n        if (props.value) {\n            if (props.min) {\n                var minDate = new Date(props.min);\n                if (minDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (props.value < minDate) {\n                    return "Should be after " + minDate.toISOString();\n                }\n            }\n            if (props.max) {\n                var maxDate = new Date(props.max);\n                if (maxDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (props.value > maxDate) {\n                    return "Should be before " + maxDate.toISOString();\n                }\n            }\n        }\n        return false;\n    }, [props.value]);\n    var onTimeChange = (0,index_js_eager_.useCallback)(function (time, hours, minutes) {\n        var _a;\n        if (props.value) {\n            var newDate = new DateConstructor(props.value);\n            if (hours && minutes) {\n                newDate.setUTCHours(hours);\n                newDate.setUTCMinutes(minutes);\n            }\n            else if (time !== \'\') {\n                var localeHours = parseInt(time === null || time === void 0 ? void 0 : time.split(\':\')[0]);\n                var localeMinutes = parseInt((_a = time === null || time === void 0 ? void 0 : time.split(\':\')[1]) === null || _a === void 0 ? void 0 : _a.split(\' \')[0]);\n                if (!isNaN(localeHours) && !isNaN(localeMinutes)) {\n                    newDate.setUTCHours(localeHours);\n                    newDate.setUTCMinutes(localeMinutes);\n                }\n            }\n            else {\n                newDate.setUTCHours(0);\n                newDate.setUTCMinutes(0);\n            }\n            props.onChange(newDate);\n        }\n    }, [props.onChange, props.value]);\n    return wrapField(props, index_js_eager_default().createElement(Flex/* Flex */.k, { style: { margin: 0 }, direction: { default: \'column\' }, id: props.id, name: props.name, ref: props.inputRef },\n        index_js_eager_default().createElement(FlexItem/* FlexItem */.B, { style: { margin: 0 } },\n            index_js_eager_default().createElement(InputGroup/* InputGroup */.B, { style: { background: \'transparent\' } },\n                index_js_eager_default().createElement(DatePicker, { id: "date-picker-" + props.id, "data-testid": "date-picker", isDisabled: props.disabled, name: props.name, onChange: onDateChange, value: (_a = parseDate()) !== null && _a !== void 0 ? _a : \'\' }),\n                index_js_eager_default().createElement(TimePicker, { id: "time-picker-" + props.id, "data-testid": "time-picker", isDisabled: props.disabled || !props.value, name: props.name, onChange: onTimeChange, style: { width: \'120px\' }, value: (_b = parseTime()) !== null && _b !== void 0 ? _b : \'\', is24Hour: true }))),\n        isInvalid && (index_js_eager_default().createElement("div", { id: props.id + "-invalid-date-time", style: {\n                fontSize: \'0.875rem\',\n                color: \'#c9190b\',\n                marginTop: \'0.25rem\',\n            } }, isInvalid))));\n}\n/* harmony default export */ const esm_DateField = ((0,index_js_.connectField)(DateField));\n\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-styles/css/layouts/Split/split.js\nvar split = __webpack_require__(48271);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/layouts/Split/Split.js\n\n\n\n\nconst Split = (_a) => {\n    var { hasGutter = false, isWrappable = false, className = \'\', children = null, component = \'div\' } = _a, props = (0,tslib_es6.__rest)(_a, ["hasGutter", "isWrappable", "className", "children", "component"]);\n    const Component = component;\n    return (react_index_js_eager_.createElement(Component, Object.assign({}, props, { className: (0,esm/* css */.i)(split/* default.split */.Z.split, hasGutter && split/* default.modifiers.gutter */.Z.modifiers.gutter, isWrappable && split/* default.modifiers.wrap */.Z.modifiers.wrap, className) }), children));\n};\nSplit.displayName = \'Split\';\n//# sourceMappingURL=Split.js.map\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-core/dist/esm/layouts/Split/SplitItem.js\n\n\n\n\nconst SplitItem = (_a) => {\n    var { isFilled = false, className = \'\', children = null } = _a, props = (0,tslib_es6.__rest)(_a, ["isFilled", "className", "children"]);\n    return (react_index_js_eager_.createElement("div", Object.assign({}, props, { className: (0,esm/* css */.i)(split/* default.splitItem */.Z.splitItem, isFilled && split/* default.modifiers.fill */.Z.modifiers.fill, className) }), children));\n};\nSplitItem.displayName = \'SplitItem\';\n//# sourceMappingURL=SplitItem.js.map\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js + 3 modules\nvar Tooltip = __webpack_require__(35224);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/outlined-question-circle-icon.js\n\n\nconst OutlinedQuestionCircleIconConfig = {\n  name: \'OutlinedQuestionCircleIcon\',\n  height: 512,\n  width: 512,\n  svgPath: \'M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 448c-110.532 0-200-89.431-200-200 0-110.495 89.472-200 200-200 110.491 0 200 89.471 200 200 0 110.53-89.431 200-200 200zm107.244-255.2c0 67.052-72.421 68.084-72.421 92.863V300c0 6.627-5.373 12-12 12h-45.647c-6.627 0-12-5.373-12-12v-8.659c0-35.745 27.1-50.034 47.579-61.516 17.561-9.845 28.324-16.541 28.324-29.579 0-17.246-21.999-28.693-39.784-28.693-23.189 0-33.894 10.977-48.942 29.969-4.057 5.12-11.46 6.071-16.666 2.124l-27.824-21.098c-5.107-3.872-6.251-11.066-2.644-16.363C184.846 131.491 214.94 112 261.794 112c49.071 0 101.45 38.304 101.45 88.8zM298 368c0 23.159-18.841 42-42 42s-42-18.841-42-42 18.841-42 42-42 42 18.841 42 42z\',\n  yOffset: 0,\n  xOffset: 0,\n};\n\nconst OutlinedQuestionCircleIcon = (0,createIcon/* createIcon */.IU)(OutlinedQuestionCircleIconConfig);\n\n/* harmony default export */ const outlined_question_circle_icon = ((/* unused pure expression or super */ null && (OutlinedQuestionCircleIcon)));\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/minus-circle-icon.js\n\n\nconst MinusCircleIconConfig = {\n  name: \'MinusCircleIcon\',\n  height: 512,\n  width: 512,\n  svgPath: \'M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z\',\n  yOffset: 0,\n  xOffset: 0,\n};\n\nconst MinusCircleIcon = (0,createIcon/* createIcon */.IU)(MinusCircleIconConfig);\n\n/* harmony default export */ const minus_circle_icon = ((/* unused pure expression or super */ null && (MinusCircleIcon)));\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ListDelField.js\n\n\n\n\n\nfunction ListDel(_a) {\n    var name = _a.name, disabled = _a.disabled, props = (0,tslib_es6.__rest)(_a, ["name", "disabled"]);\n    var nameParts = (0,index_js_.joinName)(null, name);\n    var nameIndex = +nameParts[nameParts.length - 1];\n    var parentName = (0,index_js_.joinName)(nameParts.slice(0, -1));\n    var parent = (0,index_js_.useField)(parentName, {}, { absoluteName: true })[0];\n    var limitNotReached = !disabled && !(parent.minCount >= parent.value.length);\n    return (index_js_eager_default().createElement(Button/* Button */.zx, (0,tslib_es6.__assign)({ disabled: !limitNotReached || disabled, variant: "plain", style: { paddingLeft: \'0\', paddingRight: \'0\' }, onClick: function () {\n            var value = parent.value.slice();\n            value.splice(nameIndex, 1);\n            !disabled && limitNotReached && parent.onChange(value);\n        } }, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(MinusCircleIcon, { color: "#cc0000" })));\n}\n/* harmony default export */ const ListDelField = ((0,index_js_.connectField)(ListDel, {\n    initialValue: false,\n    kind: \'leaf\',\n}));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ListItemField.js\n\n\n\n\nfunction ListItem(_a) {\n    var _b = _a.children, children = _b === void 0 ? index_js_eager_default().createElement(esm_AutoField, { label: null, name: \'\' }) : _b;\n    return (index_js_eager_default().createElement("div", { style: {\n            marginBottom: \'1rem\',\n            display: \'flex\',\n            justifyContent: \'space-between\',\n        } },\n        index_js_eager_default().createElement("div", { style: { width: \'100%\', marginRight: \'10px\' } }, children),\n        index_js_eager_default().createElement("div", null,\n            index_js_eager_default().createElement(ListDelField, { name: \'\' }))));\n}\n/* harmony default export */ const ListItemField = ((0,index_js_.connectField)(ListItem, {\n    initialValue: false,\n}));\n\n// EXTERNAL MODULE: ./node_modules/lodash/cloneDeep.js\nvar cloneDeep = __webpack_require__(50361);\nvar cloneDeep_default = /*#__PURE__*/__webpack_require__.n(cloneDeep);\n;// CONCATENATED MODULE: ./node_modules/@patternfly/react-icons/dist/esm/icons/plus-circle-icon.js\n\n\nconst PlusCircleIconConfig = {\n  name: \'PlusCircleIcon\',\n  height: 512,\n  width: 512,\n  svgPath: \'M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z\',\n  yOffset: 0,\n  xOffset: 0,\n};\n\nconst PlusCircleIcon = (0,createIcon/* createIcon */.IU)(PlusCircleIconConfig);\n\n/* harmony default export */ const plus_circle_icon = ((/* unused pure expression or super */ null && (PlusCircleIcon)));\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ListAddField.js\n\n\n\n\n\n\nfunction ListAdd(_a) {\n    var _b = _a.disabled, disabled = _b === void 0 ? false : _b, name = _a.name, value = _a.value, props = (0,tslib_es6.__rest)(_a, ["disabled", "name", "value"]);\n    var nameParts = (0,index_js_.joinName)(null, name);\n    var parentName = (0,index_js_.joinName)(nameParts.slice(0, -1));\n    var parent = (0,index_js_.useField)(parentName, {}, { absoluteName: true })[0];\n    var limitNotReached = !disabled && !(parent.maxCount <= parent.value.length);\n    return (index_js_eager_default().createElement(Button/* Button */.zx, (0,tslib_es6.__assign)({ variant: "plain", style: { paddingLeft: \'0\', paddingRight: \'0\' }, disabled: !limitNotReached, onClick: function () {\n            !disabled &&\n                limitNotReached &&\n                parent.onChange(parent.value.concat([cloneDeep_default()(value)]));\n        } }, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(PlusCircleIcon, { color: "#0088ce" })));\n}\n/* harmony default export */ const ListAddField = ((0,index_js_.connectField)(ListAdd, {\n    initialValue: false,\n    kind: \'leaf\',\n}));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ListField.js\n\n\n\n\n\n\n\nindex_js_.filterDOMProps.register(\'minCount\', \'wrapperCol\', \'labelCol\');\nfunction ListField(_a) {\n    var _b = _a.children, children = _b === void 0 ? index_js_eager_default().createElement(ListItemField, { name: "$" }) : _b, error = _a.error, errorMessage = _a.errorMessage, info = _a.info, initialCount = _a.initialCount, itemProps = _a.itemProps, label = _a.label, name = _a.name, value = _a.value, showInlineError = _a.showInlineError, props = (0,tslib_es6.__rest)(_a, ["children", "error", "errorMessage", "info", "initialCount", "itemProps", "label", "name", "value", "showInlineError"]);\n    return (index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(Split, { hasGutter: true },\n            index_js_eager_default().createElement(SplitItem, null, label && (index_js_eager_default().createElement("label", null,\n                label,\n                !!info && (index_js_eager_default().createElement("span", null,\n                    "\\u00A0",\n                    index_js_eager_default().createElement(Tooltip/* Tooltip */.u, { content: info },\n                        index_js_eager_default().createElement(OutlinedQuestionCircleIcon, null))))))),\n            index_js_eager_default().createElement(SplitItem, { isFilled: true }),\n            index_js_eager_default().createElement(SplitItem, null,\n                index_js_eager_default().createElement(ListAddField, { name: \'$\', initialCount: initialCount }))),\n        index_js_eager_default().createElement("div", null, value === null || value === void 0 ? void 0 : value.map(function (item, itemIndex) {\n            return index_js_eager_.Children.map(children, function (child, childIndex) {\n                var _a;\n                return (0,index_js_eager_.isValidElement)(child)\n                    ? (0,index_js_eager_.cloneElement)(child, (0,tslib_es6.__assign)({ key: itemIndex + "-" + childIndex, name: (_a = child.props.name) === null || _a === void 0 ? void 0 : _a.replace(\'$\', \'\' + itemIndex) }, itemProps))\n                    : child;\n            });\n        }))));\n}\n/* harmony default export */ const esm_ListField = ((0,index_js_.connectField)(ListField));\n\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Card/Card.js\nvar Card = __webpack_require__(32203);\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Card/CardBody.js\nvar CardBody = __webpack_require__(62394);\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/NestField.js\n\n\n\n\n\nvar Nest = function (_a) {\n    var children = _a.children, error = _a.error, errorMessage = _a.errorMessage, fields = _a.fields, itemProps = _a.itemProps, label = _a.label, name = _a.name, showInlineError = _a.showInlineError, disabled = _a.disabled, props = (0,tslib_es6.__rest)(_a, ["children", "error", "errorMessage", "fields", "itemProps", "label", "name", "showInlineError", "disabled"]);\n    return (index_js_eager_default().createElement(Card/* Card */.Z, (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(CardBody/* CardBody */.e, { className: "pf-c-form" },\n            label && (index_js_eager_default().createElement("label", null,\n                index_js_eager_default().createElement("b", null, label))),\n            children || (fields === null || fields === void 0 ? void 0 : fields.map(function (field) { return (index_js_eager_default().createElement(esm_AutoField, (0,tslib_es6.__assign)({ key: field, disabled: disabled, name: field }, itemProps))); })))));\n};\n/* harmony default export */ const NestField = ((0,index_js_.connectField)(Nest));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/NumField.js\n\n\n\n\nvar Num = function (props) {\n    var _a;\n    var onChange = function (value, event) {\n        var parse = props.decimal ? parseFloat : parseInt;\n        var v = parse(event.target.value);\n        props.onChange(isNaN(v) ? undefined : v);\n    };\n    return wrapField(props, index_js_eager_default().createElement(TextInput/* TextInput */.oi, { name: props.name, isDisabled: props.disabled, id: props.id, max: props.max, min: props.min, onChange: onChange, placeholder: props.placeholder, ref: props.inputRef, step: props.decimal ? 0.01 : 1, type: "number", value: (_a = props.value) !== null && _a !== void 0 ? _a : \'\', validated: props.error ? \'error\' : \'default\' }));\n};\n/* harmony default export */ const NumField = ((0,index_js_.connectField)(Num));\n\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Radio/Radio.js\nvar Radio = __webpack_require__(92504);\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/RadioField.js\n\n\n\n\n\nvar RadioField_Radio = function (props) {\n    var _a;\n    index_js_.filterDOMProps.register(\'checkboxes\', \'decimal\');\n    return wrapField(props, index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)), (_a = props.allowedValues) === null || _a === void 0 ? void 0 : _a.map(function (item) { return (index_js_eager_default().createElement((index_js_eager_default()).Fragment, { key: item },\n        index_js_eager_default().createElement(Radio/* Radio */.Y, { isChecked: item === props.value, isDisabled: props.disabled, id: "" + props.id, name: props.name, label: props.transform ? props.transform(item) : item, "aria-label": props.name, onChange: function () { return props.onChange(item); } }))); })));\n};\n/* harmony default export */ const RadioField = ((0,index_js_.connectField)(RadioField_Radio));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/SelectField.js\n\n\n\n\n\nfunction xor(item, array) {\n    var index = array.indexOf(item);\n    if (index === -1) {\n        return array.concat([item]);\n    }\n    return array.slice(0, index).concat(array.slice(index + 1));\n}\nindex_js_.filterDOMProps.register(\'autoValue\');\nfunction isSelectOptionObject(toBeDetermined) {\n    return toBeDetermined.toString !== undefined;\n}\nfunction SelectField(props) {\n    if (props.checkboxes) {\n        var Group_1 = (0,index_js_eager_.useMemo)(function () { return (props.fieldType === Array ? Checkbox/* Checkbox */.X : Radio/* Radio */.Y); }, [props]);\n        return (index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)),\n            props.label && index_js_eager_default().createElement("label", null, props.label),\n            props.allowedValues.map(function (item, index) {\n                return (index_js_eager_default().createElement((index_js_eager_default()).Fragment, { key: index },\n                    index_js_eager_default().createElement("label", { htmlFor: props.id }, props.transform ? props.transform(item) : item),\n                    index_js_eager_default().createElement(Group_1, { id: props.id + "-" + item, isDisabled: props.disabled, name: props.name, "aria-label": props.name, value: props.value, isChecked: props.fieldType === Array && Array.isArray(props.value)\n                            ? props.value.includes(item)\n                            : props.value === item, onChange: function () {\n                            props.onChange(props.fieldType === Array && Array.isArray(props.value)\n                                ? xor(item, props.value)\n                                : item);\n                        } })));\n            })));\n    }\n    var _a = (0,index_js_eager_.useState)(false), expanded = _a[0], setExpanded = _a[1];\n    var _b = (0,index_js_eager_.useState)([]), selected = _b[0], setSelected = _b[1];\n    (0,index_js_eager_.useEffect)(function () {\n        if (!props.value) {\n            setSelected([]);\n            setExpanded(false);\n        }\n        else if (Array.isArray(props.value)) {\n            setSelected((0,tslib_es6.__spreadArrays)(props.value));\n            setExpanded(false);\n        }\n        else {\n            setSelected(props.value);\n            setExpanded(false);\n        }\n    }, [props.value]);\n    var parseInput = (0,index_js_eager_.useCallback)(function (selection, fieldType) {\n        var parsedSelection = isSelectOptionObject(selection)\n            ? selection.toString()\n            : selection;\n        if (fieldType !== Array) {\n            return parsedSelection !== \'\' ? parsedSelection : \'\';\n        }\n        if (Array.isArray(selected)) {\n            if (selected.includes(parsedSelection)) {\n                return selected.filter(function (s) { return s !== parsedSelection; });\n            }\n            return (0,tslib_es6.__spreadArrays)([parsedSelection], selected);\n        }\n        return [parsedSelection, selected];\n    }, [selected]);\n    var handleSelect = (0,index_js_eager_.useCallback)(function (event, selection) {\n        if (selection === props.placeholder) {\n            props.onChange(undefined);\n        }\n        else {\n            var items = parseInput(selection, props.fieldType);\n            props.onChange(items);\n        }\n    }, [parseInput, props]);\n    var selectedOptions = (0,index_js_eager_.useMemo)(function () {\n        return props.allowedValues.map(function (value) { return (index_js_eager_default().createElement(SelectOption/* SelectOption */.$, { key: value, value: value }, props.transform ? props.transform(value) : value)); });\n    }, [props]);\n    (0,index_js_eager_.useEffect)(function () {\n        if (props.placeholder)\n            selectedOptions.unshift(index_js_eager_default().createElement(SelectOption/* SelectOption */.$, { key: props.allowedValues.length, isPlaceholder: true, value: props.placeholder }));\n    }, [props.placeholder, selectedOptions]);\n    return wrapField(props, index_js_eager_default().createElement(Select/* Select */.P, { isDisabled: props.disabled, id: props.id, variant: props.fieldType === Array\n            ? selectConstants/* SelectVariant.typeaheadMulti */.TM.typeaheadMulti\n            : selectConstants/* SelectVariant.single */.TM.single, name: props.name, placeholderText: props.placeholder, isOpen: expanded, selections: selected, onToggle: function () { return setExpanded(!expanded); }, onSelect: handleSelect, value: props.value || (props.fieldType === Array ? [] : undefined) }, selectedOptions));\n}\n/* harmony default export */ const esm_SelectField = ((0,index_js_.connectField)(SelectField));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/TextField.js\n\n\n\n\n\nvar timeRgx = /^([0-1]?[0-9]|2[0-3]):([0-5][0-9])(:[0-5][0-9])?/;\nvar Text = function (props) {\n    var _a, _b, _c, _d, _e, _f;\n    var isDateInvalid = (0,index_js_eager_.useMemo)(function () {\n        var _a;\n        if (typeof props.value === \'string\' &&\n            (props.type === \'date\' || ((_a = props.field) === null || _a === void 0 ? void 0 : _a.format) === \'date\')) {\n            var date = new Date(props.value);\n            if (typeof props.min === \'string\') {\n                var minDate = new Date(props.min);\n                if (minDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (date.toISOString() < minDate.toISOString()) {\n                    return props.errorMessage && props.errorMessage.trim().length > 0\n                        ? props.errorMessage\n                        : "Should be after " + props.min;\n                }\n            }\n            if (typeof props.max === \'string\') {\n                var maxDate = new Date(props.max);\n                if (maxDate.toString() === \'Invalid Date\') {\n                    return false;\n                }\n                else if (date.toISOString() > maxDate.toISOString()) {\n                    return props.errorMessage && props.errorMessage.trim().length > 0\n                        ? props.errorMessage\n                        : "Should be before " + props.max;\n                }\n            }\n        }\n        return false;\n    }, [props.value, props.max, props.min, props.errorMessage]);\n    var parseTime = (0,index_js_eager_.useCallback)(function (time) {\n        var parsedTime = timeRgx.exec(time);\n        var date = new Date();\n        // @ts-ignore\n        if (!parsedTime) {\n            return undefined;\n        }\n        date.setUTCHours(Number(parsedTime[1]), Number(parsedTime[2]));\n        return date;\n    }, []);\n    var isTimeInvalid = (0,index_js_eager_.useMemo)(function () {\n        var _a;\n        if (typeof props.value === \'string\' &&\n            (props.type === \'time\' || ((_a = props.field) === null || _a === void 0 ? void 0 : _a.format) === \'time\')) {\n            var parsedTime = parseTime(props.value);\n            if (parsedTime &&\n                typeof props.min === \'string\' &&\n                timeRgx.exec(props.min)) {\n                var parsedMin = parseTime(props.min);\n                if (parsedTime < parsedMin) {\n                    return "Should be after " + parsedMin.getUTCHours() + ":" + parsedMin.getUTCMinutes();\n                }\n            }\n            if (parsedTime &&\n                typeof props.max === \'string\' &&\n                timeRgx.exec(props.max)) {\n                var parsedMax = parseTime(props.max);\n                if (parsedTime > parsedMax) {\n                    return "Should be before " + parsedMax.getUTCHours() + ":" + parsedMax.getUTCMinutes();\n                }\n            }\n        }\n        return false;\n    }, [props.type, props.field, props.value, props.max, props.min]);\n    var onDateChange = (0,index_js_eager_.useCallback)(function (value) {\n        props.onChange(value);\n    }, [props.disabled, props.onChange]);\n    var onTimeChange = (0,index_js_eager_.useCallback)(function (time) {\n        var parsedTime = time.split(\':\');\n        if (parsedTime.length === 2) {\n            props.onChange((0,tslib_es6.__spreadArrays)(parsedTime, [\'00\']).join(\':\'));\n        }\n        else {\n            props.onChange(time);\n        }\n    }, [props.disabled, props.onChange]);\n    return wrapField(props, props.type === \'date\' || ((_a = props.field) === null || _a === void 0 ? void 0 : _a.format) === \'date\' ? (index_js_eager_default().createElement((index_js_eager_default()).Fragment, null,\n        index_js_eager_default().createElement(DatePicker, (0,tslib_es6.__assign)({ name: props.name, isDisabled: props.disabled, onChange: onDateChange, value: (_b = props.value) !== null && _b !== void 0 ? _b : \'\' }, (0,index_js_.filterDOMProps)(props))),\n        isDateInvalid && (index_js_eager_default().createElement("div", { style: {\n                fontSize: \'0.875rem\',\n                color: \'#c9190b\',\n                marginTop: \'0.25rem\',\n            } }, isDateInvalid)))) : props.type === \'time\' || ((_c = props.field) === null || _c === void 0 ? void 0 : _c.format) === \'time\' ? (index_js_eager_default().createElement((index_js_eager_default()).Fragment, null,\n        index_js_eager_default().createElement(TimePicker, { name: props.name, isDisabled: props.disabled, onChange: onTimeChange, is24Hour: true, value: (_d = props.value) !== null && _d !== void 0 ? _d : \'\' }),\n        isTimeInvalid && (index_js_eager_default().createElement("div", { style: {\n                fontSize: \'0.875rem\',\n                color: \'#c9190b\',\n                marginTop: \'0.25rem\',\n            } }, isTimeInvalid)))) : (index_js_eager_default().createElement(TextInput/* TextInput */.oi, (0,tslib_es6.__assign)({ name: props.name, isDisabled: props.disabled, validated: props.error ? \'error\' : \'default\', onChange: function (value, event) { return props.onChange(event.target.value); }, placeholder: props.placeholder, ref: props.inputRef, type: (_e = props.type) !== null && _e !== void 0 ? _e : \'text\', value: (_f = props.value) !== null && _f !== void 0 ? _f : \'\' }, (0,index_js_.filterDOMProps)(props)))));\n};\n/* harmony default export */ const TextField = ((0,index_js_.connectField)(Text));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/AutoField.js\n\n\n\n\n\n\n\n\n\n\nvar AutoField = (0,index_js_.createAutoField)(function (props) {\n    if (props.allowedValues) {\n        return props.checkboxes && props.fieldType !== Array\n            ? RadioField\n            : esm_SelectField;\n    }\n    switch (props.fieldType) {\n        case Array:\n            return esm_ListField;\n        case Boolean:\n            return BoolField;\n        case Date:\n            return esm_DateField;\n        case Number:\n            return NumField;\n        case Object:\n            return NestField;\n        case String:\n            return TextField;\n    }\n    return browser_default()(false, \'Unsupported field type: %s\', props.fieldType);\n});\n/* harmony default export */ const esm_AutoField = (AutoField);\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/AutoFields.js\n\n\n\n\nfunction AutoFields(_a) {\n    var _b = _a.autoField, autoField = _b === void 0 ? esm_AutoField : _b, _c = _a.element, element = _c === void 0 ? \'div\' : _c, fields = _a.fields, _d = _a.omitFields, omitFields = _d === void 0 ? [] : _d, props = (0,tslib_es6.__rest)(_a, ["autoField", "element", "fields", "omitFields"]);\n    var schema = (0,index_js_.useForm)().schema;\n    return (0,index_js_eager_.createElement)(element, props, (fields !== null && fields !== void 0 ? fields : schema.getSubfields())\n        .filter(function (field) { return !omitFields.includes(field); })\n        .map(function (field) { return (0,index_js_eager_.createElement)(autoField, { key: field, name: field }); }));\n}\n\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/Form/Form.js\nvar Form = __webpack_require__(83115);\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/BaseForm.js\n\n\n\n\nfunction Patternfly(parent) {\n    var _ = /** @class */ (function (_super) {\n        (0,tslib_es6.__extends)(_, _super);\n        function _() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        _.prototype.render = function () {\n            return (index_js_eager_default().createElement(index_js_.context.Provider, { value: this.getContext() },\n                index_js_eager_default().createElement(Form/* Form */.l, (0,tslib_es6.__assign)({}, this.getNativeFormProps()))));\n        };\n        _.Patternfly = Patternfly;\n        _.displayName = "Patternfly" + parent.displayName;\n        return _;\n    }(parent));\n    return _;\n}\n/* harmony default export */ const BaseForm = (Patternfly(index_js_.BaseForm));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ErrorsField.js\n\n\n\nfunction ErrorsField(_a) {\n    var children = _a.children, props = (0,tslib_es6.__rest)(_a, ["children"]);\n    var _b = (0,index_js_.useForm)(), error = _b.error, schema = _b.schema;\n    return !error && !children ? null : (index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)),\n        children,\n        index_js_eager_default().createElement("ul", null, schema.getErrorMessages(error).map(function (message, index) { return (index_js_eager_default().createElement("li", { key: index, style: { margin: \'3px\' } }, message)); }))));\n}\nErrorsField.defaultProps = {\n    style: {\n        backgroundColor: \'rgba(255, 85, 0, 0.2)\',\n        border: \'1px solid rgb(255, 85, 0)\',\n        borderRadius: \'7px\',\n        margin: \'20px 0px\',\n        padding: \'10px\',\n    },\n};\n/* harmony default export */ const esm_ErrorsField = (ErrorsField);\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/SubmitField.js\n\n\n\n\nfunction SubmitField(_a) {\n    var disabled = _a.disabled, inputRef = _a.inputRef, value = _a.value, props = (0,tslib_es6.__rest)(_a, ["disabled", "inputRef", "value"]);\n    var _b = (0,index_js_.useForm)(), error = _b.error, state = _b.state;\n    return (index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)),\n        index_js_eager_default().createElement(Button/* Button */.zx, { isDisabled: disabled === undefined ? !!(error || state.disabled) : disabled, type: "submit", ref: inputRef, variant: "primary" }, value)));\n}\nSubmitField.defaultProps = { value: \'Submit\' };\n/* harmony default export */ const esm_SubmitField = (SubmitField);\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/QuickForm.js\n\n\n\n\n\n\nfunction Quick(parent) {\n    var _ = /** @class */ (function (_super) {\n        (0,tslib_es6.__extends)(_, _super);\n        function _() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        _.prototype.getAutoField = function () {\n            return esm_AutoField;\n        };\n        _.prototype.getErrorsField = function () {\n            return esm_ErrorsField;\n        };\n        _.prototype.getSubmitField = function () {\n            return esm_SubmitField;\n        };\n        _.Quick = Quick;\n        return _;\n    }(index_js_.QuickForm.Quick(parent)));\n    return _;\n}\n/* harmony default export */ const QuickForm = (Quick(BaseForm));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ValidatedForm.js\n\n\n\nfunction Validated(parent) {\n    var _ = /** @class */ (function (_super) {\n        (0,tslib_es6.__extends)(_, _super);\n        function _() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        _.Validated = Validated;\n        return _;\n    }(index_js_.ValidatedForm.Validated(parent)));\n    return _;\n}\n/* harmony default export */ const ValidatedForm = (Validated(BaseForm));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ValidatedQuickForm.js\n\n\n\n/* harmony default export */ const ValidatedQuickForm = (ValidatedForm.Validated(QuickForm.Quick(BaseForm)));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/AutoForm.js\n\n\n\nfunction Auto(parent) {\n    var _ = /** @class */ (function (_super) {\n        (0,tslib_es6.__extends)(_, _super);\n        function _() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        _.Auto = Auto;\n        return _;\n    }(index_js_.AutoForm.Auto(parent)));\n    return _;\n}\n/* harmony default export */ const AutoForm = (Auto(ValidatedQuickForm));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/ErrorField.js\n\n\n\nvar Error = function (_a) {\n    var children = _a.children, error = _a.error, errorMessage = _a.errorMessage, props = (0,tslib_es6.__rest)(_a, ["children", "error", "errorMessage"]);\n    return !error ? null : (index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)), children ? (children) : (index_js_eager_default().createElement("div", { style: { margin: \'3px\' } }, errorMessage))));\n};\nError.defaultProps = {\n    style: {\n        backgroundColor: \'rgba(255, 85, 0, 0.2)\',\n        border: \'1px solid rgb(255, 85, 0)\',\n        borderRadius: \'7px\',\n        margin: \'20px 0px\',\n        padding: \'10px\',\n    },\n};\n/* harmony default export */ const ErrorField = ((0,index_js_.connectField)(Error, { initialValue: false }));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/HiddenField.js\n\n\n\nfunction HiddenField(_a) {\n    var _b;\n    var value = _a.value, rawProps = (0,tslib_es6.__rest)(_a, ["value"]);\n    var props = (0,index_js_.useField)(rawProps.name, rawProps, { initialValue: false })[0];\n    (0,index_js_eager_.useEffect)(function () {\n        if (value !== undefined && value !== props.value)\n            props.onChange(value);\n    });\n    return props.noDOM ? null : (index_js_eager_default().createElement("input", (0,tslib_es6.__assign)({ disabled: props.disabled, id: props.id, name: props.name, ref: props.inputRef, type: "hidden", value: (_b = value !== null && value !== void 0 ? value : props.value) !== null && _b !== void 0 ? _b : \'\' }, (0,index_js_.filterDOMProps)(props))));\n}\n\n// EXTERNAL MODULE: ./node_modules/@patternfly/react-core/dist/esm/components/TextArea/TextArea.js + 1 modules\nvar TextArea = __webpack_require__(23393);\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/LongTextField.js\n\n\n\n\nvar LongText = function (_a) {\n    var disabled = _a.disabled, id = _a.id, inputRef = _a.inputRef, label = _a.label, name = _a.name, onChange = _a.onChange, placeholder = _a.placeholder, value = _a.value, props = (0,tslib_es6.__rest)(_a, ["disabled", "id", "inputRef", "label", "name", "onChange", "placeholder", "value"]);\n    return (index_js_eager_default().createElement("div", (0,tslib_es6.__assign)({}, (0,index_js_.filterDOMProps)(props)),\n        label && index_js_eager_default().createElement("label", { htmlFor: id }, label),\n        index_js_eager_default().createElement(TextArea/* TextArea */.Kx, { id: id, disabled: disabled, name: name, "aria-label": name, onChange: function (value, event) { return onChange(event.target.value); }, placeholder: placeholder, ref: inputRef, value: value !== null && value !== void 0 ? value : \'\' })));\n};\n/* harmony default export */ const LongTextField = ((0,index_js_.connectField)(LongText));\n\n;// CONCATENATED MODULE: ./node_modules/uniforms-patternfly/dist/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUNBO0FBQ0EsK0NBQWUsS0FBSyxrQkFBa0IsQ0FBQyxFQUFDOzs7QUNkQztBQUNmO0FBQzhCO0FBQ3hEO0FBQ0EsMEZBQTBGLG9CQUFNO0FBQ2hHLDRCQUE0QixzQ0FBbUIsUUFBUSxzQkFBUSxHQUFHLEVBQUUsNEJBQWMsbUNBQW1DLHNDQUFtQixVQUFVLFNBQVMsaUJBQWlCO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBZSwwQkFBWSxVQUFVLHFCQUFxQixDQUFDLEVBQUM7OztBQ2hCbkI7QUFDQTtBQUNXO0FBQ3JDO0FBQ2Y7QUFDQSxxQ0FBcUMsb0JBQU07QUFDM0MsZ0JBQWdCLHNCQUFRLDRCQUE0QixxQkFBcUI7QUFDekUsSUFBSSw2QkFBUztBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLHNDQUFtQixVQUFVLHNCQUFRLEdBQUcsMk1BQTJNLEVBQUUsNEJBQWM7QUFDcFM7Ozs7O0FDWnlDO0FBQ2Y7QUFDd0I7QUFDTTtBQUN4RDtBQUNBLHNMQUFzTCxvQkFBTTtBQUM1TCxZQUFZLHNDQUFtQixRQUFRLHNCQUFRLEdBQUcsRUFBRSw0QkFBYztBQUNsRSxpQkFBaUIsc0NBQW1CLFlBQVksYUFBYTtBQUM3RCxRQUFRLHNDQUFtQixDQUFDLHlCQUFRLElBQUksZ0dBQWdHLHNDQUFzQyxtR0FBbUc7QUFDalI7QUFDQSxvREFBZSwwQkFBWSxVQUFVLEVBQUM7OztBQ1ZlO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDTjtBQUNRO0FBQ0E7QUFDUjtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDSjtBQUNRO0FBQ1UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtY29yZS9kaXN0L2VzbS9jb21wb25lbnRzL1N3aXRjaC9Td2l0Y2guanM/ZjcwMSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS93cmFwRmllbGQuanM/NWQyYSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9Cb29sRmllbGQuanM/N2FhNiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvb3V0bGluZWQtY2FsZW5kYXItYWx0LWljb24uanM/ZWJhZiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvYXJyb3ctbGVmdC1pY29uLmpzPzI3ODEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LWljb25zL2Rpc3QvZXNtL2ljb25zL2Fycm93LXJpZ2h0LWljb24uanM/ZDgzNyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtY29yZS9kaXN0L2VzbS9jb21wb25lbnRzL0NhbGVuZGFyTW9udGgvQ2FsZW5kYXJNb250aC5qcz9jNjY3Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy9AcGF0dGVybmZseS9yZWFjdC1jb3JlL2Rpc3QvZXNtL2NvbXBvbmVudHMvRGF0ZVBpY2tlci9EYXRlUGlja2VyLmpzPzc0NTUiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUvZGlzdC9lc20vY29tcG9uZW50cy9UaW1lUGlja2VyL1RpbWVPcHRpb24uanM/MTI5MyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtY29yZS9kaXN0L2VzbS9jb21wb25lbnRzL1RpbWVQaWNrZXIvVGltZVBpY2tlclV0aWxzLmpzPzFmZGMiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUvZGlzdC9lc20vY29tcG9uZW50cy9UaW1lUGlja2VyL1RpbWVQaWNrZXIuanM/YTcxZiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9EYXRlRmllbGQuanM/MTJkOCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtY29yZS9kaXN0L2VzbS9sYXlvdXRzL1NwbGl0L1NwbGl0LmpzPzM5ODEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUvZGlzdC9lc20vbGF5b3V0cy9TcGxpdC9TcGxpdEl0ZW0uanM/ZGY3ZSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvb3V0bGluZWQtcXVlc3Rpb24tY2lyY2xlLWljb24uanM/NDczNiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvbWludXMtY2lyY2xlLWljb24uanM/ZjQzMyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9MaXN0RGVsRmllbGQuanM/Yzk1MyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9MaXN0SXRlbUZpZWxkLmpzPzExNzMiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL0BwYXR0ZXJuZmx5L3JlYWN0LWljb25zL2Rpc3QvZXNtL2ljb25zL3BsdXMtY2lyY2xlLWljb24uanM/ZGViYSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9MaXN0QWRkRmllbGQuanM/ODU4ZCIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9MaXN0RmllbGQuanM/ZTlkYiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9OZXN0RmllbGQuanM/NTM2YSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9OdW1GaWVsZC5qcz8xOGUzIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy1wYXR0ZXJuZmx5L2Rpc3QvZXNtL1JhZGlvRmllbGQuanM/MGU0NSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9TZWxlY3RGaWVsZC5qcz8xNWQ0Iiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy1wYXR0ZXJuZmx5L2Rpc3QvZXNtL1RleHRGaWVsZC5qcz9kZDkxIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy1wYXR0ZXJuZmx5L2Rpc3QvZXNtL0F1dG9GaWVsZC5qcz9iNTRjIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy1wYXR0ZXJuZmx5L2Rpc3QvZXNtL0F1dG9GaWVsZHMuanM/Y2ZhMyIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9CYXNlRm9ybS5qcz9hZjhlIiwid2VicGFjazovL2Nvcy11aS8uL25vZGVfbW9kdWxlcy91bmlmb3Jtcy1wYXR0ZXJuZmx5L2Rpc3QvZXNtL0Vycm9yc0ZpZWxkLmpzPzhkNTAiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zLXBhdHRlcm5mbHkvZGlzdC9lc20vU3VibWl0RmllbGQuanM/Yzk0MiIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9RdWlja0Zvcm0uanM/YWRhOSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9WYWxpZGF0ZWRGb3JtLmpzP2IxZDkiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zLXBhdHRlcm5mbHkvZGlzdC9lc20vVmFsaWRhdGVkUXVpY2tGb3JtLmpzPzNhNDkiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zLXBhdHRlcm5mbHkvZGlzdC9lc20vQXV0b0Zvcm0uanM/MTRiYSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9FcnJvckZpZWxkLmpzPzA2YTEiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zLXBhdHRlcm5mbHkvZGlzdC9lc20vSGlkZGVuRmllbGQuanM/ZmY4OSIsIndlYnBhY2s6Ly9jb3MtdWkvLi9ub2RlX21vZHVsZXMvdW5pZm9ybXMtcGF0dGVybmZseS9kaXN0L2VzbS9Mb25nVGV4dEZpZWxkLmpzP2QwNWIiLCJ3ZWJwYWNrOi8vY29zLXVpLy4vbm9kZV9tb2R1bGVzL3VuaWZvcm1zLXBhdHRlcm5mbHkvZGlzdC9lc20vaW5kZXguanM/NWM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzL2Nzcy9jb21wb25lbnRzL1N3aXRjaC9zd2l0Y2gnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzJztcbmltcG9ydCBDaGVja0ljb24gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvY2hlY2staWNvbic7XG5pbXBvcnQgeyBnZXRVbmlxdWVJZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbCc7XG5pbXBvcnQgeyBnZXRPVUlBUHJvcHMsIGdldERlZmF1bHRPVUlBSWQgfSBmcm9tICcuLi8uLi9oZWxwZXJzJztcbmV4cG9ydCBjbGFzcyBTd2l0Y2ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgaWYgKCFwcm9wcy5sYWJlbCAmJiAhcHJvcHNbJ2FyaWEtbGFiZWwnXSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N3aXRjaDogU3dpdGNoIHJlcXVpcmVzIGVpdGhlciBhIGxhYmVsIG9yIGFuIGFyaWEtbGFiZWwgdG8gYmUgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkIHx8IGdldFVuaXF1ZUlkKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBvdWlhU3RhdGVJZDogZ2V0RGVmYXVsdE9VSUFJZChTd2l0Y2guZGlzcGxheU5hbWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCB7IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGlkLCBjbGFzc05hbWUsIGxhYmVsLCBsYWJlbE9mZiwgaXNDaGVja2VkLCBpc0Rpc2FibGVkLCBvbkNoYW5nZSwgaXNSZXZlcnNlZCwgb3VpYUlkLCBvdWlhU2FmZSB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJpZFwiLCBcImNsYXNzTmFtZVwiLCBcImxhYmVsXCIsIFwibGFiZWxPZmZcIiwgXCJpc0NoZWNrZWRcIiwgXCJpc0Rpc2FibGVkXCIsIFwib25DaGFuZ2VcIiwgXCJpc1JldmVyc2VkXCIsIFwib3VpYUlkXCIsIFwib3VpYVNhZmVcIl0pO1xuICAgICAgICBjb25zdCBpc0FyaWFMYWJlbGxlZEJ5ID0gcHJvcHNbJ2FyaWEtbGFiZWwnXSA9PT0gJyc7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuc3dpdGNoLCBpc1JldmVyc2VkICYmIHN0eWxlcy5tb2RpZmllcnMucmV2ZXJzZSwgY2xhc3NOYW1lKSwgaHRtbEZvcjogdGhpcy5pZCB9LCBnZXRPVUlBUHJvcHMoU3dpdGNoLmRpc3BsYXlOYW1lLCBvdWlhSWQgIT09IHVuZGVmaW5lZCA/IG91aWFJZCA6IHRoaXMuc3RhdGUub3VpYVN0YXRlSWQsIG91aWFTYWZlKSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgT2JqZWN0LmFzc2lnbih7IGlkOiB0aGlzLmlkLCBjbGFzc05hbWU6IGNzcyhzdHlsZXMuc3dpdGNoSW5wdXQpLCB0eXBlOiBcImNoZWNrYm94XCIsIG9uQ2hhbmdlOiBldmVudCA9PiBvbkNoYW5nZShldmVudC50YXJnZXQuY2hlY2tlZCwgZXZlbnQpLCBjaGVja2VkOiBpc0NoZWNrZWQsIGRpc2FibGVkOiBpc0Rpc2FibGVkLCBcImFyaWEtbGFiZWxsZWRieVwiOiBpc0FyaWFMYWJlbGxlZEJ5ID8gYCR7dGhpcy5pZH0tb25gIDogbnVsbCB9LCBwcm9wcykpLFxuICAgICAgICAgICAgbGFiZWwgIT09IHVuZGVmaW5lZCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLnN3aXRjaFRvZ2dsZSkgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuc3dpdGNoTGFiZWwsIHN0eWxlcy5tb2RpZmllcnMub24pLCBpZDogaXNBcmlhTGFiZWxsZWRCeSA/IGAke3RoaXMuaWR9LW9uYCA6IG51bGwsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSwgbGFiZWwpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLnN3aXRjaExhYmVsLCBzdHlsZXMubW9kaWZpZXJzLm9mZiksIGlkOiBpc0FyaWFMYWJlbGxlZEJ5ID8gYCR7dGhpcy5pZH0tb2ZmYCA6IG51bGwsIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSwgbGFiZWxPZmYgIT09IHVuZGVmaW5lZCA/IGxhYmVsT2ZmIDogbGFiZWwpKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuc3dpdGNoVG9nZ2xlKSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuc3dpdGNoVG9nZ2xlSWNvbiksIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDaGVja0ljb24sIHsgbm9WZXJ0aWNhbEFsaWduOiB0cnVlIH0pKSkpKSk7XG4gICAgfVxufVxuU3dpdGNoLmRpc3BsYXlOYW1lID0gJ1N3aXRjaCc7XG5Td2l0Y2guZGVmYXVsdFByb3BzID0ge1xuICAgIGlzQ2hlY2tlZDogdHJ1ZSxcbiAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICBpc1JldmVyc2VkOiBmYWxzZSxcbiAgICAnYXJpYS1sYWJlbCc6ICcnLFxuICAgIG9uQ2hhbmdlOiAoKSA9PiB1bmRlZmluZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Td2l0Y2guanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG5maWx0ZXJET01Qcm9wcy5yZWdpc3RlcignZGVjaW1hbCcsICdtaW5Db3VudCcsICdhdXRvVmFsdWUnLCAnaXNEaXNhYmxlZCcsICdleGNsdXNpdmVNYXhpbXVtJywgJ2V4Y2x1c2l2ZU1pbmltdW0nKTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdyYXBGaWVsZChfYSwgY2hpbGRyZW4pIHtcbiAgICB2YXIgaWQgPSBfYS5pZCwgbGFiZWwgPSBfYS5sYWJlbCwgdHlwZSA9IF9hLnR5cGUsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIGVycm9yID0gX2EuZXJyb3IsIGVycm9yTWVzc2FnZSA9IF9hLmVycm9yTWVzc2FnZSwgc2hvd0lubGluZUVycm9yID0gX2Euc2hvd0lubGluZUVycm9yLCBoZWxwID0gX2EuaGVscCwgcmVxdWlyZWQgPSBfYS5yZXF1aXJlZCwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImlkXCIsIFwibGFiZWxcIiwgXCJ0eXBlXCIsIFwiZGlzYWJsZWRcIiwgXCJlcnJvclwiLCBcImVycm9yTWVzc2FnZVwiLCBcInNob3dJbmxpbmVFcnJvclwiLCBcImhlbHBcIiwgXCJyZXF1aXJlZFwiXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1Hcm91cCwgX19hc3NpZ24oeyBmaWVsZElkOiBpZCwgbGFiZWw6IGxhYmVsLCBpc1JlcXVpcmVkOiByZXF1aXJlZCwgdmFsaWRhdGVkOiBlcnJvciA/ICdlcnJvcicgOiAnZGVmYXVsdCcsIHR5cGU6IHR5cGUsIGhlbHBlclRleHQ6IGhlbHAsIGhlbHBlclRleHRJbnZhbGlkOiBlcnJvck1lc3NhZ2UgfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSwgY2hpbGRyZW4pKTtcbn1cbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGVja2JveCwgU3dpdGNoLCB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IHdyYXBGaWVsZCBmcm9tICcuL3dyYXBGaWVsZCc7XG52YXIgQ29tcG9uZW50VHlwZTtcbihmdW5jdGlvbiAoQ29tcG9uZW50VHlwZSkge1xuICAgIENvbXBvbmVudFR5cGVbXCJjaGVja2JveFwiXSA9IFwiY2hlY2tib3hcIjtcbiAgICBDb21wb25lbnRUeXBlW1wic3dpdGNoXCJdID0gXCJzd2l0Y2hcIjtcbn0pKENvbXBvbmVudFR5cGUgfHwgKENvbXBvbmVudFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gQm9vbChfYSkge1xuICAgIHZhciBhcHBlYXJhbmNlID0gX2EuYXBwZWFyYW5jZSwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgaWQgPSBfYS5pZCwgaW5wdXRSZWYgPSBfYS5pbnB1dFJlZiwgbGFiZWwgPSBfYS5sYWJlbCwgbmFtZSA9IF9hLm5hbWUsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIHZhbHVlID0gX2EudmFsdWUsIHByb3BzID0gX19yZXN0KF9hLCBbXCJhcHBlYXJhbmNlXCIsIFwiZGlzYWJsZWRcIiwgXCJpZFwiLCBcImlucHV0UmVmXCIsIFwibGFiZWxcIiwgXCJuYW1lXCIsIFwib25DaGFuZ2VcIiwgXCJ2YWx1ZVwiXSk7XG4gICAgdmFyIENvbXBvbmVudCA9IGFwcGVhcmFuY2UgPT09IENvbXBvbmVudFR5cGUuc3dpdGNoID8gU3dpdGNoIDogQ2hlY2tib3g7XG4gICAgcmV0dXJuIHdyYXBGaWVsZChfX2Fzc2lnbih7IGlkOiBpZCB9LCBwcm9wcyksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IGlzQ2hlY2tlZDogdmFsdWUgfHwgZmFsc2UsIGlzRGlzYWJsZWQ6IGRpc2FibGVkLCBpZDogaWQsIG5hbWU6IG5hbWUsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNhYmxlZCB8fCBvbkNoYW5nZSghdmFsdWUpOyB9LCByZWY6IGlucHV0UmVmLCBsYWJlbDogbGFiZWwgfSkpO1xufVxuQm9vbC5kZWZhdWx0UHJvcHMgPSB7IGFwcGVhcmFuY2U6IENvbXBvbmVudFR5cGUuY2hlY2tib3ggfTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChCb29sKTtcbiIsImltcG9ydCB7IGNyZWF0ZUljb24gfSBmcm9tICcuLi9jcmVhdGVJY29uJztcblxuZXhwb3J0IGNvbnN0IE91dGxpbmVkQ2FsZW5kYXJBbHRJY29uQ29uZmlnID0ge1xuICBuYW1lOiAnT3V0bGluZWRDYWxlbmRhckFsdEljb24nLFxuICBoZWlnaHQ6IDUxMixcbiAgd2lkdGg6IDQ0OCxcbiAgc3ZnUGF0aDogJ00xNDggMjg4aC00MGMtNi42IDAtMTItNS40LTEyLTEydi00MGMwLTYuNiA1LjQtMTIgMTItMTJoNDBjNi42IDAgMTIgNS40IDEyIDEydjQwYzAgNi42LTUuNCAxMi0xMiAxMnptMTA4LTEydi00MGMwLTYuNi01LjQtMTItMTItMTJoLTQwYy02LjYgMC0xMiA1LjQtMTIgMTJ2NDBjMCA2LjYgNS40IDEyIDEyIDEyaDQwYzYuNiAwIDEyLTUuNCAxMi0xMnptOTYgMHYtNDBjMC02LjYtNS40LTEyLTEyLTEyaC00MGMtNi42IDAtMTIgNS40LTEyIDEydjQwYzAgNi42IDUuNCAxMiAxMiAxMmg0MGM2LjYgMCAxMi01LjQgMTItMTJ6bS05NiA5NnYtNDBjMC02LjYtNS40LTEyLTEyLTEyaC00MGMtNi42IDAtMTIgNS40LTEyIDEydjQwYzAgNi42IDUuNCAxMiAxMiAxMmg0MGM2LjYgMCAxMi01LjQgMTItMTJ6bS05NiAwdi00MGMwLTYuNi01LjQtMTItMTItMTJoLTQwYy02LjYgMC0xMiA1LjQtMTIgMTJ2NDBjMCA2LjYgNS40IDEyIDEyIDEyaDQwYzYuNiAwIDEyLTUuNCAxMi0xMnptMTkyIDB2LTQwYzAtNi42LTUuNC0xMi0xMi0xMmgtNDBjLTYuNiAwLTEyIDUuNC0xMiAxMnY0MGMwIDYuNiA1LjQgMTIgMTIgMTJoNDBjNi42IDAgMTItNS40IDEyLTEyem05Ni0yNjB2MzUyYzAgMjYuNS0yMS41IDQ4LTQ4IDQ4SDQ4Yy0yNi41IDAtNDgtMjEuNS00OC00OFYxMTJjMC0yNi41IDIxLjUtNDggNDgtNDhoNDhWMTJjMC02LjYgNS40LTEyIDEyLTEyaDQwYzYuNiAwIDEyIDUuNCAxMiAxMnY1MmgxMjhWMTJjMC02LjYgNS40LTEyIDEyLTEyaDQwYzYuNiAwIDEyIDUuNCAxMiAxMnY1Mmg0OGMyNi41IDAgNDggMjEuNSA0OCA0OHptLTQ4IDM0NlYxNjBINDh2Mjk4YzAgMy4zIDIuNyA2IDYgNmgzNDBjMy4zIDAgNi0yLjcgNi02eicsXG4gIHlPZmZzZXQ6IDAsXG4gIHhPZmZzZXQ6IDAsXG59O1xuXG5leHBvcnQgY29uc3QgT3V0bGluZWRDYWxlbmRhckFsdEljb24gPSBjcmVhdGVJY29uKE91dGxpbmVkQ2FsZW5kYXJBbHRJY29uQ29uZmlnKTtcblxuZXhwb3J0IGRlZmF1bHQgT3V0bGluZWRDYWxlbmRhckFsdEljb247IiwiaW1wb3J0IHsgY3JlYXRlSWNvbiB9IGZyb20gJy4uL2NyZWF0ZUljb24nO1xuXG5leHBvcnQgY29uc3QgQXJyb3dMZWZ0SWNvbkNvbmZpZyA9IHtcbiAgbmFtZTogJ0Fycm93TGVmdEljb24nLFxuICBoZWlnaHQ6IDUxMixcbiAgd2lkdGg6IDQ0OCxcbiAgc3ZnUGF0aDogJ00yNTcuNSA0NDUuMWwtMjIuMiAyMi4yYy05LjQgOS40LTI0LjYgOS40LTMzLjkgMEw3IDI3M2MtOS40LTkuNC05LjQtMjQuNiAwLTMzLjlMMjAxLjQgNDQuN2M5LjQtOS40IDI0LjYtOS40IDMzLjkgMGwyMi4yIDIyLjJjOS41IDkuNSA5LjMgMjUtLjQgMzQuM0wxMzYuNiAyMTZINDI0YzEzLjMgMCAyNCAxMC43IDI0IDI0djMyYzAgMTMuMy0xMC43IDI0LTI0IDI0SDEzNi42bDEyMC41IDExNC44YzkuOCA5LjMgMTAgMjQuOC40IDM0LjN6JyxcbiAgeU9mZnNldDogMCxcbiAgeE9mZnNldDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBBcnJvd0xlZnRJY29uID0gY3JlYXRlSWNvbihBcnJvd0xlZnRJY29uQ29uZmlnKTtcblxuZXhwb3J0IGRlZmF1bHQgQXJyb3dMZWZ0SWNvbjsiLCJpbXBvcnQgeyBjcmVhdGVJY29uIH0gZnJvbSAnLi4vY3JlYXRlSWNvbic7XG5cbmV4cG9ydCBjb25zdCBBcnJvd1JpZ2h0SWNvbkNvbmZpZyA9IHtcbiAgbmFtZTogJ0Fycm93UmlnaHRJY29uJyxcbiAgaGVpZ2h0OiA1MTIsXG4gIHdpZHRoOiA0NDgsXG4gIHN2Z1BhdGg6ICdNMTkwLjUgNjYuOWwyMi4yLTIyLjJjOS40LTkuNCAyNC42LTkuNCAzMy45IDBMNDQxIDIzOWM5LjQgOS40IDkuNCAyNC42IDAgMzMuOUwyNDYuNiA0NjcuM2MtOS40IDkuNC0yNC42IDkuNC0zMy45IDBsLTIyLjItMjIuMmMtOS41LTkuNS05LjMtMjUgLjQtMzQuM0wzMTEuNCAyOTZIMjRjLTEzLjMgMC0yNC0xMC43LTI0LTI0di0zMmMwLTEzLjMgMTAuNy0yNCAyNC0yNGgyODcuNEwxOTAuOSAxMDEuMmMtOS44LTkuMy0xMC0yNC44LS40LTM0LjN6JyxcbiAgeU9mZnNldDogMCxcbiAgeE9mZnNldDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBBcnJvd1JpZ2h0SWNvbiA9IGNyZWF0ZUljb24oQXJyb3dSaWdodEljb25Db25maWcpO1xuXG5leHBvcnQgZGVmYXVsdCBBcnJvd1JpZ2h0SWNvbjsiLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0SW5wdXQgfSBmcm9tICcuLi9UZXh0SW5wdXQvVGV4dElucHV0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4uL0J1dHRvbi9CdXR0b24nO1xuaW1wb3J0IHsgU2VsZWN0LCBTZWxlY3RPcHRpb24gfSBmcm9tICcuLi9TZWxlY3QnO1xuaW1wb3J0IEFycm93TGVmdEljb24gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvYXJyb3ctbGVmdC1pY29uJztcbmltcG9ydCBBcnJvd1JpZ2h0SWNvbiBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1pY29ucy9kaXN0L2VzbS9pY29ucy9hcnJvdy1yaWdodC1pY29uJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcy9jc3MvY29tcG9uZW50cy9DYWxlbmRhck1vbnRoL2NhbGVuZGFyLW1vbnRoJztcbmltcG9ydCB7IGdldFVuaXF1ZUlkIH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlsJztcbmV4cG9ydCB2YXIgV2Vla2RheTtcbihmdW5jdGlvbiAoV2Vla2RheSkge1xuICAgIFdlZWtkYXlbV2Vla2RheVtcIlN1bmRheVwiXSA9IDBdID0gXCJTdW5kYXlcIjtcbiAgICBXZWVrZGF5W1dlZWtkYXlbXCJNb25kYXlcIl0gPSAxXSA9IFwiTW9uZGF5XCI7XG4gICAgV2Vla2RheVtXZWVrZGF5W1wiVHVlc2RheVwiXSA9IDJdID0gXCJUdWVzZGF5XCI7XG4gICAgV2Vla2RheVtXZWVrZGF5W1wiV2VkbmVzZGF5XCJdID0gM10gPSBcIldlZG5lc2RheVwiO1xuICAgIFdlZWtkYXlbV2Vla2RheVtcIlRodXJzZGF5XCJdID0gNF0gPSBcIlRodXJzZGF5XCI7XG4gICAgV2Vla2RheVtXZWVrZGF5W1wiRnJpZGF5XCJdID0gNV0gPSBcIkZyaWRheVwiO1xuICAgIFdlZWtkYXlbV2Vla2RheVtcIlNhdHVyZGF5XCJdID0gNl0gPSBcIlNhdHVyZGF5XCI7XG59KShXZWVrZGF5IHx8IChXZWVrZGF5ID0ge30pKTtcbi8vIE11c3QgYmUgbnVtZXJpYyBnaXZlbiBjdXJyZW50IGhlYWRlciBkZXNpZ25cbmNvbnN0IHllYXJGb3JtYXQgPSAoZGF0ZSkgPT4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuY29uc3QgYnVpbGRDYWxlbmRhciA9ICh5ZWFyLCBtb250aCwgd2Vla1N0YXJ0LCB2YWxpZGF0b3JzKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0ZWREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgpO1xuICAgIGNvbnN0IGZpcnN0RGF5T2ZXZWVrID0gbmV3IERhdGUoc2VsZWN0ZWREYXRlKTtcbiAgICBmaXJzdERheU9mV2Vlay5zZXREYXRlKGZpcnN0RGF5T2ZXZWVrLmdldERhdGUoKSAtIGZpcnN0RGF5T2ZXZWVrLmdldERheSgpICsgd2Vla1N0YXJ0KTtcbiAgICAvLyBXZSB3aWxsIGFsd2F5cyBzaG93IDYgd2Vla3MgbGlrZSBnb29nbGUgY2FsZW5kYXJcbiAgICAvLyBBc3N1bWUgd2UganVzdCB3YW50IHRoZSBudW1iZXJzIGZvciBub3cuLi5cbiAgICBjb25zdCBjYWxlbmRhcldlZWtzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgY29uc3Qgd2VlayA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgICAgIHdlZWsucHVzaCh7XG4gICAgICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiB2YWxpZGF0b3JzLmV2ZXJ5KHZhbGlkYXRvciA9PiB2YWxpZGF0b3IoZGF0ZSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrLnNldERhdGUoZmlyc3REYXlPZldlZWsuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsZW5kYXJXZWVrcy5wdXNoKHdlZWspO1xuICAgIH1cbiAgICByZXR1cm4gY2FsZW5kYXJXZWVrcztcbn07XG5jb25zdCBpc1NhbWVEYXRlID0gKGQxLCBkMikgPT4gZDEuZ2V0RnVsbFllYXIoKSA9PT0gZDIuZ2V0RnVsbFllYXIoKSAmJiBkMS5nZXRNb250aCgpID09PSBkMi5nZXRNb250aCgpICYmIGQxLmdldERhdGUoKSA9PT0gZDIuZ2V0RGF0ZSgpO1xuZXhwb3J0IGNvbnN0IGlzVmFsaWREYXRlID0gKGRhdGUpID0+IEJvb2xlYW4oZGF0ZSAmJiAhaXNOYU4oZGF0ZSkpO1xuY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuZXhwb3J0IGNvbnN0IENhbGVuZGFyTW9udGggPSAoX2EpID0+IHtcbiAgICB2YXIgeyBkYXRlOiBkYXRlUHJvcCA9IHRvZGF5LCBsb2NhbGUgPSB1bmRlZmluZWQsIG1vbnRoRm9ybWF0ID0gZGF0ZSA9PiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhsb2NhbGUsIHsgbW9udGg6ICdsb25nJyB9KSwgd2Vla2RheUZvcm1hdCA9IGRhdGUgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcobG9jYWxlLCB7IHdlZWtkYXk6ICduYXJyb3cnIH0pLCBsb25nV2Vla2RheUZvcm1hdCA9IGRhdGUgPT4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcobG9jYWxlLCB7IHdlZWtkYXk6ICdsb25nJyB9KSwgZGF5Rm9ybWF0ID0gZGF0ZSA9PiBkYXRlLmdldERhdGUoKSwgd2Vla1N0YXJ0ID0gMCwgLy8gVXNlIHRoZSBBbWVyaWNhbiBTdW5kYXkgYXMgYSBkZWZhdWx0XG4gICAgb25DaGFuZ2UgPSAoKSA9PiB7IH0sIHZhbGlkYXRvcnMgPSBbKCkgPT4gdHJ1ZV0sIGNsYXNzTmFtZSwgb25TZWxlY3RUb2dnbGUgPSAoKSA9PiB7IH0sIHJhbmdlU3RhcnQsIHByZXZNb250aEFyaWFMYWJlbCA9ICdQcmV2aW91cyBtb250aCcsIG5leHRNb250aEFyaWFMYWJlbCA9ICdOZXh0IG1vbnRoJywgeWVhcklucHV0QXJpYUxhYmVsID0gJ1NlbGVjdCB5ZWFyJywgY2VsbEFyaWFMYWJlbCB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJkYXRlXCIsIFwibG9jYWxlXCIsIFwibW9udGhGb3JtYXRcIiwgXCJ3ZWVrZGF5Rm9ybWF0XCIsIFwibG9uZ1dlZWtkYXlGb3JtYXRcIiwgXCJkYXlGb3JtYXRcIiwgXCJ3ZWVrU3RhcnRcIiwgXCJvbkNoYW5nZVwiLCBcInZhbGlkYXRvcnNcIiwgXCJjbGFzc05hbWVcIiwgXCJvblNlbGVjdFRvZ2dsZVwiLCBcInJhbmdlU3RhcnRcIiwgXCJwcmV2TW9udGhBcmlhTGFiZWxcIiwgXCJuZXh0TW9udGhBcmlhTGFiZWxcIiwgXCJ5ZWFySW5wdXRBcmlhTGFiZWxcIiwgXCJjZWxsQXJpYUxhYmVsXCJdKTtcbiAgICBjb25zdCBsb25nTW9udGhzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV0ubWFwKG1vbnRoTnVtID0+IG5ldyBEYXRlKDE5OTAsIG1vbnRoTnVtKSkubWFwKG1vbnRoRm9ybWF0KTtcbiAgICBjb25zdCBbaXNTZWxlY3RPcGVuLCBzZXRJc1NlbGVjdE9wZW5dID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgW2ZvY3VzZWREYXRlLCBzZXRGb2N1c2VkRGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShuZXcgRGF0ZShkYXRlUHJvcCkpO1xuICAgIGlmICghaXNWYWxpZERhdGUoZm9jdXNlZERhdGUpKSB7XG4gICAgICAgIGZvY3VzZWREYXRlID0gdG9kYXk7XG4gICAgfVxuICAgIGNvbnN0IFtob3ZlcmVkRGF0ZSwgc2V0SG92ZXJlZERhdGVdID0gUmVhY3QudXNlU3RhdGUobmV3IERhdGUoZm9jdXNlZERhdGUpKTtcbiAgICBjb25zdCBmb2N1c1JlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IFtoaWRkZW5Nb250aElkXSA9IFJlYWN0LnVzZVN0YXRlKGdldFVuaXF1ZUlkKCdoaWRkZW4tbW9udGgtc3BhbicpKTtcbiAgICBjb25zdCBbc2hvdWxkRm9jdXMsIHNldFNob3VsZEZvY3VzXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IGlzVmFsaWRhdGVkID0gKGRhdGUpID0+IHZhbGlkYXRvcnMuZXZlcnkodmFsaWRhdG9yID0+IHZhbGlkYXRvcihkYXRlKSk7XG4gICAgY29uc3QgZm9jdXNlZERhdGVWYWxpZGF0ZWQgPSBpc1ZhbGlkYXRlZChmb2N1c2VkRGF0ZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCEoaXNWYWxpZERhdGUoZGF0ZVByb3ApICYmIGlzU2FtZURhdGUoZm9jdXNlZERhdGUsIGRhdGVQcm9wKSkpIHtcbiAgICAgICAgICAgIHNldEZvY3VzZWREYXRlKGRhdGVQcm9wKTtcbiAgICAgICAgfVxuICAgIH0sIFtkYXRlUHJvcF0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgaGVhZGVyIGNvbnRyb2xzIGRvbid0IG1vdmUgZm9jdXNcbiAgICAgICAgaWYgKHNob3VsZEZvY3VzKSB7XG4gICAgICAgICAgICBpZiAoZm9jdXNSZWYuY3VycmVudCAmJiBmb2N1c2VkRGF0ZVZhbGlkYXRlZCkge1xuICAgICAgICAgICAgICAgIGZvY3VzUmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFNob3VsZEZvY3VzKHRydWUpO1xuICAgICAgICB9XG4gICAgfSwgW2ZvY3VzZWREYXRlXSk7XG4gICAgY29uc3Qgb25Nb250aENsaWNrID0gKG5ld0RhdGUpID0+IHtcbiAgICAgICAgc2V0Rm9jdXNlZERhdGUobmV3RGF0ZSk7XG4gICAgICAgIHNldEhvdmVyZWREYXRlKG5ld0RhdGUpO1xuICAgICAgICBzZXRTaG91bGRGb2N1cyhmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKGZvY3VzZWREYXRlKTtcbiAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICBuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkgLSA3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldi5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgbmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYua2V5ID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgbmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpICsgNyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYua2V5ID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICAgICAgbmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0RhdGUuZ2V0VGltZSgpICE9PSBmb2N1c2VkRGF0ZS5nZXRUaW1lKCkgJiYgaXNWYWxpZGF0ZWQobmV3RGF0ZSkpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZXRGb2N1c2VkRGF0ZShuZXdEYXRlKTtcbiAgICAgICAgICAgIHNldEhvdmVyZWREYXRlKG5ld0RhdGUpO1xuICAgICAgICAgICAgc2V0U2hvdWxkRm9jdXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGFkZE1vbnRoID0gKHRvQWRkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShmb2N1c2VkRGF0ZSk7XG4gICAgICAgIG5ld0RhdGUuc2V0TW9udGgobmV3RGF0ZS5nZXRNb250aCgpICsgdG9BZGQpO1xuICAgICAgICByZXR1cm4gbmV3RGF0ZTtcbiAgICB9O1xuICAgIGNvbnN0IHByZXZNb250aCA9IGFkZE1vbnRoKC0xKTtcbiAgICBjb25zdCBuZXh0TW9udGggPSBhZGRNb250aCgxKTtcbiAgICBjb25zdCBmb2N1c2VkWWVhciA9IGZvY3VzZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgZm9jdXNlZE1vbnRoID0gZm9jdXNlZERhdGUuZ2V0TW9udGgoKTtcbiAgICBjb25zdCBjYWxlbmRhciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gYnVpbGRDYWxlbmRhcihmb2N1c2VkWWVhciwgZm9jdXNlZE1vbnRoLCB3ZWVrU3RhcnQsIHZhbGlkYXRvcnMpLCBbXG4gICAgICAgIGZvY3VzZWRZZWFyLFxuICAgICAgICBmb2N1c2VkTW9udGgsXG4gICAgICAgIHdlZWtTdGFydCxcbiAgICAgICAgdmFsaWRhdG9yc1xuICAgIF0pO1xuICAgIGlmICghZm9jdXNlZERhdGVWYWxpZGF0ZWQpIHtcbiAgICAgICAgY29uc3QgdG9Gb2N1cyA9IGNhbGVuZGFyXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgLi4uY3VyXSwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKCh7IGRhdGUsIGlzVmFsaWQgfSkgPT4gaXNWYWxpZCAmJiBkYXRlLmdldE1vbnRoKCkgPT09IGZvY3VzZWRNb250aClcbiAgICAgICAgICAgIC5tYXAoKHsgZGF0ZSB9KSA9PiAoeyBkYXRlLCBkYXlzOiBNYXRoLmFicyhmb2N1c2VkRGF0ZS5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWUoKSkgfSkpXG4gICAgICAgICAgICAuc29ydCgobzEsIG8yKSA9PiBvMS5kYXlzIC0gbzIuZGF5cylcbiAgICAgICAgICAgIC5tYXAoKHsgZGF0ZSB9KSA9PiBkYXRlKVswXTtcbiAgICAgICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgICAgICAgIHNldEZvY3VzZWREYXRlKHRvRm9jdXMpO1xuICAgICAgICAgICAgc2V0SG92ZXJlZERhdGUodG9Gb2N1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNIb3ZlcmVkRGF0ZVZhbGlkID0gaXNWYWxpZGF0ZWQoaG92ZXJlZERhdGUpO1xuICAgIGNvbnN0IG1vbnRoRm9ybWF0dGVkID0gbW9udGhGb3JtYXQoZm9jdXNlZERhdGUpO1xuICAgIGNvbnN0IHllYXJGb3JtYXR0ZWQgPSB5ZWFyRm9ybWF0KGZvY3VzZWREYXRlKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY3NzKHN0eWxlcy5jYWxlbmRhck1vbnRoLCBjbGFzc05hbWUpIH0sIHByb3BzKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogc3R5bGVzLmNhbGVuZGFyTW9udGhIZWFkZXIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuY2FsZW5kYXJNb250aEhlYWRlck5hdkNvbnRyb2wsIHN0eWxlcy5tb2RpZmllcnMucHJldk1vbnRoKSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7IHZhcmlhbnQ6IFwicGxhaW5cIiwgXCJhcmlhLWxhYmVsXCI6IHByZXZNb250aEFyaWFMYWJlbCwgb25DbGljazogKCkgPT4gb25Nb250aENsaWNrKHByZXZNb250aCkgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBcnJvd0xlZnRJY29uLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSB9KSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogc3R5bGVzLmNhbGVuZGFyTW9udGhIZWFkZXJNb250aCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgaWQ6IGhpZGRlbk1vbnRoSWQsIGhpZGRlbjogdHJ1ZSB9LCBcIk1vbnRoXCIpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0XG4gICAgICAgICAgICAgICAgLy8gTWF4IHdpZHRoIHdpdGggXCJTZXB0ZW1iZXJcIlxuICAgICAgICAgICAgICAgICwgeyBcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF4IHdpZHRoIHdpdGggXCJTZXB0ZW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIxNDBweFwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBoaWRkZW5Nb250aElkLCBpc09wZW46IGlzU2VsZWN0T3Blbiwgb25Ub2dnbGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU2VsZWN0T3BlbighaXNTZWxlY3RPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0VG9nZ2xlKCFpc1NlbGVjdE9wZW4pO1xuICAgICAgICAgICAgICAgICAgICB9LCBvblNlbGVjdDogKF9ldiwgbW9udGhOdW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgcHV0IENhbGVuZGFyTW9udGggaW4gYSBQb3BvdmVyIHdlIHdhbnQgdGhlIFBvcG92ZXIncyBvbkRvY3VtZW50Q2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNlZSB0aGUgU2VsZWN0T3B0aW9uIGFzIGEgY2hpbGQgc28gaXQgZG9lc24ndCBjbG9zZSB0aGUgUG9wb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU2VsZWN0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3RUb2dnbGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShmb2N1c2VkRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRNb250aChOdW1iZXIobW9udGhOdW0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c2VkRGF0ZShuZXdEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlcmVkRGF0ZShuZXdEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTaG91bGRGb2N1cyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdmFyaWFudDogXCJzaW5nbGVcIiwgc2VsZWN0aW9uczogbW9udGhGb3JtYXR0ZWQgfSwgbG9uZ01vbnRocy5tYXAoKGxvbmdNb250aCwgaW5kZXgpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdE9wdGlvbiwgeyBrZXk6IGluZGV4LCB2YWx1ZTogaW5kZXgsIGlzU2VsZWN0ZWQ6IGxvbmdNb250aCA9PT0gbW9udGhGb3JtYXR0ZWQgfSwgbG9uZ01vbnRoKSkpKSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBzdHlsZXMuY2FsZW5kYXJNb250aEhlYWRlclllYXIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRJbnB1dCwgeyBcImFyaWEtbGFiZWxcIjogeWVhcklucHV0QXJpYUxhYmVsLCB0eXBlOiBcIm51bWJlclwiLCB2YWx1ZTogeWVhckZvcm1hdHRlZCwgb25DaGFuZ2U6IHllYXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKGZvY3VzZWREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0RnVsbFllYXIoK3llYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Rm9jdXNlZERhdGUobmV3RGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlcmVkRGF0ZShuZXdEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNob3VsZEZvY3VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSB9KSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLmNhbGVuZGFyTW9udGhIZWFkZXJOYXZDb250cm9sLCBzdHlsZXMubW9kaWZpZXJzLm5leHRNb250aCkgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyB2YXJpYW50OiBcInBsYWluXCIsIFwiYXJpYS1sYWJlbFwiOiBuZXh0TW9udGhBcmlhTGFiZWwsIG9uQ2xpY2s6ICgpID0+IG9uTW9udGhDbGljayhuZXh0TW9udGgpIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXJyb3dSaWdodEljb24sIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlIH0pKSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBjbGFzc05hbWU6IHN0eWxlcy5jYWxlbmRhck1vbnRoQ2FsZW5kYXIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiLCB7IGNsYXNzTmFtZTogc3R5bGVzLmNhbGVuZGFyTW9udGhEYXlzIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsIGNhbGVuZGFyWzBdLm1hcCgoeyBkYXRlIH0sIGluZGV4KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRoXCIsIHsga2V5OiBpbmRleCwgY2xhc3NOYW1lOiBzdHlsZXMuY2FsZW5kYXJNb250aERheSwgc2NvcGU6IFwiY29sXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicGYtc2NyZWVuLXJlYWRlclwiIH0sIGxvbmdXZWVrZGF5Rm9ybWF0KGRhdGUpKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUgfSwgd2Vla2RheUZvcm1hdChkYXRlKSkpKSkpKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IG9uS2V5RG93bjogb25LZXlEb3duIH0sIGNhbGVuZGFyLm1hcCgod2VlaywgaW5kZXgpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IGluZGV4LCBjbGFzc05hbWU6IHN0eWxlcy5jYWxlbmRhck1vbnRoRGF0ZXNSb3cgfSwgd2Vlay5tYXAoKHsgZGF0ZSwgaXNWYWxpZCB9LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRheUZvcm1hdHRlZCA9IGRheUZvcm1hdChkYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1RvZGF5ID0gaXNTYW1lRGF0ZShkYXRlLCB0b2RheSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGlzVmFsaWREYXRlKGRhdGVQcm9wKSAmJiBpc1NhbWVEYXRlKGRhdGUsIGRhdGVQcm9wKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvY3VzZWQgPSBpc1NhbWVEYXRlKGRhdGUsIGZvY3VzZWREYXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FkamFjZW50TW9udGggPSBkYXRlLmdldE1vbnRoKCkgIT09IGZvY3VzZWREYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgbGV0IGlzSW5SYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBpc1JhbmdlU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgaXNSYW5nZUVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRGF0ZShyYW5nZVN0YXJ0KSAmJiBpc0hvdmVyZWREYXRlVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdmVyZWREYXRlID4gcmFuZ2VTdGFydCB8fCBpc1NhbWVEYXRlKGhvdmVyZWREYXRlLCByYW5nZVN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJblJhbmdlID0gZGF0ZSA+IHJhbmdlU3RhcnQgJiYgZGF0ZSA8IGhvdmVyZWREYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSYW5nZVN0YXJ0ID0gaXNTYW1lRGF0ZShkYXRlLCByYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmFuZ2VFbmQgPSBpc1NhbWVEYXRlKGRhdGUsIGhvdmVyZWREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBoYW5kbGUgZm9jdXNlZCBkYXRlcyBiZWZvcmUgc3RhcnQgZGF0ZXMgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29yZSB3b3VsZCBsaWtlbHkgbmVlZCBuZXcgc3R5bGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsga2V5OiBpbmRleCwgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLmNhbGVuZGFyTW9udGhEYXRlc0NlbGwsIGlzQWRqYWNlbnRNb250aCAmJiBzdHlsZXMubW9kaWZpZXJzLmFkamFjZW50TW9udGgsIGlzVG9kYXkgJiYgc3R5bGVzLm1vZGlmaWVycy5jdXJyZW50LCAoaXNTZWxlY3RlZCB8fCBpc1JhbmdlU3RhcnQpICYmIHN0eWxlcy5tb2RpZmllcnMuc2VsZWN0ZWQsICFpc1ZhbGlkICYmIHN0eWxlcy5tb2RpZmllcnMuZGlzYWJsZWQsIChpc0luUmFuZ2UgfHwgaXNSYW5nZVN0YXJ0IHx8IGlzUmFuZ2VFbmQpICYmIHN0eWxlcy5tb2RpZmllcnMuaW5SYW5nZSwgaXNSYW5nZVN0YXJ0ICYmIHN0eWxlcy5tb2RpZmllcnMuc3RhcnRSYW5nZSwgaXNSYW5nZUVuZCAmJiBzdHlsZXMubW9kaWZpZXJzLmVuZFJhbmdlKSB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuY2FsZW5kYXJNb250aERhdGUsIGlzUmFuZ2VFbmQgJiYgc3R5bGVzLm1vZGlmaWVycy5ob3ZlciwgIWlzVmFsaWQgJiYgc3R5bGVzLm1vZGlmaWVycy5kaXNhYmxlZCksIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IG9uQ2hhbmdlKGRhdGUpLCBvbk1vdXNlT3ZlcjogKCkgPT4gc2V0SG92ZXJlZERhdGUoZGF0ZSksIHRhYkluZGV4OiBpc0ZvY3VzZWQgPyAwIDogLTEsIGRpc2FibGVkOiAhaXNWYWxpZCwgXCJhcmlhLWxhYmVsXCI6IGNlbGxBcmlhTGFiZWwgPyBjZWxsQXJpYUxhYmVsKGRhdGUpIDogYCR7ZGF5Rm9ybWF0dGVkfSAke21vbnRoRm9ybWF0dGVkfSAke3llYXJGb3JtYXR0ZWR9YCB9LCAoaXNGb2N1c2VkICYmIHsgcmVmOiBmb2N1c1JlZiB9KSksIGRheUZvcm1hdHRlZCkpKTtcbiAgICAgICAgICAgIH0pKSkpKSkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWxlbmRhck1vbnRoLmpzLm1hcCIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzL2Nzcy9jb21wb25lbnRzL0RhdGVQaWNrZXIvZGF0ZS1waWNrZXInO1xuaW1wb3J0IGJ1dHRvblN0eWxlcyBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1zdHlsZXMvY3NzL2NvbXBvbmVudHMvQnV0dG9uL2J1dHRvbic7XG5pbXBvcnQgeyBUZXh0SW5wdXQgfSBmcm9tICcuLi9UZXh0SW5wdXQvVGV4dElucHV0JztcbmltcG9ydCB7IFBvcG92ZXIgfSBmcm9tICcuLi9Qb3BvdmVyL1BvcG92ZXInO1xuaW1wb3J0IHsgSW5wdXRHcm91cCB9IGZyb20gJy4uL0lucHV0R3JvdXAvSW5wdXRHcm91cCc7XG5pbXBvcnQgT3V0bGluZWRDYWxlbmRhckFsdEljb24gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMvZGlzdC9lc20vaWNvbnMvb3V0bGluZWQtY2FsZW5kYXItYWx0LWljb24nO1xuaW1wb3J0IHsgQ2FsZW5kYXJNb250aCwgaXNWYWxpZERhdGUgfSBmcm9tICcuLi9DYWxlbmRhck1vbnRoJztcbmV4cG9ydCBjb25zdCB5eXl5TU1kZEZvcm1hdCA9IChkYXRlKSA9PiBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LSR7KGRhdGUuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0tJHtkYXRlXG4gICAgLmdldERhdGUoKVxuICAgIC50b1N0cmluZygpXG4gICAgLnBhZFN0YXJ0KDIsICcwJyl9YDtcbmV4cG9ydCBjb25zdCBEYXRlUGlja2VyID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgY2xhc3NOYW1lLCBsb2NhbGUgPSB1bmRlZmluZWQsIGRhdGVGb3JtYXQgPSB5eXl5TU1kZEZvcm1hdCwgZGF0ZVBhcnNlID0gKHZhbCkgPT4gdmFsLnNwbGl0KCctJykubGVuZ3RoID09PSAzICYmIG5ldyBEYXRlKGAke3ZhbH1UMDA6MDA6MDBgKSwgaXNEaXNhYmxlZCA9IGZhbHNlLCBwbGFjZWhvbGRlciA9ICdZWVlZLU1NLUREJywgdmFsdWU6IHZhbHVlUHJvcCA9ICcnLCAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCA9ICdEYXRlIHBpY2tlcicsIGJ1dHRvbkFyaWFMYWJlbCA9ICdUb2dnbGUgZGF0ZSBwaWNrZXInLCBvbkNoYW5nZSA9ICgpID0+IHVuZGVmaW5lZCwgaW52YWxpZEZvcm1hdFRleHQgPSAnSW52YWxpZCBkYXRlJywgaGVscGVyVGV4dCwgYXBwZW5kVG8sIHBvcG92ZXJQcm9wcywgbW9udGhGb3JtYXQsIHdlZWtkYXlGb3JtYXQsIGxvbmdXZWVrZGF5Rm9ybWF0LCBkYXlGb3JtYXQsIHdlZWtTdGFydCwgdmFsaWRhdG9ycyA9IFtdLCByYW5nZVN0YXJ0LCBzdHlsZTogc3R5bGVQcm9wcyA9IHt9LCBpbnB1dFByb3BzID0ge30gfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2xhc3NOYW1lXCIsIFwibG9jYWxlXCIsIFwiZGF0ZUZvcm1hdFwiLCBcImRhdGVQYXJzZVwiLCBcImlzRGlzYWJsZWRcIiwgXCJwbGFjZWhvbGRlclwiLCBcInZhbHVlXCIsICdhcmlhLWxhYmVsJywgXCJidXR0b25BcmlhTGFiZWxcIiwgXCJvbkNoYW5nZVwiLCBcImludmFsaWRGb3JtYXRUZXh0XCIsIFwiaGVscGVyVGV4dFwiLCBcImFwcGVuZFRvXCIsIFwicG9wb3ZlclByb3BzXCIsIFwibW9udGhGb3JtYXRcIiwgXCJ3ZWVrZGF5Rm9ybWF0XCIsIFwibG9uZ1dlZWtkYXlGb3JtYXRcIiwgXCJkYXlGb3JtYXRcIiwgXCJ3ZWVrU3RhcnRcIiwgXCJ2YWxpZGF0b3JzXCIsIFwicmFuZ2VTdGFydFwiLCBcInN0eWxlXCIsIFwiaW5wdXRQcm9wc1wiXSk7XG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSh2YWx1ZVByb3ApO1xuICAgIGNvbnN0IFt2YWx1ZURhdGUsIHNldFZhbHVlRGF0ZV0gPSBSZWFjdC51c2VTdGF0ZShkYXRlUGFyc2UodmFsdWUpKTtcbiAgICBjb25zdCBbZXJyb3JUZXh0LCBzZXRFcnJvclRleHRdID0gUmVhY3QudXNlU3RhdGUoJycpO1xuICAgIGNvbnN0IFtwb3BvdmVyT3Blbiwgc2V0UG9wb3Zlck9wZW5dID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWxlY3RPcGVuLCBzZXRTZWxlY3RPcGVuXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcHJpc3RpbmUsIHNldFByaXN0aW5lXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IHdpZHRoQ2hhcnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IE1hdGgubWF4KGRhdGVGb3JtYXQobmV3IERhdGUoKSkubGVuZ3RoLCBwbGFjZWhvbGRlci5sZW5ndGgpLCBbZGF0ZUZvcm1hdF0pO1xuICAgIGNvbnN0IHN0eWxlID0gT2JqZWN0LmFzc2lnbih7ICctLXBmLWMtZGF0ZS1waWNrZXJfX2lucHV0LS1jLWZvcm0tY29udHJvbC0td2lkdGgtY2hhcnMnOiB3aWR0aENoYXJzIH0sIHN0eWxlUHJvcHMpO1xuICAgIGNvbnN0IGJ1dHRvblJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldFZhbHVlKHZhbHVlUHJvcCk7XG4gICAgICAgIHNldFZhbHVlRGF0ZShkYXRlUGFyc2UodmFsdWVQcm9wKSk7XG4gICAgfSwgW3ZhbHVlUHJvcF0pO1xuICAgIGNvbnN0IHNldEVycm9yID0gKGRhdGUpID0+IHNldEVycm9yVGV4dCh2YWxpZGF0b3JzLm1hcCh2YWxpZGF0b3IgPT4gdmFsaWRhdG9yKGRhdGUpKS5qb2luKCdcXG4nKSB8fCAnJyk7XG4gICAgY29uc3Qgb25UZXh0SW5wdXQgPSAodmFsdWUpID0+IHtcbiAgICAgICAgc2V0UHJpc3RpbmUoZmFsc2UpO1xuICAgICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHNldEVycm9yVGV4dCgnJyk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlRGF0ZSA9IGRhdGVQYXJzZSh2YWx1ZSk7XG4gICAgICAgIHNldFZhbHVlRGF0ZShuZXdWYWx1ZURhdGUpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUobmV3VmFsdWVEYXRlKSkge1xuICAgICAgICAgICAgb25DaGFuZ2UodmFsdWUsIG5ldyBEYXRlKG5ld1ZhbHVlRGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbklucHV0Qmx1ciA9ICgpID0+IHtcbiAgICAgICAgaWYgKHByaXN0aW5lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VmFsdWVEYXRlID0gZGF0ZVBhcnNlKHZhbHVlKTtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlKG5ld1ZhbHVlRGF0ZSkpIHtcbiAgICAgICAgICAgIHNldEVycm9yKG5ld1ZhbHVlRGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRFcnJvclRleHQoaW52YWxpZEZvcm1hdFRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkRhdGVDbGljayA9IChuZXdWYWx1ZURhdGUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBkYXRlRm9ybWF0KG5ld1ZhbHVlRGF0ZSk7XG4gICAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgc2V0VmFsdWVEYXRlKG5ld1ZhbHVlRGF0ZSk7XG4gICAgICAgIHNldEVycm9yKG5ld1ZhbHVlRGF0ZSk7XG4gICAgICAgIHNldFBvcG92ZXJPcGVuKGZhbHNlKTtcbiAgICAgICAgb25DaGFuZ2UobmV3VmFsdWUsIG5ldyBEYXRlKG5ld1ZhbHVlRGF0ZSkpO1xuICAgIH07XG4gICAgY29uc3Qgb25LZXlQcmVzcyA9IChldikgPT4ge1xuICAgICAgICBpZiAoZXYua2V5ID09PSAnRW50ZXInICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZERhdGUodmFsdWVEYXRlKSkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHZhbHVlRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvclRleHQoaW52YWxpZEZvcm1hdFRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY3NzKHN0eWxlcy5kYXRlUGlja2VyLCBjbGFzc05hbWUpLCBzdHlsZTogc3R5bGUgfSwgcHJvcHMpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFBvcG92ZXIsIE9iamVjdC5hc3NpZ24oeyBwb3NpdGlvbjogXCJib3R0b21cIiwgYm9keUNvbnRlbnQ6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJNb250aCwgeyBkYXRlOiB2YWx1ZURhdGUsIG9uQ2hhbmdlOiBvbkRhdGVDbGljaywgbG9jYWxlOiBsb2NhbGUsIFxuICAgICAgICAgICAgICAgIC8vIFVzZSB0cnV0aHkgdmFsdWVzIG9mIHN0cmluZ3NcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzLm1hcCh2YWxpZGF0b3IgPT4gKGRhdGUpID0+ICF2YWxpZGF0b3IoZGF0ZSkpLCBvblNlbGVjdFRvZ2dsZTogb3BlbiA9PiBzZXRTZWxlY3RPcGVuKG9wZW4pLCBtb250aEZvcm1hdDogbW9udGhGb3JtYXQsIHdlZWtkYXlGb3JtYXQ6IHdlZWtkYXlGb3JtYXQsIGxvbmdXZWVrZGF5Rm9ybWF0OiBsb25nV2Vla2RheUZvcm1hdCwgZGF5Rm9ybWF0OiBkYXlGb3JtYXQsIHdlZWtTdGFydDogd2Vla1N0YXJ0LCByYW5nZVN0YXJ0OiByYW5nZVN0YXJ0IH0pLCBzaG93Q2xvc2U6IGZhbHNlLCBpc1Zpc2libGU6IHBvcG92ZXJPcGVuLCBzaG91bGRDbG9zZTogKF8xLCBfMiwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIC8vIExldCB0aGUgc2VsZWN0IG1lbnUgY2xvc2VcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAmJiBldmVudC5rZXlDb2RlID09PSAyNyAmJiBzZWxlY3RPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGV0IG91ciBidXR0b24gaGFuZGxlIHRvZ2dsaW5nXG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvblJlZi5jdXJyZW50ICYmIGJ1dHRvblJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQb3BvdmVyT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCB3aXRoRm9jdXNUcmFwOiB0cnVlLCBoYXNOb1BhZGRpbmc6IHRydWUsIGhhc0F1dG9XaWR0aDogdHJ1ZSwgYXBwZW5kVG86IGFwcGVuZFRvIH0sIHBvcG92ZXJQcm9wcyksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBzdHlsZXMuZGF0ZVBpY2tlcklucHV0IH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJbnB1dEdyb3VwLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRJbnB1dCwgT2JqZWN0LmFzc2lnbih7IGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgdmFsaWRhdGVkOiBlcnJvclRleHQgPyAnZXJyb3InIDogJ2RlZmF1bHQnLCB2YWx1ZTogdmFsdWUsIG9uQ2hhbmdlOiBvblRleHRJbnB1dCwgb25CbHVyOiBvbklucHV0Qmx1ciwgb25LZXlQcmVzczogb25LZXlQcmVzcyB9LCBpbnB1dFByb3BzKSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvblJlZiwgY2xhc3NOYW1lOiBjc3MoYnV0dG9uU3R5bGVzLmJ1dHRvbiwgYnV0dG9uU3R5bGVzLm1vZGlmaWVycy5jb250cm9sKSwgXCJhcmlhLWxhYmVsXCI6IGJ1dHRvbkFyaWFMYWJlbCwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogKCkgPT4gc2V0UG9wb3Zlck9wZW4oIXBvcG92ZXJPcGVuKSwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZWRDYWxlbmRhckFsdEljb24sIG51bGwpKSkpKSxcbiAgICAgICAgaGVscGVyVGV4dCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBzdHlsZXMuZGF0ZVBpY2tlckhlbHBlclRleHQgfSwgaGVscGVyVGV4dCksXG4gICAgICAgIGVycm9yVGV4dC50cmltKCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY3NzKHN0eWxlcy5kYXRlUGlja2VySGVscGVyVGV4dCwgc3R5bGVzLm1vZGlmaWVycy5lcnJvcikgfSwgZXJyb3JUZXh0KSkpO1xufTtcbkRhdGVQaWNrZXIuZGlzcGxheU5hbWUgPSAnRGF0ZVBpY2tlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRlUGlja2VyLmpzLm1hcCIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzL2Nzcy9jb21wb25lbnRzL1NlbGVjdC9zZWxlY3QnO1xuZXhwb3J0IGNvbnN0IFRpbWVPcHRpb24gPSAoX2EpID0+IHtcbiAgICB2YXIgeyBjbGFzc05hbWUgPSAnJywgdmFsdWUgPSAnJywgb25TZWxlY3QgPSAoKSA9PiB7IH0sIGNoaWxkcmVuLCBpZCwgaXNGb2N1c2VkIH0gPSBfYSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNsYXNzTmFtZVwiLCBcInZhbHVlXCIsIFwib25TZWxlY3RcIiwgXCJjaGlsZHJlblwiLCBcImlkXCIsIFwiaXNGb2N1c2VkXCJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBPYmplY3QuYXNzaWduKHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLnNlbGVjdE1lbnVXcmFwcGVyLCBpc0ZvY3VzZWQgJiYgc3R5bGVzLm1vZGlmaWVycy5mb2N1cywgY2xhc3NOYW1lKSB9LCBwcm9wcyksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IGNzcyhzdHlsZXMuc2VsZWN0TWVudUl0ZW0pLCBvbkNsaWNrOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgb25TZWxlY3QodmFsdWUsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sIHJvbGU6IFwib3B0aW9uXCIsIHR5cGU6IFwiYnV0dG9uXCIsIGlkOiBpZCB9LCBjaGlsZHJlbiB8fCB2YWx1ZS50b1N0cmluZygpKSkpO1xufTtcblRpbWVPcHRpb24uZGlzcGxheU5hbWUgPSAnVGltZU9wdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lT3B0aW9uLmpzLm1hcCIsImV4cG9ydCBjb25zdCBhbVN1ZmZpeCA9ICcgQU0nO1xuZXhwb3J0IGNvbnN0IHBtU3VmZml4ID0gJyBQTSc7XG5leHBvcnQgY29uc3QgbWFrZVRpbWVPcHRpb25zID0gKHN0ZXBNaW51dGVzLCBob3VyMTIsIGRlbGltaXRlcikgPT4ge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGl0ZXIgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKTtcbiAgICBjb25zdCBpdGVyRGF5ID0gaXRlci5nZXREYXkoKTtcbiAgICB3aGlsZSAoaXRlci5nZXREYXkoKSA9PT0gaXRlckRheSkge1xuICAgICAgICBsZXQgaG91ciA9IGl0ZXIuZ2V0SG91cnMoKTtcbiAgICAgICAgbGV0IHN1ZmZpeCA9IGFtU3VmZml4O1xuICAgICAgICBpZiAoaG91cjEyKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAxMjsgLy8gMTJhbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaG91ciA+PSAxMikge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHBtU3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgJT0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goKGhvdXIxMiA/IGhvdXIudG9TdHJpbmcoKSA6IGhvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpKSArXG4gICAgICAgICAgICBkZWxpbWl0ZXIgK1xuICAgICAgICAgICAgaXRlclxuICAgICAgICAgICAgICAgIC5nZXRNaW51dGVzKClcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIC5wYWRTdGFydCgyLCAnMCcpICtcbiAgICAgICAgICAgIChob3VyMTIgPyBzdWZmaXggOiAnJykpO1xuICAgICAgICBpdGVyLnNldE1pbnV0ZXMoaXRlci5nZXRNaW51dGVzKCkgKyBzdGVwTWludXRlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0IGNvbnN0IHBhcnNlVGltZSA9ICh0aW1lLCB0aW1lUmVnZXgsIGRlbGltaXRlciwgaXMxMkhvdXIpID0+IHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZSk7XG4gICAgLy8gaWYgZGVmYXVsdCB0aW1lIGlzIGEgSVNPIDg2MDEgZm9ybWF0dGVkIGRhdGUgc3RyaW5nLCB3ZSBwYXJzZSBpdCB0byBoaDptbShhbS9wbSkgZm9ybWF0XG4gICAgaWYgKCFpc05hTihkYXRlLmdldERhdGUoKSkgJiYgKHRpbWUgaW5zdGFuY2VvZiBEYXRlIHx8IHRpbWUuaW5jbHVkZXMoJ1QnKSkpIHtcbiAgICAgICAgY29uc3QgaG91cnMgPSBpczEySG91clxuICAgICAgICAgICAgPyBgJHtkYXRlLmdldEhvdXJzKCkgPiAxMiA/IGRhdGUuZ2V0SG91cnMoKSAtIDEyIDogZGF0ZS5nZXRIb3VycygpfWBcbiAgICAgICAgICAgIDogYCR7ZGF0ZS5nZXRIb3VycygpfWAucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IGAke2RhdGUuZ2V0TWludXRlcygpfWAucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgbGV0IGFtcG0gPSAnJztcbiAgICAgICAgaWYgKGlzMTJIb3VyICYmIGRhdGUuZ2V0SG91cnMoKSA+IDExKSB7XG4gICAgICAgICAgICBhbXBtID0gcG1TdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXMxMkhvdXIpIHtcbiAgICAgICAgICAgIGFtcG0gPSBhbVN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7aG91cnN9JHtkZWxpbWl0ZXJ9JHttaW51dGVzfSR7YW1wbX1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGltZSA9IHRpbWUudHJpbSgpO1xuICAgICAgICBpZiAoaXMxMkhvdXIgJiYgdGltZSAhPT0gJycgJiYgdmFsaWRhdGVUaW1lKHRpbWUsIHRpbWVSZWdleCwgZGVsaW1pdGVyLCBpczEySG91cikpIHtcbiAgICAgICAgICAgIC8vIEZvcm1hdCBBTS9QTSBhY2NvcmRpbmcgdG8gZGVzaWduXG4gICAgICAgICAgICBsZXQgYW1wbSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRpbWUudG9VcHBlckNhc2UoKS5pbmNsdWRlcyhhbVN1ZmZpeC50b1VwcGVyQ2FzZSgpLnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdGltZVxuICAgICAgICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShhbVN1ZmZpeC50b1VwcGVyQ2FzZSgpLnRyaW0oKSwgJycpXG4gICAgICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgICAgICAgICAgYW1wbSA9IGFtU3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGltZS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKHBtU3VmZml4LnRvVXBwZXJDYXNlKCkudHJpbSgpKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHBtU3VmZml4LnRvVXBwZXJDYXNlKCkudHJpbSgpLCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBhbXBtID0gcG1TdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIDEyIGhvdXIgdGltZSBpcyBtaXNzaW5nIGFtL3BtIGJ1dCBvdGhlcndpc2UgdmFsaWQsXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGFtL3BtIGRlcGVuZGluZyBvbiB0aW1lIG9mIGRheVxuICAgICAgICAgICAgICAgIGFtcG0gPSBuZXcgRGF0ZSgpLmdldEhvdXJzKCkgPiAxMSA/IHBtU3VmZml4IDogYW1TdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYCR7dGltZX0ke2FtcG19YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGltZS50b1N0cmluZygpO1xufTtcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVRpbWUgPSAodGltZSwgdGltZVJlZ2V4LCBkZWxpbWl0ZXIsIGlzMTJIb3VyKSA9PiB7XG4gICAgLy8gSVNPIDg2MDEgZm9ybWF0IGlzIHZhbGlkXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXREYXRlKCkpICYmIHRpbWUuaW5jbHVkZXMoJ1QnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaG91cnMgb25seSB2YWxpZCBpZiB0aGV5IGFyZSBbMC0yM10gb3IgWzEtMTJdXG4gICAgY29uc3QgaG91cnMgPSBwYXJzZUludCh0aW1lLnNwbGl0KGRlbGltaXRlcilbMF0pO1xuICAgIGNvbnN0IHZhbGlkSG91cnMgPSBob3VycyA+PSAoaXMxMkhvdXIgPyAxIDogMCkgJiYgaG91cnMgPD0gKGlzMTJIb3VyID8gMTIgOiAyMyk7XG4gICAgLy8gbWludXRlcyB2ZXJpZmllZCBieSB0aW1lUmVnZXhcbiAgICAvLyBlbXB0eSBzdHJpbmcgaXMgdmFsaWRcbiAgICByZXR1cm4gdGltZSA9PT0gJycgfHwgKHRpbWVSZWdleC50ZXN0KHRpbWUpICYmIHZhbGlkSG91cnMpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRIb3VycyA9ICh0aW1lLCB0aW1lUmVnZXgpID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHRpbWUubWF0Y2godGltZVJlZ2V4KTtcbiAgICBpZiAocGFydHMgJiYgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICgvcG0vaS50ZXN0KHBhcnRzWzNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhcnRzWzFdKSA9PT0gMTIgPyBwYXJzZUludChwYXJ0c1sxXSkgOiBwYXJzZUludChwYXJ0c1sxXSkgKyAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL2FtL2kudGVzdChwYXJ0c1szXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChwYXJ0c1sxXSkgPT09IDEyID8gMCA6IHBhcnNlSW50KHBhcnRzWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQocGFydHNbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnQgY29uc3QgZ2V0TWludXRlcyA9ICh0aW1lLCB0aW1lUmVnZXgpID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHRpbWUubWF0Y2godGltZVJlZ2V4KTtcbiAgICByZXR1cm4gcGFydHMgJiYgcGFydHMubGVuZ3RoID8gcGFyc2VJbnQocGFydHNbMl0pIDogbnVsbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lUGlja2VyVXRpbHMuanMubWFwIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1zdHlsZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1zdHlsZXMvY3NzL2NvbXBvbmVudHMvU2VsZWN0L3NlbGVjdCc7XG5pbXBvcnQgZGF0ZVBpY2tlclN0eWxlcyBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1zdHlsZXMvY3NzL2NvbXBvbmVudHMvRGF0ZVBpY2tlci9kYXRlLXBpY2tlcic7XG5pbXBvcnQgZm9ybVN0eWxlcyBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1zdHlsZXMvY3NzL2NvbXBvbmVudHMvRm9ybUNvbnRyb2wvZm9ybS1jb250cm9sJztcbmltcG9ydCB7IGdldFVuaXF1ZUlkIH0gZnJvbSAnLi4vLi4vaGVscGVycyc7XG5pbXBvcnQgeyBQb3BwZXIgfSBmcm9tICcuLi8uLi9oZWxwZXJzL1BvcHBlci9Qb3BwZXInO1xuaW1wb3J0IHsgVGltZU9wdGlvbiB9IGZyb20gJy4vVGltZU9wdGlvbic7XG5pbXBvcnQgeyBLZXlUeXBlcywgU2VsZWN0RGlyZWN0aW9uIH0gZnJvbSAnLi4vU2VsZWN0JztcbmltcG9ydCB7IElucHV0R3JvdXAgfSBmcm9tICcuLi9JbnB1dEdyb3VwJztcbmltcG9ydCB7IFRleHRJbnB1dCB9IGZyb20gJy4uL1RleHRJbnB1dCc7XG5pbXBvcnQgeyBwYXJzZVRpbWUsIHZhbGlkYXRlVGltZSwgbWFrZVRpbWVPcHRpb25zLCBhbVN1ZmZpeCwgcG1TdWZmaXgsIGdldEhvdXJzLCBnZXRNaW51dGVzIH0gZnJvbSAnLi9UaW1lUGlja2VyVXRpbHMnO1xuZXhwb3J0IGNsYXNzIFRpbWVQaWNrZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5wYXJlbnRSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy50b2dnbGVSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5pbnB1dFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLm1lbnVSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5vbkRvY0NsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGlja2VkT25Ub2dnbGUgPSB0aGlzLnBhcmVudFJlZiAmJiB0aGlzLnBhcmVudFJlZi5jdXJyZW50ICYmIHRoaXMucGFyZW50UmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWNrZWRXaXRoaW5NZW51ID0gdGhpcy5tZW51UmVmICYmXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnVSZWYuY3VycmVudC5jb250YWlucyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWVudVJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pc09wZW4gJiYgIShjbGlja2VkT25Ub2dnbGUgfHwgY2xpY2tlZFdpdGhpbk1lbnUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlR2xvYmFsS2V5cyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpc09wZW4sIGZvY3VzZWRJbmRleCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIC8vIGtleWJvYXJkIHByZXNzZWQgd2hpbGUgZm9jdXMgb24gdG9nZ2xlXG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dFJlZiAmJiB0aGlzLmlucHV0UmVmLmN1cnJlbnQgJiYgdGhpcy5pbnB1dFJlZi5jdXJyZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3BlbiAmJiBldmVudC5rZXkgIT09IEtleVR5cGVzLlRhYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVG9nZ2xlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gS2V5VHlwZXMuRXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVG9nZ2xlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09IEtleVR5cGVzLlRhYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSBLZXlUeXBlcy5FbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWRJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TZWxlY3QodGhpcy5nZXRPcHRpb25zKClbZm9jdXNlZEluZGV4XS5pbm5lclRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRvZ2dsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSBLZXlUeXBlcy5BcnJvd0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXNlZEluZGV4KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09IEtleVR5cGVzLkFycm93VXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRm9jdXNlZEluZGV4KC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRm9jdXNlZEluZGV4ID0gKGluY3JlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5nZXRPcHRpb25zKCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldlN0YXRlLmZvY3VzZWRJbmRleCAhPT0gbnVsbCA/IHByZXZTdGF0ZS5mb2N1c2VkSW5kZXggKyBpbmNyZW1lbnQgOiBwcmV2U3RhdGUuc2Nyb2xsSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHRJbmRleCA+IG1heEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChuZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWRJbmRleDogbmV4dEluZGV4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXggPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucygpW2luZGV4XS5vZmZzZXRQYXJlbnQuc2Nyb2xsVG9wID0gdGhpcy5nZXRPcHRpb25zKClbaW5kZXhdLm9mZnNldFRvcDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGlvbiA9ICh0aW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlciwgaXMyNEhvdXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgc3BsaXRUaW1lID0gdGltZS5zcGxpdCh0aGlzLnByb3BzLmRlbGltaXRlcik7XG4gICAgICAgICAgICBsZXQgZm9jdXNlZEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGJ1aWxkIG91dCB0aGUgcmVzdCBvZiB0aGUgdGltZSBhc3N1bWluZyBoaDowMCBpZiBpdCdzIGEgcGFydGlhbCB0aW1lXG4gICAgICAgICAgICBpZiAoc3BsaXRUaW1lLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYCR7dGltZX0ke2RlbGltaXRlcn0wMGA7XG4gICAgICAgICAgICAgICAgc3BsaXRUaW1lID0gdGltZS5zcGxpdChkZWxpbWl0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yIDEyaHIgdmFyaWFudCwgYXV0b3Njcm9sbCB0byBwbSBpZiBpdCdzIGN1cnJlbnRseSB0aGUgYWZ0ZXJub29uLCBvdGhlcndpc2UgYXV0b3Njcm9sbCB0byBhbVxuICAgICAgICAgICAgaWYgKCFpczI0SG91ciAmJiBzcGxpdFRpbWUubGVuZ3RoID4gMSAmJiBzcGxpdFRpbWVbMV0ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBzcGxpdFRpbWVbMV0ubGVuZ3RoID09PSAwID8gJzAwJyA6IHNwbGl0VGltZVsxXSArICcwJztcbiAgICAgICAgICAgICAgICB0aW1lID0gYCR7c3BsaXRUaW1lWzBdfSR7ZGVsaW1pdGVyfSR7bWludXRlc30ke25ldyBEYXRlKCkuZ2V0SG91cnMoKSA+IDExID8gcG1TdWZmaXggOiBhbVN1ZmZpeH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzMjRIb3VyICYmXG4gICAgICAgICAgICAgICAgc3BsaXRUaW1lLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICBzcGxpdFRpbWVbMV0ubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgIXRpbWUudG9VcHBlckNhc2UoKS5pbmNsdWRlcyhhbVN1ZmZpeC50b1VwcGVyQ2FzZSgpLnRyaW0oKSkgJiZcbiAgICAgICAgICAgICAgICAhdGltZS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKHBtU3VmZml4LnRvVXBwZXJDYXNlKCkudHJpbSgpKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSBgJHt0aW1lfSR7bmV3IERhdGUoKS5nZXRIb3VycygpID4gMTEgPyBwbVN1ZmZpeCA6IGFtU3VmZml4fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2Nyb2xsSW5kZXggPSB0aGlzLmdldE9wdGlvbnMoKS5maW5kSW5kZXgob3B0aW9uID0+IG9wdGlvbi5pbm5lclRleHQgPT09IHRpbWUpO1xuICAgICAgICAgICAgLy8gaWYgd2UgZm91bmQgYW4gZXhhY3QgbWF0Y2gsIHNjcm9sbCB0byBtYXRjaCBhbmQgcmV0dXJuIGluZGV4IG9mIG1hdGNoIGZvciBmb2N1c1xuICAgICAgICAgICAgaWYgKHNjcm9sbEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChzY3JvbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgZm9jdXNlZEluZGV4ID0gc2Nyb2xsSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGxpdFRpbWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gZXhhY3QgbWF0Y2gsIHNjcm9sbCB0byBjbG9zZXN0IGhvdXIgYnV0IGRvbid0IHJldHVybiBpbmRleCBmb3IgZm9jdXNcbiAgICAgICAgICAgICAgICBsZXQgYW1QbSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICghaXMyNEhvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0VGltZVsxXS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKCdQJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtUG0gPSBwbVN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzcGxpdFRpbWVbMV0udG9VcHBlckNhc2UoKS5pbmNsdWRlcygnQScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbVBtID0gYW1TdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZSA9IGAke3NwbGl0VGltZVswXX0ke2RlbGltaXRlcn0wMCR7YW1QbX1gO1xuICAgICAgICAgICAgICAgIHNjcm9sbEluZGV4ID0gdGhpcy5nZXRPcHRpb25zKCkuZmluZEluZGV4KG9wdGlvbiA9PiBvcHRpb24uaW5uZXJUZXh0ID09PSB0aW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChzY3JvbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZm9jdXNlZEluZGV4LFxuICAgICAgICAgICAgICAgIHNjcm9sbEluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSZWdFeHAgPSAoKSA9PiB0aGlzLnByb3BzLmlzMjRIb3VyXG4gICAgICAgICAgICA/IG5ldyBSZWdFeHAoYF5cXFxccyooXFxcXGRcXFxcZD8pJHt0aGlzLnByb3BzLmRlbGltaXRlcn0oWzAtNV1cXFxcZClcXFxccyokYClcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChgXlxcXFxzKihcXFxcZFxcXFxkPykke3RoaXMucHJvcHMuZGVsaW1pdGVyfShbMC01XVxcXFxkKVxcXFxzKihbQWFQcF1bTW1dKT9cXFxccyokYCk7XG4gICAgICAgIHRoaXMuZ2V0T3B0aW9ucyA9ICgpID0+ICh0aGlzLm1lbnVSZWYgJiYgdGhpcy5tZW51UmVmLmN1cnJlbnQgPyBBcnJheS5mcm9tKHRoaXMubWVudVJlZi5jdXJyZW50LmNoaWxkcmVuKSA6IFtdKTtcbiAgICAgICAgdGhpcy5pc1ZhbGlkID0gKHRpbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnZhbGlkYXRlVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnZhbGlkYXRlVGltZSh0aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGVsaW1pdGVyLCBpczI0SG91ciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVRpbWUodGltZSwgdGhpcy5zdGF0ZS50aW1lUmVnZXgsIGRlbGltaXRlciwgIWlzMjRIb3VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblRvZ2dsZSA9IChpc09wZW4pID0+IHtcbiAgICAgICAgICAgIC8vIG9uIGNsb3NlLCBwYXJzZSBhbmQgdmFsaWRhdGUgaW5wdXRcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVSZWdleCwgaXNJbnZhbGlkIH0gPSBwcmV2U3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXIsIGlzMjRIb3VyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBwYXJzZVRpbWUocHJldlN0YXRlLnRpbWVTdGF0ZSwgdGltZVJlZ2V4LCBkZWxpbWl0ZXIsICFpczI0SG91cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXNPcGVuLFxuICAgICAgICAgICAgICAgICAgICB0aW1lU3RhdGU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZDogaXNPcGVuID8gaXNJbnZhbGlkIDogIXRoaXMuaXNWYWxpZCh0aW1lKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNlbGVjdCA9IChzZWxlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZVJlZ2V4LCB0aW1lU3RhdGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlciwgaXMyNEhvdXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VUaW1lKHNlbGVjdGlvbiwgdGltZVJlZ2V4LCBkZWxpbWl0ZXIsICFpczI0SG91cik7XG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGltZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbklucHV0Q2hhbmdlKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXNPcGVuOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JbnB1dEZvY3VzID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVG9nZ2xlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbklucHV0Q2hhbmdlID0gKG5ld1RpbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShuZXdUaW1lLCBnZXRIb3VycyhuZXdUaW1lLCB0aGlzLnN0YXRlLnRpbWVSZWdleCksIGdldE1pbnV0ZXMobmV3VGltZSwgdGhpcy5zdGF0ZS50aW1lUmVnZXgpLCB0aGlzLmlzVmFsaWQobmV3VGltZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGlvbihuZXdUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHRpbWVTdGF0ZTogbmV3VGltZSxcbiAgICAgICAgICAgICAgICBpc0ludmFsaWQ6ICF0aGlzLmlzVmFsaWQobmV3VGltZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQmx1ciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0aW1lUmVnZXggfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlciwgaXMyNEhvdXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VUaW1lKGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsIHRpbWVSZWdleCwgZGVsaW1pdGVyLCAhaXMyNEhvdXIpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaXNJbnZhbGlkOiAhdGhpcy5pc1ZhbGlkKHRpbWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBpczI0SG91ciwgZGVsaW1pdGVyLCB0aW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB0aW1lUmVnZXggPSB0aGlzLmdldFJlZ0V4cCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXNJbnZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICAgICAgICB0aW1lU3RhdGU6IHBhcnNlVGltZSh0aW1lLCB0aW1lUmVnZXgsIGRlbGltaXRlciwgIWlzMjRIb3VyKSxcbiAgICAgICAgICAgIGZvY3VzZWRJbmRleDogbnVsbCxcbiAgICAgICAgICAgIHNjcm9sbEluZGV4OiAwLFxuICAgICAgICAgICAgdGltZVJlZ2V4XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uRG9jQ2xpY2spO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkRvY0NsaWNrKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlR2xvYmFsS2V5cyk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uRG9jQ2xpY2spO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbkRvY0NsaWNrKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlR2xvYmFsS2V5cyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICBjb25zdCB7IHRpbWVTdGF0ZSwgaXNPcGVuLCBpc0ludmFsaWQsIHRpbWVSZWdleCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyB0aW1lLCBpczI0SG91ciwgZGVsaW1pdGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoaXNPcGVuICYmICFwcmV2U3RhdGUuaXNPcGVuICYmIHRpbWVTdGF0ZSAmJiAhaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0aW9uKHRpbWVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGltaXRlciAhPT0gcHJldlByb3BzLmRlbGltaXRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdGltZVJlZ2V4OiB0aGlzLmdldFJlZ0V4cCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSAhPT0gJycgJiYgdGltZSAhPT0gcHJldlByb3BzLnRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHRpbWVTdGF0ZTogcGFyc2VUaW1lKHRpbWUsIHRpbWVSZWdleCwgZGVsaW1pdGVyLCAhaXMyNEhvdXIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IF9hID0gdGhpcy5wcm9wcywgeyAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCwgaXNEaXNhYmxlZCwgY2xhc3NOYW1lLCBwbGFjZWhvbGRlciwgaWQsIG1lbnVBcHBlbmRUbywgaXMyNEhvdXIsIGludmFsaWRGb3JtYXRFcnJvck1lc3NhZ2UsIGRpcmVjdGlvbiwgc3RlcE1pbnV0ZXMsIHdpZHRoLCBkZWxpbWl0ZXIsIFxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgb25DaGFuZ2UsIHRpbWUsIHZhbGlkYXRlVGltZSwgaW5wdXRQcm9wcyB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbJ2FyaWEtbGFiZWwnLCBcImlzRGlzYWJsZWRcIiwgXCJjbGFzc05hbWVcIiwgXCJwbGFjZWhvbGRlclwiLCBcImlkXCIsIFwibWVudUFwcGVuZFRvXCIsIFwiaXMyNEhvdXJcIiwgXCJpbnZhbGlkRm9ybWF0RXJyb3JNZXNzYWdlXCIsIFwiZGlyZWN0aW9uXCIsIFwic3RlcE1pbnV0ZXNcIiwgXCJ3aWR0aFwiLCBcImRlbGltaXRlclwiLCBcIm9uQ2hhbmdlXCIsIFwidGltZVwiLCBcInZhbGlkYXRlVGltZVwiLCBcImlucHV0UHJvcHNcIl0pO1xuICAgICAgICBjb25zdCB7IHRpbWVTdGF0ZSwgaXNPcGVuLCBpc0ludmFsaWQsIGZvY3VzZWRJbmRleCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB7ICctLXBmLWMtZGF0ZS1waWNrZXJfX2lucHV0LS1jLWZvcm0tY29udHJvbC0tV2lkdGgnOiB3aWR0aCB9O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWFrZVRpbWVPcHRpb25zKHN0ZXBNaW51dGVzLCAhaXMyNEhvdXIsIGRlbGltaXRlcik7XG4gICAgICAgIGNvbnN0IHJhbmRvbUlkID0gaWQgfHwgZ2V0VW5pcXVlSWQoJ3RpbWUtcGlja2VyJyk7XG4gICAgICAgIGNvbnN0IG1lbnVDb250YWluZXIgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgcmVmOiB0aGlzLm1lbnVSZWYsIGNsYXNzTmFtZTogY3NzKHN0eWxlcy5zZWxlY3RNZW51KSwgcm9sZTogXCJsaXN0Ym94XCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGAke2lkfS1pbnB1dGAsIHN0eWxlOiB7IG1heEhlaWdodDogJzIwMHB4Jywgb3ZlcmZsb3dZOiAnYXV0bycgfSB9LCBvcHRpb25zLm1hcCgob3B0aW9uLCBpbmRleCkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZU9wdGlvbiwgeyBrZXk6IGluZGV4LCB2YWx1ZTogb3B0aW9uLCBpbmRleDogaW5kZXgsIG9uU2VsZWN0OiB0aGlzLm9uU2VsZWN0LCBpc0ZvY3VzZWQ6IGluZGV4ID09PSBmb2N1c2VkSW5kZXgsIGlkOiBgJHtpZH0tb3B0aW9uLSR7aW5kZXh9YCB9KSkpKSk7XG4gICAgICAgIGNvbnN0IGlucHV0QW5kVG9nZ2xlID0gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7IGNsYXNzTmFtZTogY3NzKGRhdGVQaWNrZXJTdHlsZXMuZGF0ZVBpY2tlcklucHV0KSwgc3R5bGU6IHN0eWxlIH0sIHByb3BzKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRHcm91cCwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLnNlbGVjdCwgaXNPcGVuICYmIHN0eWxlcy5tb2RpZmllcnMuZXhwYW5kZWQsIGRpcmVjdGlvbiA9PT0gU2VsZWN0RGlyZWN0aW9uLnVwICYmIHN0eWxlcy5tb2RpZmllcnMudG9wLCBjbGFzc05hbWUpLCBpZDogcmFuZG9tSWQsIHJlZjogdGhpcy5wYXJlbnRSZWYgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy50b2dnbGVSZWYsIGNsYXNzTmFtZTogY3NzKHN0eWxlcy5zZWxlY3RUb2dnbGUsIGlzRGlzYWJsZWQgJiYgc3R5bGVzLm1vZGlmaWVycy5kaXNhYmxlZCwgc3R5bGVzLm1vZGlmaWVycy50eXBlYWhlYWQpLCBzdHlsZTogeyBwYWRkaW5nTGVmdDogJzAnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCBPYmplY3QuYXNzaWduKHsgY2xhc3NOYW1lOiBjc3MoZm9ybVN0eWxlcy5mb3JtQ29udHJvbCwgc3R5bGVzLnNlbGVjdFRvZ2dsZVR5cGVhaGVhZCksIGlkOiBgJHtyYW5kb21JZH0taW5wdXRgLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCB2YWxpZGF0ZWQ6IGlzSW52YWxpZCA/ICdlcnJvcicgOiAnZGVmYXVsdCcsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgdmFsdWU6IHRpbWVTdGF0ZSB8fCAnJywgdHlwZTogXCJ0ZXh0XCIsIGljb25WYXJpYW50OiBcImNsb2NrXCIsIG9uQ2xpY2s6IHRoaXMub25JbnB1dEZvY3VzLCBvbkZvY3VzOiB0aGlzLm9uSW5wdXRGb2N1cywgb25DaGFuZ2U6IHRoaXMub25JbnB1dENoYW5nZSwgb25CbHVyOiB0aGlzLm9uQmx1ciwgYXV0b0NvbXBsZXRlOiBcIm9mZlwiLCBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLCByZWY6IHRoaXMuaW5wdXRSZWYgfSwgaW5wdXRQcm9wcykpKSxcbiAgICAgICAgICAgICAgICAgICAgaXNPcGVuICYmIG1lbnVBcHBlbmRUbyA9PT0gJ2lubGluZScgJiYgbWVudUNvbnRhaW5lcikpLFxuICAgICAgICAgICAgaXNJbnZhbGlkICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjc3MoZGF0ZVBpY2tlclN0eWxlcy5kYXRlUGlja2VySGVscGVyVGV4dCwgZGF0ZVBpY2tlclN0eWxlcy5tb2RpZmllcnMuZXJyb3IpIH0sIGludmFsaWRGb3JtYXRFcnJvck1lc3NhZ2UpKSkpO1xuICAgICAgICBjb25zdCBwb3BwZXJDb250YWluZXIgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY3NzKHN0eWxlcy5zZWxlY3QsIGlzT3BlbiAmJiBzdHlsZXMubW9kaWZpZXJzLmV4cGFuZGVkLCBkaXJlY3Rpb24gPT09IFNlbGVjdERpcmVjdGlvbi51cCAmJiBzdHlsZXMubW9kaWZpZXJzLnRvcCwgY2xhc3NOYW1lKSB9LCBpc09wZW4gJiYgbWVudUNvbnRhaW5lcikpO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNzcyhkYXRlUGlja2VyU3R5bGVzLmRhdGVQaWNrZXIsIGNsYXNzTmFtZSkgfSwgbWVudUFwcGVuZFRvID09PSAnaW5saW5lJyA/IChpbnB1dEFuZFRvZ2dsZSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChQb3BwZXIsIHsgdHJpZ2dlcjogaW5wdXRBbmRUb2dnbGUsIHBvcHBlcjogcG9wcGVyQ29udGFpbmVyLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgYXBwZW5kVG86IG1lbnVBcHBlbmRUbywgaXNWaXNpYmxlOiBpc09wZW4gfSkpKSk7XG4gICAgfVxufVxuVGltZVBpY2tlci5kaXNwbGF5TmFtZSA9ICdUaW1lUGlja2VyJztcblRpbWVQaWNrZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogJycsXG4gICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgdGltZTogJycsXG4gICAgaXMyNEhvdXI6IGZhbHNlLFxuICAgIGludmFsaWRGb3JtYXRFcnJvck1lc3NhZ2U6ICdJbnZhbGlkIHRpbWUgZm9ybWF0JyxcbiAgICBwbGFjZWhvbGRlcjogJ2hoOm1tJyxcbiAgICBkZWxpbWl0ZXI6ICc6JyxcbiAgICAnYXJpYS1sYWJlbCc6ICdUaW1lIHBpY2tlcicsXG4gICAgbWVudUFwcGVuZFRvOiAnaW5saW5lJyxcbiAgICBkaXJlY3Rpb246ICdkb3duJyxcbiAgICB3aWR0aDogMTUwLFxuICAgIHN0ZXBNaW51dGVzOiAzMCxcbiAgICBpbnB1dFByb3BzOiB7fVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVQaWNrZXIuanMubWFwIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlciwgRmxleCwgRmxleEl0ZW0sIElucHV0R3JvdXAsIFRpbWVQaWNrZXIsIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgd3JhcEZpZWxkIGZyb20gJy4vd3JhcEZpZWxkJztcbnZhciBEYXRlQ29uc3RydWN0b3IgPSAodHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgPyBnbG9iYWwgOiB3aW5kb3cpLkRhdGU7XG5mdW5jdGlvbiBEYXRlRmllbGQocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBwYXJzZURhdGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMudmFsdWUudG9JU09TdHJpbmcoKS5zbGljZSgwLCAtMTQpO1xuICAgIH0sIFtwcm9wcy52YWx1ZV0pO1xuICAgIHZhciBwYXJzZVRpbWUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMudmFsdWUuZ2V0VVRDSG91cnMoKSArIFwiOlwiICsgcHJvcHMudmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgIH0sIFtwcm9wcy52YWx1ZV0pO1xuICAgIHZhciBvbkRhdGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUsIGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZUNvbnN0cnVjdG9yKGRhdGUpO1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBwYXJzZVRpbWUoKTtcbiAgICAgICAgICAgIGlmICh0aW1lICE9PSAnJykge1xuICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0VVRDSG91cnMocGFyc2VJbnQodGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lLnNwbGl0KCc6JylbMF0pKTtcbiAgICAgICAgICAgICAgICBuZXdEYXRlLnNldFVUQ01pbnV0ZXMocGFyc2VJbnQoKF9hID0gdGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lLnNwbGl0KCc6JylbMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnICcpWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRlLnNldFVUQ0hvdXJzKDApO1xuICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0VVRDTWludXRlcygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKG5ld0RhdGUpO1xuICAgICAgICB9XG4gICAgfSwgW3Byb3BzLm9uQ2hhbmdlLCBwYXJzZVRpbWVdKTtcbiAgICB2YXIgaXNJbnZhbGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLm1pbikge1xuICAgICAgICAgICAgICAgIHZhciBtaW5EYXRlID0gbmV3IERhdGUocHJvcHMubWluKTtcbiAgICAgICAgICAgICAgICBpZiAobWluRGF0ZS50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLnZhbHVlIDwgbWluRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTaG91bGQgYmUgYWZ0ZXIgXCIgKyBtaW5EYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLm1heCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhEYXRlID0gbmV3IERhdGUocHJvcHMubWF4KTtcbiAgICAgICAgICAgICAgICBpZiAobWF4RGF0ZS50b1N0cmluZygpID09PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLnZhbHVlID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTaG91bGQgYmUgYmVmb3JlIFwiICsgbWF4RGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3Byb3BzLnZhbHVlXSk7XG4gICAgdmFyIG9uVGltZUNoYW5nZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0aW1lLCBob3VycywgbWludXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZUNvbnN0cnVjdG9yKHByb3BzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChob3VycyAmJiBtaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENIb3Vycyhob3Vycyk7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKG1pbnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGltZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxlSG91cnMgPSBwYXJzZUludCh0aW1lID09PSBudWxsIHx8IHRpbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWUuc3BsaXQoJzonKVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsZU1pbnV0ZXMgPSBwYXJzZUludCgoX2EgPSB0aW1lID09PSBudWxsIHx8IHRpbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRpbWUuc3BsaXQoJzonKVsxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KCcgJylbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obG9jYWxlSG91cnMpICYmICFpc05hTihsb2NhbGVNaW51dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRlLnNldFVUQ0hvdXJzKGxvY2FsZUhvdXJzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKGxvY2FsZU1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0RhdGUuc2V0VVRDSG91cnMoMCk7XG4gICAgICAgICAgICAgICAgbmV3RGF0ZS5zZXRVVENNaW51dGVzKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UobmV3RGF0ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMub25DaGFuZ2UsIHByb3BzLnZhbHVlXSk7XG4gICAgcmV0dXJuIHdyYXBGaWVsZChwcm9wcywgUmVhY3QuY3JlYXRlRWxlbWVudChGbGV4LCB7IHN0eWxlOiB7IG1hcmdpbjogMCB9LCBkaXJlY3Rpb246IHsgZGVmYXVsdDogJ2NvbHVtbicgfSwgaWQ6IHByb3BzLmlkLCBuYW1lOiBwcm9wcy5uYW1lLCByZWY6IHByb3BzLmlucHV0UmVmIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxleEl0ZW0sIHsgc3R5bGU6IHsgbWFyZ2luOiAwIH0gfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRHcm91cCwgeyBzdHlsZTogeyBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnIH0gfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGVQaWNrZXIsIHsgaWQ6IFwiZGF0ZS1waWNrZXItXCIgKyBwcm9wcy5pZCwgXCJkYXRhLXRlc3RpZFwiOiBcImRhdGUtcGlja2VyXCIsIGlzRGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLCBuYW1lOiBwcm9wcy5uYW1lLCBvbkNoYW5nZTogb25EYXRlQ2hhbmdlLCB2YWx1ZTogKF9hID0gcGFyc2VEYXRlKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGltZVBpY2tlciwgeyBpZDogXCJ0aW1lLXBpY2tlci1cIiArIHByb3BzLmlkLCBcImRhdGEtdGVzdGlkXCI6IFwidGltZS1waWNrZXJcIiwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQgfHwgIXByb3BzLnZhbHVlLCBuYW1lOiBwcm9wcy5uYW1lLCBvbkNoYW5nZTogb25UaW1lQ2hhbmdlLCBzdHlsZTogeyB3aWR0aDogJzEyMHB4JyB9LCB2YWx1ZTogKF9iID0gcGFyc2VUaW1lKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCBpczI0SG91cjogdHJ1ZSB9KSkpLFxuICAgICAgICBpc0ludmFsaWQgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBpZDogcHJvcHMuaWQgKyBcIi1pbnZhbGlkLWRhdGUtdGltZVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC44NzVyZW0nLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2M5MTkwYicsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnMC4yNXJlbScsXG4gICAgICAgICAgICB9IH0sIGlzSW52YWxpZCkpKSk7XG59XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0RmllbGQoRGF0ZUZpZWxkKTtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1zdHlsZXMvY3NzL2xheW91dHMvU3BsaXQvc3BsaXQnO1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzJztcbmV4cG9ydCBjb25zdCBTcGxpdCA9IChfYSkgPT4ge1xuICAgIHZhciB7IGhhc0d1dHRlciA9IGZhbHNlLCBpc1dyYXBwYWJsZSA9IGZhbHNlLCBjbGFzc05hbWUgPSAnJywgY2hpbGRyZW4gPSBudWxsLCBjb21wb25lbnQgPSAnZGl2JyB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJoYXNHdXR0ZXJcIiwgXCJpc1dyYXBwYWJsZVwiLCBcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCIsIFwiY29tcG9uZW50XCJdKTtcbiAgICBjb25zdCBDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLnNwbGl0LCBoYXNHdXR0ZXIgJiYgc3R5bGVzLm1vZGlmaWVycy5ndXR0ZXIsIGlzV3JhcHBhYmxlICYmIHN0eWxlcy5tb2RpZmllcnMud3JhcCwgY2xhc3NOYW1lKSB9KSwgY2hpbGRyZW4pKTtcbn07XG5TcGxpdC5kaXNwbGF5TmFtZSA9ICdTcGxpdCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TcGxpdC5qcy5tYXAiLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3Qtc3R5bGVzL2Nzcy9sYXlvdXRzL1NwbGl0L3NwbGl0JztcbmltcG9ydCB7IGNzcyB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LXN0eWxlcyc7XG5leHBvcnQgY29uc3QgU3BsaXRJdGVtID0gKF9hKSA9PiB7XG4gICAgdmFyIHsgaXNGaWxsZWQgPSBmYWxzZSwgY2xhc3NOYW1lID0gJycsIGNoaWxkcmVuID0gbnVsbCB9ID0gX2EsIHByb3BzID0gX19yZXN0KF9hLCBbXCJpc0ZpbGxlZFwiLCBcImNsYXNzTmFtZVwiLCBcImNoaWxkcmVuXCJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgY2xhc3NOYW1lOiBjc3Moc3R5bGVzLnNwbGl0SXRlbSwgaXNGaWxsZWQgJiYgc3R5bGVzLm1vZGlmaWVycy5maWxsLCBjbGFzc05hbWUpIH0pLCBjaGlsZHJlbikpO1xufTtcblNwbGl0SXRlbS5kaXNwbGF5TmFtZSA9ICdTcGxpdEl0ZW0nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BsaXRJdGVtLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUljb24gfSBmcm9tICcuLi9jcmVhdGVJY29uJztcblxuZXhwb3J0IGNvbnN0IE91dGxpbmVkUXVlc3Rpb25DaXJjbGVJY29uQ29uZmlnID0ge1xuICBuYW1lOiAnT3V0bGluZWRRdWVzdGlvbkNpcmNsZUljb24nLFxuICBoZWlnaHQ6IDUxMixcbiAgd2lkdGg6IDUxMixcbiAgc3ZnUGF0aDogJ00yNTYgOEMxMTkuMDQzIDggOCAxMTkuMDgzIDggMjU2YzAgMTM2Ljk5NyAxMTEuMDQzIDI0OCAyNDggMjQ4czI0OC0xMTEuMDAzIDI0OC0yNDhDNTA0IDExOS4wODMgMzkyLjk1NyA4IDI1NiA4em0wIDQ0OGMtMTEwLjUzMiAwLTIwMC04OS40MzEtMjAwLTIwMCAwLTExMC40OTUgODkuNDcyLTIwMCAyMDAtMjAwIDExMC40OTEgMCAyMDAgODkuNDcxIDIwMCAyMDAgMCAxMTAuNTMtODkuNDMxIDIwMC0yMDAgMjAwem0xMDcuMjQ0LTI1NS4yYzAgNjcuMDUyLTcyLjQyMSA2OC4wODQtNzIuNDIxIDkyLjg2M1YzMDBjMCA2LjYyNy01LjM3MyAxMi0xMiAxMmgtNDUuNjQ3Yy02LjYyNyAwLTEyLTUuMzczLTEyLTEydi04LjY1OWMwLTM1Ljc0NSAyNy4xLTUwLjAzNCA0Ny41NzktNjEuNTE2IDE3LjU2MS05Ljg0NSAyOC4zMjQtMTYuNTQxIDI4LjMyNC0yOS41NzkgMC0xNy4yNDYtMjEuOTk5LTI4LjY5My0zOS43ODQtMjguNjkzLTIzLjE4OSAwLTMzLjg5NCAxMC45NzctNDguOTQyIDI5Ljk2OS00LjA1NyA1LjEyLTExLjQ2IDYuMDcxLTE2LjY2NiAyLjEyNGwtMjcuODI0LTIxLjA5OGMtNS4xMDctMy44NzItNi4yNTEtMTEuMDY2LTIuNjQ0LTE2LjM2M0MxODQuODQ2IDEzMS40OTEgMjE0Ljk0IDExMiAyNjEuNzk0IDExMmM0OS4wNzEgMCAxMDEuNDUgMzguMzA0IDEwMS40NSA4OC44ek0yOTggMzY4YzAgMjMuMTU5LTE4Ljg0MSA0Mi00MiA0MnMtNDItMTguODQxLTQyLTQyIDE4Ljg0MS00MiA0Mi00MiA0MiAxOC44NDEgNDIgNDJ6JyxcbiAgeU9mZnNldDogMCxcbiAgeE9mZnNldDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBPdXRsaW5lZFF1ZXN0aW9uQ2lyY2xlSWNvbiA9IGNyZWF0ZUljb24oT3V0bGluZWRRdWVzdGlvbkNpcmNsZUljb25Db25maWcpO1xuXG5leHBvcnQgZGVmYXVsdCBPdXRsaW5lZFF1ZXN0aW9uQ2lyY2xlSWNvbjsiLCJpbXBvcnQgeyBjcmVhdGVJY29uIH0gZnJvbSAnLi4vY3JlYXRlSWNvbic7XG5cbmV4cG9ydCBjb25zdCBNaW51c0NpcmNsZUljb25Db25maWcgPSB7XG4gIG5hbWU6ICdNaW51c0NpcmNsZUljb24nLFxuICBoZWlnaHQ6IDUxMixcbiAgd2lkdGg6IDUxMixcbiAgc3ZnUGF0aDogJ00yNTYgOEMxMTkgOCA4IDExOSA4IDI1NnMxMTEgMjQ4IDI0OCAyNDggMjQ4LTExMSAyNDgtMjQ4UzM5MyA4IDI1NiA4ek0xMjQgMjk2Yy02LjYgMC0xMi01LjQtMTItMTJ2LTU2YzAtNi42IDUuNC0xMiAxMi0xMmgyNjRjNi42IDAgMTIgNS40IDEyIDEydjU2YzAgNi42LTUuNCAxMi0xMiAxMkgxMjR6JyxcbiAgeU9mZnNldDogMCxcbiAgeE9mZnNldDogMCxcbn07XG5cbmV4cG9ydCBjb25zdCBNaW51c0NpcmNsZUljb24gPSBjcmVhdGVJY29uKE1pbnVzQ2lyY2xlSWNvbkNvbmZpZyk7XG5cbmV4cG9ydCBkZWZhdWx0IE1pbnVzQ2lyY2xlSWNvbjsiLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBNaW51c0NpcmNsZUljb24gfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1pY29ucyc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzLCBqb2luTmFtZSwgdXNlRmllbGQsIH0gZnJvbSAndW5pZm9ybXMnO1xuZnVuY3Rpb24gTGlzdERlbChfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcIm5hbWVcIiwgXCJkaXNhYmxlZFwiXSk7XG4gICAgdmFyIG5hbWVQYXJ0cyA9IGpvaW5OYW1lKG51bGwsIG5hbWUpO1xuICAgIHZhciBuYW1lSW5kZXggPSArbmFtZVBhcnRzW25hbWVQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcGFyZW50TmFtZSA9IGpvaW5OYW1lKG5hbWVQYXJ0cy5zbGljZSgwLCAtMSkpO1xuICAgIHZhciBwYXJlbnQgPSB1c2VGaWVsZChwYXJlbnROYW1lLCB7fSwgeyBhYnNvbHV0ZU5hbWU6IHRydWUgfSlbMF07XG4gICAgdmFyIGxpbWl0Tm90UmVhY2hlZCA9ICFkaXNhYmxlZCAmJiAhKHBhcmVudC5taW5Db3VudCA+PSBwYXJlbnQudmFsdWUubGVuZ3RoKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCBfX2Fzc2lnbih7IGRpc2FibGVkOiAhbGltaXROb3RSZWFjaGVkIHx8IGRpc2FibGVkLCB2YXJpYW50OiBcInBsYWluXCIsIHN0eWxlOiB7IHBhZGRpbmdMZWZ0OiAnMCcsIHBhZGRpbmdSaWdodDogJzAnIH0sIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmVudC52YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgdmFsdWUuc3BsaWNlKG5hbWVJbmRleCwgMSk7XG4gICAgICAgICAgICAhZGlzYWJsZWQgJiYgbGltaXROb3RSZWFjaGVkICYmIHBhcmVudC5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH0gfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNaW51c0NpcmNsZUljb24sIHsgY29sb3I6IFwiI2NjMDAwMFwiIH0pKSk7XG59XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0RmllbGQoTGlzdERlbCwge1xuICAgIGluaXRpYWxWYWx1ZTogZmFsc2UsXG4gICAga2luZDogJ2xlYWYnLFxufSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IEF1dG9GaWVsZCBmcm9tICcuL0F1dG9GaWVsZCc7XG5pbXBvcnQgTGlzdERlbEZpZWxkIGZyb20gJy4vTGlzdERlbEZpZWxkJztcbmZ1bmN0aW9uIExpc3RJdGVtKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuY2hpbGRyZW4sIGNoaWxkcmVuID0gX2IgPT09IHZvaWQgMCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXV0b0ZpZWxkLCB7IGxhYmVsOiBudWxsLCBuYW1lOiAnJyB9KSA6IF9iO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206ICcxcmVtJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgIH0gfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScsIG1hcmdpblJpZ2h0OiAnMTBweCcgfSB9LCBjaGlsZHJlbiksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdERlbEZpZWxkLCB7IG5hbWU6ICcnIH0pKSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKExpc3RJdGVtLCB7XG4gICAgaW5pdGlhbFZhbHVlOiBmYWxzZSxcbn0pO1xuIiwiaW1wb3J0IHsgY3JlYXRlSWNvbiB9IGZyb20gJy4uL2NyZWF0ZUljb24nO1xuXG5leHBvcnQgY29uc3QgUGx1c0NpcmNsZUljb25Db25maWcgPSB7XG4gIG5hbWU6ICdQbHVzQ2lyY2xlSWNvbicsXG4gIGhlaWdodDogNTEyLFxuICB3aWR0aDogNTEyLFxuICBzdmdQYXRoOiAnTTI1NiA4QzExOSA4IDggMTE5IDggMjU2czExMSAyNDggMjQ4IDI0OCAyNDgtMTExIDI0OC0yNDhTMzkzIDggMjU2IDh6bTE0NCAyNzZjMCA2LjYtNS40IDEyLTEyIDEyaC05MnY5MmMwIDYuNi01LjQgMTItMTIgMTJoLTU2Yy02LjYgMC0xMi01LjQtMTItMTJ2LTkyaC05MmMtNi42IDAtMTItNS40LTEyLTEydi01NmMwLTYuNiA1LjQtMTIgMTItMTJoOTJ2LTkyYzAtNi42IDUuNC0xMiAxMi0xMmg1NmM2LjYgMCAxMiA1LjQgMTIgMTJ2OTJoOTJjNi42IDAgMTIgNS40IDEyIDEydjU2eicsXG4gIHlPZmZzZXQ6IDAsXG4gIHhPZmZzZXQ6IDAsXG59O1xuXG5leHBvcnQgY29uc3QgUGx1c0NpcmNsZUljb24gPSBjcmVhdGVJY29uKFBsdXNDaXJjbGVJY29uQ29uZmlnKTtcblxuZXhwb3J0IGRlZmF1bHQgUGx1c0NpcmNsZUljb247IiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IFBsdXNDaXJjbGVJY29uIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtaWNvbnMnO1xuaW1wb3J0IHsgY29ubmVjdEZpZWxkLCBmaWx0ZXJET01Qcm9wcywgam9pbk5hbWUsIHVzZUZpZWxkLCB9IGZyb20gJ3VuaWZvcm1zJztcbmZ1bmN0aW9uIExpc3RBZGQoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5kaXNhYmxlZCwgZGlzYWJsZWQgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWUsIHByb3BzID0gX19yZXN0KF9hLCBbXCJkaXNhYmxlZFwiLCBcIm5hbWVcIiwgXCJ2YWx1ZVwiXSk7XG4gICAgdmFyIG5hbWVQYXJ0cyA9IGpvaW5OYW1lKG51bGwsIG5hbWUpO1xuICAgIHZhciBwYXJlbnROYW1lID0gam9pbk5hbWUobmFtZVBhcnRzLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIHBhcmVudCA9IHVzZUZpZWxkKHBhcmVudE5hbWUsIHt9LCB7IGFic29sdXRlTmFtZTogdHJ1ZSB9KVswXTtcbiAgICB2YXIgbGltaXROb3RSZWFjaGVkID0gIWRpc2FibGVkICYmICEocGFyZW50Lm1heENvdW50IDw9IHBhcmVudC52YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b24sIF9fYXNzaWduKHsgdmFyaWFudDogXCJwbGFpblwiLCBzdHlsZTogeyBwYWRkaW5nTGVmdDogJzAnLCBwYWRkaW5nUmlnaHQ6ICcwJyB9LCBkaXNhYmxlZDogIWxpbWl0Tm90UmVhY2hlZCwgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIWRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgbGltaXROb3RSZWFjaGVkICYmXG4gICAgICAgICAgICAgICAgcGFyZW50Lm9uQ2hhbmdlKHBhcmVudC52YWx1ZS5jb25jYXQoW2Nsb25lRGVlcCh2YWx1ZSldKSk7XG4gICAgICAgIH0gfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQbHVzQ2lyY2xlSWNvbiwgeyBjb2xvcjogXCIjMDA4OGNlXCIgfSkpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChMaXN0QWRkLCB7XG4gICAgaW5pdGlhbFZhbHVlOiBmYWxzZSxcbiAgICBraW5kOiAnbGVhZicsXG59KTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiwgY2xvbmVFbGVtZW50LCBpc1ZhbGlkRWxlbWVudCwgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTcGxpdCwgU3BsaXRJdGVtLCBUb29sdGlwIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBPdXRsaW5lZFF1ZXN0aW9uQ2lyY2xlSWNvbiB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWljb25zJztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCwgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgTGlzdEl0ZW1GaWVsZCBmcm9tICcuL0xpc3RJdGVtRmllbGQnO1xuaW1wb3J0IExpc3RBZGRGaWVsZCBmcm9tICcuL0xpc3RBZGRGaWVsZCc7XG5maWx0ZXJET01Qcm9wcy5yZWdpc3RlcignbWluQ291bnQnLCAnd3JhcHBlckNvbCcsICdsYWJlbENvbCcpO1xuZnVuY3Rpb24gTGlzdEZpZWxkKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuY2hpbGRyZW4sIGNoaWxkcmVuID0gX2IgPT09IHZvaWQgMCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlzdEl0ZW1GaWVsZCwgeyBuYW1lOiBcIiRcIiB9KSA6IF9iLCBlcnJvciA9IF9hLmVycm9yLCBlcnJvck1lc3NhZ2UgPSBfYS5lcnJvck1lc3NhZ2UsIGluZm8gPSBfYS5pbmZvLCBpbml0aWFsQ291bnQgPSBfYS5pbml0aWFsQ291bnQsIGl0ZW1Qcm9wcyA9IF9hLml0ZW1Qcm9wcywgbGFiZWwgPSBfYS5sYWJlbCwgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWUsIHNob3dJbmxpbmVFcnJvciA9IF9hLnNob3dJbmxpbmVFcnJvciwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiZXJyb3JcIiwgXCJlcnJvck1lc3NhZ2VcIiwgXCJpbmZvXCIsIFwiaW5pdGlhbENvdW50XCIsIFwiaXRlbVByb3BzXCIsIFwibGFiZWxcIiwgXCJuYW1lXCIsIFwidmFsdWVcIiwgXCJzaG93SW5saW5lRXJyb3JcIl0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTcGxpdCwgeyBoYXNHdXR0ZXI6IHRydWUgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3BsaXRJdGVtLCBudWxsLCBsYWJlbCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgISFpbmZvICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBcIlxcdTAwQTBcIixcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7IGNvbnRlbnQ6IGluZm8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZWRRdWVzdGlvbkNpcmNsZUljb24sIG51bGwpKSkpKSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTcGxpdEl0ZW0sIHsgaXNGaWxsZWQ6IHRydWUgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNwbGl0SXRlbSwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExpc3RBZGRGaWVsZCwgeyBuYW1lOiAnJCcsIGluaXRpYWxDb3VudDogaW5pdGlhbENvdW50IH0pKSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLm1hcChmdW5jdGlvbiAoaXRlbSwgaXRlbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQsIGNoaWxkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRFbGVtZW50KGNoaWxkKVxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lRWxlbWVudChjaGlsZCwgX19hc3NpZ24oeyBrZXk6IGl0ZW1JbmRleCArIFwiLVwiICsgY2hpbGRJbmRleCwgbmFtZTogKF9hID0gY2hpbGQucHJvcHMubmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoJyQnLCAnJyArIGl0ZW1JbmRleCkgfSwgaXRlbVByb3BzKSlcbiAgICAgICAgICAgICAgICAgICAgOiBjaGlsZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSkpKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChMaXN0RmllbGQpO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCwgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgeyBDYXJkLCBDYXJkQm9keSB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IEF1dG9GaWVsZCBmcm9tICcuL0F1dG9GaWVsZCc7XG52YXIgTmVzdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBlcnJvciA9IF9hLmVycm9yLCBlcnJvck1lc3NhZ2UgPSBfYS5lcnJvck1lc3NhZ2UsIGZpZWxkcyA9IF9hLmZpZWxkcywgaXRlbVByb3BzID0gX2EuaXRlbVByb3BzLCBsYWJlbCA9IF9hLmxhYmVsLCBuYW1lID0gX2EubmFtZSwgc2hvd0lubGluZUVycm9yID0gX2Euc2hvd0lubGluZUVycm9yLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJlcnJvclwiLCBcImVycm9yTWVzc2FnZVwiLCBcImZpZWxkc1wiLCBcIml0ZW1Qcm9wc1wiLCBcImxhYmVsXCIsIFwibmFtZVwiLCBcInNob3dJbmxpbmVFcnJvclwiLCBcImRpc2FibGVkXCJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwgX19hc3NpZ24oe30sIGZpbHRlckRPTVByb3BzKHByb3BzKSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZEJvZHksIHsgY2xhc3NOYW1lOiBcInBmLWMtZm9ybVwiIH0sXG4gICAgICAgICAgICBsYWJlbCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJcIiwgbnVsbCwgbGFiZWwpKSksXG4gICAgICAgICAgICBjaGlsZHJlbiB8fCAoZmllbGRzID09PSBudWxsIHx8IGZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEF1dG9GaWVsZCwgX19hc3NpZ24oeyBrZXk6IGZpZWxkLCBkaXNhYmxlZDogZGlzYWJsZWQsIG5hbWU6IGZpZWxkIH0sIGl0ZW1Qcm9wcykpKTsgfSkpKSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChOZXN0KTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0SW5wdXQgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCB9IGZyb20gJ3VuaWZvcm1zJztcbmltcG9ydCB3cmFwRmllbGQgZnJvbSAnLi93cmFwRmllbGQnO1xudmFyIE51bSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBwYXJzZSA9IHByb3BzLmRlY2ltYWwgPyBwYXJzZUZsb2F0IDogcGFyc2VJbnQ7XG4gICAgICAgIHZhciB2ID0gcGFyc2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UoaXNOYU4odikgPyB1bmRlZmluZWQgOiB2KTtcbiAgICB9O1xuICAgIHJldHVybiB3cmFwRmllbGQocHJvcHMsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCB7IG5hbWU6IHByb3BzLm5hbWUsIGlzRGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLCBpZDogcHJvcHMuaWQsIG1heDogcHJvcHMubWF4LCBtaW46IHByb3BzLm1pbiwgb25DaGFuZ2U6IG9uQ2hhbmdlLCBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIsIHJlZjogcHJvcHMuaW5wdXRSZWYsIHN0ZXA6IHByb3BzLmRlY2ltYWwgPyAwLjAxIDogMSwgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IChfYSA9IHByb3BzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJywgdmFsaWRhdGVkOiBwcm9wcy5lcnJvciA/ICdlcnJvcicgOiAnZGVmYXVsdCcgfSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChOdW0pO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSYWRpbyBhcyBSYWRpb0ZpZWxkIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IHdyYXBGaWVsZCBmcm9tICcuL3dyYXBGaWVsZCc7XG52YXIgUmFkaW8gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgZmlsdGVyRE9NUHJvcHMucmVnaXN0ZXIoJ2NoZWNrYm94ZXMnLCAnZGVjaW1hbCcpO1xuICAgIHJldHVybiB3cmFwRmllbGQocHJvcHMsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIGZpbHRlckRPTVByb3BzKHByb3BzKSksIChfYSA9IHByb3BzLmFsbG93ZWRWYWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaXRlbSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJhZGlvRmllbGQsIHsgaXNDaGVja2VkOiBpdGVtID09PSBwcm9wcy52YWx1ZSwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIGlkOiBcIlwiICsgcHJvcHMuaWQsIG5hbWU6IHByb3BzLm5hbWUsIGxhYmVsOiBwcm9wcy50cmFuc2Zvcm0gPyBwcm9wcy50cmFuc2Zvcm0oaXRlbSkgOiBpdGVtLCBcImFyaWEtbGFiZWxcIjogcHJvcHMubmFtZSwgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BzLm9uQ2hhbmdlKGl0ZW0pOyB9IH0pKSk7IH0pKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKFJhZGlvKTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5cyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2hlY2tib3gsIFJhZGlvLCBTZWxlY3QsIFNlbGVjdE9wdGlvbiwgU2VsZWN0VmFyaWFudCwgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCwgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgd3JhcEZpZWxkIGZyb20gJy4vd3JhcEZpZWxkJztcbmZ1bmN0aW9uIHhvcihpdGVtLCBhcnJheSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuY29uY2F0KFtpdGVtXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5zbGljZSgwLCBpbmRleCkuY29uY2F0KGFycmF5LnNsaWNlKGluZGV4ICsgMSkpO1xufVxuZmlsdGVyRE9NUHJvcHMucmVnaXN0ZXIoJ2F1dG9WYWx1ZScpO1xuZnVuY3Rpb24gaXNTZWxlY3RPcHRpb25PYmplY3QodG9CZURldGVybWluZWQpIHtcbiAgICByZXR1cm4gdG9CZURldGVybWluZWQudG9TdHJpbmcgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIFNlbGVjdEZpZWxkKHByb3BzKSB7XG4gICAgaWYgKHByb3BzLmNoZWNrYm94ZXMpIHtcbiAgICAgICAgdmFyIEdyb3VwXzEgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChwcm9wcy5maWVsZFR5cGUgPT09IEFycmF5ID8gQ2hlY2tib3ggOiBSYWRpbyk7IH0sIFtwcm9wc10pO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIGZpbHRlckRPTVByb3BzKHByb3BzKSksXG4gICAgICAgICAgICBwcm9wcy5sYWJlbCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgbnVsbCwgcHJvcHMubGFiZWwpLFxuICAgICAgICAgICAgcHJvcHMuYWxsb3dlZFZhbHVlcy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgaHRtbEZvcjogcHJvcHMuaWQgfSwgcHJvcHMudHJhbnNmb3JtID8gcHJvcHMudHJhbnNmb3JtKGl0ZW0pIDogaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXBfMSwgeyBpZDogcHJvcHMuaWQgKyBcIi1cIiArIGl0ZW0sIGlzRGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLCBuYW1lOiBwcm9wcy5uYW1lLCBcImFyaWEtbGFiZWxcIjogcHJvcHMubmFtZSwgdmFsdWU6IHByb3BzLnZhbHVlLCBpc0NoZWNrZWQ6IHByb3BzLmZpZWxkVHlwZSA9PT0gQXJyYXkgJiYgQXJyYXkuaXNBcnJheShwcm9wcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BzLnZhbHVlLmluY2x1ZGVzKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcm9wcy52YWx1ZSA9PT0gaXRlbSwgb25DaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5vbkNoYW5nZShwcm9wcy5maWVsZFR5cGUgPT09IEFycmF5ICYmIEFycmF5LmlzQXJyYXkocHJvcHMudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geG9yKGl0ZW0sIHByb3BzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgdmFyIF9hID0gdXNlU3RhdGUoZmFsc2UpLCBleHBhbmRlZCA9IF9hWzBdLCBzZXRFeHBhbmRlZCA9IF9hWzFdO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKFtdKSwgc2VsZWN0ZWQgPSBfYlswXSwgc2V0U2VsZWN0ZWQgPSBfYlsxXTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZChbXSk7XG4gICAgICAgICAgICBzZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKF9fc3ByZWFkQXJyYXlzKHByb3BzLnZhbHVlKSk7XG4gICAgICAgICAgICBzZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZChwcm9wcy52YWx1ZSk7XG4gICAgICAgICAgICBzZXRFeHBhbmRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMudmFsdWVdKTtcbiAgICB2YXIgcGFyc2VJbnB1dCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzZWxlY3Rpb24sIGZpZWxkVHlwZSkge1xuICAgICAgICB2YXIgcGFyc2VkU2VsZWN0aW9uID0gaXNTZWxlY3RPcHRpb25PYmplY3Qoc2VsZWN0aW9uKVxuICAgICAgICAgICAgPyBzZWxlY3Rpb24udG9TdHJpbmcoKVxuICAgICAgICAgICAgOiBzZWxlY3Rpb247XG4gICAgICAgIGlmIChmaWVsZFR5cGUgIT09IEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkU2VsZWN0aW9uICE9PSAnJyA/IHBhcnNlZFNlbGVjdGlvbiA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdGVkKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKHBhcnNlZFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzICE9PSBwYXJzZWRTZWxlY3Rpb247IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKFtwYXJzZWRTZWxlY3Rpb25dLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwYXJzZWRTZWxlY3Rpb24sIHNlbGVjdGVkXTtcbiAgICB9LCBbc2VsZWN0ZWRdKTtcbiAgICB2YXIgaGFuZGxlU2VsZWN0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGV2ZW50LCBzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gcHJvcHMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBwYXJzZUlucHV0KHNlbGVjdGlvbiwgcHJvcHMuZmllbGRUeXBlKTtcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlKGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH0sIFtwYXJzZUlucHV0LCBwcm9wc10pO1xuICAgIHZhciBzZWxlY3RlZE9wdGlvbnMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLmFsbG93ZWRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0T3B0aW9uLCB7IGtleTogdmFsdWUsIHZhbHVlOiB2YWx1ZSB9LCBwcm9wcy50cmFuc2Zvcm0gPyBwcm9wcy50cmFuc2Zvcm0odmFsdWUpIDogdmFsdWUpKTsgfSk7XG4gICAgfSwgW3Byb3BzXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BzLnBsYWNlaG9sZGVyKVxuICAgICAgICAgICAgc2VsZWN0ZWRPcHRpb25zLnVuc2hpZnQoUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RPcHRpb24sIHsga2V5OiBwcm9wcy5hbGxvd2VkVmFsdWVzLmxlbmd0aCwgaXNQbGFjZWhvbGRlcjogdHJ1ZSwgdmFsdWU6IHByb3BzLnBsYWNlaG9sZGVyIH0pKTtcbiAgICB9LCBbcHJvcHMucGxhY2Vob2xkZXIsIHNlbGVjdGVkT3B0aW9uc10pO1xuICAgIHJldHVybiB3cmFwRmllbGQocHJvcHMsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VsZWN0LCB7IGlzRGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLCBpZDogcHJvcHMuaWQsIHZhcmlhbnQ6IHByb3BzLmZpZWxkVHlwZSA9PT0gQXJyYXlcbiAgICAgICAgICAgID8gU2VsZWN0VmFyaWFudC50eXBlYWhlYWRNdWx0aVxuICAgICAgICAgICAgOiBTZWxlY3RWYXJpYW50LnNpbmdsZSwgbmFtZTogcHJvcHMubmFtZSwgcGxhY2Vob2xkZXJUZXh0OiBwcm9wcy5wbGFjZWhvbGRlciwgaXNPcGVuOiBleHBhbmRlZCwgc2VsZWN0aW9uczogc2VsZWN0ZWQsIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXRFeHBhbmRlZCghZXhwYW5kZWQpOyB9LCBvblNlbGVjdDogaGFuZGxlU2VsZWN0LCB2YWx1ZTogcHJvcHMudmFsdWUgfHwgKHByb3BzLmZpZWxkVHlwZSA9PT0gQXJyYXkgPyBbXSA6IHVuZGVmaW5lZCkgfSwgc2VsZWN0ZWRPcHRpb25zKSk7XG59XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0RmllbGQoU2VsZWN0RmllbGQpO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fc3ByZWFkQXJyYXlzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBEYXRlUGlja2VyLCBUZXh0SW5wdXQsIFRpbWVQaWNrZXIsIH0gZnJvbSAnQHBhdHRlcm5mbHkvcmVhY3QtY29yZSc7XG5pbXBvcnQgeyBjb25uZWN0RmllbGQsIGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IHdyYXBGaWVsZCBmcm9tICcuL3dyYXBGaWVsZCc7XG52YXIgdGltZVJneCA9IC9eKFswLTFdP1swLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pKDpbMC01XVswLTldKT8vO1xudmFyIFRleHQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICB2YXIgaXNEYXRlSW52YWxpZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHMudmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAocHJvcHMudHlwZSA9PT0gJ2RhdGUnIHx8ICgoX2EgPSBwcm9wcy5maWVsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcm1hdCkgPT09ICdkYXRlJykpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUocHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wcy5taW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBuZXcgRGF0ZShwcm9wcy5taW4pO1xuICAgICAgICAgICAgICAgIGlmIChtaW5EYXRlLnRvU3RyaW5nKCkgPT09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZS50b0lTT1N0cmluZygpIDwgbWluRGF0ZS50b0lTT1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5lcnJvck1lc3NhZ2UgJiYgcHJvcHMuZXJyb3JNZXNzYWdlLnRyaW0oKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlNob3VsZCBiZSBhZnRlciBcIiArIHByb3BzLm1pbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BzLm1heCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4RGF0ZSA9IG5ldyBEYXRlKHByb3BzLm1heCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heERhdGUudG9TdHJpbmcoKSA9PT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRlLnRvSVNPU3RyaW5nKCkgPiBtYXhEYXRlLnRvSVNPU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmVycm9yTWVzc2FnZSAmJiBwcm9wcy5lcnJvck1lc3NhZ2UudHJpbSgpLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcHJvcHMuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiU2hvdWxkIGJlIGJlZm9yZSBcIiArIHByb3BzLm1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtwcm9wcy52YWx1ZSwgcHJvcHMubWF4LCBwcm9wcy5taW4sIHByb3BzLmVycm9yTWVzc2FnZV0pO1xuICAgIHZhciBwYXJzZVRpbWUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB2YXIgcGFyc2VkVGltZSA9IHRpbWVSZ3guZXhlYyh0aW1lKTtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghcGFyc2VkVGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBkYXRlLnNldFVUQ0hvdXJzKE51bWJlcihwYXJzZWRUaW1lWzFdKSwgTnVtYmVyKHBhcnNlZFRpbWVbMl0pKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfSwgW10pO1xuICAgIHZhciBpc1RpbWVJbnZhbGlkID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wcy52YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIChwcm9wcy50eXBlID09PSAndGltZScgfHwgKChfYSA9IHByb3BzLmZpZWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9ybWF0KSA9PT0gJ3RpbWUnKSkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZFRpbWUgPSBwYXJzZVRpbWUocHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFRpbWUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcHMubWluID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIHRpbWVSZ3guZXhlYyhwcm9wcy5taW4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZE1pbiA9IHBhcnNlVGltZShwcm9wcy5taW4pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRUaW1lIDwgcGFyc2VkTWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlNob3VsZCBiZSBhZnRlciBcIiArIHBhcnNlZE1pbi5nZXRVVENIb3VycygpICsgXCI6XCIgKyBwYXJzZWRNaW4uZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWRUaW1lICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHByb3BzLm1heCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICB0aW1lUmd4LmV4ZWMocHJvcHMubWF4KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRNYXggPSBwYXJzZVRpbWUocHJvcHMubWF4KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkVGltZSA+IHBhcnNlZE1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTaG91bGQgYmUgYmVmb3JlIFwiICsgcGFyc2VkTWF4LmdldFVUQ0hvdXJzKCkgKyBcIjpcIiArIHBhcnNlZE1heC5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHJvcHMudHlwZSwgcHJvcHMuZmllbGQsIHByb3BzLnZhbHVlLCBwcm9wcy5tYXgsIHByb3BzLm1pbl0pO1xuICAgIHZhciBvbkRhdGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcHJvcHMub25DaGFuZ2UodmFsdWUpO1xuICAgIH0sIFtwcm9wcy5kaXNhYmxlZCwgcHJvcHMub25DaGFuZ2VdKTtcbiAgICB2YXIgb25UaW1lQ2hhbmdlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZFRpbWUgPSB0aW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChwYXJzZWRUaW1lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UoX19zcHJlYWRBcnJheXMocGFyc2VkVGltZSwgWycwMCddKS5qb2luKCc6JykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMuZGlzYWJsZWQsIHByb3BzLm9uQ2hhbmdlXSk7XG4gICAgcmV0dXJuIHdyYXBGaWVsZChwcm9wcywgcHJvcHMudHlwZSA9PT0gJ2RhdGUnIHx8ICgoX2EgPSBwcm9wcy5maWVsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcm1hdCkgPT09ICdkYXRlJyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGVQaWNrZXIsIF9fYXNzaWduKHsgbmFtZTogcHJvcHMubmFtZSwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIG9uQ2hhbmdlOiBvbkRhdGVDaGFuZ2UsIHZhbHVlOiAoX2IgPSBwcm9wcy52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycgfSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSksXG4gICAgICAgIGlzRGF0ZUludmFsaWQgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC44NzVyZW0nLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2M5MTkwYicsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnMC4yNXJlbScsXG4gICAgICAgICAgICB9IH0sIGlzRGF0ZUludmFsaWQpKSkpIDogcHJvcHMudHlwZSA9PT0gJ3RpbWUnIHx8ICgoX2MgPSBwcm9wcy5maWVsZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZvcm1hdCkgPT09ICd0aW1lJyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRpbWVQaWNrZXIsIHsgbmFtZTogcHJvcHMubmFtZSwgaXNEaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIG9uQ2hhbmdlOiBvblRpbWVDaGFuZ2UsIGlzMjRIb3VyOiB0cnVlLCB2YWx1ZTogKF9kID0gcHJvcHMudmFsdWUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnIH0pLFxuICAgICAgICBpc1RpbWVJbnZhbGlkICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuODc1cmVtJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogJyNjOTE5MGInLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogJzAuMjVyZW0nLFxuICAgICAgICAgICAgfSB9LCBpc1RpbWVJbnZhbGlkKSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRJbnB1dCwgX19hc3NpZ24oeyBuYW1lOiBwcm9wcy5uYW1lLCBpc0Rpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCwgdmFsaWRhdGVkOiBwcm9wcy5lcnJvciA/ICdlcnJvcicgOiAnZGVmYXVsdCcsIG9uQ2hhbmdlOiBmdW5jdGlvbiAodmFsdWUsIGV2ZW50KSB7IHJldHVybiBwcm9wcy5vbkNoYW5nZShldmVudC50YXJnZXQudmFsdWUpOyB9LCBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXIsIHJlZjogcHJvcHMuaW5wdXRSZWYsIHR5cGU6IChfZSA9IHByb3BzLnR5cGUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICd0ZXh0JywgdmFsdWU6IChfZiA9IHByb3BzLnZhbHVlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAnJyB9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpKSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3RGaWVsZChUZXh0KTtcbiIsImltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUF1dG9GaWVsZCB9IGZyb20gJ3VuaWZvcm1zJztcbmltcG9ydCBCb29sRmllbGQgZnJvbSAnLi9Cb29sRmllbGQnO1xuaW1wb3J0IERhdGVGaWVsZCBmcm9tICcuL0RhdGVGaWVsZCc7XG5pbXBvcnQgTGlzdEZpZWxkIGZyb20gJy4vTGlzdEZpZWxkJztcbmltcG9ydCBOZXN0RmllbGQgZnJvbSAnLi9OZXN0RmllbGQnO1xuaW1wb3J0IE51bUZpZWxkIGZyb20gJy4vTnVtRmllbGQnO1xuaW1wb3J0IFJhZGlvRmllbGQgZnJvbSAnLi9SYWRpb0ZpZWxkJztcbmltcG9ydCBTZWxlY3RGaWVsZCBmcm9tICcuL1NlbGVjdEZpZWxkJztcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi9UZXh0RmllbGQnO1xudmFyIEF1dG9GaWVsZCA9IGNyZWF0ZUF1dG9GaWVsZChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsb3dlZFZhbHVlcykge1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hlY2tib3hlcyAmJiBwcm9wcy5maWVsZFR5cGUgIT09IEFycmF5XG4gICAgICAgICAgICA/IFJhZGlvRmllbGRcbiAgICAgICAgICAgIDogU2VsZWN0RmllbGQ7XG4gICAgfVxuICAgIHN3aXRjaCAocHJvcHMuZmllbGRUeXBlKSB7XG4gICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICByZXR1cm4gTGlzdEZpZWxkO1xuICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4gQm9vbEZpZWxkO1xuICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgICByZXR1cm4gRGF0ZUZpZWxkO1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgIHJldHVybiBOdW1GaWVsZDtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICByZXR1cm4gTmVzdEZpZWxkO1xuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBUZXh0RmllbGQ7XG4gICAgfVxuICAgIHJldHVybiBpbnZhcmlhbnQoZmFsc2UsICdVbnN1cHBvcnRlZCBmaWVsZCB0eXBlOiAlcycsIHByb3BzLmZpZWxkVHlwZSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IEF1dG9GaWVsZDtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZvcm0gfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgQXV0b0ZpZWxkIGZyb20gJy4vQXV0b0ZpZWxkJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF1dG9GaWVsZHMoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5hdXRvRmllbGQsIGF1dG9GaWVsZCA9IF9iID09PSB2b2lkIDAgPyBBdXRvRmllbGQgOiBfYiwgX2MgPSBfYS5lbGVtZW50LCBlbGVtZW50ID0gX2MgPT09IHZvaWQgMCA/ICdkaXYnIDogX2MsIGZpZWxkcyA9IF9hLmZpZWxkcywgX2QgPSBfYS5vbWl0RmllbGRzLCBvbWl0RmllbGRzID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIHByb3BzID0gX19yZXN0KF9hLCBbXCJhdXRvRmllbGRcIiwgXCJlbGVtZW50XCIsIFwiZmllbGRzXCIsIFwib21pdEZpZWxkc1wiXSk7XG4gICAgdmFyIHNjaGVtYSA9IHVzZUZvcm0oKS5zY2hlbWE7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMsIChmaWVsZHMgIT09IG51bGwgJiYgZmllbGRzICE9PSB2b2lkIDAgPyBmaWVsZHMgOiBzY2hlbWEuZ2V0U3ViZmllbGRzKCkpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiAhb21pdEZpZWxkcy5pbmNsdWRlcyhmaWVsZCk7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGF1dG9GaWVsZCwgeyBrZXk6IGZpZWxkLCBuYW1lOiBmaWVsZCB9KTsgfSkpO1xufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm0gfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IEJhc2VGb3JtLCBjb250ZXh0IH0gZnJvbSAndW5pZm9ybXMnO1xuZnVuY3Rpb24gUGF0dGVybmZseShwYXJlbnQpIHtcbiAgICB2YXIgXyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKF8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgXy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuZ2V0Q29udGV4dCgpIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtLCBfX2Fzc2lnbih7fSwgdGhpcy5nZXROYXRpdmVGb3JtUHJvcHMoKSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF8uUGF0dGVybmZseSA9IFBhdHRlcm5mbHk7XG4gICAgICAgIF8uZGlzcGxheU5hbWUgPSBcIlBhdHRlcm5mbHlcIiArIHBhcmVudC5kaXNwbGF5TmFtZTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgfShwYXJlbnQpKTtcbiAgICByZXR1cm4gXztcbn1cbmV4cG9ydCBkZWZhdWx0IFBhdHRlcm5mbHkoQmFzZUZvcm0pO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUZvcm0sIGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuZnVuY3Rpb24gRXJyb3JzRmllbGQoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCJdKTtcbiAgICB2YXIgX2IgPSB1c2VGb3JtKCksIGVycm9yID0gX2IuZXJyb3IsIHNjaGVtYSA9IF9iLnNjaGVtYTtcbiAgICByZXR1cm4gIWVycm9yICYmICFjaGlsZHJlbiA/IG51bGwgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCBudWxsLCBzY2hlbWEuZ2V0RXJyb3JNZXNzYWdlcyhlcnJvcikubWFwKGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IGtleTogaW5kZXgsIHN0eWxlOiB7IG1hcmdpbjogJzNweCcgfSB9LCBtZXNzYWdlKSk7IH0pKSkpO1xufVxuRXJyb3JzRmllbGQuZGVmYXVsdFByb3BzID0ge1xuICAgIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCA4NSwgMCwgMC4yKScsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCByZ2IoMjU1LCA4NSwgMCknLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc3cHgnLFxuICAgICAgICBtYXJnaW46ICcyMHB4IDBweCcsXG4gICAgICAgIHBhZGRpbmc6ICcxMHB4JyxcbiAgICB9LFxufTtcbmV4cG9ydCBkZWZhdWx0IEVycm9yc0ZpZWxkO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJ0BwYXR0ZXJuZmx5L3JlYWN0LWNvcmUnO1xuaW1wb3J0IHsgZmlsdGVyRE9NUHJvcHMsIHVzZUZvcm0gfSBmcm9tICd1bmlmb3Jtcyc7XG5mdW5jdGlvbiBTdWJtaXRGaWVsZChfYSkge1xuICAgIHZhciBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBpbnB1dFJlZiA9IF9hLmlucHV0UmVmLCB2YWx1ZSA9IF9hLnZhbHVlLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiZGlzYWJsZWRcIiwgXCJpbnB1dFJlZlwiLCBcInZhbHVlXCJdKTtcbiAgICB2YXIgX2IgPSB1c2VGb3JtKCksIGVycm9yID0gX2IuZXJyb3IsIHN0YXRlID0gX2Iuc3RhdGU7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgeyBpc0Rpc2FibGVkOiBkaXNhYmxlZCA9PT0gdW5kZWZpbmVkID8gISEoZXJyb3IgfHwgc3RhdGUuZGlzYWJsZWQpIDogZGlzYWJsZWQsIHR5cGU6IFwic3VibWl0XCIsIHJlZjogaW5wdXRSZWYsIHZhcmlhbnQ6IFwicHJpbWFyeVwiIH0sIHZhbHVlKSkpO1xufVxuU3VibWl0RmllbGQuZGVmYXVsdFByb3BzID0geyB2YWx1ZTogJ1N1Ym1pdCcgfTtcbmV4cG9ydCBkZWZhdWx0IFN1Ym1pdEZpZWxkO1xuIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBRdWlja0Zvcm0gfSBmcm9tICd1bmlmb3Jtcyc7XG5pbXBvcnQgQXV0b0ZpZWxkIGZyb20gJy4vQXV0b0ZpZWxkJztcbmltcG9ydCBCYXNlRm9ybSBmcm9tICcuL0Jhc2VGb3JtJztcbmltcG9ydCBFcnJvcnNGaWVsZCBmcm9tICcuL0Vycm9yc0ZpZWxkJztcbmltcG9ydCBTdWJtaXRGaWVsZCBmcm9tICcuL1N1Ym1pdEZpZWxkJztcbmZ1bmN0aW9uIFF1aWNrKHBhcmVudCkge1xuICAgIHZhciBfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfLnByb3RvdHlwZS5nZXRBdXRvRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXV0b0ZpZWxkO1xuICAgICAgICB9O1xuICAgICAgICBfLnByb3RvdHlwZS5nZXRFcnJvcnNGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvcnNGaWVsZDtcbiAgICAgICAgfTtcbiAgICAgICAgXy5wcm90b3R5cGUuZ2V0U3VibWl0RmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gU3VibWl0RmllbGQ7XG4gICAgICAgIH07XG4gICAgICAgIF8uUXVpY2sgPSBRdWljaztcbiAgICAgICAgcmV0dXJuIF87XG4gICAgfShRdWlja0Zvcm0uUXVpY2socGFyZW50KSkpO1xuICAgIHJldHVybiBfO1xufVxuZXhwb3J0IGRlZmF1bHQgUXVpY2soQmFzZUZvcm0pO1xuIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBWYWxpZGF0ZWRGb3JtIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IEJhc2VGb3JtIGZyb20gJy4vQmFzZUZvcm0nO1xuZnVuY3Rpb24gVmFsaWRhdGVkKHBhcmVudCkge1xuICAgIHZhciBfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfLlZhbGlkYXRlZCA9IFZhbGlkYXRlZDtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgfShWYWxpZGF0ZWRGb3JtLlZhbGlkYXRlZChwYXJlbnQpKSk7XG4gICAgcmV0dXJuIF87XG59XG5leHBvcnQgZGVmYXVsdCBWYWxpZGF0ZWQoQmFzZUZvcm0pO1xuIiwiaW1wb3J0IEJhc2VGb3JtIGZyb20gJy4vQmFzZUZvcm0nO1xuaW1wb3J0IFF1aWNrRm9ybSBmcm9tICcuL1F1aWNrRm9ybSc7XG5pbXBvcnQgVmFsaWRhdGVkRm9ybSBmcm9tICcuL1ZhbGlkYXRlZEZvcm0nO1xuZXhwb3J0IGRlZmF1bHQgVmFsaWRhdGVkRm9ybS5WYWxpZGF0ZWQoUXVpY2tGb3JtLlF1aWNrKEJhc2VGb3JtKSk7XG4iLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEF1dG9Gb3JtIH0gZnJvbSAndW5pZm9ybXMnO1xuaW1wb3J0IFZhbGlkYXRlZFF1aWNrRm9ybSBmcm9tICcuL1ZhbGlkYXRlZFF1aWNrRm9ybSc7XG5mdW5jdGlvbiBBdXRvKHBhcmVudCkge1xuICAgIHZhciBfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gXygpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfLkF1dG8gPSBBdXRvO1xuICAgICAgICByZXR1cm4gXztcbiAgICB9KEF1dG9Gb3JtLkF1dG8ocGFyZW50KSkpO1xuICAgIHJldHVybiBfO1xufVxuZXhwb3J0IGRlZmF1bHQgQXV0byhWYWxpZGF0ZWRRdWlja0Zvcm0pO1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCwgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG52YXIgRXJyb3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZXJyb3IgPSBfYS5lcnJvciwgZXJyb3JNZXNzYWdlID0gX2EuZXJyb3JNZXNzYWdlLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJlcnJvclwiLCBcImVycm9yTWVzc2FnZVwiXSk7XG4gICAgcmV0dXJuICFlcnJvciA/IG51bGwgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSwgY2hpbGRyZW4gPyAoY2hpbGRyZW4pIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogeyBtYXJnaW46ICczcHgnIH0gfSwgZXJyb3JNZXNzYWdlKSkpKTtcbn07XG5FcnJvci5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDg1LCAwLCAwLjIpJyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIHJnYigyNTUsIDg1LCAwKScsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzdweCcsXG4gICAgICAgIG1hcmdpbjogJzIwcHggMHB4JyxcbiAgICAgICAgcGFkZGluZzogJzEwcHgnLFxuICAgIH0sXG59O1xuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKEVycm9yLCB7IGluaXRpYWxWYWx1ZTogZmFsc2UgfSk7XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRmllbGQsIGZpbHRlckRPTVByb3BzIH0gZnJvbSAndW5pZm9ybXMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGlkZGVuRmllbGQoX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIHJhd1Byb3BzID0gX19yZXN0KF9hLCBbXCJ2YWx1ZVwiXSk7XG4gICAgdmFyIHByb3BzID0gdXNlRmllbGQocmF3UHJvcHMubmFtZSwgcmF3UHJvcHMsIHsgaW5pdGlhbFZhbHVlOiBmYWxzZSB9KVswXTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gcHJvcHMudmFsdWUpXG4gICAgICAgICAgICBwcm9wcy5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3BzLm5vRE9NID8gbnVsbCA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgX19hc3NpZ24oeyBkaXNhYmxlZDogcHJvcHMuZGlzYWJsZWQsIGlkOiBwcm9wcy5pZCwgbmFtZTogcHJvcHMubmFtZSwgcmVmOiBwcm9wcy5pbnB1dFJlZiwgdHlwZTogXCJoaWRkZW5cIiwgdmFsdWU6IChfYiA9IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHByb3BzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyB9LCBmaWx0ZXJET01Qcm9wcyhwcm9wcykpKSk7XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGV4dEFyZWEgfSBmcm9tICdAcGF0dGVybmZseS9yZWFjdC1jb3JlJztcbmltcG9ydCB7IGNvbm5lY3RGaWVsZCwgZmlsdGVyRE9NUHJvcHMgfSBmcm9tICd1bmlmb3Jtcyc7XG52YXIgTG9uZ1RleHQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgaWQgPSBfYS5pZCwgaW5wdXRSZWYgPSBfYS5pbnB1dFJlZiwgbGFiZWwgPSBfYS5sYWJlbCwgbmFtZSA9IF9hLm5hbWUsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIHBsYWNlaG9sZGVyID0gX2EucGxhY2Vob2xkZXIsIHZhbHVlID0gX2EudmFsdWUsIHByb3BzID0gX19yZXN0KF9hLCBbXCJkaXNhYmxlZFwiLCBcImlkXCIsIFwiaW5wdXRSZWZcIiwgXCJsYWJlbFwiLCBcIm5hbWVcIiwgXCJvbkNoYW5nZVwiLCBcInBsYWNlaG9sZGVyXCIsIFwidmFsdWVcIl0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgZmlsdGVyRE9NUHJvcHMocHJvcHMpKSxcbiAgICAgICAgbGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImxhYmVsXCIsIHsgaHRtbEZvcjogaWQgfSwgbGFiZWwpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRBcmVhLCB7IGlkOiBpZCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBuYW1lOiBuYW1lLCBcImFyaWEtbGFiZWxcIjogbmFtZSwgb25DaGFuZ2U6IGZ1bmN0aW9uICh2YWx1ZSwgZXZlbnQpIHsgcmV0dXJuIG9uQ2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7IH0sIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgcmVmOiBpbnB1dFJlZiwgdmFsdWU6IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6ICcnIH0pKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgY29ubmVjdEZpZWxkKExvbmdUZXh0KTtcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgQXV0b0ZpZWxkcyB9IGZyb20gJy4vQXV0b0ZpZWxkcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1dG9GaWVsZCB9IGZyb20gJy4vQXV0b0ZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXV0b0Zvcm0gfSBmcm9tICcuL0F1dG9Gb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQmFzZUZvcm0gfSBmcm9tICcuL0Jhc2VGb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm9vbEZpZWxkIH0gZnJvbSAnLi9Cb29sRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBEYXRlRmllbGQgfSBmcm9tICcuL0RhdGVGaWVsZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVycm9yRmllbGQgfSBmcm9tICcuL0Vycm9yRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFcnJvcnNGaWVsZCB9IGZyb20gJy4vRXJyb3JzRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBIaWRkZW5GaWVsZCB9IGZyb20gJy4vSGlkZGVuRmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0QWRkRmllbGQgfSBmcm9tICcuL0xpc3RBZGRGaWVsZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIExpc3REZWxGaWVsZCB9IGZyb20gJy4vTGlzdERlbEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlzdEZpZWxkIH0gZnJvbSAnLi9MaXN0RmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0SXRlbUZpZWxkIH0gZnJvbSAnLi9MaXN0SXRlbUZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9uZ1RleHRGaWVsZCB9IGZyb20gJy4vTG9uZ1RleHRGaWVsZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5lc3RGaWVsZCB9IGZyb20gJy4vTmVzdEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTnVtRmllbGQgfSBmcm9tICcuL051bUZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUXVpY2tGb3JtIH0gZnJvbSAnLi9RdWlja0Zvcm0nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSYWRpb0ZpZWxkIH0gZnJvbSAnLi9SYWRpb0ZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VsZWN0RmllbGQgfSBmcm9tICcuL1NlbGVjdEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3VibWl0RmllbGQgfSBmcm9tICcuL1N1Ym1pdEZpZWxkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dEZpZWxkIH0gZnJvbSAnLi9UZXh0RmllbGQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWYWxpZGF0ZWRGb3JtIH0gZnJvbSAnLi9WYWxpZGF0ZWRGb3JtJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVmFsaWRhdGVkUXVpY2tGb3JtIH0gZnJvbSAnLi9WYWxpZGF0ZWRRdWlja0Zvcm0nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22882\n')}}]);